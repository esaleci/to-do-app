# Next.js dark theme to-do app
_Exported on 1/17/2026 at 02:41:20 GMT+4 from Cursor (2.3.35)_

---

**User**

install nextjs last version , and make a to-do-app via dark theme and use a react-form-hook and shadcnui and zod validation for validate a filed just with mock data 

---

**Cursor**

Got it. I’ll scaffold a **latest Next.js** app in this workspace, install/configure **shadcn/ui** with a **dark theme**, then build a simple **mock-data to‑do app** using **react-hook-form + zod** validation (e.g., validate a “title” field). Next I’ll run it once to ensure everything compiles.

Nice—workspace is empty, so we can scaffold cleanly. Next I’ll check whether any terminals are already running, then run `create-next-app@latest` and start wiring up Tailwind + shadcn/ui for a dark theme.

Aha, Next.js is scaffolded with Tailwind + App Router already—perfect foundation for shadcn/ui. Next I’ll initialize shadcn/ui (Tailwind + CSS variables) and set up dark mode, then we’ll build the form-driven to-do UI with zod validation.

Good news: the shadcn CLI supports `--defaults` and `--src-dir`, so we can initialize shadcn/ui in one shot and keep everything consistent with your `src/` layout. Next I’ll run `shadcn init`, then add the core UI components (form/input/button/card/checkbox) we’ll use for the to-do app.

Nice—shadcn is initialized with Tailwind v4 CSS variables already, so dark mode is as simple as toggling the `.dark` class on `<html>`. Next I’ll add `next-themes` provider + a theme toggle button, then replace the default homepage with the mock to-do app wired to `react-hook-form` + `zod`.

```typescriptreact
"use client"

import * as React from "react"
import { ThemeProvider as NextThemesProvider } from "next-themes"
import type { ThemeProviderProps } from "next-themes/dist/types"

export function ThemeProvider({ children, ...props }: ThemeProviderProps) {
  return <NextThemesProvider {...props}>{children}</NextThemesProvider>
}


```

```typescriptreact
"use client"

import * as React from "react"
import { Moon, Sun } from "lucide-react"
import { useTheme } from "next-themes"

import { Button } from "@/components/ui/button"

export function ModeToggle() {
  const { resolvedTheme, setTheme } = useTheme()
  const [mounted, setMounted] = React.useState(false)

  React.useEffect(() => setMounted(true), [])

  const isDark = (mounted ? resolvedTheme : "dark") === "dark"

  return (
    <Button
      type="button"
      variant="outline"
      size="icon"
      aria-label="Toggle theme"
      onClick={() => setTheme(isDark ? "light" : "dark")}
    >
      {isDark ? <Sun className="h-4 w-4" /> : <Moon className="h-4 w-4" />}
    </Button>
  )
}


```

```typescriptreact
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";
import { ThemeProvider } from "@/components/theme-provider";
import { cn } from "@/lib/utils";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "To-Do App",
  description: "Mock-data to-do app using shadcn/ui, react-hook-form, and zod.",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en" suppressHydrationWarning>
      <body
        className={cn(
          geistSans.variable,
          geistMono.variable,
          "min-h-screen bg-background font-sans antialiased"
        )}
      >
        <ThemeProvider
          attribute="class"
          defaultTheme="dark"
          enableSystem={false}
          disableTransitionOnChange
        >
          {children}
        </ThemeProvider>
      </body>
    </html>
  );
}

```

```typescriptreact
export default function Home() {
  return (
    <div className="mx-auto flex min-h-screen max-w-2xl flex-col gap-6 px-4 py-10">
      <TodoApp />
    </div>
  );
}

import { zodResolver } from "@hookform/resolvers/zod"
import { Trash2 } from "lucide-react"
import * as React from "react"
import { useForm } from "react-hook-form"
import { z } from "zod"

import { ModeToggle } from "@/components/mode-toggle"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Checkbox } from "@/components/ui/checkbox"
import { Form, FormControl, FormField, FormItem, FormMessage } from "@/components/ui/form"
import { Input } from "@/components/ui/input"
import { Separator } from "@/components/ui/separator"
import { cn } from "@/lib/utils"

type Todo = {
  id: string
  title: string
  completed: boolean
}

const todoSchema = z.object({
  title: z
    .string()
    .trim()
    .min(1, "Title is required.")
    .max(80, "Keep it under 80 characters."),
})

type TodoFormValues = z.infer<typeof todoSchema>

const initialTodos: Todo[] = [
  { id: "1", title: "Create a Next.js app", completed: true },
  { id: "2", title: "Add shadcn/ui + dark theme", completed: true },
  { id: "3", title: "Build a mock-data to-do list", completed: false },
]

function TodoApp() {
  const [todos, setTodos] = React.useState<Todo[]>(initialTodos)

  const form = useForm<TodoFormValues>({
    resolver: zodResolver(todoSchema),
    defaultValues: { title: "" },
    mode: "onSubmit",
  })

  const completedCount = todos.filter((t) => t.completed).length

  function addTodo(values: TodoFormValues) {
    setTodos((prev) => [
      { id: crypto.randomUUID(), title: values.title.trim(), completed: false },
      ...prev,
    ])
    form.reset()
  }

  function toggleTodo(id: string, completed: boolean) {
    setTodos((prev) => prev.map((t) => (t.id === id ? { ...t, completed } : t)))
  }

  function deleteTodo(id: string) {
    setTodos((prev) => prev.filter((t) => t.id !== id))
  }

  function clearCompleted() {
    setTodos((prev) => prev.filter((t) => !t.completed))
  }

  return (
    <Card>
      <CardHeader className="flex flex-row items-center justify-between gap-4">
        <div className="space-y-1">
          <CardTitle className="text-2xl">To‑Do</CardTitle>
          <p className="text-muted-foreground text-sm">
            {completedCount}/{todos.length} completed
          </p>
        </div>
        <ModeToggle />
      </CardHeader>

      <CardContent className="space-y-6">
        <Form {...form}>
          <form
            onSubmit={form.handleSubmit(addTodo)}
            className="space-y-2"
            noValidate
          >
            <div className="flex gap-2">
              <FormField
                control={form.control}
                name="title"
                render={({ field }) => (
                  <FormItem className="flex-1">
                    <FormControl>
                      <Input
                        placeholder="Add a task…"
                        autoComplete="off"
                        {...field}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <Button type="submit">Add</Button>
            </div>
          </form>
        </Form>

        <Separator />

        <div className="space-y-2">
          {todos.length === 0 ? (
            <p className="text-muted-foreground text-sm">No tasks yet.</p>
          ) : (
            todos.map((todo) => (
              <div
                key={todo.id}
                className="flex items-start justify-between gap-3 rounded-lg border px-3 py-2"
              >
                <label className="flex cursor-pointer items-start gap-3">
                  <Checkbox
                    checked={todo.completed}
                    onCheckedChange={(v) => toggleTodo(todo.id, Boolean(v))}
                    aria-label={`Mark "${todo.title}" as ${
                      todo.completed ? "not completed" : "completed"
                    }`}
                    className="mt-0.5"
                  />
                  <span
                    className={cn(
                      "leading-6",
                      todo.completed && "text-muted-foreground line-through"
                    )}
                  >
                    {todo.title}
                  </span>
                </label>

                <Button
                  type="button"
                  variant="ghost"
                  size="icon"
                  aria-label={`Delete "${todo.title}"`}
                  onClick={() => deleteTodo(todo.id)}
                >
                  <Trash2 className="h-4 w-4" />
                </Button>
              </div>
            ))
          )}
        </div>

        <div className="flex items-center justify-between gap-2">
          <Button
            type="button"
            variant="secondary"
            onClick={clearCompleted}
            disabled={completedCount === 0}
          >
            Clear completed
          </Button>
          <span className="text-muted-foreground text-sm">
            Mock data only (no backend)
          </span>
        </div>
      </CardContent>
    </Card>
  )
}

```

Good catch: the homepage uses React hooks and form logic, so it must be a **client component** and the imports must be at the top of the file. Next I’ll clean up `src/app/page.tsx` structure, then run lint/build to ensure everything compiles cleanly.

```typescriptreact
"use client"

import { zodResolver } from "@hookform/resolvers/zod"
import { Trash2 } from "lucide-react"
import * as React from "react"
import { useForm } from "react-hook-form"
import { z } from "zod"

import { ModeToggle } from "@/components/mode-toggle"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Checkbox } from "@/components/ui/checkbox"
import { Form, FormControl, FormField, FormItem, FormMessage } from "@/components/ui/form"
import { Input } from "@/components/ui/input"
import { Separator } from "@/components/ui/separator"
import { cn } from "@/lib/utils"

type Todo = {
  id: string
  title: string
  completed: boolean
}

const todoSchema = z.object({
  title: z
    .string()
    .trim()
    .min(1, "Title is required.")
    .max(80, "Keep it under 80 characters."),
})

type TodoFormValues = z.infer<typeof todoSchema>

const initialTodos: Todo[] = [
  { id: "1", title: "Create a Next.js app", completed: true },
  { id: "2", title: "Add shadcn/ui + dark theme", completed: true },
  { id: "3", title: "Build a mock-data to-do list", completed: false },
]

export default function Home() {
  return (
    <div className="mx-auto flex min-h-screen max-w-2xl flex-col gap-6 px-4 py-10">
      <TodoApp />
    </div>
  )
}

function TodoApp() {
  const [todos, setTodos] = React.useState<Todo[]>(initialTodos)

  const form = useForm<TodoFormValues>({
    resolver: zodResolver(todoSchema),
    defaultValues: { title: "" },
    mode: "onSubmit",
  })

  const completedCount = todos.filter((t) => t.completed).length

  function addTodo(values: TodoFormValues) {
    setTodos((prev) => [
      { id: crypto.randomUUID(), title: values.title.trim(), completed: false },
      ...prev,
    ])
    form.reset()
  }

  function toggleTodo(id: string, completed: boolean) {
    setTodos((prev) => prev.map((t) => (t.id === id ? { ...t, completed } : t)))
  }

  function deleteTodo(id: string) {
    setTodos((prev) => prev.filter((t) => t.id !== id))
  }

  function clearCompleted() {
    setTodos((prev) => prev.filter((t) => !t.completed))
  }

  return (
    <Card>
      <CardHeader className="flex flex-row items-center justify-between gap-4">
        <div className="space-y-1">
          <CardTitle className="text-2xl">To‑Do</CardTitle>
          <p className="text-muted-foreground text-sm">
            {completedCount}/{todos.length} completed
          </p>
        </div>
        <ModeToggle />
      </CardHeader>

      <CardContent className="space-y-6">
        <Form {...form}>
          <form
            onSubmit={form.handleSubmit(addTodo)}
            className="space-y-2"
            noValidate
          >
            <div className="flex gap-2">
              <FormField
                control={form.control}
                name="title"
                render={({ field }) => (
                  <FormItem className="flex-1">
                    <FormControl>
                      <Input
                        placeholder="Add a task…"
                        autoComplete="off"
                        {...field}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <Button type="submit">Add</Button>
            </div>
          </form>
        </Form>

        <Separator />

        <div className="space-y-2">
          {todos.length === 0 ? (
            <p className="text-muted-foreground text-sm">No tasks yet.</p>
          ) : (
            todos.map((todo) => (
              <div
                key={todo.id}
                className="flex items-start justify-between gap-3 rounded-lg border px-3 py-2"
              >
                <label className="flex cursor-pointer items-start gap-3">
                  <Checkbox
                    checked={todo.completed}
                    onCheckedChange={(v) => toggleTodo(todo.id, Boolean(v))}
                    aria-label={`Mark "${todo.title}" as ${
                      todo.completed ? "not completed" : "completed"
                    }`}
                    className="mt-0.5"
                  />
                  <span
                    className={cn(
                      "leading-6",
                      todo.completed && "text-muted-foreground line-through"
                    )}
                  >
                    {todo.title}
                  </span>
                </label>

                <Button
                  type="button"
                  variant="ghost"
                  size="icon"
                  aria-label={`Delete "${todo.title}"`}
                  onClick={() => deleteTodo(todo.id)}
                >
                  <Trash2 className="h-4 w-4" />
                </Button>
              </div>
            ))
          )}
        </div>

        <div className="flex items-center justify-between gap-2">
          <Button
            type="button"
            variant="secondary"
            onClick={clearCompleted}
            disabled={completedCount === 0}
          >
            Clear completed
          </Button>
          <span className="text-muted-foreground text-sm">
            Mock data only (no backend)
          </span>
        </div>
      </CardContent>
    </Card>
  )
}

```

```typescriptreact
"use client"

import * as React from "react"
import { ThemeProvider as NextThemesProvider } from "next-themes"
import type { ThemeProviderProps } from "next-themes"

export function ThemeProvider({ children, ...props }: ThemeProviderProps) {
  return <NextThemesProvider {...props}>{children}</NextThemesProvider>
}


```

### Done
- **Installed latest Next.js (16.1.2)** and scaffolded the project with TypeScript + Tailwind.
- **Installed/configured shadcn/ui** (CSS variables + dark theme ready).
- Built a **dark-themed mock-data To‑Do app** with:
  - **react-hook-form**
  - **zod validation** for the **title** field (required, max length)
  - shadcn/ui components (Card, Button, Input, Checkbox, Form, etc.)
  - add / toggle complete / delete / clear completed

### Where the main code is
- **To‑do app UI + form + zod validation**: `src/app/page.tsx`
- **Theme provider (next-themes)**: `src/components/theme-provider.tsx`
- **Dark/light toggle button**: `src/components/mode-toggle.tsx`
- **App layout (default theme = dark)**: `src/app/layout.tsx`

### Run it
```bash
npm run dev
```

```shellscript
npm run dev
```

---

**User**

ok now i want add a multiplay file(pdf,xls,word,text),image,voice,and video to the task list when check a task complated ,when added show in list attachment with related icon and create a download link for download it from task 

---

**Cursor**

Makes sense. I’ll extend each todo item to store **multiple attachments** (kept as mock client-side `File` objects via `URL.createObjectURL`), open a file picker when you mark a task **completed**, then render an **attachment list with type icons + download links**. Next I’ll update `src/app/page.tsx` and re-run a production build to confirm it compiles.

Nice—your current todo rendering is already clean and componentized enough that we can layer attachments in without restructuring the app. Next I’ll update the `Todo` type to include attachments, add a single shared hidden file input (multiple), wire it to trigger when a task is marked completed, and then render an attachment list with per-type icons + download links.

```typescriptreact
"use client"

import { zodResolver } from "@hookform/resolvers/zod"
import {
  Download,
  File,
  FileSpreadsheet,
  FileText,
  Image as ImageIcon,
  Music,
  Trash2,
  Video,
} from "lucide-react"
import * as React from "react"
import { useForm } from "react-hook-form"
import { z } from "zod"

import { ModeToggle } from "@/components/mode-toggle"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Checkbox } from "@/components/ui/checkbox"
import { Form, FormControl, FormField, FormItem, FormMessage } from "@/components/ui/form"
import { Input } from "@/components/ui/input"
import { Separator } from "@/components/ui/separator"
import { cn } from "@/lib/utils"

type AttachmentKind =
  | "image"
  | "audio"
  | "video"
  | "pdf"
  | "spreadsheet"
  | "document"
  | "text"
  | "file"

type Attachment = {
  id: string
  name: string
  type: string
  size: number
  url: string
  kind: AttachmentKind
}

type Todo = {
  id: string
  title: string
  completed: boolean
  attachments: Attachment[]
}

const todoSchema = z.object({
  title: z
    .string()
    .trim()
    .min(1, "Title is required.")
    .max(80, "Keep it under 80 characters."),
})

type TodoFormValues = z.infer<typeof todoSchema>

const initialTodos: Todo[] = [
  { id: "1", title: "Create a Next.js app", completed: true, attachments: [] },
  { id: "2", title: "Add shadcn/ui + dark theme", completed: true, attachments: [] },
  { id: "3", title: "Build a mock-data to-do list", completed: false, attachments: [] },
]

function getAttachmentKind(file: File): AttachmentKind {
  const type = (file.type || "").toLowerCase()
  const name = file.name.toLowerCase()
  const ext = name.includes(".") ? name.split(".").pop() ?? "" : ""

  if (type.startsWith("image/")) return "image"
  if (type.startsWith("audio/")) return "audio"
  if (type.startsWith("video/")) return "video"

  if (ext === "pdf") return "pdf"
  if (["xls", "xlsx", "csv"].includes(ext)) return "spreadsheet"
  if (["doc", "docx"].includes(ext)) return "document"
  if (["txt", "md", "rtf"].includes(ext)) return "text"

  return "file"
}

function makeAttachment(file: File): Attachment {
  return {
    id: crypto.randomUUID(),
    name: file.name,
    type: file.type,
    size: file.size,
    url: URL.createObjectURL(file),
    kind: getAttachmentKind(file),
  }
}

function revokeTodoAttachments(todo: Todo) {
  for (const a of todo.attachments) URL.revokeObjectURL(a.url)
}

function AttachmentIcon({ kind }: { kind: AttachmentKind }) {
  const className = "h-4 w-4 text-muted-foreground"

  switch (kind) {
    case "image":
      return <ImageIcon className={className} />
    case "audio":
      return <Music className={className} />
    case "video":
      return <Video className={className} />
    case "spreadsheet":
      return <FileSpreadsheet className={className} />
    case "pdf":
    case "document":
    case "text":
      return <FileText className={className} />
    default:
      return <File className={className} />
  }
}

export default function Home() {
  return (
    <div className="mx-auto flex min-h-screen max-w-2xl flex-col gap-6 px-4 py-10">
      <TodoApp />
    </div>
  )
}

function TodoApp() {
  const [todos, setTodos] = React.useState<Todo[]>(initialTodos)
  const [attachTargetTodoId, setAttachTargetTodoId] = React.useState<string | null>(
    null
  )
  const fileInputRef = React.useRef<HTMLInputElement>(null)

  const todosRef = React.useRef(todos)
  React.useEffect(() => {
    todosRef.current = todos
  }, [todos])
  React.useEffect(() => {
    return () => {
      for (const t of todosRef.current) revokeTodoAttachments(t)
    }
  }, [])

  const form = useForm<TodoFormValues>({
    resolver: zodResolver(todoSchema),
    defaultValues: { title: "" },
    mode: "onSubmit",
  })

  const completedCount = todos.filter((t) => t.completed).length

  function addTodo(values: TodoFormValues) {
    setTodos((prev) => [
      {
        id: crypto.randomUUID(),
        title: values.title.trim(),
        completed: false,
        attachments: [],
      },
      ...prev,
    ])
    form.reset()
  }

  function toggleTodo(id: string, completed: boolean) {
    setTodos((prev) => prev.map((t) => (t.id === id ? { ...t, completed } : t)))
  }

  function requestAttachmentsForTodo(todoId: string) {
    setAttachTargetTodoId(todoId)
    // Let state update before opening picker (some browsers are picky).
    queueMicrotask(() => fileInputRef.current?.click())
  }

  function handleFilesPicked(e: React.ChangeEvent<HTMLInputElement>) {
    const files = Array.from(e.target.files ?? [])
    const targetId = attachTargetTodoId

    // reset input so picking the same file again triggers onChange
    e.target.value = ""
    setAttachTargetTodoId(null)

    if (!targetId || files.length === 0) return

    const attachments = files.map(makeAttachment)

    setTodos((prev) =>
      prev.map((t) =>
        t.id === targetId
          ? { ...t, attachments: [...t.attachments, ...attachments] }
          : t
      )
    )
  }

  function deleteTodo(id: string) {
    setTodos((prev) => {
      const victim = prev.find((t) => t.id === id)
      if (victim) revokeTodoAttachments(victim)
      return prev.filter((t) => t.id !== id)
    })
  }

  function clearCompleted() {
    setTodos((prev) => {
      for (const t of prev) {
        if (t.completed) revokeTodoAttachments(t)
      }
      return prev.filter((t) => !t.completed)
    })
  }

  return (
    <Card>
      <CardHeader className="flex flex-row items-center justify-between gap-4">
        <div className="space-y-1">
          <CardTitle className="text-2xl">To‑Do</CardTitle>
          <p className="text-muted-foreground text-sm">
            {completedCount}/{todos.length} completed
          </p>
        </div>
        <ModeToggle />
      </CardHeader>

      <CardContent className="space-y-6">
        <input
          ref={fileInputRef}
          type="file"
          multiple
          className="hidden"
          accept={[
            "image/*",
            "audio/*",
            "video/*",
            ".pdf",
            ".doc",
            ".docx",
            ".xls",
            ".xlsx",
            ".csv",
            ".txt",
            ".md",
            ".rtf",
          ].join(",")}
          onChange={handleFilesPicked}
        />

        <Form {...form}>
          <form
            onSubmit={form.handleSubmit(addTodo)}
            className="space-y-2"
            noValidate
          >
            <div className="flex gap-2">
              <FormField
                control={form.control}
                name="title"
                render={({ field }) => (
                  <FormItem className="flex-1">
                    <FormControl>
                      <Input
                        placeholder="Add a task…"
                        autoComplete="off"
                        {...field}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <Button type="submit">Add</Button>
            </div>
          </form>
        </Form>

        <Separator />

        <div className="space-y-2">
          {todos.length === 0 ? (
            <p className="text-muted-foreground text-sm">No tasks yet.</p>
          ) : (
            todos.map((todo) => (
              <div key={todo.id} className="rounded-lg border px-3 py-2">
                <div className="flex items-start justify-between gap-3">
                  <label className="flex cursor-pointer items-start gap-3">
                    <Checkbox
                      checked={todo.completed}
                      onCheckedChange={(v) => {
                        const next = Boolean(v)
                        toggleTodo(todo.id, next)
                        if (next && !todo.completed) {
                          requestAttachmentsForTodo(todo.id)
                        }
                      }}
                      aria-label={`Mark "${todo.title}" as ${
                        todo.completed ? "not completed" : "completed"
                      }`}
                      className="mt-0.5"
                    />
                    <span
                      className={cn(
                        "leading-6",
                        todo.completed && "text-muted-foreground line-through"
                      )}
                    >
                      {todo.title}
                    </span>
                  </label>

                  <div className="flex items-center gap-1">
                    {todo.completed && (
                      <Button
                        type="button"
                        variant="outline"
                        size="sm"
                        onClick={() => requestAttachmentsForTodo(todo.id)}
                      >
                        Add files
                      </Button>
                    )}
                    <Button
                      type="button"
                      variant="ghost"
                      size="icon"
                      aria-label={`Delete "${todo.title}"`}
                      onClick={() => deleteTodo(todo.id)}
                    >
                      <Trash2 className="h-4 w-4" />
                    </Button>
                  </div>
                </div>

                {todo.completed && todo.attachments.length > 0 && (
                  <div className="mt-3 space-y-2">
                    <p className="text-muted-foreground text-xs">Attachments</p>
                    <ul className="space-y-1">
                      {todo.attachments.map((a) => (
                        <li
                          key={a.id}
                          className="flex items-center justify-between gap-3 rounded-md bg-muted/30 px-2 py-1"
                        >
                          <div className="flex min-w-0 items-center gap-2">
                            <AttachmentIcon kind={a.kind} />
                            <span className="truncate text-sm">{a.name}</span>
                          </div>
                          <a
                            href={a.url}
                            download={a.name}
                            className="inline-flex items-center gap-1 text-sm font-medium underline underline-offset-4"
                          >
                            <Download className="h-4 w-4" />
                            Download
                          </a>
                        </li>
                      ))}
                    </ul>
                  </div>
                )}
              </div>
            ))
          )}
        </div>

        <div className="flex items-center justify-between gap-2">
          <Button
            type="button"
            variant="secondary"
            onClick={clearCompleted}
            disabled={completedCount === 0}
          >
            Clear completed
          </Button>
          <span className="text-muted-foreground text-sm">
            Mock data only (no backend)
          </span>
        </div>
      </CardContent>
    </Card>
  )
}

```

### What changed
- **Completed task → file picker opens** so you can attach **multiple files** (pdf/xls/doc/txt + images + audio + video).
- Attached files show under the task as an **Attachments list** with a **related icon** and a **Download** link.
- Attachments are **mock-only** (kept in browser memory via `URL.createObjectURL`). URLs are **revoked** when a task is deleted / cleared / on unmount.

### Where it is
- Everything is implemented in: `src/app/page.tsx`

### How to use
- Run:

```bash
npm run dev
```

- Check a task as completed → select multiple files → they appear under that task with a download link.
- You can also click **“Add files”** on a completed task to attach more later.

```shellscript
npm run dev
```

---

**User**

i need a schedule date and timing for create a new task and filter for show a tasks between data or just on date&time , the time is very important get date and time and show with filter

---

**Cursor**

Got it—next I’ll add a **scheduled due date+time** to every task (picked via a `datetime-local` input, validated with **zod**), then add a **filter panel** that can show tasks **between two date-times** or **exactly at a specific date-time**. After wiring it into the list rendering, I’ll run a build to ensure TypeScript passes.

```typescriptreact
"use client"

import { zodResolver } from "@hookform/resolvers/zod"
import {
  Download,
  File,
  FileSpreadsheet,
  FileText,
  Image as ImageIcon,
  Music,
  Trash2,
  Video,
} from "lucide-react"
import * as React from "react"
import { useForm } from "react-hook-form"
import { z } from "zod"

import { ModeToggle } from "@/components/mode-toggle"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Checkbox } from "@/components/ui/checkbox"
import { Form, FormControl, FormField, FormItem, FormMessage } from "@/components/ui/form"
import { Input } from "@/components/ui/input"
import { Separator } from "@/components/ui/separator"
import { cn } from "@/lib/utils"

type AttachmentKind =
  | "image"
  | "audio"
  | "video"
  | "pdf"
  | "spreadsheet"
  | "document"
  | "text"
  | "file"

type Attachment = {
  id: string
  name: string
  type: string
  size: number
  url: string
  kind: AttachmentKind
}

type Todo = {
  id: string
  title: string
  completed: boolean
  // Stored as `datetime-local` string (YYYY-MM-DDTHH:mm) in local time.
  dueAt: string
  attachments: Attachment[]
}

const todoSchema = z.object({
  title: z
    .string()
    .trim()
    .min(1, "Title is required.")
    .max(80, "Keep it under 80 characters."),
  dueAt: z
    .string()
    .min(1, "Due date & time is required.")
    .regex(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}$/, "Invalid date/time."),
})

type TodoFormValues = z.infer<typeof todoSchema>

const initialTodos: Todo[] = [
  {
    id: "1",
    title: "Create a Next.js app",
    completed: true,
    dueAt: "2026-01-16T09:00",
    attachments: [],
  },
  {
    id: "2",
    title: "Add shadcn/ui + dark theme",
    completed: true,
    dueAt: "2026-01-16T10:30",
    attachments: [],
  },
  {
    id: "3",
    title: "Build a mock-data to-do list",
    completed: false,
    dueAt: "2026-01-16T15:00",
    attachments: [],
  },
]

function parseLocalDateTime(value: string): number {
  // value: "YYYY-MM-DDTHH:mm"
  const [datePart, timePart] = value.split("T")
  const [y, m, d] = datePart.split("-").map(Number)
  const [hh, mm] = timePart.split(":").map(Number)
  return new Date(y, m - 1, d, hh, mm, 0, 0).getTime()
}

function formatLocalDateTime(value: string): string {
  const ms = parseLocalDateTime(value)
  if (!Number.isFinite(ms)) return value
  return new Intl.DateTimeFormat(undefined, {
    year: "numeric",
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  }).format(new Date(ms))
}

function getAttachmentKind(file: File): AttachmentKind {
  const type = (file.type || "").toLowerCase()
  const name = file.name.toLowerCase()
  const ext = name.includes(".") ? name.split(".").pop() ?? "" : ""

  if (type.startsWith("image/")) return "image"
  if (type.startsWith("audio/")) return "audio"
  if (type.startsWith("video/")) return "video"

  if (ext === "pdf") return "pdf"
  if (["xls", "xlsx", "csv"].includes(ext)) return "spreadsheet"
  if (["doc", "docx"].includes(ext)) return "document"
  if (["txt", "md", "rtf"].includes(ext)) return "text"

  return "file"
}

function makeAttachment(file: File): Attachment {
  return {
    id: crypto.randomUUID(),
    name: file.name,
    type: file.type,
    size: file.size,
    url: URL.createObjectURL(file),
    kind: getAttachmentKind(file),
  }
}

function revokeTodoAttachments(todo: Todo) {
  for (const a of todo.attachments) URL.revokeObjectURL(a.url)
}

function AttachmentIcon({ kind }: { kind: AttachmentKind }) {
  const className = "h-4 w-4 text-muted-foreground"

  switch (kind) {
    case "image":
      return <ImageIcon className={className} />
    case "audio":
      return <Music className={className} />
    case "video":
      return <Video className={className} />
    case "spreadsheet":
      return <FileSpreadsheet className={className} />
    case "pdf":
    case "document":
    case "text":
      return <FileText className={className} />
    default:
      return <File className={className} />
  }
}

export default function Home() {
  return (
    <div className="mx-auto flex min-h-screen max-w-2xl flex-col gap-6 px-4 py-10">
      <TodoApp />
    </div>
  )
}

function TodoApp() {
  const [todos, setTodos] = React.useState<Todo[]>(initialTodos)
  const [attachTargetTodoId, setAttachTargetTodoId] = React.useState<string | null>(
    null
  )
  const [filterMode, setFilterMode] = React.useState<"between" | "exact">("between")
  const [filterFrom, setFilterFrom] = React.useState<string>("")
  const [filterTo, setFilterTo] = React.useState<string>("")
  const [filterExact, setFilterExact] = React.useState<string>("")
  const fileInputRef = React.useRef<HTMLInputElement>(null)

  const todosRef = React.useRef(todos)
  React.useEffect(() => {
    todosRef.current = todos
  }, [todos])
  React.useEffect(() => {
    return () => {
      for (const t of todosRef.current) revokeTodoAttachments(t)
    }
  }, [])

  const form = useForm<TodoFormValues>({
    resolver: zodResolver(todoSchema),
    defaultValues: { title: "", dueAt: "" },
    mode: "onSubmit",
  })

  const filteredTodos = React.useMemo(() => {
    const withMs = todos.map((t) => ({ ...t, _dueMs: parseLocalDateTime(t.dueAt) }))
    if (filterMode === "exact") {
      if (!filterExact) return withMs
      const exactMs = parseLocalDateTime(filterExact)
      return withMs.filter((t) => t._dueMs === exactMs)
    }
    // between
    const fromMs = filterFrom ? parseLocalDateTime(filterFrom) : Number.NEGATIVE_INFINITY
    const toMs = filterTo ? parseLocalDateTime(filterTo) : Number.POSITIVE_INFINITY
    return withMs.filter((t) => t._dueMs >= fromMs && t._dueMs <= toMs)
  }, [todos, filterExact, filterFrom, filterMode, filterTo])

  const completedCount = filteredTodos.filter((t) => t.completed).length

  function addTodo(values: TodoFormValues) {
    setTodos((prev) => [
      {
        id: crypto.randomUUID(),
        title: values.title.trim(),
        completed: false,
        dueAt: values.dueAt,
        attachments: [],
      },
      ...prev,
    ])
    form.reset()
  }

  function toggleTodo(id: string, completed: boolean) {
    setTodos((prev) => prev.map((t) => (t.id === id ? { ...t, completed } : t)))
  }

  function requestAttachmentsForTodo(todoId: string) {
    setAttachTargetTodoId(todoId)
    // Let state update before opening picker (some browsers are picky).
    queueMicrotask(() => fileInputRef.current?.click())
  }

  function handleFilesPicked(e: React.ChangeEvent<HTMLInputElement>) {
    const files = Array.from(e.target.files ?? [])
    const targetId = attachTargetTodoId

    // reset input so picking the same file again triggers onChange
    e.target.value = ""
    setAttachTargetTodoId(null)

    if (!targetId || files.length === 0) return

    const attachments = files.map(makeAttachment)

    setTodos((prev) =>
      prev.map((t) =>
        t.id === targetId
          ? { ...t, attachments: [...t.attachments, ...attachments] }
          : t
      )
    )
  }

  function deleteTodo(id: string) {
    setTodos((prev) => {
      const victim = prev.find((t) => t.id === id)
      if (victim) revokeTodoAttachments(victim)
      return prev.filter((t) => t.id !== id)
    })
  }

  function clearCompleted() {
    setTodos((prev) => {
      for (const t of prev) {
        if (t.completed) revokeTodoAttachments(t)
      }
      return prev.filter((t) => !t.completed)
    })
  }

  return (
    <Card>
      <CardHeader className="flex flex-row items-center justify-between gap-4">
        <div className="space-y-1">
          <CardTitle className="text-2xl">To‑Do</CardTitle>
          <p className="text-muted-foreground text-sm">
            {completedCount}/{filteredTodos.length} completed
          </p>
        </div>
        <ModeToggle />
      </CardHeader>

      <CardContent className="space-y-6">
        <input
          ref={fileInputRef}
          type="file"
          multiple
          className="hidden"
          accept={[
            "image/*",
            "audio/*",
            "video/*",
            ".pdf",
            ".doc",
            ".docx",
            ".xls",
            ".xlsx",
            ".csv",
            ".txt",
            ".md",
            ".rtf",
          ].join(",")}
          onChange={handleFilesPicked}
        />

        <Form {...form}>
          <form
            onSubmit={form.handleSubmit(addTodo)}
            className="space-y-2"
            noValidate
          >
            <div className="flex flex-col gap-2 sm:flex-row">
              <FormField
                control={form.control}
                name="title"
                render={({ field }) => (
                  <FormItem className="flex-1">
                    <FormControl>
                      <Input
                        placeholder="Add a task…"
                        autoComplete="off"
                        {...field}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="dueAt"
                render={({ field }) => (
                  <FormItem className="sm:w-64">
                    <FormControl>
                      <Input type="datetime-local" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <Button type="submit">Add</Button>
            </div>
          </form>
        </Form>

        <Separator />

        <div className="space-y-3">
          <div className="flex flex-wrap items-center justify-between gap-2">
            <p className="text-sm font-medium">Filter by date & time</p>
            <div className="flex items-center gap-2">
              <Button
                type="button"
                size="sm"
                variant={filterMode === "between" ? "default" : "outline"}
                onClick={() => setFilterMode("between")}
              >
                Between
              </Button>
              <Button
                type="button"
                size="sm"
                variant={filterMode === "exact" ? "default" : "outline"}
                onClick={() => setFilterMode("exact")}
              >
                Exact
              </Button>
              <Button
                type="button"
                size="sm"
                variant="ghost"
                onClick={() => {
                  setFilterFrom("")
                  setFilterTo("")
                  setFilterExact("")
                }}
              >
                Clear
              </Button>
            </div>
          </div>

          {filterMode === "between" ? (
            <div className="grid gap-2 sm:grid-cols-2">
              <Input
                type="datetime-local"
                value={filterFrom}
                onChange={(e) => setFilterFrom(e.target.value)}
                placeholder="From"
              />
              <Input
                type="datetime-local"
                value={filterTo}
                onChange={(e) => setFilterTo(e.target.value)}
                placeholder="To"
              />
            </div>
          ) : (
            <Input
              type="datetime-local"
              value={filterExact}
              onChange={(e) => setFilterExact(e.target.value)}
              placeholder="Exact date & time"
            />
          )}
        </div>

        <Separator />

        <div className="space-y-2">
          {filteredTodos.length === 0 ? (
            <p className="text-muted-foreground text-sm">No tasks yet.</p>
          ) : (
            filteredTodos
              .slice()
              .sort((a, b) => parseLocalDateTime(a.dueAt) - parseLocalDateTime(b.dueAt))
              .map((todo) => (
              <div key={todo.id} className="rounded-lg border px-3 py-2">
                <div className="flex items-start justify-between gap-3">
                  <label className="flex cursor-pointer items-start gap-3">
                    <Checkbox
                      checked={todo.completed}
                      onCheckedChange={(v) => {
                        const next = Boolean(v)
                        toggleTodo(todo.id, next)
                        if (next && !todo.completed) {
                          requestAttachmentsForTodo(todo.id)
                        }
                      }}
                      aria-label={`Mark "${todo.title}" as ${
                        todo.completed ? "not completed" : "completed"
                      }`}
                      className="mt-0.5"
                    />
                    <span
                      className={cn(
                        "leading-6",
                        todo.completed && "text-muted-foreground line-through"
                      )}
                    >
                      <span className="block">{todo.title}</span>
                      <span className="text-muted-foreground block text-xs">
                        Due: {formatLocalDateTime(todo.dueAt)}
                      </span>
                    </span>
                  </label>

                  <div className="flex items-center gap-1">
                    {todo.completed && (
                      <Button
                        type="button"
                        variant="outline"
                        size="sm"
                        onClick={() => requestAttachmentsForTodo(todo.id)}
                      >
                        Add files
                      </Button>
                    )}
                    <Button
                      type="button"
                      variant="ghost"
                      size="icon"
                      aria-label={`Delete "${todo.title}"`}
                      onClick={() => deleteTodo(todo.id)}
                    >
                      <Trash2 className="h-4 w-4" />
                    </Button>
                  </div>
                </div>

                {todo.completed && todo.attachments.length > 0 && (
                  <div className="mt-3 space-y-2">
                    <p className="text-muted-foreground text-xs">Attachments</p>
                    <ul className="space-y-1">
                      {todo.attachments.map((a) => (
                        <li
                          key={a.id}
                          className="flex items-center justify-between gap-3 rounded-md bg-muted/30 px-2 py-1"
                        >
                          <div className="flex min-w-0 items-center gap-2">
                            <AttachmentIcon kind={a.kind} />
                            <span className="truncate text-sm">{a.name}</span>
                          </div>
                          <a
                            href={a.url}
                            download={a.name}
                            className="inline-flex items-center gap-1 text-sm font-medium underline underline-offset-4"
                          >
                            <Download className="h-4 w-4" />
                            Download
                          </a>
                        </li>
                      ))}
                    </ul>
                  </div>
                )}
              </div>
            ))
          )}
        </div>

        <div className="flex items-center justify-between gap-2">
          <Button
            type="button"
            variant="secondary"
            onClick={clearCompleted}
            disabled={completedCount === 0}
          >
            Clear completed
          </Button>
          <span className="text-muted-foreground text-sm">
            Mock data only (no backend)
          </span>
        </div>
      </CardContent>
    </Card>
  )
}

```

### Added scheduling (date + time) to tasks
- **New task form** now requires **Due date & time** (`datetime-local`) and validates it with **zod**.
- Each task shows **Due: Jan 16, 2026, 03:00 PM** (localized display).

### Added filtering by date & time
- A **Filter by date & time** panel lets you:
  - **Between**: pick **From** + **To** date-times (shows tasks within the range)
  - **Exact**: pick one **exact date-time** (shows only tasks scheduled exactly at that minute)
  - **Clear**: resets filters

### Where it is
- Implemented in: `src/app/page.tsx`

### Run
```bash
npm run dev
```

```shellscript
npm run dev
```

---

**User**

I need several summary cards above the form to display brief information, including:

Today’s Tasks Card
Shows how many tasks are completed and how many tasks are still pending.

Tomorrow’s Tasks Card
Shows how many tasks are scheduled within a 4-hour time window (for example, from 8:00 AM to 12:00 PM).

Tasks Until Next Week Card
Shows how many upcoming tasks are scheduled within 4-hour time windows, similar to the previous card.

---

**Cursor**

Cool—your data model already has `dueAt` as a local date+time, so we can compute these summary stats very reliably. Next I’ll add three compact “summary cards” above the form and compute counts from all tasks (not affected by the filter), then verify build.

```typescriptreact
"use client"

import { zodResolver } from "@hookform/resolvers/zod"
import {
  Download,
  File,
  FileSpreadsheet,
  FileText,
  Image as ImageIcon,
  Music,
  Trash2,
  Video,
} from "lucide-react"
import * as React from "react"
import { useForm } from "react-hook-form"
import { z } from "zod"

import { ModeToggle } from "@/components/mode-toggle"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Checkbox } from "@/components/ui/checkbox"
import { Form, FormControl, FormField, FormItem, FormMessage } from "@/components/ui/form"
import { Input } from "@/components/ui/input"
import { Separator } from "@/components/ui/separator"
import { cn } from "@/lib/utils"

type AttachmentKind =
  | "image"
  | "audio"
  | "video"
  | "pdf"
  | "spreadsheet"
  | "document"
  | "text"
  | "file"

type Attachment = {
  id: string
  name: string
  type: string
  size: number
  url: string
  kind: AttachmentKind
}

type Todo = {
  id: string
  title: string
  completed: boolean
  // Stored as `datetime-local` string (YYYY-MM-DDTHH:mm) in local time.
  dueAt: string
  attachments: Attachment[]
}

const todoSchema = z.object({
  title: z
    .string()
    .trim()
    .min(1, "Title is required.")
    .max(80, "Keep it under 80 characters."),
  dueAt: z
    .string()
    .min(1, "Due date & time is required.")
    .regex(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}$/, "Invalid date/time."),
})

type TodoFormValues = z.infer<typeof todoSchema>

const initialTodos: Todo[] = [
  {
    id: "1",
    title: "Create a Next.js app",
    completed: true,
    dueAt: "2026-01-16T09:00",
    attachments: [],
  },
  {
    id: "2",
    title: "Add shadcn/ui + dark theme",
    completed: true,
    dueAt: "2026-01-16T10:30",
    attachments: [],
  },
  {
    id: "3",
    title: "Build a mock-data to-do list",
    completed: false,
    dueAt: "2026-01-16T15:00",
    attachments: [],
  },
]

function parseLocalDateTime(value: string): number {
  // value: "YYYY-MM-DDTHH:mm"
  const [datePart, timePart] = value.split("T")
  const [y, m, d] = datePart.split("-").map(Number)
  const [hh, mm] = timePart.split(":").map(Number)
  return new Date(y, m - 1, d, hh, mm, 0, 0).getTime()
}

function pad2(n: number) {
  return String(n).padStart(2, "0")
}

function localDateKey(d: Date) {
  return `${d.getFullYear()}-${pad2(d.getMonth() + 1)}-${pad2(d.getDate())}`
}

function addDays(date: Date, days: number) {
  const d = new Date(date)
  d.setDate(d.getDate() + days)
  return d
}

function startOfDay(date: Date) {
  return new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0, 0)
}

function formatLocalDateTime(value: string): string {
  const ms = parseLocalDateTime(value)
  if (!Number.isFinite(ms)) return value
  return new Intl.DateTimeFormat(undefined, {
    year: "numeric",
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  }).format(new Date(ms))
}

function getAttachmentKind(file: File): AttachmentKind {
  const type = (file.type || "").toLowerCase()
  const name = file.name.toLowerCase()
  const ext = name.includes(".") ? name.split(".").pop() ?? "" : ""

  if (type.startsWith("image/")) return "image"
  if (type.startsWith("audio/")) return "audio"
  if (type.startsWith("video/")) return "video"

  if (ext === "pdf") return "pdf"
  if (["xls", "xlsx", "csv"].includes(ext)) return "spreadsheet"
  if (["doc", "docx"].includes(ext)) return "document"
  if (["txt", "md", "rtf"].includes(ext)) return "text"

  return "file"
}

function makeAttachment(file: File): Attachment {
  return {
    id: crypto.randomUUID(),
    name: file.name,
    type: file.type,
    size: file.size,
    url: URL.createObjectURL(file),
    kind: getAttachmentKind(file),
  }
}

function revokeTodoAttachments(todo: Todo) {
  for (const a of todo.attachments) URL.revokeObjectURL(a.url)
}

function AttachmentIcon({ kind }: { kind: AttachmentKind }) {
  const className = "h-4 w-4 text-muted-foreground"

  switch (kind) {
    case "image":
      return <ImageIcon className={className} />
    case "audio":
      return <Music className={className} />
    case "video":
      return <Video className={className} />
    case "spreadsheet":
      return <FileSpreadsheet className={className} />
    case "pdf":
    case "document":
    case "text":
      return <FileText className={className} />
    default:
      return <File className={className} />
  }
}

export default function Home() {
  return (
    <div className="mx-auto flex min-h-screen max-w-2xl flex-col gap-6 px-4 py-10">
      <TodoApp />
    </div>
  )
}

function TodoApp() {
  const [todos, setTodos] = React.useState<Todo[]>(initialTodos)
  const [attachTargetTodoId, setAttachTargetTodoId] = React.useState<string | null>(
    null
  )
  const [filterMode, setFilterMode] = React.useState<"between" | "exact">("between")
  const [filterFrom, setFilterFrom] = React.useState<string>("")
  const [filterTo, setFilterTo] = React.useState<string>("")
  const [filterExact, setFilterExact] = React.useState<string>("")
  const fileInputRef = React.useRef<HTMLInputElement>(null)

  const todosRef = React.useRef(todos)
  React.useEffect(() => {
    todosRef.current = todos
  }, [todos])
  React.useEffect(() => {
    return () => {
      for (const t of todosRef.current) revokeTodoAttachments(t)
    }
  }, [])

  const form = useForm<TodoFormValues>({
    resolver: zodResolver(todoSchema),
    defaultValues: { title: "", dueAt: "" },
    mode: "onSubmit",
  })

  const summary = React.useMemo(() => {
    const now = new Date()
    const todayKey = localDateKey(now)
    const tomorrow = addDays(now, 1)
    const tomorrowKey = localDateKey(tomorrow)

    const todays = todos.filter((t) => t.dueAt.startsWith(todayKey))
    const todayCompleted = todays.filter((t) => t.completed).length
    const todayPending = todays.length - todayCompleted

    // Tomorrow 4-hour window: 08:00–12:00 (local time)
    const windowStartHour = 8
    const windowHours = 4
    const tomorrowWindowStart = new Date(
      tomorrow.getFullYear(),
      tomorrow.getMonth(),
      tomorrow.getDate(),
      windowStartHour,
      0,
      0,
      0
    ).getTime()
    const tomorrowWindowEnd = tomorrowWindowStart + windowHours * 60 * 60 * 1000
    const tomorrowInWindow = todos.filter((t) => {
      if (!t.dueAt.startsWith(tomorrowKey)) return false
      const ms = parseLocalDateTime(t.dueAt)
      return ms >= tomorrowWindowStart && ms < tomorrowWindowEnd
    }).length

    // Until next week = next 7 days starting tomorrow (local), grouped into 4-hour windows.
    const rangeStart = startOfDay(tomorrow).getTime()
    const rangeEnd = addDays(startOfDay(tomorrow), 7).getTime()
    const buckets = Array.from({ length: 6 }, () => 0) as number[]

    const upcoming = todos.filter((t) => {
      const ms = parseLocalDateTime(t.dueAt)
      return ms >= rangeStart && ms < rangeEnd
    })

    for (const t of upcoming) {
      const ms = parseLocalDateTime(t.dueAt)
      const hour = new Date(ms).getHours()
      const idx = Math.floor(hour / 4)
      buckets[idx] = (buckets[idx] ?? 0) + 1
    }

    const labels = ["00:00–04:00", "04:00–08:00", "08:00–12:00", "12:00–16:00", "16:00–20:00", "20:00–24:00"]

    return {
      todayCompleted,
      todayPending,
      tomorrowInWindow,
      windowLabel: `${pad2(windowStartHour)}:00–${pad2(windowStartHour + windowHours)}:00`,
      upcomingTotal: upcoming.length,
      upcomingBuckets: labels.map((label, i) => ({ label, count: buckets[i] ?? 0 })),
    }
  }, [todos])

  const filteredTodos = React.useMemo(() => {
    const withMs = todos.map((t) => ({ ...t, _dueMs: parseLocalDateTime(t.dueAt) }))
    if (filterMode === "exact") {
      if (!filterExact) return withMs
      const exactMs = parseLocalDateTime(filterExact)
      return withMs.filter((t) => t._dueMs === exactMs)
    }
    // between
    const fromMs = filterFrom ? parseLocalDateTime(filterFrom) : Number.NEGATIVE_INFINITY
    const toMs = filterTo ? parseLocalDateTime(filterTo) : Number.POSITIVE_INFINITY
    return withMs.filter((t) => t._dueMs >= fromMs && t._dueMs <= toMs)
  }, [todos, filterExact, filterFrom, filterMode, filterTo])

  const completedCount = filteredTodos.filter((t) => t.completed).length

  function addTodo(values: TodoFormValues) {
    setTodos((prev) => [
      {
        id: crypto.randomUUID(),
        title: values.title.trim(),
        completed: false,
        dueAt: values.dueAt,
        attachments: [],
      },
      ...prev,
    ])
    form.reset()
  }

  function toggleTodo(id: string, completed: boolean) {
    setTodos((prev) => prev.map((t) => (t.id === id ? { ...t, completed } : t)))
  }

  function requestAttachmentsForTodo(todoId: string) {
    setAttachTargetTodoId(todoId)
    // Let state update before opening picker (some browsers are picky).
    queueMicrotask(() => fileInputRef.current?.click())
  }

  function handleFilesPicked(e: React.ChangeEvent<HTMLInputElement>) {
    const files = Array.from(e.target.files ?? [])
    const targetId = attachTargetTodoId

    // reset input so picking the same file again triggers onChange
    e.target.value = ""
    setAttachTargetTodoId(null)

    if (!targetId || files.length === 0) return

    const attachments = files.map(makeAttachment)

    setTodos((prev) =>
      prev.map((t) =>
        t.id === targetId
          ? { ...t, attachments: [...t.attachments, ...attachments] }
          : t
      )
    )
  }

  function deleteTodo(id: string) {
    setTodos((prev) => {
      const victim = prev.find((t) => t.id === id)
      if (victim) revokeTodoAttachments(victim)
      return prev.filter((t) => t.id !== id)
    })
  }

  function clearCompleted() {
    setTodos((prev) => {
      for (const t of prev) {
        if (t.completed) revokeTodoAttachments(t)
      }
      return prev.filter((t) => !t.completed)
    })
  }

  return (
    <Card>
      <CardHeader className="flex flex-row items-center justify-between gap-4">
        <div className="space-y-1">
          <CardTitle className="text-2xl">To‑Do</CardTitle>
          <p className="text-muted-foreground text-sm">
            {completedCount}/{filteredTodos.length} completed
          </p>
        </div>
        <ModeToggle />
      </CardHeader>

      <CardContent className="space-y-6">
        <input
          ref={fileInputRef}
          type="file"
          multiple
          className="hidden"
          accept={[
            "image/*",
            "audio/*",
            "video/*",
            ".pdf",
            ".doc",
            ".docx",
            ".xls",
            ".xlsx",
            ".csv",
            ".txt",
            ".md",
            ".rtf",
          ].join(",")}
          onChange={handleFilesPicked}
        />

        <div className="grid gap-3 sm:grid-cols-3">
          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Today’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">
              {summary.todayCompleted} completed
            </p>
            <p className="text-muted-foreground text-sm">{summary.todayPending} pending</p>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tomorrow’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">{summary.tomorrowInWindow}</p>
            <p className="text-muted-foreground text-sm">
              Scheduled in {summary.windowLabel}
            </p>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tasks Until Next Week</p>
            <p className="mt-2 text-2xl font-semibold">{summary.upcomingTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.upcomingBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>
        </div>

        <Form {...form}>
          <form
            onSubmit={form.handleSubmit(addTodo)}
            className="space-y-2"
            noValidate
          >
            <div className="flex flex-col gap-2 sm:flex-row">
              <FormField
                control={form.control}
                name="title"
                render={({ field }) => (
                  <FormItem className="flex-1">
                    <FormControl>
                      <Input
                        placeholder="Add a task…"
                        autoComplete="off"
                        {...field}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="dueAt"
                render={({ field }) => (
                  <FormItem className="sm:w-64">
                    <FormControl>
                      <Input type="datetime-local" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <Button type="submit">Add</Button>
            </div>
          </form>
        </Form>

        <Separator />

        <div className="space-y-3">
          <div className="flex flex-wrap items-center justify-between gap-2">
            <p className="text-sm font-medium">Filter by date & time</p>
            <div className="flex items-center gap-2">
              <Button
                type="button"
                size="sm"
                variant={filterMode === "between" ? "default" : "outline"}
                onClick={() => setFilterMode("between")}
              >
                Between
              </Button>
              <Button
                type="button"
                size="sm"
                variant={filterMode === "exact" ? "default" : "outline"}
                onClick={() => setFilterMode("exact")}
              >
                Exact
              </Button>
              <Button
                type="button"
                size="sm"
                variant="ghost"
                onClick={() => {
                  setFilterFrom("")
                  setFilterTo("")
                  setFilterExact("")
                }}
              >
                Clear
              </Button>
            </div>
          </div>

          {filterMode === "between" ? (
            <div className="grid gap-2 sm:grid-cols-2">
              <Input
                type="datetime-local"
                value={filterFrom}
                onChange={(e) => setFilterFrom(e.target.value)}
                placeholder="From"
              />
              <Input
                type="datetime-local"
                value={filterTo}
                onChange={(e) => setFilterTo(e.target.value)}
                placeholder="To"
              />
            </div>
          ) : (
            <Input
              type="datetime-local"
              value={filterExact}
              onChange={(e) => setFilterExact(e.target.value)}
              placeholder="Exact date & time"
            />
          )}
        </div>

        <Separator />

        <div className="space-y-2">
          {filteredTodos.length === 0 ? (
            <p className="text-muted-foreground text-sm">No tasks yet.</p>
          ) : (
            filteredTodos
              .slice()
              .sort((a, b) => parseLocalDateTime(a.dueAt) - parseLocalDateTime(b.dueAt))
              .map((todo) => (
              <div key={todo.id} className="rounded-lg border px-3 py-2">
                <div className="flex items-start justify-between gap-3">
                  <label className="flex cursor-pointer items-start gap-3">
                    <Checkbox
                      checked={todo.completed}
                      onCheckedChange={(v) => {
                        const next = Boolean(v)
                        toggleTodo(todo.id, next)
                        if (next && !todo.completed) {
                          requestAttachmentsForTodo(todo.id)
                        }
                      }}
                      aria-label={`Mark "${todo.title}" as ${
                        todo.completed ? "not completed" : "completed"
                      }`}
                      className="mt-0.5"
                    />
                    <span
                      className={cn(
                        "leading-6",
                        todo.completed && "text-muted-foreground line-through"
                      )}
                    >
                      <span className="block">{todo.title}</span>
                      <span className="text-muted-foreground block text-xs">
                        Due: {formatLocalDateTime(todo.dueAt)}
                      </span>
                    </span>
                  </label>

                  <div className="flex items-center gap-1">
                    {todo.completed && (
                      <Button
                        type="button"
                        variant="outline"
                        size="sm"
                        onClick={() => requestAttachmentsForTodo(todo.id)}
                      >
                        Add files
                      </Button>
                    )}
                    <Button
                      type="button"
                      variant="ghost"
                      size="icon"
                      aria-label={`Delete "${todo.title}"`}
                      onClick={() => deleteTodo(todo.id)}
                    >
                      <Trash2 className="h-4 w-4" />
                    </Button>
                  </div>
                </div>

                {todo.completed && todo.attachments.length > 0 && (
                  <div className="mt-3 space-y-2">
                    <p className="text-muted-foreground text-xs">Attachments</p>
                    <ul className="space-y-1">
                      {todo.attachments.map((a) => (
                        <li
                          key={a.id}
                          className="flex items-center justify-between gap-3 rounded-md bg-muted/30 px-2 py-1"
                        >
                          <div className="flex min-w-0 items-center gap-2">
                            <AttachmentIcon kind={a.kind} />
                            <span className="truncate text-sm">{a.name}</span>
                          </div>
                          <a
                            href={a.url}
                            download={a.name}
                            className="inline-flex items-center gap-1 text-sm font-medium underline underline-offset-4"
                          >
                            <Download className="h-4 w-4" />
                            Download
                          </a>
                        </li>
                      ))}
                    </ul>
                  </div>
                )}
              </div>
            ))
          )}
        </div>

        <div className="flex items-center justify-between gap-2">
          <Button
            type="button"
            variant="secondary"
            onClick={clearCompleted}
            disabled={completedCount === 0}
          >
            Clear completed
          </Button>
          <span className="text-muted-foreground text-sm">
            Mock data only (no backend)
          </span>
        </div>
      </CardContent>
    </Card>
  )
}

```

### Summary cards added (above the form)
Implemented in **`src/app/page.tsx`**:

- **Today’s Tasks Card**
  - Counts tasks **due today** and shows **completed** vs **pending**.

- **Tomorrow’s Tasks Card**
  - Counts tasks **due tomorrow** within the **4-hour window 08:00–12:00** (local time).

- **Tasks Until Next Week Card**
  - Counts tasks scheduled in the **next 7 days starting tomorrow**, and shows a **breakdown by 4-hour time windows** (00–04, 04–08, 08–12, 12–16, 16–20, 20–24).

### Run
```bash
npm run dev
```

```shellscript
npm run dev
```

---

**User**

The Tomorrow’s Tasks summary card should be similar to the Tasks Until Next Week card.

---

**Cursor**

Got it—I'll change **Tomorrow’s Tasks** to show the same kind of **4-hour bucket breakdown** (00–04, 04–08, …) but **restricted to tomorrow only**, instead of a single 08:00–12:00 window. Next I’ll update `src/app/page.tsx` and re-run a build.

```typescriptreact
"use client"

import { zodResolver } from "@hookform/resolvers/zod"
import {
  Download,
  File,
  FileSpreadsheet,
  FileText,
  Image as ImageIcon,
  Music,
  Trash2,
  Video,
} from "lucide-react"
import * as React from "react"
import { useForm } from "react-hook-form"
import { z } from "zod"

import { ModeToggle } from "@/components/mode-toggle"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Checkbox } from "@/components/ui/checkbox"
import { Form, FormControl, FormField, FormItem, FormMessage } from "@/components/ui/form"
import { Input } from "@/components/ui/input"
import { Separator } from "@/components/ui/separator"
import { cn } from "@/lib/utils"

type AttachmentKind =
  | "image"
  | "audio"
  | "video"
  | "pdf"
  | "spreadsheet"
  | "document"
  | "text"
  | "file"

type Attachment = {
  id: string
  name: string
  type: string
  size: number
  url: string
  kind: AttachmentKind
}

type Todo = {
  id: string
  title: string
  completed: boolean
  // Stored as `datetime-local` string (YYYY-MM-DDTHH:mm) in local time.
  dueAt: string
  attachments: Attachment[]
}

const todoSchema = z.object({
  title: z
    .string()
    .trim()
    .min(1, "Title is required.")
    .max(80, "Keep it under 80 characters."),
  dueAt: z
    .string()
    .min(1, "Due date & time is required.")
    .regex(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}$/, "Invalid date/time."),
})

type TodoFormValues = z.infer<typeof todoSchema>

const initialTodos: Todo[] = [
  {
    id: "1",
    title: "Create a Next.js app",
    completed: true,
    dueAt: "2026-01-16T09:00",
    attachments: [],
  },
  {
    id: "2",
    title: "Add shadcn/ui + dark theme",
    completed: true,
    dueAt: "2026-01-16T10:30",
    attachments: [],
  },
  {
    id: "3",
    title: "Build a mock-data to-do list",
    completed: false,
    dueAt: "2026-01-16T15:00",
    attachments: [],
  },
]

function parseLocalDateTime(value: string): number {
  // value: "YYYY-MM-DDTHH:mm"
  const [datePart, timePart] = value.split("T")
  const [y, m, d] = datePart.split("-").map(Number)
  const [hh, mm] = timePart.split(":").map(Number)
  return new Date(y, m - 1, d, hh, mm, 0, 0).getTime()
}

function pad2(n: number) {
  return String(n).padStart(2, "0")
}

function localDateKey(d: Date) {
  return `${d.getFullYear()}-${pad2(d.getMonth() + 1)}-${pad2(d.getDate())}`
}

function addDays(date: Date, days: number) {
  const d = new Date(date)
  d.setDate(d.getDate() + days)
  return d
}

function startOfDay(date: Date) {
  return new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0, 0)
}

function formatLocalDateTime(value: string): string {
  const ms = parseLocalDateTime(value)
  if (!Number.isFinite(ms)) return value
  return new Intl.DateTimeFormat(undefined, {
    year: "numeric",
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  }).format(new Date(ms))
}

function getAttachmentKind(file: File): AttachmentKind {
  const type = (file.type || "").toLowerCase()
  const name = file.name.toLowerCase()
  const ext = name.includes(".") ? name.split(".").pop() ?? "" : ""

  if (type.startsWith("image/")) return "image"
  if (type.startsWith("audio/")) return "audio"
  if (type.startsWith("video/")) return "video"

  if (ext === "pdf") return "pdf"
  if (["xls", "xlsx", "csv"].includes(ext)) return "spreadsheet"
  if (["doc", "docx"].includes(ext)) return "document"
  if (["txt", "md", "rtf"].includes(ext)) return "text"

  return "file"
}

function makeAttachment(file: File): Attachment {
  return {
    id: crypto.randomUUID(),
    name: file.name,
    type: file.type,
    size: file.size,
    url: URL.createObjectURL(file),
    kind: getAttachmentKind(file),
  }
}

function revokeTodoAttachments(todo: Todo) {
  for (const a of todo.attachments) URL.revokeObjectURL(a.url)
}

function AttachmentIcon({ kind }: { kind: AttachmentKind }) {
  const className = "h-4 w-4 text-muted-foreground"

  switch (kind) {
    case "image":
      return <ImageIcon className={className} />
    case "audio":
      return <Music className={className} />
    case "video":
      return <Video className={className} />
    case "spreadsheet":
      return <FileSpreadsheet className={className} />
    case "pdf":
    case "document":
    case "text":
      return <FileText className={className} />
    default:
      return <File className={className} />
  }
}

export default function Home() {
  return (
    <div className="mx-auto flex min-h-screen max-w-2xl flex-col gap-6 px-4 py-10">
      <TodoApp />
    </div>
  )
}

function TodoApp() {
  const [todos, setTodos] = React.useState<Todo[]>(initialTodos)
  const [attachTargetTodoId, setAttachTargetTodoId] = React.useState<string | null>(
    null
  )
  const [filterMode, setFilterMode] = React.useState<"between" | "exact">("between")
  const [filterFrom, setFilterFrom] = React.useState<string>("")
  const [filterTo, setFilterTo] = React.useState<string>("")
  const [filterExact, setFilterExact] = React.useState<string>("")
  const fileInputRef = React.useRef<HTMLInputElement>(null)

  const todosRef = React.useRef(todos)
  React.useEffect(() => {
    todosRef.current = todos
  }, [todos])
  React.useEffect(() => {
    return () => {
      for (const t of todosRef.current) revokeTodoAttachments(t)
    }
  }, [])

  const form = useForm<TodoFormValues>({
    resolver: zodResolver(todoSchema),
    defaultValues: { title: "", dueAt: "" },
    mode: "onSubmit",
  })

  const summary = React.useMemo(() => {
    const now = new Date()
    const todayKey = localDateKey(now)
    const tomorrow = addDays(now, 1)
    const tomorrowKey = localDateKey(tomorrow)

    const todays = todos.filter((t) => t.dueAt.startsWith(todayKey))
    const todayCompleted = todays.filter((t) => t.completed).length
    const todayPending = todays.length - todayCompleted

    const labels = [
      "00:00–04:00",
      "04:00–08:00",
      "08:00–12:00",
      "12:00–16:00",
      "16:00–20:00",
      "20:00–24:00",
    ]

    // Tomorrow: same 4-hour windows breakdown
    const tomorrowTasks = todos.filter((t) => t.dueAt.startsWith(tomorrowKey))
    const tomorrowBuckets = Array.from({ length: 6 }, () => 0) as number[]
    for (const t of tomorrowTasks) {
      const ms = parseLocalDateTime(t.dueAt)
      const hour = new Date(ms).getHours()
      const idx = Math.floor(hour / 4)
      tomorrowBuckets[idx] = (tomorrowBuckets[idx] ?? 0) + 1
    }

    // Until next week = next 7 days starting tomorrow (local), grouped into 4-hour windows.
    const rangeStart = startOfDay(tomorrow).getTime()
    const rangeEnd = addDays(startOfDay(tomorrow), 7).getTime()
    const buckets = Array.from({ length: 6 }, () => 0) as number[]

    const upcoming = todos.filter((t) => {
      const ms = parseLocalDateTime(t.dueAt)
      return ms >= rangeStart && ms < rangeEnd
    })

    for (const t of upcoming) {
      const ms = parseLocalDateTime(t.dueAt)
      const hour = new Date(ms).getHours()
      const idx = Math.floor(hour / 4)
      buckets[idx] = (buckets[idx] ?? 0) + 1
    }

    return {
      todayCompleted,
      todayPending,
      tomorrowTotal: tomorrowTasks.length,
      tomorrowBuckets: labels.map((label, i) => ({ label, count: tomorrowBuckets[i] ?? 0 })),
      upcomingTotal: upcoming.length,
      upcomingBuckets: labels.map((label, i) => ({ label, count: buckets[i] ?? 0 })),
    }
  }, [todos])

  const filteredTodos = React.useMemo(() => {
    const withMs = todos.map((t) => ({ ...t, _dueMs: parseLocalDateTime(t.dueAt) }))
    if (filterMode === "exact") {
      if (!filterExact) return withMs
      const exactMs = parseLocalDateTime(filterExact)
      return withMs.filter((t) => t._dueMs === exactMs)
    }
    // between
    const fromMs = filterFrom ? parseLocalDateTime(filterFrom) : Number.NEGATIVE_INFINITY
    const toMs = filterTo ? parseLocalDateTime(filterTo) : Number.POSITIVE_INFINITY
    return withMs.filter((t) => t._dueMs >= fromMs && t._dueMs <= toMs)
  }, [todos, filterExact, filterFrom, filterMode, filterTo])

  const completedCount = filteredTodos.filter((t) => t.completed).length

  function addTodo(values: TodoFormValues) {
    setTodos((prev) => [
      {
        id: crypto.randomUUID(),
        title: values.title.trim(),
        completed: false,
        dueAt: values.dueAt,
        attachments: [],
      },
      ...prev,
    ])
    form.reset()
  }

  function toggleTodo(id: string, completed: boolean) {
    setTodos((prev) => prev.map((t) => (t.id === id ? { ...t, completed } : t)))
  }

  function requestAttachmentsForTodo(todoId: string) {
    setAttachTargetTodoId(todoId)
    // Let state update before opening picker (some browsers are picky).
    queueMicrotask(() => fileInputRef.current?.click())
  }

  function handleFilesPicked(e: React.ChangeEvent<HTMLInputElement>) {
    const files = Array.from(e.target.files ?? [])
    const targetId = attachTargetTodoId

    // reset input so picking the same file again triggers onChange
    e.target.value = ""
    setAttachTargetTodoId(null)

    if (!targetId || files.length === 0) return

    const attachments = files.map(makeAttachment)

    setTodos((prev) =>
      prev.map((t) =>
        t.id === targetId
          ? { ...t, attachments: [...t.attachments, ...attachments] }
          : t
      )
    )
  }

  function deleteTodo(id: string) {
    setTodos((prev) => {
      const victim = prev.find((t) => t.id === id)
      if (victim) revokeTodoAttachments(victim)
      return prev.filter((t) => t.id !== id)
    })
  }

  function clearCompleted() {
    setTodos((prev) => {
      for (const t of prev) {
        if (t.completed) revokeTodoAttachments(t)
      }
      return prev.filter((t) => !t.completed)
    })
  }

  return (
    <Card>
      <CardHeader className="flex flex-row items-center justify-between gap-4">
        <div className="space-y-1">
          <CardTitle className="text-2xl">To‑Do</CardTitle>
          <p className="text-muted-foreground text-sm">
            {completedCount}/{filteredTodos.length} completed
          </p>
        </div>
        <ModeToggle />
      </CardHeader>

      <CardContent className="space-y-6">
        <input
          ref={fileInputRef}
          type="file"
          multiple
          className="hidden"
          accept={[
            "image/*",
            "audio/*",
            "video/*",
            ".pdf",
            ".doc",
            ".docx",
            ".xls",
            ".xlsx",
            ".csv",
            ".txt",
            ".md",
            ".rtf",
          ].join(",")}
          onChange={handleFilesPicked}
        />

        <div className="grid gap-3 sm:grid-cols-3">
          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Today’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">
              {summary.todayCompleted} completed
            </p>
            <p className="text-muted-foreground text-sm">{summary.todayPending} pending</p>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tomorrow’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">{summary.tomorrowTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.tomorrowBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tasks Until Next Week</p>
            <p className="mt-2 text-2xl font-semibold">{summary.upcomingTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.upcomingBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>
        </div>

        <Form {...form}>
          <form
            onSubmit={form.handleSubmit(addTodo)}
            className="space-y-2"
            noValidate
          >
            <div className="flex flex-col gap-2 sm:flex-row">
              <FormField
                control={form.control}
                name="title"
                render={({ field }) => (
                  <FormItem className="flex-1">
                    <FormControl>
                      <Input
                        placeholder="Add a task…"
                        autoComplete="off"
                        {...field}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="dueAt"
                render={({ field }) => (
                  <FormItem className="sm:w-64">
                    <FormControl>
                      <Input type="datetime-local" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <Button type="submit">Add</Button>
            </div>
          </form>
        </Form>

        <Separator />

        <div className="space-y-3">
          <div className="flex flex-wrap items-center justify-between gap-2">
            <p className="text-sm font-medium">Filter by date & time</p>
            <div className="flex items-center gap-2">
              <Button
                type="button"
                size="sm"
                variant={filterMode === "between" ? "default" : "outline"}
                onClick={() => setFilterMode("between")}
              >
                Between
              </Button>
              <Button
                type="button"
                size="sm"
                variant={filterMode === "exact" ? "default" : "outline"}
                onClick={() => setFilterMode("exact")}
              >
                Exact
              </Button>
              <Button
                type="button"
                size="sm"
                variant="ghost"
                onClick={() => {
                  setFilterFrom("")
                  setFilterTo("")
                  setFilterExact("")
                }}
              >
                Clear
              </Button>
            </div>
          </div>

          {filterMode === "between" ? (
            <div className="grid gap-2 sm:grid-cols-2">
              <Input
                type="datetime-local"
                value={filterFrom}
                onChange={(e) => setFilterFrom(e.target.value)}
                placeholder="From"
              />
              <Input
                type="datetime-local"
                value={filterTo}
                onChange={(e) => setFilterTo(e.target.value)}
                placeholder="To"
              />
            </div>
          ) : (
            <Input
              type="datetime-local"
              value={filterExact}
              onChange={(e) => setFilterExact(e.target.value)}
              placeholder="Exact date & time"
            />
          )}
        </div>

        <Separator />

        <div className="space-y-2">
          {filteredTodos.length === 0 ? (
            <p className="text-muted-foreground text-sm">No tasks yet.</p>
          ) : (
            filteredTodos
              .slice()
              .sort((a, b) => parseLocalDateTime(a.dueAt) - parseLocalDateTime(b.dueAt))
              .map((todo) => (
              <div key={todo.id} className="rounded-lg border px-3 py-2">
                <div className="flex items-start justify-between gap-3">
                  <label className="flex cursor-pointer items-start gap-3">
                    <Checkbox
                      checked={todo.completed}
                      onCheckedChange={(v) => {
                        const next = Boolean(v)
                        toggleTodo(todo.id, next)
                        if (next && !todo.completed) {
                          requestAttachmentsForTodo(todo.id)
                        }
                      }}
                      aria-label={`Mark "${todo.title}" as ${
                        todo.completed ? "not completed" : "completed"
                      }`}
                      className="mt-0.5"
                    />
                    <span
                      className={cn(
                        "leading-6",
                        todo.completed && "text-muted-foreground line-through"
                      )}
                    >
                      <span className="block">{todo.title}</span>
                      <span className="text-muted-foreground block text-xs">
                        Due: {formatLocalDateTime(todo.dueAt)}
                      </span>
                    </span>
                  </label>

                  <div className="flex items-center gap-1">
                    {todo.completed && (
                      <Button
                        type="button"
                        variant="outline"
                        size="sm"
                        onClick={() => requestAttachmentsForTodo(todo.id)}
                      >
                        Add files
                      </Button>
                    )}
                    <Button
                      type="button"
                      variant="ghost"
                      size="icon"
                      aria-label={`Delete "${todo.title}"`}
                      onClick={() => deleteTodo(todo.id)}
                    >
                      <Trash2 className="h-4 w-4" />
                    </Button>
                  </div>
                </div>

                {todo.completed && todo.attachments.length > 0 && (
                  <div className="mt-3 space-y-2">
                    <p className="text-muted-foreground text-xs">Attachments</p>
                    <ul className="space-y-1">
                      {todo.attachments.map((a) => (
                        <li
                          key={a.id}
                          className="flex items-center justify-between gap-3 rounded-md bg-muted/30 px-2 py-1"
                        >
                          <div className="flex min-w-0 items-center gap-2">
                            <AttachmentIcon kind={a.kind} />
                            <span className="truncate text-sm">{a.name}</span>
                          </div>
                          <a
                            href={a.url}
                            download={a.name}
                            className="inline-flex items-center gap-1 text-sm font-medium underline underline-offset-4"
                          >
                            <Download className="h-4 w-4" />
                            Download
                          </a>
                        </li>
                      ))}
                    </ul>
                  </div>
                )}
              </div>
            ))
          )}
        </div>

        <div className="flex items-center justify-between gap-2">
          <Button
            type="button"
            variant="secondary"
            onClick={clearCompleted}
            disabled={completedCount === 0}
          >
            Clear completed
          </Button>
          <span className="text-muted-foreground text-sm">
            Mock data only (no backend)
          </span>
        </div>
      </CardContent>
    </Card>
  )
}

```

### Updated Tomorrow’s Tasks card
- **Tomorrow’s Tasks** now matches **Tasks Until Next Week** style:
  - shows **total tasks due tomorrow**
  - shows a **4-hour window breakdown** (00–04, 04–08, 08–12, 12–16, 16–20, 20–24)

### Where
- `src/app/page.tsx`

---

**User**

If only a date is selected, display tasks for that date. If a time is selected, filter the tasks by time.

---

**Cursor**

Yep—right now the filters require a full date+time, so I’ll refactor the filter UI into separate **Date** and **Time** inputs. Then the filter logic will behave like you described: **date-only → filter by date**, and **time present → additionally filter by time (or time range)**.

```typescriptreact
"use client"

import { zodResolver } from "@hookform/resolvers/zod"
import {
  Download,
  File,
  FileSpreadsheet,
  FileText,
  Image as ImageIcon,
  Music,
  Trash2,
  Video,
} from "lucide-react"
import * as React from "react"
import { useForm } from "react-hook-form"
import { z } from "zod"

import { ModeToggle } from "@/components/mode-toggle"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Checkbox } from "@/components/ui/checkbox"
import { Form, FormControl, FormField, FormItem, FormMessage } from "@/components/ui/form"
import { Input } from "@/components/ui/input"
import { Separator } from "@/components/ui/separator"
import { cn } from "@/lib/utils"

type AttachmentKind =
  | "image"
  | "audio"
  | "video"
  | "pdf"
  | "spreadsheet"
  | "document"
  | "text"
  | "file"

type Attachment = {
  id: string
  name: string
  type: string
  size: number
  url: string
  kind: AttachmentKind
}

type Todo = {
  id: string
  title: string
  completed: boolean
  // Stored as `datetime-local` string (YYYY-MM-DDTHH:mm) in local time.
  dueAt: string
  attachments: Attachment[]
}

const todoSchema = z.object({
  title: z
    .string()
    .trim()
    .min(1, "Title is required.")
    .max(80, "Keep it under 80 characters."),
  dueAt: z
    .string()
    .min(1, "Due date & time is required.")
    .regex(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}$/, "Invalid date/time."),
})

type TodoFormValues = z.infer<typeof todoSchema>

const initialTodos: Todo[] = [
  {
    id: "1",
    title: "Create a Next.js app",
    completed: true,
    dueAt: "2026-01-16T09:00",
    attachments: [],
  },
  {
    id: "2",
    title: "Add shadcn/ui + dark theme",
    completed: true,
    dueAt: "2026-01-16T10:30",
    attachments: [],
  },
  {
    id: "3",
    title: "Build a mock-data to-do list",
    completed: false,
    dueAt: "2026-01-16T15:00",
    attachments: [],
  },
]

function parseLocalDateTime(value: string): number {
  // value: "YYYY-MM-DDTHH:mm"
  const [datePart, timePart] = value.split("T")
  const [y, m, d] = datePart.split("-").map(Number)
  const [hh, mm] = timePart.split(":").map(Number)
  return new Date(y, m - 1, d, hh, mm, 0, 0).getTime()
}

function pad2(n: number) {
  return String(n).padStart(2, "0")
}

function localDateKey(d: Date) {
  return `${d.getFullYear()}-${pad2(d.getMonth() + 1)}-${pad2(d.getDate())}`
}

function addDays(date: Date, days: number) {
  const d = new Date(date)
  d.setDate(d.getDate() + days)
  return d
}

function startOfDay(date: Date) {
  return new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0, 0)
}

function endOfDay(date: Date) {
  return new Date(
    date.getFullYear(),
    date.getMonth(),
    date.getDate(),
    23,
    59,
    59,
    999
  )
}

function getDatePart(dueAt: string) {
  return dueAt.split("T")[0] ?? ""
}

function getTimePart(dueAt: string) {
  return dueAt.split("T")[1] ?? ""
}

function parseLocalDateOnly(value: string): Date {
  // value: "YYYY-MM-DD"
  const [y, m, d] = value.split("-").map(Number)
  return new Date(y, m - 1, d, 0, 0, 0, 0)
}

function parseLocalTimeToMinutes(value: string): number {
  // value: "HH:mm"
  const [hh, mm] = value.split(":").map(Number)
  return hh * 60 + mm
}

function formatLocalDateTime(value: string): string {
  const ms = parseLocalDateTime(value)
  if (!Number.isFinite(ms)) return value
  return new Intl.DateTimeFormat(undefined, {
    year: "numeric",
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  }).format(new Date(ms))
}

function getAttachmentKind(file: File): AttachmentKind {
  const type = (file.type || "").toLowerCase()
  const name = file.name.toLowerCase()
  const ext = name.includes(".") ? name.split(".").pop() ?? "" : ""

  if (type.startsWith("image/")) return "image"
  if (type.startsWith("audio/")) return "audio"
  if (type.startsWith("video/")) return "video"

  if (ext === "pdf") return "pdf"
  if (["xls", "xlsx", "csv"].includes(ext)) return "spreadsheet"
  if (["doc", "docx"].includes(ext)) return "document"
  if (["txt", "md", "rtf"].includes(ext)) return "text"

  return "file"
}

function makeAttachment(file: File): Attachment {
  return {
    id: crypto.randomUUID(),
    name: file.name,
    type: file.type,
    size: file.size,
    url: URL.createObjectURL(file),
    kind: getAttachmentKind(file),
  }
}

function revokeTodoAttachments(todo: Todo) {
  for (const a of todo.attachments) URL.revokeObjectURL(a.url)
}

function AttachmentIcon({ kind }: { kind: AttachmentKind }) {
  const className = "h-4 w-4 text-muted-foreground"

  switch (kind) {
    case "image":
      return <ImageIcon className={className} />
    case "audio":
      return <Music className={className} />
    case "video":
      return <Video className={className} />
    case "spreadsheet":
      return <FileSpreadsheet className={className} />
    case "pdf":
    case "document":
    case "text":
      return <FileText className={className} />
    default:
      return <File className={className} />
  }
}

export default function Home() {
  return (
    <div className="mx-auto flex min-h-screen max-w-2xl flex-col gap-6 px-4 py-10">
      <TodoApp />
    </div>
  )
}

function TodoApp() {
  const [todos, setTodos] = React.useState<Todo[]>(initialTodos)
  const [attachTargetTodoId, setAttachTargetTodoId] = React.useState<string | null>(
    null
  )
  const [filterMode, setFilterMode] = React.useState<"between" | "exact">("between")
  const [filterFromDate, setFilterFromDate] = React.useState<string>("")
  const [filterFromTime, setFilterFromTime] = React.useState<string>("")
  const [filterToDate, setFilterToDate] = React.useState<string>("")
  const [filterToTime, setFilterToTime] = React.useState<string>("")
  const [filterExactDate, setFilterExactDate] = React.useState<string>("")
  const [filterExactTime, setFilterExactTime] = React.useState<string>("")
  const fileInputRef = React.useRef<HTMLInputElement>(null)

  const todosRef = React.useRef(todos)
  React.useEffect(() => {
    todosRef.current = todos
  }, [todos])
  React.useEffect(() => {
    return () => {
      for (const t of todosRef.current) revokeTodoAttachments(t)
    }
  }, [])

  const form = useForm<TodoFormValues>({
    resolver: zodResolver(todoSchema),
    defaultValues: { title: "", dueAt: "" },
    mode: "onSubmit",
  })

  const summary = React.useMemo(() => {
    const now = new Date()
    const todayKey = localDateKey(now)
    const tomorrow = addDays(now, 1)
    const tomorrowKey = localDateKey(tomorrow)

    const todays = todos.filter((t) => t.dueAt.startsWith(todayKey))
    const todayCompleted = todays.filter((t) => t.completed).length
    const todayPending = todays.length - todayCompleted

    const labels = [
      "00:00–04:00",
      "04:00–08:00",
      "08:00–12:00",
      "12:00–16:00",
      "16:00–20:00",
      "20:00–24:00",
    ]

    // Tomorrow: same 4-hour windows breakdown
    const tomorrowTasks = todos.filter((t) => t.dueAt.startsWith(tomorrowKey))
    const tomorrowBuckets = Array.from({ length: 6 }, () => 0) as number[]
    for (const t of tomorrowTasks) {
      const ms = parseLocalDateTime(t.dueAt)
      const hour = new Date(ms).getHours()
      const idx = Math.floor(hour / 4)
      tomorrowBuckets[idx] = (tomorrowBuckets[idx] ?? 0) + 1
    }

    // Until next week = next 7 days starting tomorrow (local), grouped into 4-hour windows.
    const rangeStart = startOfDay(tomorrow).getTime()
    const rangeEnd = addDays(startOfDay(tomorrow), 7).getTime()
    const buckets = Array.from({ length: 6 }, () => 0) as number[]

    const upcoming = todos.filter((t) => {
      const ms = parseLocalDateTime(t.dueAt)
      return ms >= rangeStart && ms < rangeEnd
    })

    for (const t of upcoming) {
      const ms = parseLocalDateTime(t.dueAt)
      const hour = new Date(ms).getHours()
      const idx = Math.floor(hour / 4)
      buckets[idx] = (buckets[idx] ?? 0) + 1
    }

    return {
      todayCompleted,
      todayPending,
      tomorrowTotal: tomorrowTasks.length,
      tomorrowBuckets: labels.map((label, i) => ({ label, count: tomorrowBuckets[i] ?? 0 })),
      upcomingTotal: upcoming.length,
      upcomingBuckets: labels.map((label, i) => ({ label, count: buckets[i] ?? 0 })),
    }
  }, [todos])

  const filteredTodos = React.useMemo(() => {
    const withMs = todos.map((t) => ({ ...t, _dueMs: parseLocalDateTime(t.dueAt) }))
    if (filterMode === "exact") {
      // If only date is selected -> show tasks for that date.
      // If time is selected too -> match exact date+time.
      // If only time is selected -> match time-of-day across all dates.
      if (!filterExactDate && !filterExactTime) return withMs

      if (filterExactDate && !filterExactTime) {
        return withMs.filter((t) => getDatePart(t.dueAt) === filterExactDate)
      }

      if (filterExactDate && filterExactTime) {
        const exactMs = parseLocalDateTime(`${filterExactDate}T${filterExactTime}`)
        return withMs.filter((t) => t._dueMs === exactMs)
      }

      // time only
      return withMs.filter((t) => getTimePart(t.dueAt) === filterExactTime)
    }
    // between
    const hasAnyDate = Boolean(filterFromDate || filterToDate)
    const hasAnyTime = Boolean(filterFromTime || filterToTime)

    // Date range (optional)
    const fromDateMs = filterFromDate
      ? startOfDay(parseLocalDateOnly(filterFromDate)).getTime()
      : Number.NEGATIVE_INFINITY
    const toDateMs = filterToDate
      ? endOfDay(parseLocalDateOnly(filterToDate)).getTime()
      : Number.POSITIVE_INFINITY

    // Time-of-day range (optional)
    const fromTimeMin = filterFromTime ? parseLocalTimeToMinutes(filterFromTime) : 0
    const toTimeMin = filterToTime ? parseLocalTimeToMinutes(filterToTime) : 24 * 60 - 1

    return withMs.filter((t) => {
      const ms = t._dueMs
      if (hasAnyDate && (ms < fromDateMs || ms > toDateMs)) return false

      if (hasAnyTime) {
        const time = getTimePart(t.dueAt)
        if (!time) return false
        const mins = parseLocalTimeToMinutes(time)
        // Simple (non-wrapping) range. If you want wrap-around (e.g. 22:00–02:00), tell me.
        if (mins < fromTimeMin || mins > toTimeMin) return false
      }

      // If neither date nor time selected, pass through (handled above anyway)
      return true
    })
  }, [
    todos,
    filterExactDate,
    filterExactTime,
    filterFromDate,
    filterFromTime,
    filterMode,
    filterToDate,
    filterToTime,
  ])

  const completedCount = filteredTodos.filter((t) => t.completed).length

  function addTodo(values: TodoFormValues) {
    setTodos((prev) => [
      {
        id: crypto.randomUUID(),
        title: values.title.trim(),
        completed: false,
        dueAt: values.dueAt,
        attachments: [],
      },
      ...prev,
    ])
    form.reset()
  }

  function toggleTodo(id: string, completed: boolean) {
    setTodos((prev) => prev.map((t) => (t.id === id ? { ...t, completed } : t)))
  }

  function requestAttachmentsForTodo(todoId: string) {
    setAttachTargetTodoId(todoId)
    // Let state update before opening picker (some browsers are picky).
    queueMicrotask(() => fileInputRef.current?.click())
  }

  function handleFilesPicked(e: React.ChangeEvent<HTMLInputElement>) {
    const files = Array.from(e.target.files ?? [])
    const targetId = attachTargetTodoId

    // reset input so picking the same file again triggers onChange
    e.target.value = ""
    setAttachTargetTodoId(null)

    if (!targetId || files.length === 0) return

    const attachments = files.map(makeAttachment)

    setTodos((prev) =>
      prev.map((t) =>
        t.id === targetId
          ? { ...t, attachments: [...t.attachments, ...attachments] }
          : t
      )
    )
  }

  function deleteTodo(id: string) {
    setTodos((prev) => {
      const victim = prev.find((t) => t.id === id)
      if (victim) revokeTodoAttachments(victim)
      return prev.filter((t) => t.id !== id)
    })
  }

  function clearCompleted() {
    setTodos((prev) => {
      for (const t of prev) {
        if (t.completed) revokeTodoAttachments(t)
      }
      return prev.filter((t) => !t.completed)
    })
  }

  return (
    <Card>
      <CardHeader className="flex flex-row items-center justify-between gap-4">
        <div className="space-y-1">
          <CardTitle className="text-2xl">To‑Do</CardTitle>
          <p className="text-muted-foreground text-sm">
            {completedCount}/{filteredTodos.length} completed
          </p>
        </div>
        <ModeToggle />
      </CardHeader>

      <CardContent className="space-y-6">
        <input
          ref={fileInputRef}
          type="file"
          multiple
          className="hidden"
          accept={[
            "image/*",
            "audio/*",
            "video/*",
            ".pdf",
            ".doc",
            ".docx",
            ".xls",
            ".xlsx",
            ".csv",
            ".txt",
            ".md",
            ".rtf",
          ].join(",")}
          onChange={handleFilesPicked}
        />

        <div className="grid gap-3 sm:grid-cols-3">
          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Today’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">
              {summary.todayCompleted} completed
            </p>
            <p className="text-muted-foreground text-sm">{summary.todayPending} pending</p>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tomorrow’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">{summary.tomorrowTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.tomorrowBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tasks Until Next Week</p>
            <p className="mt-2 text-2xl font-semibold">{summary.upcomingTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.upcomingBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>
        </div>

        <Form {...form}>
          <form
            onSubmit={form.handleSubmit(addTodo)}
            className="space-y-2"
            noValidate
          >
            <div className="flex flex-col gap-2 sm:flex-row">
              <FormField
                control={form.control}
                name="title"
                render={({ field }) => (
                  <FormItem className="flex-1">
                    <FormControl>
                      <Input
                        placeholder="Add a task…"
                        autoComplete="off"
                        {...field}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="dueAt"
                render={({ field }) => (
                  <FormItem className="sm:w-64">
                    <FormControl>
                      <Input type="datetime-local" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <Button type="submit">Add</Button>
            </div>
          </form>
        </Form>

        <Separator />

        <div className="space-y-3">
          <div className="flex flex-wrap items-center justify-between gap-2">
            <p className="text-sm font-medium">Filter by date & time</p>
            <div className="flex items-center gap-2">
              <Button
                type="button"
                size="sm"
                variant={filterMode === "between" ? "default" : "outline"}
                onClick={() => setFilterMode("between")}
              >
                Between
              </Button>
              <Button
                type="button"
                size="sm"
                variant={filterMode === "exact" ? "default" : "outline"}
                onClick={() => setFilterMode("exact")}
              >
                Exact
              </Button>
              <Button
                type="button"
                size="sm"
                variant="ghost"
                onClick={() => {
                  setFilterFromDate("")
                  setFilterFromTime("")
                  setFilterToDate("")
                  setFilterToTime("")
                  setFilterExactDate("")
                  setFilterExactTime("")
                }}
              >
                Clear
              </Button>
            </div>
          </div>

          {filterMode === "between" ? (
            <div className="grid gap-2 sm:grid-cols-2">
              <div className="grid gap-2 sm:grid-cols-2">
                <Input
                  type="date"
                  value={filterFromDate}
                  onChange={(e) => setFilterFromDate(e.target.value)}
                />
                <Input
                  type="time"
                  value={filterFromTime}
                  onChange={(e) => setFilterFromTime(e.target.value)}
                />
              </div>
              <div className="grid gap-2 sm:grid-cols-2">
                <Input
                  type="date"
                  value={filterToDate}
                  onChange={(e) => setFilterToDate(e.target.value)}
                />
                <Input
                  type="time"
                  value={filterToTime}
                  onChange={(e) => setFilterToTime(e.target.value)}
                />
              </div>
            </div>
          ) : (
            <div className="grid gap-2 sm:grid-cols-2">
              <Input
                type="date"
                value={filterExactDate}
                onChange={(e) => setFilterExactDate(e.target.value)}
              />
              <Input
                type="time"
                value={filterExactTime}
                onChange={(e) => setFilterExactTime(e.target.value)}
              />
            </div>
          )}
        </div>

        <Separator />

        <div className="space-y-2">
          {filteredTodos.length === 0 ? (
            <p className="text-muted-foreground text-sm">No tasks yet.</p>
          ) : (
            filteredTodos
              .slice()
              .sort((a, b) => parseLocalDateTime(a.dueAt) - parseLocalDateTime(b.dueAt))
              .map((todo) => (
              <div key={todo.id} className="rounded-lg border px-3 py-2">
                <div className="flex items-start justify-between gap-3">
                  <label className="flex cursor-pointer items-start gap-3">
                    <Checkbox
                      checked={todo.completed}
                      onCheckedChange={(v) => {
                        const next = Boolean(v)
                        toggleTodo(todo.id, next)
                        if (next && !todo.completed) {
                          requestAttachmentsForTodo(todo.id)
                        }
                      }}
                      aria-label={`Mark "${todo.title}" as ${
                        todo.completed ? "not completed" : "completed"
                      }`}
                      className="mt-0.5"
                    />
                    <span
                      className={cn(
                        "leading-6",
                        todo.completed && "text-muted-foreground line-through"
                      )}
                    >
                      <span className="block">{todo.title}</span>
                      <span className="text-muted-foreground block text-xs">
                        Due: {formatLocalDateTime(todo.dueAt)}
                      </span>
                    </span>
                  </label>

                  <div className="flex items-center gap-1">
                    {todo.completed && (
                      <Button
                        type="button"
                        variant="outline"
                        size="sm"
                        onClick={() => requestAttachmentsForTodo(todo.id)}
                      >
                        Add files
                      </Button>
                    )}
                    <Button
                      type="button"
                      variant="ghost"
                      size="icon"
                      aria-label={`Delete "${todo.title}"`}
                      onClick={() => deleteTodo(todo.id)}
                    >
                      <Trash2 className="h-4 w-4" />
                    </Button>
                  </div>
                </div>

                {todo.completed && todo.attachments.length > 0 && (
                  <div className="mt-3 space-y-2">
                    <p className="text-muted-foreground text-xs">Attachments</p>
                    <ul className="space-y-1">
                      {todo.attachments.map((a) => (
                        <li
                          key={a.id}
                          className="flex items-center justify-between gap-3 rounded-md bg-muted/30 px-2 py-1"
                        >
                          <div className="flex min-w-0 items-center gap-2">
                            <AttachmentIcon kind={a.kind} />
                            <span className="truncate text-sm">{a.name}</span>
                          </div>
                          <a
                            href={a.url}
                            download={a.name}
                            className="inline-flex items-center gap-1 text-sm font-medium underline underline-offset-4"
                          >
                            <Download className="h-4 w-4" />
                            Download
                          </a>
                        </li>
                      ))}
                    </ul>
                  </div>
                )}
              </div>
            ))
          )}
        </div>

        <div className="flex items-center justify-between gap-2">
          <Button
            type="button"
            variant="secondary"
            onClick={clearCompleted}
            disabled={completedCount === 0}
          >
            Clear completed
          </Button>
          <span className="text-muted-foreground text-sm">
            Mock data only (no backend)
          </span>
        </div>
      </CardContent>
    </Card>
  )
}

```

### Updated filter behavior (date-only vs time)
Implemented in **`src/app/page.tsx`** by splitting the filter inputs into **Date** + **Time**.

- **Exact mode**
  - **Date only** → shows **all tasks on that date**
  - **Date + time** → shows tasks **exactly at that minute**
  - **Time only** → shows tasks with that **time-of-day across all dates**

- **Between mode**
  - **Dates only** → shows tasks between those dates (full days)
  - **Times only** → filters by **time-of-day range** (across all dates)
  - **Dates + times** → applies both (date range + time-of-day range)

### Run
```bash
npm run dev
```

```shellscript
npm run dev
```

---

**User**

Add more mock tasks with varying dates and times, from yesterday through next week.

---

**Cursor**

Cool—this will make the filters and summary cards feel “real” immediately. Next I’ll expand the `initialTodos` mock list to include tasks from **yesterday through next week** with different times (morning/afternoon/evening), then quickly re-run a build.

```typescriptreact
"use client"

import { zodResolver } from "@hookform/resolvers/zod"
import {
  Download,
  File,
  FileSpreadsheet,
  FileText,
  Image as ImageIcon,
  Music,
  Trash2,
  Video,
} from "lucide-react"
import * as React from "react"
import { useForm } from "react-hook-form"
import { z } from "zod"

import { ModeToggle } from "@/components/mode-toggle"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Checkbox } from "@/components/ui/checkbox"
import { Form, FormControl, FormField, FormItem, FormMessage } from "@/components/ui/form"
import { Input } from "@/components/ui/input"
import { Separator } from "@/components/ui/separator"
import { cn } from "@/lib/utils"

type AttachmentKind =
  | "image"
  | "audio"
  | "video"
  | "pdf"
  | "spreadsheet"
  | "document"
  | "text"
  | "file"

type Attachment = {
  id: string
  name: string
  type: string
  size: number
  url: string
  kind: AttachmentKind
}

type Todo = {
  id: string
  title: string
  completed: boolean
  // Stored as `datetime-local` string (YYYY-MM-DDTHH:mm) in local time.
  dueAt: string
  attachments: Attachment[]
}

const todoSchema = z.object({
  title: z
    .string()
    .trim()
    .min(1, "Title is required.")
    .max(80, "Keep it under 80 characters."),
  dueAt: z
    .string()
    .min(1, "Due date & time is required.")
    .regex(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}$/, "Invalid date/time."),
})

type TodoFormValues = z.infer<typeof todoSchema>

const initialTodos: Todo[] = [
  {
    id: "1",
    title: "Create a Next.js app",
    completed: true,
    dueAt: "2026-01-16T09:00",
    attachments: [],
  },
  {
    id: "2",
    title: "Add shadcn/ui + dark theme",
    completed: true,
    dueAt: "2026-01-16T10:30",
    attachments: [],
  },
  {
    id: "3",
    title: "Build a mock-data to-do list",
    completed: false,
    dueAt: "2026-01-16T15:00",
    attachments: [],
  },
  {
    id: "4",
    title: "Yesterday: review requirements",
    completed: true,
    dueAt: "2026-01-15T11:15",
    attachments: [],
  },
  {
    id: "5",
    title: "Yesterday: sketch UI layout",
    completed: true,
    dueAt: "2026-01-15T17:45",
    attachments: [],
  },
  {
    id: "6",
    title: "Today: add attachments support",
    completed: false,
    dueAt: "2026-01-16T18:20",
    attachments: [],
  },
  {
    id: "7",
    title: "Tomorrow: QA the filters",
    completed: false,
    dueAt: "2026-01-17T08:05",
    attachments: [],
  },
  {
    id: "8",
    title: "Tomorrow: polish summary cards",
    completed: false,
    dueAt: "2026-01-17T13:30",
    attachments: [],
  },
  {
    id: "9",
    title: "Tomorrow: write small UX notes",
    completed: false,
    dueAt: "2026-01-17T20:10",
    attachments: [],
  },
  {
    id: "10",
    title: "This weekend: add more mock tasks",
    completed: false,
    dueAt: "2026-01-18T10:00",
    attachments: [],
  },
  {
    id: "11",
    title: "This weekend: check time-only filter",
    completed: false,
    dueAt: "2026-01-18T22:15",
    attachments: [],
  },
  {
    id: "12",
    title: "Next week: sync with team",
    completed: false,
    dueAt: "2026-01-19T09:30",
    attachments: [],
  },
  {
    id: "13",
    title: "Next week: test date-only filter",
    completed: false,
    dueAt: "2026-01-20T14:05",
    attachments: [],
  },
  {
    id: "14",
    title: "Next week: test exact date+time filter",
    completed: false,
    dueAt: "2026-01-21T12:00",
    attachments: [],
  },
  {
    id: "15",
    title: "Next week: attach docs to completed tasks",
    completed: false,
    dueAt: "2026-01-22T16:40",
    attachments: [],
  },
  {
    id: "16",
    title: "Next week: final review",
    completed: false,
    dueAt: "2026-01-23T11:00",
    attachments: [],
  },
]

function parseLocalDateTime(value: string): number {
  // value: "YYYY-MM-DDTHH:mm"
  const [datePart, timePart] = value.split("T")
  const [y, m, d] = datePart.split("-").map(Number)
  const [hh, mm] = timePart.split(":").map(Number)
  return new Date(y, m - 1, d, hh, mm, 0, 0).getTime()
}

function pad2(n: number) {
  return String(n).padStart(2, "0")
}

function localDateKey(d: Date) {
  return `${d.getFullYear()}-${pad2(d.getMonth() + 1)}-${pad2(d.getDate())}`
}

function addDays(date: Date, days: number) {
  const d = new Date(date)
  d.setDate(d.getDate() + days)
  return d
}

function startOfDay(date: Date) {
  return new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0, 0)
}

function endOfDay(date: Date) {
  return new Date(
    date.getFullYear(),
    date.getMonth(),
    date.getDate(),
    23,
    59,
    59,
    999
  )
}

function getDatePart(dueAt: string) {
  return dueAt.split("T")[0] ?? ""
}

function getTimePart(dueAt: string) {
  return dueAt.split("T")[1] ?? ""
}

function parseLocalDateOnly(value: string): Date {
  // value: "YYYY-MM-DD"
  const [y, m, d] = value.split("-").map(Number)
  return new Date(y, m - 1, d, 0, 0, 0, 0)
}

function parseLocalTimeToMinutes(value: string): number {
  // value: "HH:mm"
  const [hh, mm] = value.split(":").map(Number)
  return hh * 60 + mm
}

function formatLocalDateTime(value: string): string {
  const ms = parseLocalDateTime(value)
  if (!Number.isFinite(ms)) return value
  return new Intl.DateTimeFormat(undefined, {
    year: "numeric",
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  }).format(new Date(ms))
}

function getAttachmentKind(file: File): AttachmentKind {
  const type = (file.type || "").toLowerCase()
  const name = file.name.toLowerCase()
  const ext = name.includes(".") ? name.split(".").pop() ?? "" : ""

  if (type.startsWith("image/")) return "image"
  if (type.startsWith("audio/")) return "audio"
  if (type.startsWith("video/")) return "video"

  if (ext === "pdf") return "pdf"
  if (["xls", "xlsx", "csv"].includes(ext)) return "spreadsheet"
  if (["doc", "docx"].includes(ext)) return "document"
  if (["txt", "md", "rtf"].includes(ext)) return "text"

  return "file"
}

function makeAttachment(file: File): Attachment {
  return {
    id: crypto.randomUUID(),
    name: file.name,
    type: file.type,
    size: file.size,
    url: URL.createObjectURL(file),
    kind: getAttachmentKind(file),
  }
}

function revokeTodoAttachments(todo: Todo) {
  for (const a of todo.attachments) URL.revokeObjectURL(a.url)
}

function AttachmentIcon({ kind }: { kind: AttachmentKind }) {
  const className = "h-4 w-4 text-muted-foreground"

  switch (kind) {
    case "image":
      return <ImageIcon className={className} />
    case "audio":
      return <Music className={className} />
    case "video":
      return <Video className={className} />
    case "spreadsheet":
      return <FileSpreadsheet className={className} />
    case "pdf":
    case "document":
    case "text":
      return <FileText className={className} />
    default:
      return <File className={className} />
  }
}

export default function Home() {
  return (
    <div className="mx-auto flex min-h-screen max-w-2xl flex-col gap-6 px-4 py-10">
      <TodoApp />
    </div>
  )
}

function TodoApp() {
  const [todos, setTodos] = React.useState<Todo[]>(initialTodos)
  const [attachTargetTodoId, setAttachTargetTodoId] = React.useState<string | null>(
    null
  )
  const [filterMode, setFilterMode] = React.useState<"between" | "exact">("between")
  const [filterFromDate, setFilterFromDate] = React.useState<string>("")
  const [filterFromTime, setFilterFromTime] = React.useState<string>("")
  const [filterToDate, setFilterToDate] = React.useState<string>("")
  const [filterToTime, setFilterToTime] = React.useState<string>("")
  const [filterExactDate, setFilterExactDate] = React.useState<string>("")
  const [filterExactTime, setFilterExactTime] = React.useState<string>("")
  const fileInputRef = React.useRef<HTMLInputElement>(null)

  const todosRef = React.useRef(todos)
  React.useEffect(() => {
    todosRef.current = todos
  }, [todos])
  React.useEffect(() => {
    return () => {
      for (const t of todosRef.current) revokeTodoAttachments(t)
    }
  }, [])

  const form = useForm<TodoFormValues>({
    resolver: zodResolver(todoSchema),
    defaultValues: { title: "", dueAt: "" },
    mode: "onSubmit",
  })

  const summary = React.useMemo(() => {
    const now = new Date()
    const todayKey = localDateKey(now)
    const tomorrow = addDays(now, 1)
    const tomorrowKey = localDateKey(tomorrow)

    const todays = todos.filter((t) => t.dueAt.startsWith(todayKey))
    const todayCompleted = todays.filter((t) => t.completed).length
    const todayPending = todays.length - todayCompleted

    const labels = [
      "00:00–04:00",
      "04:00–08:00",
      "08:00–12:00",
      "12:00–16:00",
      "16:00–20:00",
      "20:00–24:00",
    ]

    // Tomorrow: same 4-hour windows breakdown
    const tomorrowTasks = todos.filter((t) => t.dueAt.startsWith(tomorrowKey))
    const tomorrowBuckets = Array.from({ length: 6 }, () => 0) as number[]
    for (const t of tomorrowTasks) {
      const ms = parseLocalDateTime(t.dueAt)
      const hour = new Date(ms).getHours()
      const idx = Math.floor(hour / 4)
      tomorrowBuckets[idx] = (tomorrowBuckets[idx] ?? 0) + 1
    }

    // Until next week = next 7 days starting tomorrow (local), grouped into 4-hour windows.
    const rangeStart = startOfDay(tomorrow).getTime()
    const rangeEnd = addDays(startOfDay(tomorrow), 7).getTime()
    const buckets = Array.from({ length: 6 }, () => 0) as number[]

    const upcoming = todos.filter((t) => {
      const ms = parseLocalDateTime(t.dueAt)
      return ms >= rangeStart && ms < rangeEnd
    })

    for (const t of upcoming) {
      const ms = parseLocalDateTime(t.dueAt)
      const hour = new Date(ms).getHours()
      const idx = Math.floor(hour / 4)
      buckets[idx] = (buckets[idx] ?? 0) + 1
    }

    return {
      todayCompleted,
      todayPending,
      tomorrowTotal: tomorrowTasks.length,
      tomorrowBuckets: labels.map((label, i) => ({ label, count: tomorrowBuckets[i] ?? 0 })),
      upcomingTotal: upcoming.length,
      upcomingBuckets: labels.map((label, i) => ({ label, count: buckets[i] ?? 0 })),
    }
  }, [todos])

  const filteredTodos = React.useMemo(() => {
    const withMs = todos.map((t) => ({ ...t, _dueMs: parseLocalDateTime(t.dueAt) }))
    if (filterMode === "exact") {
      // If only date is selected -> show tasks for that date.
      // If time is selected too -> match exact date+time.
      // If only time is selected -> match time-of-day across all dates.
      if (!filterExactDate && !filterExactTime) return withMs

      if (filterExactDate && !filterExactTime) {
        return withMs.filter((t) => getDatePart(t.dueAt) === filterExactDate)
      }

      if (filterExactDate && filterExactTime) {
        const exactMs = parseLocalDateTime(`${filterExactDate}T${filterExactTime}`)
        return withMs.filter((t) => t._dueMs === exactMs)
      }

      // time only
      return withMs.filter((t) => getTimePart(t.dueAt) === filterExactTime)
    }
    // between
    const hasAnyDate = Boolean(filterFromDate || filterToDate)
    const hasAnyTime = Boolean(filterFromTime || filterToTime)

    // Date range (optional)
    const fromDateMs = filterFromDate
      ? startOfDay(parseLocalDateOnly(filterFromDate)).getTime()
      : Number.NEGATIVE_INFINITY
    const toDateMs = filterToDate
      ? endOfDay(parseLocalDateOnly(filterToDate)).getTime()
      : Number.POSITIVE_INFINITY

    // Time-of-day range (optional)
    const fromTimeMin = filterFromTime ? parseLocalTimeToMinutes(filterFromTime) : 0
    const toTimeMin = filterToTime ? parseLocalTimeToMinutes(filterToTime) : 24 * 60 - 1

    return withMs.filter((t) => {
      const ms = t._dueMs
      if (hasAnyDate && (ms < fromDateMs || ms > toDateMs)) return false

      if (hasAnyTime) {
        const time = getTimePart(t.dueAt)
        if (!time) return false
        const mins = parseLocalTimeToMinutes(time)
        // Simple (non-wrapping) range. If you want wrap-around (e.g. 22:00–02:00), tell me.
        if (mins < fromTimeMin || mins > toTimeMin) return false
      }

      // If neither date nor time selected, pass through (handled above anyway)
      return true
    })
  }, [
    todos,
    filterExactDate,
    filterExactTime,
    filterFromDate,
    filterFromTime,
    filterMode,
    filterToDate,
    filterToTime,
  ])

  const completedCount = filteredTodos.filter((t) => t.completed).length

  function addTodo(values: TodoFormValues) {
    setTodos((prev) => [
      {
        id: crypto.randomUUID(),
        title: values.title.trim(),
        completed: false,
        dueAt: values.dueAt,
        attachments: [],
      },
      ...prev,
    ])
    form.reset()
  }

  function toggleTodo(id: string, completed: boolean) {
    setTodos((prev) => prev.map((t) => (t.id === id ? { ...t, completed } : t)))
  }

  function requestAttachmentsForTodo(todoId: string) {
    setAttachTargetTodoId(todoId)
    // Let state update before opening picker (some browsers are picky).
    queueMicrotask(() => fileInputRef.current?.click())
  }

  function handleFilesPicked(e: React.ChangeEvent<HTMLInputElement>) {
    const files = Array.from(e.target.files ?? [])
    const targetId = attachTargetTodoId

    // reset input so picking the same file again triggers onChange
    e.target.value = ""
    setAttachTargetTodoId(null)

    if (!targetId || files.length === 0) return

    const attachments = files.map(makeAttachment)

    setTodos((prev) =>
      prev.map((t) =>
        t.id === targetId
          ? { ...t, attachments: [...t.attachments, ...attachments] }
          : t
      )
    )
  }

  function deleteTodo(id: string) {
    setTodos((prev) => {
      const victim = prev.find((t) => t.id === id)
      if (victim) revokeTodoAttachments(victim)
      return prev.filter((t) => t.id !== id)
    })
  }

  function clearCompleted() {
    setTodos((prev) => {
      for (const t of prev) {
        if (t.completed) revokeTodoAttachments(t)
      }
      return prev.filter((t) => !t.completed)
    })
  }

  return (
    <Card>
      <CardHeader className="flex flex-row items-center justify-between gap-4">
        <div className="space-y-1">
          <CardTitle className="text-2xl">To‑Do</CardTitle>
          <p className="text-muted-foreground text-sm">
            {completedCount}/{filteredTodos.length} completed
          </p>
        </div>
        <ModeToggle />
      </CardHeader>

      <CardContent className="space-y-6">
        <input
          ref={fileInputRef}
          type="file"
          multiple
          className="hidden"
          accept={[
            "image/*",
            "audio/*",
            "video/*",
            ".pdf",
            ".doc",
            ".docx",
            ".xls",
            ".xlsx",
            ".csv",
            ".txt",
            ".md",
            ".rtf",
          ].join(",")}
          onChange={handleFilesPicked}
        />

        <div className="grid gap-3 sm:grid-cols-3">
          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Today’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">
              {summary.todayCompleted} completed
            </p>
            <p className="text-muted-foreground text-sm">{summary.todayPending} pending</p>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tomorrow’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">{summary.tomorrowTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.tomorrowBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tasks Until Next Week</p>
            <p className="mt-2 text-2xl font-semibold">{summary.upcomingTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.upcomingBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>
        </div>

        <Form {...form}>
          <form
            onSubmit={form.handleSubmit(addTodo)}
            className="space-y-2"
            noValidate
          >
            <div className="flex flex-col gap-2 sm:flex-row">
              <FormField
                control={form.control}
                name="title"
                render={({ field }) => (
                  <FormItem className="flex-1">
                    <FormControl>
                      <Input
                        placeholder="Add a task…"
                        autoComplete="off"
                        {...field}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="dueAt"
                render={({ field }) => (
                  <FormItem className="sm:w-64">
                    <FormControl>
                      <Input type="datetime-local" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <Button type="submit">Add</Button>
            </div>
          </form>
        </Form>

        <Separator />

        <div className="space-y-3">
          <div className="flex flex-wrap items-center justify-between gap-2">
            <p className="text-sm font-medium">Filter by date & time</p>
            <div className="flex items-center gap-2">
              <Button
                type="button"
                size="sm"
                variant={filterMode === "between" ? "default" : "outline"}
                onClick={() => setFilterMode("between")}
              >
                Between
              </Button>
              <Button
                type="button"
                size="sm"
                variant={filterMode === "exact" ? "default" : "outline"}
                onClick={() => setFilterMode("exact")}
              >
                Exact
              </Button>
              <Button
                type="button"
                size="sm"
                variant="ghost"
                onClick={() => {
                  setFilterFromDate("")
                  setFilterFromTime("")
                  setFilterToDate("")
                  setFilterToTime("")
                  setFilterExactDate("")
                  setFilterExactTime("")
                }}
              >
                Clear
              </Button>
            </div>
          </div>

          {filterMode === "between" ? (
            <div className="grid gap-2 sm:grid-cols-2">
              <div className="grid gap-2 sm:grid-cols-2">
                <Input
                  type="date"
                  value={filterFromDate}
                  onChange={(e) => setFilterFromDate(e.target.value)}
                />
                <Input
                  type="time"
                  value={filterFromTime}
                  onChange={(e) => setFilterFromTime(e.target.value)}
                />
              </div>
              <div className="grid gap-2 sm:grid-cols-2">
                <Input
                  type="date"
                  value={filterToDate}
                  onChange={(e) => setFilterToDate(e.target.value)}
                />
                <Input
                  type="time"
                  value={filterToTime}
                  onChange={(e) => setFilterToTime(e.target.value)}
                />
              </div>
            </div>
          ) : (
            <div className="grid gap-2 sm:grid-cols-2">
              <Input
                type="date"
                value={filterExactDate}
                onChange={(e) => setFilterExactDate(e.target.value)}
              />
              <Input
                type="time"
                value={filterExactTime}
                onChange={(e) => setFilterExactTime(e.target.value)}
              />
            </div>
          )}
        </div>

        <Separator />

        <div className="space-y-2">
          {filteredTodos.length === 0 ? (
            <p className="text-muted-foreground text-sm">No tasks yet.</p>
          ) : (
            filteredTodos
              .slice()
              .sort((a, b) => parseLocalDateTime(a.dueAt) - parseLocalDateTime(b.dueAt))
              .map((todo) => (
              <div key={todo.id} className="rounded-lg border px-3 py-2">
                <div className="flex items-start justify-between gap-3">
                  <label className="flex cursor-pointer items-start gap-3">
                    <Checkbox
                      checked={todo.completed}
                      onCheckedChange={(v) => {
                        const next = Boolean(v)
                        toggleTodo(todo.id, next)
                        if (next && !todo.completed) {
                          requestAttachmentsForTodo(todo.id)
                        }
                      }}
                      aria-label={`Mark "${todo.title}" as ${
                        todo.completed ? "not completed" : "completed"
                      }`}
                      className="mt-0.5"
                    />
                    <span
                      className={cn(
                        "leading-6",
                        todo.completed && "text-muted-foreground line-through"
                      )}
                    >
                      <span className="block">{todo.title}</span>
                      <span className="text-muted-foreground block text-xs">
                        Due: {formatLocalDateTime(todo.dueAt)}
                      </span>
                    </span>
                  </label>

                  <div className="flex items-center gap-1">
                    {todo.completed && (
                      <Button
                        type="button"
                        variant="outline"
                        size="sm"
                        onClick={() => requestAttachmentsForTodo(todo.id)}
                      >
                        Add files
                      </Button>
                    )}
                    <Button
                      type="button"
                      variant="ghost"
                      size="icon"
                      aria-label={`Delete "${todo.title}"`}
                      onClick={() => deleteTodo(todo.id)}
                    >
                      <Trash2 className="h-4 w-4" />
                    </Button>
                  </div>
                </div>

                {todo.completed && todo.attachments.length > 0 && (
                  <div className="mt-3 space-y-2">
                    <p className="text-muted-foreground text-xs">Attachments</p>
                    <ul className="space-y-1">
                      {todo.attachments.map((a) => (
                        <li
                          key={a.id}
                          className="flex items-center justify-between gap-3 rounded-md bg-muted/30 px-2 py-1"
                        >
                          <div className="flex min-w-0 items-center gap-2">
                            <AttachmentIcon kind={a.kind} />
                            <span className="truncate text-sm">{a.name}</span>
                          </div>
                          <a
                            href={a.url}
                            download={a.name}
                            className="inline-flex items-center gap-1 text-sm font-medium underline underline-offset-4"
                          >
                            <Download className="h-4 w-4" />
                            Download
                          </a>
                        </li>
                      ))}
                    </ul>
                  </div>
                )}
              </div>
            ))
          )}
        </div>

        <div className="flex items-center justify-between gap-2">
          <Button
            type="button"
            variant="secondary"
            onClick={clearCompleted}
            disabled={completedCount === 0}
          >
            Clear completed
          </Button>
          <span className="text-muted-foreground text-sm">
            Mock data only (no backend)
          </span>
        </div>
      </CardContent>
    </Card>
  )
}

```

### Added more mock tasks (yesterday → next week)
- Expanded the mock list in **`src/app/page.tsx`** (`initialTodos`) with tasks scheduled from **2026‑01‑15** (yesterday) through **2026‑01‑23** (next week), with varied times and completion states.

### Run
```bash
npm run dev
```

```shellscript
npm run dev
```

---

**User**

Group the list by date using a divider line and date label for better visual clarity.

---

**Cursor**

Nice—since tasks are already sorted by `dueAt`, we can group them by the `YYYY-MM-DD` date part and render a clean date header + divider before each group. Next I’ll adjust the list rendering in `src/app/page.tsx`, then run a quick build to confirm everything compiles.

```typescriptreact
"use client"

import { zodResolver } from "@hookform/resolvers/zod"
import {
  Download,
  File,
  FileSpreadsheet,
  FileText,
  Image as ImageIcon,
  Music,
  Trash2,
  Video,
} from "lucide-react"
import * as React from "react"
import { useForm } from "react-hook-form"
import { z } from "zod"

import { ModeToggle } from "@/components/mode-toggle"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Checkbox } from "@/components/ui/checkbox"
import { Form, FormControl, FormField, FormItem, FormMessage } from "@/components/ui/form"
import { Input } from "@/components/ui/input"
import { Separator } from "@/components/ui/separator"
import { cn } from "@/lib/utils"

type AttachmentKind =
  | "image"
  | "audio"
  | "video"
  | "pdf"
  | "spreadsheet"
  | "document"
  | "text"
  | "file"

type Attachment = {
  id: string
  name: string
  type: string
  size: number
  url: string
  kind: AttachmentKind
}

type Todo = {
  id: string
  title: string
  completed: boolean
  // Stored as `datetime-local` string (YYYY-MM-DDTHH:mm) in local time.
  dueAt: string
  attachments: Attachment[]
}

const todoSchema = z.object({
  title: z
    .string()
    .trim()
    .min(1, "Title is required.")
    .max(80, "Keep it under 80 characters."),
  dueAt: z
    .string()
    .min(1, "Due date & time is required.")
    .regex(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}$/, "Invalid date/time."),
})

type TodoFormValues = z.infer<typeof todoSchema>

const initialTodos: Todo[] = [
  {
    id: "1",
    title: "Create a Next.js app",
    completed: true,
    dueAt: "2026-01-16T09:00",
    attachments: [],
  },
  {
    id: "2",
    title: "Add shadcn/ui + dark theme",
    completed: true,
    dueAt: "2026-01-16T10:30",
    attachments: [],
  },
  {
    id: "3",
    title: "Build a mock-data to-do list",
    completed: false,
    dueAt: "2026-01-16T15:00",
    attachments: [],
  },
  {
    id: "4",
    title: "Yesterday: review requirements",
    completed: true,
    dueAt: "2026-01-15T11:15",
    attachments: [],
  },
  {
    id: "5",
    title: "Yesterday: sketch UI layout",
    completed: true,
    dueAt: "2026-01-15T17:45",
    attachments: [],
  },
  {
    id: "6",
    title: "Today: add attachments support",
    completed: false,
    dueAt: "2026-01-16T18:20",
    attachments: [],
  },
  {
    id: "7",
    title: "Tomorrow: QA the filters",
    completed: false,
    dueAt: "2026-01-17T08:05",
    attachments: [],
  },
  {
    id: "8",
    title: "Tomorrow: polish summary cards",
    completed: false,
    dueAt: "2026-01-17T13:30",
    attachments: [],
  },
  {
    id: "9",
    title: "Tomorrow: write small UX notes",
    completed: false,
    dueAt: "2026-01-17T20:10",
    attachments: [],
  },
  {
    id: "10",
    title: "This weekend: add more mock tasks",
    completed: false,
    dueAt: "2026-01-18T10:00",
    attachments: [],
  },
  {
    id: "11",
    title: "This weekend: check time-only filter",
    completed: false,
    dueAt: "2026-01-18T22:15",
    attachments: [],
  },
  {
    id: "12",
    title: "Next week: sync with team",
    completed: false,
    dueAt: "2026-01-19T09:30",
    attachments: [],
  },
  {
    id: "13",
    title: "Next week: test date-only filter",
    completed: false,
    dueAt: "2026-01-20T14:05",
    attachments: [],
  },
  {
    id: "14",
    title: "Next week: test exact date+time filter",
    completed: false,
    dueAt: "2026-01-21T12:00",
    attachments: [],
  },
  {
    id: "15",
    title: "Next week: attach docs to completed tasks",
    completed: false,
    dueAt: "2026-01-22T16:40",
    attachments: [],
  },
  {
    id: "16",
    title: "Next week: final review",
    completed: false,
    dueAt: "2026-01-23T11:00",
    attachments: [],
  },
]

function parseLocalDateTime(value: string): number {
  // value: "YYYY-MM-DDTHH:mm"
  const [datePart, timePart] = value.split("T")
  const [y, m, d] = datePart.split("-").map(Number)
  const [hh, mm] = timePart.split(":").map(Number)
  return new Date(y, m - 1, d, hh, mm, 0, 0).getTime()
}

function pad2(n: number) {
  return String(n).padStart(2, "0")
}

function localDateKey(d: Date) {
  return `${d.getFullYear()}-${pad2(d.getMonth() + 1)}-${pad2(d.getDate())}`
}

function addDays(date: Date, days: number) {
  const d = new Date(date)
  d.setDate(d.getDate() + days)
  return d
}

function startOfDay(date: Date) {
  return new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0, 0)
}

function endOfDay(date: Date) {
  return new Date(
    date.getFullYear(),
    date.getMonth(),
    date.getDate(),
    23,
    59,
    59,
    999
  )
}

function getDatePart(dueAt: string) {
  return dueAt.split("T")[0] ?? ""
}

function getTimePart(dueAt: string) {
  return dueAt.split("T")[1] ?? ""
}

function parseLocalDateOnly(value: string): Date {
  // value: "YYYY-MM-DD"
  const [y, m, d] = value.split("-").map(Number)
  return new Date(y, m - 1, d, 0, 0, 0, 0)
}

function parseLocalTimeToMinutes(value: string): number {
  // value: "HH:mm"
  const [hh, mm] = value.split(":").map(Number)
  return hh * 60 + mm
}

function formatLocalDateTime(value: string): string {
  const ms = parseLocalDateTime(value)
  if (!Number.isFinite(ms)) return value
  return new Intl.DateTimeFormat(undefined, {
    year: "numeric",
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  }).format(new Date(ms))
}

function getAttachmentKind(file: File): AttachmentKind {
  const type = (file.type || "").toLowerCase()
  const name = file.name.toLowerCase()
  const ext = name.includes(".") ? name.split(".").pop() ?? "" : ""

  if (type.startsWith("image/")) return "image"
  if (type.startsWith("audio/")) return "audio"
  if (type.startsWith("video/")) return "video"

  if (ext === "pdf") return "pdf"
  if (["xls", "xlsx", "csv"].includes(ext)) return "spreadsheet"
  if (["doc", "docx"].includes(ext)) return "document"
  if (["txt", "md", "rtf"].includes(ext)) return "text"

  return "file"
}

function makeAttachment(file: File): Attachment {
  return {
    id: crypto.randomUUID(),
    name: file.name,
    type: file.type,
    size: file.size,
    url: URL.createObjectURL(file),
    kind: getAttachmentKind(file),
  }
}

function revokeTodoAttachments(todo: Todo) {
  for (const a of todo.attachments) URL.revokeObjectURL(a.url)
}

function AttachmentIcon({ kind }: { kind: AttachmentKind }) {
  const className = "h-4 w-4 text-muted-foreground"

  switch (kind) {
    case "image":
      return <ImageIcon className={className} />
    case "audio":
      return <Music className={className} />
    case "video":
      return <Video className={className} />
    case "spreadsheet":
      return <FileSpreadsheet className={className} />
    case "pdf":
    case "document":
    case "text":
      return <FileText className={className} />
    default:
      return <File className={className} />
  }
}

export default function Home() {
  return (
    <div className="mx-auto flex min-h-screen max-w-2xl flex-col gap-6 px-4 py-10">
      <TodoApp />
    </div>
  )
}

function TodoApp() {
  const [todos, setTodos] = React.useState<Todo[]>(initialTodos)
  const [attachTargetTodoId, setAttachTargetTodoId] = React.useState<string | null>(
    null
  )
  const [filterMode, setFilterMode] = React.useState<"between" | "exact">("between")
  const [filterFromDate, setFilterFromDate] = React.useState<string>("")
  const [filterFromTime, setFilterFromTime] = React.useState<string>("")
  const [filterToDate, setFilterToDate] = React.useState<string>("")
  const [filterToTime, setFilterToTime] = React.useState<string>("")
  const [filterExactDate, setFilterExactDate] = React.useState<string>("")
  const [filterExactTime, setFilterExactTime] = React.useState<string>("")
  const fileInputRef = React.useRef<HTMLInputElement>(null)

  const todosRef = React.useRef(todos)
  React.useEffect(() => {
    todosRef.current = todos
  }, [todos])
  React.useEffect(() => {
    return () => {
      for (const t of todosRef.current) revokeTodoAttachments(t)
    }
  }, [])

  const form = useForm<TodoFormValues>({
    resolver: zodResolver(todoSchema),
    defaultValues: { title: "", dueAt: "" },
    mode: "onSubmit",
  })

  const summary = React.useMemo(() => {
    const now = new Date()
    const todayKey = localDateKey(now)
    const tomorrow = addDays(now, 1)
    const tomorrowKey = localDateKey(tomorrow)

    const todays = todos.filter((t) => t.dueAt.startsWith(todayKey))
    const todayCompleted = todays.filter((t) => t.completed).length
    const todayPending = todays.length - todayCompleted

    const labels = [
      "00:00–04:00",
      "04:00–08:00",
      "08:00–12:00",
      "12:00–16:00",
      "16:00–20:00",
      "20:00–24:00",
    ]

    // Tomorrow: same 4-hour windows breakdown
    const tomorrowTasks = todos.filter((t) => t.dueAt.startsWith(tomorrowKey))
    const tomorrowBuckets = Array.from({ length: 6 }, () => 0) as number[]
    for (const t of tomorrowTasks) {
      const ms = parseLocalDateTime(t.dueAt)
      const hour = new Date(ms).getHours()
      const idx = Math.floor(hour / 4)
      tomorrowBuckets[idx] = (tomorrowBuckets[idx] ?? 0) + 1
    }

    // Until next week = next 7 days starting tomorrow (local), grouped into 4-hour windows.
    const rangeStart = startOfDay(tomorrow).getTime()
    const rangeEnd = addDays(startOfDay(tomorrow), 7).getTime()
    const buckets = Array.from({ length: 6 }, () => 0) as number[]

    const upcoming = todos.filter((t) => {
      const ms = parseLocalDateTime(t.dueAt)
      return ms >= rangeStart && ms < rangeEnd
    })

    for (const t of upcoming) {
      const ms = parseLocalDateTime(t.dueAt)
      const hour = new Date(ms).getHours()
      const idx = Math.floor(hour / 4)
      buckets[idx] = (buckets[idx] ?? 0) + 1
    }

    return {
      todayCompleted,
      todayPending,
      tomorrowTotal: tomorrowTasks.length,
      tomorrowBuckets: labels.map((label, i) => ({ label, count: tomorrowBuckets[i] ?? 0 })),
      upcomingTotal: upcoming.length,
      upcomingBuckets: labels.map((label, i) => ({ label, count: buckets[i] ?? 0 })),
    }
  }, [todos])

  const filteredTodos = React.useMemo(() => {
    const withMs = todos.map((t) => ({ ...t, _dueMs: parseLocalDateTime(t.dueAt) }))
    if (filterMode === "exact") {
      // If only date is selected -> show tasks for that date.
      // If time is selected too -> match exact date+time.
      // If only time is selected -> match time-of-day across all dates.
      if (!filterExactDate && !filterExactTime) return withMs

      if (filterExactDate && !filterExactTime) {
        return withMs.filter((t) => getDatePart(t.dueAt) === filterExactDate)
      }

      if (filterExactDate && filterExactTime) {
        const exactMs = parseLocalDateTime(`${filterExactDate}T${filterExactTime}`)
        return withMs.filter((t) => t._dueMs === exactMs)
      }

      // time only
      return withMs.filter((t) => getTimePart(t.dueAt) === filterExactTime)
    }
    // between
    const hasAnyDate = Boolean(filterFromDate || filterToDate)
    const hasAnyTime = Boolean(filterFromTime || filterToTime)

    // Date range (optional)
    const fromDateMs = filterFromDate
      ? startOfDay(parseLocalDateOnly(filterFromDate)).getTime()
      : Number.NEGATIVE_INFINITY
    const toDateMs = filterToDate
      ? endOfDay(parseLocalDateOnly(filterToDate)).getTime()
      : Number.POSITIVE_INFINITY

    // Time-of-day range (optional)
    const fromTimeMin = filterFromTime ? parseLocalTimeToMinutes(filterFromTime) : 0
    const toTimeMin = filterToTime ? parseLocalTimeToMinutes(filterToTime) : 24 * 60 - 1

    return withMs.filter((t) => {
      const ms = t._dueMs
      if (hasAnyDate && (ms < fromDateMs || ms > toDateMs)) return false

      if (hasAnyTime) {
        const time = getTimePart(t.dueAt)
        if (!time) return false
        const mins = parseLocalTimeToMinutes(time)
        // Simple (non-wrapping) range. If you want wrap-around (e.g. 22:00–02:00), tell me.
        if (mins < fromTimeMin || mins > toTimeMin) return false
      }

      // If neither date nor time selected, pass through (handled above anyway)
      return true
    })
  }, [
    todos,
    filterExactDate,
    filterExactTime,
    filterFromDate,
    filterFromTime,
    filterMode,
    filterToDate,
    filterToTime,
  ])

  const groupedTodos = React.useMemo(() => {
    const sorted = filteredTodos
      .slice()
      .sort((a, b) => parseLocalDateTime(a.dueAt) - parseLocalDateTime(b.dueAt))

    const groups: Array<{ date: string; items: typeof sorted }> = []
    for (const t of sorted) {
      const date = getDatePart(t.dueAt)
      const last = groups[groups.length - 1]
      if (!last || last.date !== date) groups.push({ date, items: [t] })
      else last.items.push(t)
    }
    return groups
  }, [filteredTodos])

  const completedCount = filteredTodos.filter((t) => t.completed).length

  function addTodo(values: TodoFormValues) {
    setTodos((prev) => [
      {
        id: crypto.randomUUID(),
        title: values.title.trim(),
        completed: false,
        dueAt: values.dueAt,
        attachments: [],
      },
      ...prev,
    ])
    form.reset()
  }

  function toggleTodo(id: string, completed: boolean) {
    setTodos((prev) => prev.map((t) => (t.id === id ? { ...t, completed } : t)))
  }

  function requestAttachmentsForTodo(todoId: string) {
    setAttachTargetTodoId(todoId)
    // Let state update before opening picker (some browsers are picky).
    queueMicrotask(() => fileInputRef.current?.click())
  }

  function handleFilesPicked(e: React.ChangeEvent<HTMLInputElement>) {
    const files = Array.from(e.target.files ?? [])
    const targetId = attachTargetTodoId

    // reset input so picking the same file again triggers onChange
    e.target.value = ""
    setAttachTargetTodoId(null)

    if (!targetId || files.length === 0) return

    const attachments = files.map(makeAttachment)

    setTodos((prev) =>
      prev.map((t) =>
        t.id === targetId
          ? { ...t, attachments: [...t.attachments, ...attachments] }
          : t
      )
    )
  }

  function deleteTodo(id: string) {
    setTodos((prev) => {
      const victim = prev.find((t) => t.id === id)
      if (victim) revokeTodoAttachments(victim)
      return prev.filter((t) => t.id !== id)
    })
  }

  function clearCompleted() {
    setTodos((prev) => {
      for (const t of prev) {
        if (t.completed) revokeTodoAttachments(t)
      }
      return prev.filter((t) => !t.completed)
    })
  }

  return (
    <Card>
      <CardHeader className="flex flex-row items-center justify-between gap-4">
        <div className="space-y-1">
          <CardTitle className="text-2xl">To‑Do</CardTitle>
          <p className="text-muted-foreground text-sm">
            {completedCount}/{filteredTodos.length} completed
          </p>
        </div>
        <ModeToggle />
      </CardHeader>

      <CardContent className="space-y-6">
        <input
          ref={fileInputRef}
          type="file"
          multiple
          className="hidden"
          accept={[
            "image/*",
            "audio/*",
            "video/*",
            ".pdf",
            ".doc",
            ".docx",
            ".xls",
            ".xlsx",
            ".csv",
            ".txt",
            ".md",
            ".rtf",
          ].join(",")}
          onChange={handleFilesPicked}
        />

        <div className="grid gap-3 sm:grid-cols-3">
          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Today’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">
              {summary.todayCompleted} completed
            </p>
            <p className="text-muted-foreground text-sm">{summary.todayPending} pending</p>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tomorrow’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">{summary.tomorrowTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.tomorrowBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tasks Until Next Week</p>
            <p className="mt-2 text-2xl font-semibold">{summary.upcomingTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.upcomingBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>
        </div>

        <Form {...form}>
          <form
            onSubmit={form.handleSubmit(addTodo)}
            className="space-y-2"
            noValidate
          >
            <div className="flex flex-col gap-2 sm:flex-row">
              <FormField
                control={form.control}
                name="title"
                render={({ field }) => (
                  <FormItem className="flex-1">
                    <FormControl>
                      <Input
                        placeholder="Add a task…"
                        autoComplete="off"
                        {...field}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="dueAt"
                render={({ field }) => (
                  <FormItem className="sm:w-64">
                    <FormControl>
                      <Input type="datetime-local" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <Button type="submit">Add</Button>
            </div>
          </form>
        </Form>

        <Separator />

        <div className="space-y-3">
          <div className="flex flex-wrap items-center justify-between gap-2">
            <p className="text-sm font-medium">Filter by date & time</p>
            <div className="flex items-center gap-2">
              <Button
                type="button"
                size="sm"
                variant={filterMode === "between" ? "default" : "outline"}
                onClick={() => setFilterMode("between")}
              >
                Between
              </Button>
              <Button
                type="button"
                size="sm"
                variant={filterMode === "exact" ? "default" : "outline"}
                onClick={() => setFilterMode("exact")}
              >
                Exact
              </Button>
              <Button
                type="button"
                size="sm"
                variant="ghost"
                onClick={() => {
                  setFilterFromDate("")
                  setFilterFromTime("")
                  setFilterToDate("")
                  setFilterToTime("")
                  setFilterExactDate("")
                  setFilterExactTime("")
                }}
              >
                Clear
              </Button>
            </div>
          </div>

          {filterMode === "between" ? (
            <div className="grid gap-2 sm:grid-cols-2">
              <div className="grid gap-2 sm:grid-cols-2">
                <Input
                  type="date"
                  value={filterFromDate}
                  onChange={(e) => setFilterFromDate(e.target.value)}
                />
                <Input
                  type="time"
                  value={filterFromTime}
                  onChange={(e) => setFilterFromTime(e.target.value)}
                />
              </div>
              <div className="grid gap-2 sm:grid-cols-2">
                <Input
                  type="date"
                  value={filterToDate}
                  onChange={(e) => setFilterToDate(e.target.value)}
                />
                <Input
                  type="time"
                  value={filterToTime}
                  onChange={(e) => setFilterToTime(e.target.value)}
                />
              </div>
            </div>
          ) : (
            <div className="grid gap-2 sm:grid-cols-2">
              <Input
                type="date"
                value={filterExactDate}
                onChange={(e) => setFilterExactDate(e.target.value)}
              />
              <Input
                type="time"
                value={filterExactTime}
                onChange={(e) => setFilterExactTime(e.target.value)}
              />
            </div>
          )}
        </div>

        <Separator />

        <div className="space-y-2">
          {groupedTodos.length === 0 ? (
            <p className="text-muted-foreground text-sm">No tasks yet.</p>
          ) : (
            groupedTodos.map((group) => (
              <div key={group.date} className="space-y-2">
                <div className="flex items-center gap-3 pt-2">
                  <Separator className="flex-1" />
                  <span className="text-muted-foreground whitespace-nowrap text-xs font-medium">
                    {new Intl.DateTimeFormat(undefined, {
                      weekday: "short",
                      year: "numeric",
                      month: "short",
                      day: "2-digit",
                    }).format(parseLocalDateOnly(group.date))}
                  </span>
                  <Separator className="flex-1" />
                </div>

                {group.items.map((todo) => (
                  <div key={todo.id} className="rounded-lg border px-3 py-2">
                    <div className="flex items-start justify-between gap-3">
                      <label className="flex cursor-pointer items-start gap-3">
                        <Checkbox
                          checked={todo.completed}
                          onCheckedChange={(v) => {
                            const next = Boolean(v)
                            toggleTodo(todo.id, next)
                            if (next && !todo.completed) {
                              requestAttachmentsForTodo(todo.id)
                            }
                          }}
                          aria-label={`Mark "${todo.title}" as ${
                            todo.completed ? "not completed" : "completed"
                          }`}
                          className="mt-0.5"
                        />
                        <span
                          className={cn(
                            "leading-6",
                            todo.completed && "text-muted-foreground line-through"
                          )}
                        >
                          <span className="block">{todo.title}</span>
                          <span className="text-muted-foreground block text-xs">
                            Due: {formatLocalDateTime(todo.dueAt)}
                          </span>
                        </span>
                      </label>

                      <div className="flex items-center gap-1">
                        {todo.completed && (
                          <Button
                            type="button"
                            variant="outline"
                            size="sm"
                            onClick={() => requestAttachmentsForTodo(todo.id)}
                          >
                            Add files
                          </Button>
                        )}
                        <Button
                          type="button"
                          variant="ghost"
                          size="icon"
                          aria-label={`Delete "${todo.title}"`}
                          onClick={() => deleteTodo(todo.id)}
                        >
                          <Trash2 className="h-4 w-4" />
                        </Button>
                      </div>
                    </div>

                    {todo.completed && todo.attachments.length > 0 && (
                      <div className="mt-3 space-y-2">
                        <p className="text-muted-foreground text-xs">Attachments</p>
                        <ul className="space-y-1">
                          {todo.attachments.map((a) => (
                            <li
                              key={a.id}
                              className="flex items-center justify-between gap-3 rounded-md bg-muted/30 px-2 py-1"
                            >
                              <div className="flex min-w-0 items-center gap-2">
                                <AttachmentIcon kind={a.kind} />
                                <span className="truncate text-sm">{a.name}</span>
                              </div>
                              <a
                                href={a.url}
                                download={a.name}
                                className="inline-flex items-center gap-1 text-sm font-medium underline underline-offset-4"
                              >
                                <Download className="h-4 w-4" />
                                Download
                              </a>
                            </li>
                          ))}
                        </ul>
                      </div>
                    )}
                  </div>
                ))}
              </div>
            ))
          )}
        </div>

        <div className="flex items-center justify-between gap-2">
          <Button
            type="button"
            variant="secondary"
            onClick={clearCompleted}
            disabled={completedCount === 0}
          >
            Clear completed
          </Button>
          <span className="text-muted-foreground text-sm">
            Mock data only (no backend)
          </span>
        </div>
      </CardContent>
    </Card>
  )
}

```

### Grouped the task list by date
- The list is now **grouped by day**, and each group has a **divider line + date label** for clarity.
- Implemented in: `src/app/page.tsx`

### Run
```bash
npm run dev
```

```shellscript
npm run dev
```

---

**User**

I need pagination for the list when there are more than 5 items, and the user should be able to choose how many items are displayed per page using a dropdown.

---

**Cursor**

Makes sense. I’ll add **client-side pagination** on the filtered/sorted task list (paginate by items, then group that page by date), plus a **shadcn Select dropdown** to choose page size (default 5). After wiring Prev/Next + page count, I’ll run a build to confirm everything compiles.

```typescriptreact
"use client"

import { zodResolver } from "@hookform/resolvers/zod"
import {
  Download,
  File,
  FileSpreadsheet,
  FileText,
  Image as ImageIcon,
  Music,
  Trash2,
  Video,
} from "lucide-react"
import * as React from "react"
import { useForm } from "react-hook-form"
import { z } from "zod"

import { ModeToggle } from "@/components/mode-toggle"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Checkbox } from "@/components/ui/checkbox"
import { Form, FormControl, FormField, FormItem, FormMessage } from "@/components/ui/form"
import { Input } from "@/components/ui/input"
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select"
import { Separator } from "@/components/ui/separator"
import { cn } from "@/lib/utils"

type AttachmentKind =
  | "image"
  | "audio"
  | "video"
  | "pdf"
  | "spreadsheet"
  | "document"
  | "text"
  | "file"

type Attachment = {
  id: string
  name: string
  type: string
  size: number
  url: string
  kind: AttachmentKind
}

type Todo = {
  id: string
  title: string
  completed: boolean
  // Stored as `datetime-local` string (YYYY-MM-DDTHH:mm) in local time.
  dueAt: string
  attachments: Attachment[]
}

const todoSchema = z.object({
  title: z
    .string()
    .trim()
    .min(1, "Title is required.")
    .max(80, "Keep it under 80 characters."),
  dueAt: z
    .string()
    .min(1, "Due date & time is required.")
    .regex(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}$/, "Invalid date/time."),
})

type TodoFormValues = z.infer<typeof todoSchema>

const initialTodos: Todo[] = [
  {
    id: "1",
    title: "Create a Next.js app",
    completed: true,
    dueAt: "2026-01-16T09:00",
    attachments: [],
  },
  {
    id: "2",
    title: "Add shadcn/ui + dark theme",
    completed: true,
    dueAt: "2026-01-16T10:30",
    attachments: [],
  },
  {
    id: "3",
    title: "Build a mock-data to-do list",
    completed: false,
    dueAt: "2026-01-16T15:00",
    attachments: [],
  },
  {
    id: "4",
    title: "Yesterday: review requirements",
    completed: true,
    dueAt: "2026-01-15T11:15",
    attachments: [],
  },
  {
    id: "5",
    title: "Yesterday: sketch UI layout",
    completed: true,
    dueAt: "2026-01-15T17:45",
    attachments: [],
  },
  {
    id: "6",
    title: "Today: add attachments support",
    completed: false,
    dueAt: "2026-01-16T18:20",
    attachments: [],
  },
  {
    id: "7",
    title: "Tomorrow: QA the filters",
    completed: false,
    dueAt: "2026-01-17T08:05",
    attachments: [],
  },
  {
    id: "8",
    title: "Tomorrow: polish summary cards",
    completed: false,
    dueAt: "2026-01-17T13:30",
    attachments: [],
  },
  {
    id: "9",
    title: "Tomorrow: write small UX notes",
    completed: false,
    dueAt: "2026-01-17T20:10",
    attachments: [],
  },
  {
    id: "10",
    title: "This weekend: add more mock tasks",
    completed: false,
    dueAt: "2026-01-18T10:00",
    attachments: [],
  },
  {
    id: "11",
    title: "This weekend: check time-only filter",
    completed: false,
    dueAt: "2026-01-18T22:15",
    attachments: [],
  },
  {
    id: "12",
    title: "Next week: sync with team",
    completed: false,
    dueAt: "2026-01-19T09:30",
    attachments: [],
  },
  {
    id: "13",
    title: "Next week: test date-only filter",
    completed: false,
    dueAt: "2026-01-20T14:05",
    attachments: [],
  },
  {
    id: "14",
    title: "Next week: test exact date+time filter",
    completed: false,
    dueAt: "2026-01-21T12:00",
    attachments: [],
  },
  {
    id: "15",
    title: "Next week: attach docs to completed tasks",
    completed: false,
    dueAt: "2026-01-22T16:40",
    attachments: [],
  },
  {
    id: "16",
    title: "Next week: final review",
    completed: false,
    dueAt: "2026-01-23T11:00",
    attachments: [],
  },
]

function parseLocalDateTime(value: string): number {
  // value: "YYYY-MM-DDTHH:mm"
  const [datePart, timePart] = value.split("T")
  const [y, m, d] = datePart.split("-").map(Number)
  const [hh, mm] = timePart.split(":").map(Number)
  return new Date(y, m - 1, d, hh, mm, 0, 0).getTime()
}

function pad2(n: number) {
  return String(n).padStart(2, "0")
}

function localDateKey(d: Date) {
  return `${d.getFullYear()}-${pad2(d.getMonth() + 1)}-${pad2(d.getDate())}`
}

function addDays(date: Date, days: number) {
  const d = new Date(date)
  d.setDate(d.getDate() + days)
  return d
}

function startOfDay(date: Date) {
  return new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0, 0)
}

function endOfDay(date: Date) {
  return new Date(
    date.getFullYear(),
    date.getMonth(),
    date.getDate(),
    23,
    59,
    59,
    999
  )
}

function getDatePart(dueAt: string) {
  return dueAt.split("T")[0] ?? ""
}

function getTimePart(dueAt: string) {
  return dueAt.split("T")[1] ?? ""
}

function parseLocalDateOnly(value: string): Date {
  // value: "YYYY-MM-DD"
  const [y, m, d] = value.split("-").map(Number)
  return new Date(y, m - 1, d, 0, 0, 0, 0)
}

function parseLocalTimeToMinutes(value: string): number {
  // value: "HH:mm"
  const [hh, mm] = value.split(":").map(Number)
  return hh * 60 + mm
}

function formatLocalDateTime(value: string): string {
  const ms = parseLocalDateTime(value)
  if (!Number.isFinite(ms)) return value
  return new Intl.DateTimeFormat(undefined, {
    year: "numeric",
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  }).format(new Date(ms))
}

function getAttachmentKind(file: File): AttachmentKind {
  const type = (file.type || "").toLowerCase()
  const name = file.name.toLowerCase()
  const ext = name.includes(".") ? name.split(".").pop() ?? "" : ""

  if (type.startsWith("image/")) return "image"
  if (type.startsWith("audio/")) return "audio"
  if (type.startsWith("video/")) return "video"

  if (ext === "pdf") return "pdf"
  if (["xls", "xlsx", "csv"].includes(ext)) return "spreadsheet"
  if (["doc", "docx"].includes(ext)) return "document"
  if (["txt", "md", "rtf"].includes(ext)) return "text"

  return "file"
}

function makeAttachment(file: File): Attachment {
  return {
    id: crypto.randomUUID(),
    name: file.name,
    type: file.type,
    size: file.size,
    url: URL.createObjectURL(file),
    kind: getAttachmentKind(file),
  }
}

function revokeTodoAttachments(todo: Todo) {
  for (const a of todo.attachments) URL.revokeObjectURL(a.url)
}

function AttachmentIcon({ kind }: { kind: AttachmentKind }) {
  const className = "h-4 w-4 text-muted-foreground"

  switch (kind) {
    case "image":
      return <ImageIcon className={className} />
    case "audio":
      return <Music className={className} />
    case "video":
      return <Video className={className} />
    case "spreadsheet":
      return <FileSpreadsheet className={className} />
    case "pdf":
    case "document":
    case "text":
      return <FileText className={className} />
    default:
      return <File className={className} />
  }
}

export default function Home() {
  return (
    <div className="mx-auto flex min-h-screen max-w-2xl flex-col gap-6 px-4 py-10">
      <TodoApp />
    </div>
  )
}

function TodoApp() {
  const [todos, setTodos] = React.useState<Todo[]>(initialTodos)
  const [attachTargetTodoId, setAttachTargetTodoId] = React.useState<string | null>(
    null
  )
  const [filterMode, setFilterMode] = React.useState<"between" | "exact">("between")
  const [filterFromDate, setFilterFromDate] = React.useState<string>("")
  const [filterFromTime, setFilterFromTime] = React.useState<string>("")
  const [filterToDate, setFilterToDate] = React.useState<string>("")
  const [filterToTime, setFilterToTime] = React.useState<string>("")
  const [filterExactDate, setFilterExactDate] = React.useState<string>("")
  const [filterExactTime, setFilterExactTime] = React.useState<string>("")
  const fileInputRef = React.useRef<HTMLInputElement>(null)
  const [pageSize, setPageSize] = React.useState<number>(5)
  const [page, setPage] = React.useState<number>(1)

  const todosRef = React.useRef(todos)
  React.useEffect(() => {
    todosRef.current = todos
  }, [todos])
  React.useEffect(() => {
    return () => {
      for (const t of todosRef.current) revokeTodoAttachments(t)
    }
  }, [])

  const form = useForm<TodoFormValues>({
    resolver: zodResolver(todoSchema),
    defaultValues: { title: "", dueAt: "" },
    mode: "onSubmit",
  })

  const summary = React.useMemo(() => {
    const now = new Date()
    const todayKey = localDateKey(now)
    const tomorrow = addDays(now, 1)
    const tomorrowKey = localDateKey(tomorrow)

    const todays = todos.filter((t) => t.dueAt.startsWith(todayKey))
    const todayCompleted = todays.filter((t) => t.completed).length
    const todayPending = todays.length - todayCompleted

    const labels = [
      "00:00–04:00",
      "04:00–08:00",
      "08:00–12:00",
      "12:00–16:00",
      "16:00–20:00",
      "20:00–24:00",
    ]

    // Tomorrow: same 4-hour windows breakdown
    const tomorrowTasks = todos.filter((t) => t.dueAt.startsWith(tomorrowKey))
    const tomorrowBuckets = Array.from({ length: 6 }, () => 0) as number[]
    for (const t of tomorrowTasks) {
      const ms = parseLocalDateTime(t.dueAt)
      const hour = new Date(ms).getHours()
      const idx = Math.floor(hour / 4)
      tomorrowBuckets[idx] = (tomorrowBuckets[idx] ?? 0) + 1
    }

    // Until next week = next 7 days starting tomorrow (local), grouped into 4-hour windows.
    const rangeStart = startOfDay(tomorrow).getTime()
    const rangeEnd = addDays(startOfDay(tomorrow), 7).getTime()
    const buckets = Array.from({ length: 6 }, () => 0) as number[]

    const upcoming = todos.filter((t) => {
      const ms = parseLocalDateTime(t.dueAt)
      return ms >= rangeStart && ms < rangeEnd
    })

    for (const t of upcoming) {
      const ms = parseLocalDateTime(t.dueAt)
      const hour = new Date(ms).getHours()
      const idx = Math.floor(hour / 4)
      buckets[idx] = (buckets[idx] ?? 0) + 1
    }

    return {
      todayCompleted,
      todayPending,
      tomorrowTotal: tomorrowTasks.length,
      tomorrowBuckets: labels.map((label, i) => ({ label, count: tomorrowBuckets[i] ?? 0 })),
      upcomingTotal: upcoming.length,
      upcomingBuckets: labels.map((label, i) => ({ label, count: buckets[i] ?? 0 })),
    }
  }, [todos])

  const filteredTodos = React.useMemo(() => {
    const withMs = todos.map((t) => ({ ...t, _dueMs: parseLocalDateTime(t.dueAt) }))
    if (filterMode === "exact") {
      // If only date is selected -> show tasks for that date.
      // If time is selected too -> match exact date+time.
      // If only time is selected -> match time-of-day across all dates.
      if (!filterExactDate && !filterExactTime) return withMs

      if (filterExactDate && !filterExactTime) {
        return withMs.filter((t) => getDatePart(t.dueAt) === filterExactDate)
      }

      if (filterExactDate && filterExactTime) {
        const exactMs = parseLocalDateTime(`${filterExactDate}T${filterExactTime}`)
        return withMs.filter((t) => t._dueMs === exactMs)
      }

      // time only
      return withMs.filter((t) => getTimePart(t.dueAt) === filterExactTime)
    }
    // between
    const hasAnyDate = Boolean(filterFromDate || filterToDate)
    const hasAnyTime = Boolean(filterFromTime || filterToTime)

    // Date range (optional)
    const fromDateMs = filterFromDate
      ? startOfDay(parseLocalDateOnly(filterFromDate)).getTime()
      : Number.NEGATIVE_INFINITY
    const toDateMs = filterToDate
      ? endOfDay(parseLocalDateOnly(filterToDate)).getTime()
      : Number.POSITIVE_INFINITY

    // Time-of-day range (optional)
    const fromTimeMin = filterFromTime ? parseLocalTimeToMinutes(filterFromTime) : 0
    const toTimeMin = filterToTime ? parseLocalTimeToMinutes(filterToTime) : 24 * 60 - 1

    return withMs.filter((t) => {
      const ms = t._dueMs
      if (hasAnyDate && (ms < fromDateMs || ms > toDateMs)) return false

      if (hasAnyTime) {
        const time = getTimePart(t.dueAt)
        if (!time) return false
        const mins = parseLocalTimeToMinutes(time)
        // Simple (non-wrapping) range. If you want wrap-around (e.g. 22:00–02:00), tell me.
        if (mins < fromTimeMin || mins > toTimeMin) return false
      }

      // If neither date nor time selected, pass through (handled above anyway)
      return true
    })
  }, [
    todos,
    filterExactDate,
    filterExactTime,
    filterFromDate,
    filterFromTime,
    filterMode,
    filterToDate,
    filterToTime,
  ])

  const sortedFilteredTodos = React.useMemo(
    () =>
      filteredTodos
        .slice()
        .sort((a, b) => parseLocalDateTime(a.dueAt) - parseLocalDateTime(b.dueAt)),
    [filteredTodos]
  )

  // Clamp page when filters/pageSize change.
  React.useEffect(() => {
    const totalPages = Math.max(1, Math.ceil(sortedFilteredTodos.length / pageSize))
    setPage((p) => Math.min(Math.max(1, p), totalPages))
  }, [pageSize, sortedFilteredTodos.length])

  const totalItems = sortedFilteredTodos.length
  const totalPages = Math.max(1, Math.ceil(totalItems / pageSize))
  const showPagination = totalItems > pageSize

  const pageItems = React.useMemo(() => {
    const start = (page - 1) * pageSize
    return sortedFilteredTodos.slice(start, start + pageSize)
  }, [page, pageSize, sortedFilteredTodos])

  const groupedTodos = React.useMemo(() => {
    const groups: Array<{ date: string; items: typeof pageItems }> = []
    for (const t of pageItems) {
      const date = getDatePart(t.dueAt)
      const last = groups[groups.length - 1]
      if (!last || last.date !== date) groups.push({ date, items: [t] })
      else last.items.push(t)
    }
    return groups
  }, [pageItems])

    const groups: Array<{ date: string; items: typeof sorted }> = []
    for (const t of sorted) {
      const date = getDatePart(t.dueAt)
      const last = groups[groups.length - 1]
      if (!last || last.date !== date) groups.push({ date, items: [t] })
      else last.items.push(t)
    }
    return groups
  }, [filteredTodos])

  const completedCount = filteredTodos.filter((t) => t.completed).length

  function addTodo(values: TodoFormValues) {
    setTodos((prev) => [
      {
        id: crypto.randomUUID(),
        title: values.title.trim(),
        completed: false,
        dueAt: values.dueAt,
        attachments: [],
      },
      ...prev,
    ])
    form.reset()
  }

  function toggleTodo(id: string, completed: boolean) {
    setTodos((prev) => prev.map((t) => (t.id === id ? { ...t, completed } : t)))
  }

  function requestAttachmentsForTodo(todoId: string) {
    setAttachTargetTodoId(todoId)
    // Let state update before opening picker (some browsers are picky).
    queueMicrotask(() => fileInputRef.current?.click())
  }

  function handleFilesPicked(e: React.ChangeEvent<HTMLInputElement>) {
    const files = Array.from(e.target.files ?? [])
    const targetId = attachTargetTodoId

    // reset input so picking the same file again triggers onChange
    e.target.value = ""
    setAttachTargetTodoId(null)

    if (!targetId || files.length === 0) return

    const attachments = files.map(makeAttachment)

    setTodos((prev) =>
      prev.map((t) =>
        t.id === targetId
          ? { ...t, attachments: [...t.attachments, ...attachments] }
          : t
      )
    )
  }

  function deleteTodo(id: string) {
    setTodos((prev) => {
      const victim = prev.find((t) => t.id === id)
      if (victim) revokeTodoAttachments(victim)
      return prev.filter((t) => t.id !== id)
    })
  }

  function clearCompleted() {
    setTodos((prev) => {
      for (const t of prev) {
        if (t.completed) revokeTodoAttachments(t)
      }
      return prev.filter((t) => !t.completed)
    })
  }

  return (
    <Card>
      <CardHeader className="flex flex-row items-center justify-between gap-4">
        <div className="space-y-1">
          <CardTitle className="text-2xl">To‑Do</CardTitle>
          <p className="text-muted-foreground text-sm">
            {completedCount}/{filteredTodos.length} completed
          </p>
        </div>
        <ModeToggle />
      </CardHeader>

      <CardContent className="space-y-6">
        <input
          ref={fileInputRef}
          type="file"
          multiple
          className="hidden"
          accept={[
            "image/*",
            "audio/*",
            "video/*",
            ".pdf",
            ".doc",
            ".docx",
            ".xls",
            ".xlsx",
            ".csv",
            ".txt",
            ".md",
            ".rtf",
          ].join(",")}
          onChange={handleFilesPicked}
        />

        <div className="grid gap-3 sm:grid-cols-3">
          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Today’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">
              {summary.todayCompleted} completed
            </p>
            <p className="text-muted-foreground text-sm">{summary.todayPending} pending</p>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tomorrow’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">{summary.tomorrowTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.tomorrowBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tasks Until Next Week</p>
            <p className="mt-2 text-2xl font-semibold">{summary.upcomingTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.upcomingBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>
        </div>

        <Form {...form}>
          <form
            onSubmit={form.handleSubmit(addTodo)}
            className="space-y-2"
            noValidate
          >
            <div className="flex flex-col gap-2 sm:flex-row">
              <FormField
                control={form.control}
                name="title"
                render={({ field }) => (
                  <FormItem className="flex-1">
                    <FormControl>
                      <Input
                        placeholder="Add a task…"
                        autoComplete="off"
                        {...field}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="dueAt"
                render={({ field }) => (
                  <FormItem className="sm:w-64">
                    <FormControl>
                      <Input type="datetime-local" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <Button type="submit">Add</Button>
            </div>
          </form>
        </Form>

        <Separator />

        <div className="space-y-3">
          <div className="flex flex-wrap items-center justify-between gap-2">
            <p className="text-sm font-medium">Filter by date & time</p>
            <div className="flex items-center gap-2">
              <Button
                type="button"
                size="sm"
                variant={filterMode === "between" ? "default" : "outline"}
                onClick={() => setFilterMode("between")}
              >
                Between
              </Button>
              <Button
                type="button"
                size="sm"
                variant={filterMode === "exact" ? "default" : "outline"}
                onClick={() => setFilterMode("exact")}
              >
                Exact
              </Button>
              <Button
                type="button"
                size="sm"
                variant="ghost"
                onClick={() => {
                  setFilterFromDate("")
                  setFilterFromTime("")
                  setFilterToDate("")
                  setFilterToTime("")
                  setFilterExactDate("")
                  setFilterExactTime("")
                }}
              >
                Clear
              </Button>
            </div>
          </div>

          {filterMode === "between" ? (
            <div className="grid gap-2 sm:grid-cols-2">
              <div className="grid gap-2 sm:grid-cols-2">
                <Input
                  type="date"
                  value={filterFromDate}
                  onChange={(e) => setFilterFromDate(e.target.value)}
                />
                <Input
                  type="time"
                  value={filterFromTime}
                  onChange={(e) => setFilterFromTime(e.target.value)}
                />
              </div>
              <div className="grid gap-2 sm:grid-cols-2">
                <Input
                  type="date"
                  value={filterToDate}
                  onChange={(e) => setFilterToDate(e.target.value)}
                />
                <Input
                  type="time"
                  value={filterToTime}
                  onChange={(e) => setFilterToTime(e.target.value)}
                />
              </div>
            </div>
          ) : (
            <div className="grid gap-2 sm:grid-cols-2">
              <Input
                type="date"
                value={filterExactDate}
                onChange={(e) => setFilterExactDate(e.target.value)}
              />
              <Input
                type="time"
                value={filterExactTime}
                onChange={(e) => setFilterExactTime(e.target.value)}
              />
            </div>
          )}
        </div>

        <Separator />

        <div className="space-y-2">
          {groupedTodos.length === 0 ? (
            <p className="text-muted-foreground text-sm">No tasks yet.</p>
          ) : (
            groupedTodos.map((group) => (
              <div key={group.date} className="space-y-2">
                <div className="flex items-center gap-3 pt-2">
                  <Separator className="flex-1" />
                  <span className="text-muted-foreground whitespace-nowrap text-xs font-medium">
                    {new Intl.DateTimeFormat(undefined, {
                      weekday: "short",
                      year: "numeric",
                      month: "short",
                      day: "2-digit",
                    }).format(parseLocalDateOnly(group.date))}
                  </span>
                  <Separator className="flex-1" />
                </div>

                {group.items.map((todo) => (
                  <div key={todo.id} className="rounded-lg border px-3 py-2">
                    <div className="flex items-start justify-between gap-3">
                      <label className="flex cursor-pointer items-start gap-3">
                        <Checkbox
                          checked={todo.completed}
                          onCheckedChange={(v) => {
                            const next = Boolean(v)
                            toggleTodo(todo.id, next)
                            if (next && !todo.completed) {
                              requestAttachmentsForTodo(todo.id)
                            }
                          }}
                          aria-label={`Mark "${todo.title}" as ${
                            todo.completed ? "not completed" : "completed"
                          }`}
                          className="mt-0.5"
                        />
                        <span
                          className={cn(
                            "leading-6",
                            todo.completed && "text-muted-foreground line-through"
                          )}
                        >
                          <span className="block">{todo.title}</span>
                          <span className="text-muted-foreground block text-xs">
                            Due: {formatLocalDateTime(todo.dueAt)}
                          </span>
                        </span>
                      </label>

                      <div className="flex items-center gap-1">
                        {todo.completed && (
                          <Button
                            type="button"
                            variant="outline"
                            size="sm"
                            onClick={() => requestAttachmentsForTodo(todo.id)}
                          >
                            Add files
                          </Button>
                        )}
                        <Button
                          type="button"
                          variant="ghost"
                          size="icon"
                          aria-label={`Delete "${todo.title}"`}
                          onClick={() => deleteTodo(todo.id)}
                        >
                          <Trash2 className="h-4 w-4" />
                        </Button>
                      </div>
                    </div>

                    {todo.completed && todo.attachments.length > 0 && (
                      <div className="mt-3 space-y-2">
                        <p className="text-muted-foreground text-xs">Attachments</p>
                        <ul className="space-y-1">
                          {todo.attachments.map((a) => (
                            <li
                              key={a.id}
                              className="flex items-center justify-between gap-3 rounded-md bg-muted/30 px-2 py-1"
                            >
                              <div className="flex min-w-0 items-center gap-2">
                                <AttachmentIcon kind={a.kind} />
                                <span className="truncate text-sm">{a.name}</span>
                              </div>
                              <a
                                href={a.url}
                                download={a.name}
                                className="inline-flex items-center gap-1 text-sm font-medium underline underline-offset-4"
                              >
                                <Download className="h-4 w-4" />
                                Download
                              </a>
                            </li>
                          ))}
                        </ul>
                      </div>
                    )}
                  </div>
                ))}
              </div>
            ))
          )}
        </div>

        {groupedTodos.length > 0 && (
          <div className="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
            <div className="flex items-center gap-2">
              <span className="text-muted-foreground text-sm">Items per page</span>
              <Select
                value={String(pageSize)}
                onValueChange={(v) => {
                  const next = Number(v)
                  setPageSize(next)
                  setPage(1)
                }}
              >
                <SelectTrigger className="w-[110px]">
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="5">5</SelectItem>
                  <SelectItem value="10">10</SelectItem>
                  <SelectItem value="15">15</SelectItem>
                  <SelectItem value="20">20</SelectItem>
                </SelectContent>
              </Select>
            </div>

            {showPagination && (
              <div className="flex items-center justify-between gap-3 sm:justify-end">
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={() => setPage((p) => Math.max(1, p - 1))}
                  disabled={page <= 1}
                >
                  Prev
                </Button>
                <span className="text-muted-foreground text-sm">
                  Page {page} of {totalPages}
                </span>
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={() => setPage((p) => Math.min(totalPages, p + 1))}
                  disabled={page >= totalPages}
                >
                  Next
                </Button>
              </div>
            )}
          </div>
        )}

        <div className="flex items-center justify-between gap-2">
          <Button
            type="button"
            variant="secondary"
            onClick={clearCompleted}
            disabled={completedCount === 0}
          >
            Clear completed
          </Button>
          <span className="text-muted-foreground text-sm">
            Mock data only (no backend)
          </span>
        </div>
      </CardContent>
    </Card>
  )
}

```

I see a Turbopack parse error around the old `groupedTodos` memo—it likely left behind a stray `, [filteredTodos])` from the previous implementation. Next I’ll open the relevant section, clean it up, then re-run the build.

```typescriptreact
"use client"

import { zodResolver } from "@hookform/resolvers/zod"
import {
  Download,
  File,
  FileSpreadsheet,
  FileText,
  Image as ImageIcon,
  Music,
  Trash2,
  Video,
} from "lucide-react"
import * as React from "react"
import { useForm } from "react-hook-form"
import { z } from "zod"

import { ModeToggle } from "@/components/mode-toggle"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Checkbox } from "@/components/ui/checkbox"
import { Form, FormControl, FormField, FormItem, FormMessage } from "@/components/ui/form"
import { Input } from "@/components/ui/input"
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select"
import { Separator } from "@/components/ui/separator"
import { cn } from "@/lib/utils"

type AttachmentKind =
  | "image"
  | "audio"
  | "video"
  | "pdf"
  | "spreadsheet"
  | "document"
  | "text"
  | "file"

type Attachment = {
  id: string
  name: string
  type: string
  size: number
  url: string
  kind: AttachmentKind
}

type Todo = {
  id: string
  title: string
  completed: boolean
  // Stored as `datetime-local` string (YYYY-MM-DDTHH:mm) in local time.
  dueAt: string
  attachments: Attachment[]
}

const todoSchema = z.object({
  title: z
    .string()
    .trim()
    .min(1, "Title is required.")
    .max(80, "Keep it under 80 characters."),
  dueAt: z
    .string()
    .min(1, "Due date & time is required.")
    .regex(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}$/, "Invalid date/time."),
})

type TodoFormValues = z.infer<typeof todoSchema>

const initialTodos: Todo[] = [
  {
    id: "1",
    title: "Create a Next.js app",
    completed: true,
    dueAt: "2026-01-16T09:00",
    attachments: [],
  },
  {
    id: "2",
    title: "Add shadcn/ui + dark theme",
    completed: true,
    dueAt: "2026-01-16T10:30",
    attachments: [],
  },
  {
    id: "3",
    title: "Build a mock-data to-do list",
    completed: false,
    dueAt: "2026-01-16T15:00",
    attachments: [],
  },
  {
    id: "4",
    title: "Yesterday: review requirements",
    completed: true,
    dueAt: "2026-01-15T11:15",
    attachments: [],
  },
  {
    id: "5",
    title: "Yesterday: sketch UI layout",
    completed: true,
    dueAt: "2026-01-15T17:45",
    attachments: [],
  },
  {
    id: "6",
    title: "Today: add attachments support",
    completed: false,
    dueAt: "2026-01-16T18:20",
    attachments: [],
  },
  {
    id: "7",
    title: "Tomorrow: QA the filters",
    completed: false,
    dueAt: "2026-01-17T08:05",
    attachments: [],
  },
  {
    id: "8",
    title: "Tomorrow: polish summary cards",
    completed: false,
    dueAt: "2026-01-17T13:30",
    attachments: [],
  },
  {
    id: "9",
    title: "Tomorrow: write small UX notes",
    completed: false,
    dueAt: "2026-01-17T20:10",
    attachments: [],
  },
  {
    id: "10",
    title: "This weekend: add more mock tasks",
    completed: false,
    dueAt: "2026-01-18T10:00",
    attachments: [],
  },
  {
    id: "11",
    title: "This weekend: check time-only filter",
    completed: false,
    dueAt: "2026-01-18T22:15",
    attachments: [],
  },
  {
    id: "12",
    title: "Next week: sync with team",
    completed: false,
    dueAt: "2026-01-19T09:30",
    attachments: [],
  },
  {
    id: "13",
    title: "Next week: test date-only filter",
    completed: false,
    dueAt: "2026-01-20T14:05",
    attachments: [],
  },
  {
    id: "14",
    title: "Next week: test exact date+time filter",
    completed: false,
    dueAt: "2026-01-21T12:00",
    attachments: [],
  },
  {
    id: "15",
    title: "Next week: attach docs to completed tasks",
    completed: false,
    dueAt: "2026-01-22T16:40",
    attachments: [],
  },
  {
    id: "16",
    title: "Next week: final review",
    completed: false,
    dueAt: "2026-01-23T11:00",
    attachments: [],
  },
]

function parseLocalDateTime(value: string): number {
  // value: "YYYY-MM-DDTHH:mm"
  const [datePart, timePart] = value.split("T")
  const [y, m, d] = datePart.split("-").map(Number)
  const [hh, mm] = timePart.split(":").map(Number)
  return new Date(y, m - 1, d, hh, mm, 0, 0).getTime()
}

function pad2(n: number) {
  return String(n).padStart(2, "0")
}

function localDateKey(d: Date) {
  return `${d.getFullYear()}-${pad2(d.getMonth() + 1)}-${pad2(d.getDate())}`
}

function addDays(date: Date, days: number) {
  const d = new Date(date)
  d.setDate(d.getDate() + days)
  return d
}

function startOfDay(date: Date) {
  return new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0, 0)
}

function endOfDay(date: Date) {
  return new Date(
    date.getFullYear(),
    date.getMonth(),
    date.getDate(),
    23,
    59,
    59,
    999
  )
}

function getDatePart(dueAt: string) {
  return dueAt.split("T")[0] ?? ""
}

function getTimePart(dueAt: string) {
  return dueAt.split("T")[1] ?? ""
}

function parseLocalDateOnly(value: string): Date {
  // value: "YYYY-MM-DD"
  const [y, m, d] = value.split("-").map(Number)
  return new Date(y, m - 1, d, 0, 0, 0, 0)
}

function parseLocalTimeToMinutes(value: string): number {
  // value: "HH:mm"
  const [hh, mm] = value.split(":").map(Number)
  return hh * 60 + mm
}

function formatLocalDateTime(value: string): string {
  const ms = parseLocalDateTime(value)
  if (!Number.isFinite(ms)) return value
  return new Intl.DateTimeFormat(undefined, {
    year: "numeric",
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  }).format(new Date(ms))
}

function getAttachmentKind(file: File): AttachmentKind {
  const type = (file.type || "").toLowerCase()
  const name = file.name.toLowerCase()
  const ext = name.includes(".") ? name.split(".").pop() ?? "" : ""

  if (type.startsWith("image/")) return "image"
  if (type.startsWith("audio/")) return "audio"
  if (type.startsWith("video/")) return "video"

  if (ext === "pdf") return "pdf"
  if (["xls", "xlsx", "csv"].includes(ext)) return "spreadsheet"
  if (["doc", "docx"].includes(ext)) return "document"
  if (["txt", "md", "rtf"].includes(ext)) return "text"

  return "file"
}

function makeAttachment(file: File): Attachment {
  return {
    id: crypto.randomUUID(),
    name: file.name,
    type: file.type,
    size: file.size,
    url: URL.createObjectURL(file),
    kind: getAttachmentKind(file),
  }
}

function revokeTodoAttachments(todo: Todo) {
  for (const a of todo.attachments) URL.revokeObjectURL(a.url)
}

function AttachmentIcon({ kind }: { kind: AttachmentKind }) {
  const className = "h-4 w-4 text-muted-foreground"

  switch (kind) {
    case "image":
      return <ImageIcon className={className} />
    case "audio":
      return <Music className={className} />
    case "video":
      return <Video className={className} />
    case "spreadsheet":
      return <FileSpreadsheet className={className} />
    case "pdf":
    case "document":
    case "text":
      return <FileText className={className} />
    default:
      return <File className={className} />
  }
}

export default function Home() {
  return (
    <div className="mx-auto flex min-h-screen max-w-2xl flex-col gap-6 px-4 py-10">
      <TodoApp />
    </div>
  )
}

function TodoApp() {
  const [todos, setTodos] = React.useState<Todo[]>(initialTodos)
  const [attachTargetTodoId, setAttachTargetTodoId] = React.useState<string | null>(
    null
  )
  const [filterMode, setFilterMode] = React.useState<"between" | "exact">("between")
  const [filterFromDate, setFilterFromDate] = React.useState<string>("")
  const [filterFromTime, setFilterFromTime] = React.useState<string>("")
  const [filterToDate, setFilterToDate] = React.useState<string>("")
  const [filterToTime, setFilterToTime] = React.useState<string>("")
  const [filterExactDate, setFilterExactDate] = React.useState<string>("")
  const [filterExactTime, setFilterExactTime] = React.useState<string>("")
  const fileInputRef = React.useRef<HTMLInputElement>(null)
  const [pageSize, setPageSize] = React.useState<number>(5)
  const [page, setPage] = React.useState<number>(1)

  const todosRef = React.useRef(todos)
  React.useEffect(() => {
    todosRef.current = todos
  }, [todos])
  React.useEffect(() => {
    return () => {
      for (const t of todosRef.current) revokeTodoAttachments(t)
    }
  }, [])

  const form = useForm<TodoFormValues>({
    resolver: zodResolver(todoSchema),
    defaultValues: { title: "", dueAt: "" },
    mode: "onSubmit",
  })

  const summary = React.useMemo(() => {
    const now = new Date()
    const todayKey = localDateKey(now)
    const tomorrow = addDays(now, 1)
    const tomorrowKey = localDateKey(tomorrow)

    const todays = todos.filter((t) => t.dueAt.startsWith(todayKey))
    const todayCompleted = todays.filter((t) => t.completed).length
    const todayPending = todays.length - todayCompleted

    const labels = [
      "00:00–04:00",
      "04:00–08:00",
      "08:00–12:00",
      "12:00–16:00",
      "16:00–20:00",
      "20:00–24:00",
    ]

    // Tomorrow: same 4-hour windows breakdown
    const tomorrowTasks = todos.filter((t) => t.dueAt.startsWith(tomorrowKey))
    const tomorrowBuckets = Array.from({ length: 6 }, () => 0) as number[]
    for (const t of tomorrowTasks) {
      const ms = parseLocalDateTime(t.dueAt)
      const hour = new Date(ms).getHours()
      const idx = Math.floor(hour / 4)
      tomorrowBuckets[idx] = (tomorrowBuckets[idx] ?? 0) + 1
    }

    // Until next week = next 7 days starting tomorrow (local), grouped into 4-hour windows.
    const rangeStart = startOfDay(tomorrow).getTime()
    const rangeEnd = addDays(startOfDay(tomorrow), 7).getTime()
    const buckets = Array.from({ length: 6 }, () => 0) as number[]

    const upcoming = todos.filter((t) => {
      const ms = parseLocalDateTime(t.dueAt)
      return ms >= rangeStart && ms < rangeEnd
    })

    for (const t of upcoming) {
      const ms = parseLocalDateTime(t.dueAt)
      const hour = new Date(ms).getHours()
      const idx = Math.floor(hour / 4)
      buckets[idx] = (buckets[idx] ?? 0) + 1
    }

    return {
      todayCompleted,
      todayPending,
      tomorrowTotal: tomorrowTasks.length,
      tomorrowBuckets: labels.map((label, i) => ({ label, count: tomorrowBuckets[i] ?? 0 })),
      upcomingTotal: upcoming.length,
      upcomingBuckets: labels.map((label, i) => ({ label, count: buckets[i] ?? 0 })),
    }
  }, [todos])

  const filteredTodos = React.useMemo(() => {
    const withMs = todos.map((t) => ({ ...t, _dueMs: parseLocalDateTime(t.dueAt) }))
    if (filterMode === "exact") {
      // If only date is selected -> show tasks for that date.
      // If time is selected too -> match exact date+time.
      // If only time is selected -> match time-of-day across all dates.
      if (!filterExactDate && !filterExactTime) return withMs

      if (filterExactDate && !filterExactTime) {
        return withMs.filter((t) => getDatePart(t.dueAt) === filterExactDate)
      }

      if (filterExactDate && filterExactTime) {
        const exactMs = parseLocalDateTime(`${filterExactDate}T${filterExactTime}`)
        return withMs.filter((t) => t._dueMs === exactMs)
      }

      // time only
      return withMs.filter((t) => getTimePart(t.dueAt) === filterExactTime)
    }
    // between
    const hasAnyDate = Boolean(filterFromDate || filterToDate)
    const hasAnyTime = Boolean(filterFromTime || filterToTime)

    // Date range (optional)
    const fromDateMs = filterFromDate
      ? startOfDay(parseLocalDateOnly(filterFromDate)).getTime()
      : Number.NEGATIVE_INFINITY
    const toDateMs = filterToDate
      ? endOfDay(parseLocalDateOnly(filterToDate)).getTime()
      : Number.POSITIVE_INFINITY

    // Time-of-day range (optional)
    const fromTimeMin = filterFromTime ? parseLocalTimeToMinutes(filterFromTime) : 0
    const toTimeMin = filterToTime ? parseLocalTimeToMinutes(filterToTime) : 24 * 60 - 1

    return withMs.filter((t) => {
      const ms = t._dueMs
      if (hasAnyDate && (ms < fromDateMs || ms > toDateMs)) return false

      if (hasAnyTime) {
        const time = getTimePart(t.dueAt)
        if (!time) return false
        const mins = parseLocalTimeToMinutes(time)
        // Simple (non-wrapping) range. If you want wrap-around (e.g. 22:00–02:00), tell me.
        if (mins < fromTimeMin || mins > toTimeMin) return false
      }

      // If neither date nor time selected, pass through (handled above anyway)
      return true
    })
  }, [
    todos,
    filterExactDate,
    filterExactTime,
    filterFromDate,
    filterFromTime,
    filterMode,
    filterToDate,
    filterToTime,
  ])

  const sortedFilteredTodos = React.useMemo(
    () =>
      filteredTodos
        .slice()
        .sort((a, b) => parseLocalDateTime(a.dueAt) - parseLocalDateTime(b.dueAt)),
    [filteredTodos]
  )

  // Clamp page when filters/pageSize change.
  React.useEffect(() => {
    const totalPages = Math.max(1, Math.ceil(sortedFilteredTodos.length / pageSize))
    setPage((p) => Math.min(Math.max(1, p), totalPages))
  }, [pageSize, sortedFilteredTodos.length])

  const totalItems = sortedFilteredTodos.length
  const totalPages = Math.max(1, Math.ceil(totalItems / pageSize))
  const showPagination = totalPages > 1

  const pageItems = React.useMemo(() => {
    const start = (page - 1) * pageSize
    return sortedFilteredTodos.slice(start, start + pageSize)
  }, [page, pageSize, sortedFilteredTodos])

  const groupedTodos = React.useMemo(() => {
    const groups: Array<{ date: string; items: typeof pageItems }> = []
    for (const t of pageItems) {
      const date = getDatePart(t.dueAt)
      const last = groups[groups.length - 1]
      if (!last || last.date !== date) groups.push({ date, items: [t] })
      else last.items.push(t)
    }
    return groups
  }, [pageItems])

  const completedCount = filteredTodos.filter((t) => t.completed).length

  function addTodo(values: TodoFormValues) {
    setTodos((prev) => [
      {
        id: crypto.randomUUID(),
        title: values.title.trim(),
        completed: false,
        dueAt: values.dueAt,
        attachments: [],
      },
      ...prev,
    ])
    form.reset()
  }

  function toggleTodo(id: string, completed: boolean) {
    setTodos((prev) => prev.map((t) => (t.id === id ? { ...t, completed } : t)))
  }

  function requestAttachmentsForTodo(todoId: string) {
    setAttachTargetTodoId(todoId)
    // Let state update before opening picker (some browsers are picky).
    queueMicrotask(() => fileInputRef.current?.click())
  }

  function handleFilesPicked(e: React.ChangeEvent<HTMLInputElement>) {
    const files = Array.from(e.target.files ?? [])
    const targetId = attachTargetTodoId

    // reset input so picking the same file again triggers onChange
    e.target.value = ""
    setAttachTargetTodoId(null)

    if (!targetId || files.length === 0) return

    const attachments = files.map(makeAttachment)

    setTodos((prev) =>
      prev.map((t) =>
        t.id === targetId
          ? { ...t, attachments: [...t.attachments, ...attachments] }
          : t
      )
    )
  }

  function deleteTodo(id: string) {
    setTodos((prev) => {
      const victim = prev.find((t) => t.id === id)
      if (victim) revokeTodoAttachments(victim)
      return prev.filter((t) => t.id !== id)
    })
  }

  function clearCompleted() {
    setTodos((prev) => {
      for (const t of prev) {
        if (t.completed) revokeTodoAttachments(t)
      }
      return prev.filter((t) => !t.completed)
    })
  }

  return (
    <Card>
      <CardHeader className="flex flex-row items-center justify-between gap-4">
        <div className="space-y-1">
          <CardTitle className="text-2xl">To‑Do</CardTitle>
          <p className="text-muted-foreground text-sm">
            {completedCount}/{filteredTodos.length} completed
          </p>
        </div>
        <ModeToggle />
      </CardHeader>

      <CardContent className="space-y-6">
        <input
          ref={fileInputRef}
          type="file"
          multiple
          className="hidden"
          accept={[
            "image/*",
            "audio/*",
            "video/*",
            ".pdf",
            ".doc",
            ".docx",
            ".xls",
            ".xlsx",
            ".csv",
            ".txt",
            ".md",
            ".rtf",
          ].join(",")}
          onChange={handleFilesPicked}
        />

        <div className="grid gap-3 sm:grid-cols-3">
          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Today’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">
              {summary.todayCompleted} completed
            </p>
            <p className="text-muted-foreground text-sm">{summary.todayPending} pending</p>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tomorrow’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">{summary.tomorrowTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.tomorrowBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tasks Until Next Week</p>
            <p className="mt-2 text-2xl font-semibold">{summary.upcomingTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.upcomingBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>
        </div>

        <Form {...form}>
          <form
            onSubmit={form.handleSubmit(addTodo)}
            className="space-y-2"
            noValidate
          >
            <div className="flex flex-col gap-2 sm:flex-row">
              <FormField
                control={form.control}
                name="title"
                render={({ field }) => (
                  <FormItem className="flex-1">
                    <FormControl>
                      <Input
                        placeholder="Add a task…"
                        autoComplete="off"
                        {...field}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="dueAt"
                render={({ field }) => (
                  <FormItem className="sm:w-64">
                    <FormControl>
                      <Input type="datetime-local" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <Button type="submit">Add</Button>
            </div>
          </form>
        </Form>

        <Separator />

        <div className="space-y-3">
          <div className="flex flex-wrap items-center justify-between gap-2">
            <p className="text-sm font-medium">Filter by date & time</p>
            <div className="flex items-center gap-2">
              <Button
                type="button"
                size="sm"
                variant={filterMode === "between" ? "default" : "outline"}
                onClick={() => setFilterMode("between")}
              >
                Between
              </Button>
              <Button
                type="button"
                size="sm"
                variant={filterMode === "exact" ? "default" : "outline"}
                onClick={() => setFilterMode("exact")}
              >
                Exact
              </Button>
              <Button
                type="button"
                size="sm"
                variant="ghost"
                onClick={() => {
                  setFilterFromDate("")
                  setFilterFromTime("")
                  setFilterToDate("")
                  setFilterToTime("")
                  setFilterExactDate("")
                  setFilterExactTime("")
                }}
              >
                Clear
              </Button>
            </div>
          </div>

          {filterMode === "between" ? (
            <div className="grid gap-2 sm:grid-cols-2">
              <div className="grid gap-2 sm:grid-cols-2">
                <Input
                  type="date"
                  value={filterFromDate}
                  onChange={(e) => setFilterFromDate(e.target.value)}
                />
                <Input
                  type="time"
                  value={filterFromTime}
                  onChange={(e) => setFilterFromTime(e.target.value)}
                />
              </div>
              <div className="grid gap-2 sm:grid-cols-2">
                <Input
                  type="date"
                  value={filterToDate}
                  onChange={(e) => setFilterToDate(e.target.value)}
                />
                <Input
                  type="time"
                  value={filterToTime}
                  onChange={(e) => setFilterToTime(e.target.value)}
                />
              </div>
            </div>
          ) : (
            <div className="grid gap-2 sm:grid-cols-2">
              <Input
                type="date"
                value={filterExactDate}
                onChange={(e) => setFilterExactDate(e.target.value)}
              />
              <Input
                type="time"
                value={filterExactTime}
                onChange={(e) => setFilterExactTime(e.target.value)}
              />
            </div>
          )}
        </div>

        <Separator />

        <div className="space-y-2">
          {groupedTodos.length === 0 ? (
            <p className="text-muted-foreground text-sm">No tasks yet.</p>
          ) : (
            groupedTodos.map((group) => (
              <div key={group.date} className="space-y-2">
                <div className="flex items-center gap-3 pt-2">
                  <Separator className="flex-1" />
                  <span className="text-muted-foreground whitespace-nowrap text-xs font-medium">
                    {new Intl.DateTimeFormat(undefined, {
                      weekday: "short",
                      year: "numeric",
                      month: "short",
                      day: "2-digit",
                    }).format(parseLocalDateOnly(group.date))}
                  </span>
                  <Separator className="flex-1" />
                </div>

                {group.items.map((todo) => (
                  <div key={todo.id} className="rounded-lg border px-3 py-2">
                    <div className="flex items-start justify-between gap-3">
                      <label className="flex cursor-pointer items-start gap-3">
                        <Checkbox
                          checked={todo.completed}
                          onCheckedChange={(v) => {
                            const next = Boolean(v)
                            toggleTodo(todo.id, next)
                            if (next && !todo.completed) {
                              requestAttachmentsForTodo(todo.id)
                            }
                          }}
                          aria-label={`Mark "${todo.title}" as ${
                            todo.completed ? "not completed" : "completed"
                          }`}
                          className="mt-0.5"
                        />
                        <span
                          className={cn(
                            "leading-6",
                            todo.completed && "text-muted-foreground line-through"
                          )}
                        >
                          <span className="block">{todo.title}</span>
                          <span className="text-muted-foreground block text-xs">
                            Due: {formatLocalDateTime(todo.dueAt)}
                          </span>
                        </span>
                      </label>

                      <div className="flex items-center gap-1">
                        {todo.completed && (
                          <Button
                            type="button"
                            variant="outline"
                            size="sm"
                            onClick={() => requestAttachmentsForTodo(todo.id)}
                          >
                            Add files
                          </Button>
                        )}
                        <Button
                          type="button"
                          variant="ghost"
                          size="icon"
                          aria-label={`Delete "${todo.title}"`}
                          onClick={() => deleteTodo(todo.id)}
                        >
                          <Trash2 className="h-4 w-4" />
                        </Button>
                      </div>
                    </div>

                    {todo.completed && todo.attachments.length > 0 && (
                      <div className="mt-3 space-y-2">
                        <p className="text-muted-foreground text-xs">Attachments</p>
                        <ul className="space-y-1">
                          {todo.attachments.map((a) => (
                            <li
                              key={a.id}
                              className="flex items-center justify-between gap-3 rounded-md bg-muted/30 px-2 py-1"
                            >
                              <div className="flex min-w-0 items-center gap-2">
                                <AttachmentIcon kind={a.kind} />
                                <span className="truncate text-sm">{a.name}</span>
                              </div>
                              <a
                                href={a.url}
                                download={a.name}
                                className="inline-flex items-center gap-1 text-sm font-medium underline underline-offset-4"
                              >
                                <Download className="h-4 w-4" />
                                Download
                              </a>
                            </li>
                          ))}
                        </ul>
                      </div>
                    )}
                  </div>
                ))}
              </div>
            ))
          )}
        </div>

        {groupedTodos.length > 0 && (
          <div className="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
            <div className="flex items-center gap-2">
              <span className="text-muted-foreground text-sm">Items per page</span>
              <Select
                value={String(pageSize)}
                onValueChange={(v) => {
                  const next = Number(v)
                  setPageSize(next)
                  setPage(1)
                }}
              >
                <SelectTrigger className="w-[110px]">
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="5">5</SelectItem>
                  <SelectItem value="10">10</SelectItem>
                  <SelectItem value="15">15</SelectItem>
                  <SelectItem value="20">20</SelectItem>
                </SelectContent>
              </Select>
            </div>

            {showPagination && (
              <div className="flex items-center justify-between gap-3 sm:justify-end">
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={() => setPage((p) => Math.max(1, p - 1))}
                  disabled={page <= 1}
                >
                  Prev
                </Button>
                <span className="text-muted-foreground text-sm">
                  Page {page} of {totalPages}
                </span>
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={() => setPage((p) => Math.min(totalPages, p + 1))}
                  disabled={page >= totalPages}
                >
                  Next
                </Button>
              </div>
            )}
          </div>
        )}

        <div className="flex items-center justify-between gap-2">
          <Button
            type="button"
            variant="secondary"
            onClick={clearCompleted}
            disabled={completedCount === 0}
          >
            Clear completed
          </Button>
          <span className="text-muted-foreground text-sm">
            Mock data only (no backend)
          </span>
        </div>
      </CardContent>
    </Card>
  )
}

```

### Pagination + page-size dropdown added
- The task list now **paginates when there’s more than one page** (default **5 items/page**).
- Users can choose **items per page** via a **shadcn/ui Select dropdown** (5/10/15/20).
- The list is paginated **by items**, then the current page is still **grouped by date** with dividers.

### Files updated
- **New**: `src/components/ui/select.tsx`
- **Updated**: `src/app/page.tsx`

### Run
```bash
npm run dev
```

```shellscript
npm run dev
```

---

**User**

Time Conflict Hint – When a user adds a task, the app checks the existing tasks for the same date and time. If a conflict is found, it highlights the conflicting tasks in the list and shows a toast notification to inform the user that the time slot is already full.

---

**Cursor**

Nice request—this fits cleanly into the existing `dueAt` model. Next I’ll add shadcn’s toast (Sonner), wire a conflict check when submitting the form, auto-focus the list on that conflicting date+time, and visually highlight the conflicting tasks for a few seconds.

```typescriptreact
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";
import { ThemeProvider } from "@/components/theme-provider";
import { cn } from "@/lib/utils";
import { Toaster } from "@/components/ui/sonner";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "To-Do App",
  description: "Mock-data to-do app using shadcn/ui, react-hook-form, and zod.",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en" suppressHydrationWarning>
      <body
        className={cn(
          geistSans.variable,
          geistMono.variable,
          "min-h-screen bg-background font-sans antialiased"
        )}
      >
        <ThemeProvider
          attribute="class"
          defaultTheme="dark"
          enableSystem={false}
          disableTransitionOnChange
        >
          {children}
          <Toaster richColors position="top-right" />
        </ThemeProvider>
      </body>
    </html>
  );
}

```

```typescriptreact
"use client"

import { zodResolver } from "@hookform/resolvers/zod"
import {
  Download,
  File,
  FileSpreadsheet,
  FileText,
  Image as ImageIcon,
  Music,
  Trash2,
  Video,
} from "lucide-react"
import * as React from "react"
import { useForm } from "react-hook-form"
import { toast } from "sonner"
import { z } from "zod"

import { ModeToggle } from "@/components/mode-toggle"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Checkbox } from "@/components/ui/checkbox"
import { Form, FormControl, FormField, FormItem, FormMessage } from "@/components/ui/form"
import { Input } from "@/components/ui/input"
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select"
import { Separator } from "@/components/ui/separator"
import { cn } from "@/lib/utils"

type AttachmentKind =
  | "image"
  | "audio"
  | "video"
  | "pdf"
  | "spreadsheet"
  | "document"
  | "text"
  | "file"

type Attachment = {
  id: string
  name: string
  type: string
  size: number
  url: string
  kind: AttachmentKind
}

type Todo = {
  id: string
  title: string
  completed: boolean
  // Stored as `datetime-local` string (YYYY-MM-DDTHH:mm) in local time.
  dueAt: string
  attachments: Attachment[]
}

const todoSchema = z.object({
  title: z
    .string()
    .trim()
    .min(1, "Title is required.")
    .max(80, "Keep it under 80 characters."),
  dueAt: z
    .string()
    .min(1, "Due date & time is required.")
    .regex(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}$/, "Invalid date/time."),
})

type TodoFormValues = z.infer<typeof todoSchema>

const initialTodos: Todo[] = [
  {
    id: "1",
    title: "Create a Next.js app",
    completed: true,
    dueAt: "2026-01-16T09:00",
    attachments: [],
  },
  {
    id: "2",
    title: "Add shadcn/ui + dark theme",
    completed: true,
    dueAt: "2026-01-16T10:30",
    attachments: [],
  },
  {
    id: "3",
    title: "Build a mock-data to-do list",
    completed: false,
    dueAt: "2026-01-16T15:00",
    attachments: [],
  },
  {
    id: "4",
    title: "Yesterday: review requirements",
    completed: true,
    dueAt: "2026-01-15T11:15",
    attachments: [],
  },
  {
    id: "5",
    title: "Yesterday: sketch UI layout",
    completed: true,
    dueAt: "2026-01-15T17:45",
    attachments: [],
  },
  {
    id: "6",
    title: "Today: add attachments support",
    completed: false,
    dueAt: "2026-01-16T18:20",
    attachments: [],
  },
  {
    id: "7",
    title: "Tomorrow: QA the filters",
    completed: false,
    dueAt: "2026-01-17T08:05",
    attachments: [],
  },
  {
    id: "8",
    title: "Tomorrow: polish summary cards",
    completed: false,
    dueAt: "2026-01-17T13:30",
    attachments: [],
  },
  {
    id: "9",
    title: "Tomorrow: write small UX notes",
    completed: false,
    dueAt: "2026-01-17T20:10",
    attachments: [],
  },
  {
    id: "10",
    title: "This weekend: add more mock tasks",
    completed: false,
    dueAt: "2026-01-18T10:00",
    attachments: [],
  },
  {
    id: "11",
    title: "This weekend: check time-only filter",
    completed: false,
    dueAt: "2026-01-18T22:15",
    attachments: [],
  },
  {
    id: "12",
    title: "Next week: sync with team",
    completed: false,
    dueAt: "2026-01-19T09:30",
    attachments: [],
  },
  {
    id: "13",
    title: "Next week: test date-only filter",
    completed: false,
    dueAt: "2026-01-20T14:05",
    attachments: [],
  },
  {
    id: "14",
    title: "Next week: test exact date+time filter",
    completed: false,
    dueAt: "2026-01-21T12:00",
    attachments: [],
  },
  {
    id: "15",
    title: "Next week: attach docs to completed tasks",
    completed: false,
    dueAt: "2026-01-22T16:40",
    attachments: [],
  },
  {
    id: "16",
    title: "Next week: final review",
    completed: false,
    dueAt: "2026-01-23T11:00",
    attachments: [],
  },
]

function parseLocalDateTime(value: string): number {
  // value: "YYYY-MM-DDTHH:mm"
  const [datePart, timePart] = value.split("T")
  const [y, m, d] = datePart.split("-").map(Number)
  const [hh, mm] = timePart.split(":").map(Number)
  return new Date(y, m - 1, d, hh, mm, 0, 0).getTime()
}

function pad2(n: number) {
  return String(n).padStart(2, "0")
}

function localDateKey(d: Date) {
  return `${d.getFullYear()}-${pad2(d.getMonth() + 1)}-${pad2(d.getDate())}`
}

function addDays(date: Date, days: number) {
  const d = new Date(date)
  d.setDate(d.getDate() + days)
  return d
}

function startOfDay(date: Date) {
  return new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0, 0)
}

function endOfDay(date: Date) {
  return new Date(
    date.getFullYear(),
    date.getMonth(),
    date.getDate(),
    23,
    59,
    59,
    999
  )
}

function getDatePart(dueAt: string) {
  return dueAt.split("T")[0] ?? ""
}

function getTimePart(dueAt: string) {
  return dueAt.split("T")[1] ?? ""
}

function parseLocalDateOnly(value: string): Date {
  // value: "YYYY-MM-DD"
  const [y, m, d] = value.split("-").map(Number)
  return new Date(y, m - 1, d, 0, 0, 0, 0)
}

function parseLocalTimeToMinutes(value: string): number {
  // value: "HH:mm"
  const [hh, mm] = value.split(":").map(Number)
  return hh * 60 + mm
}

function formatLocalDateTime(value: string): string {
  const ms = parseLocalDateTime(value)
  if (!Number.isFinite(ms)) return value
  return new Intl.DateTimeFormat(undefined, {
    year: "numeric",
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  }).format(new Date(ms))
}

function getAttachmentKind(file: File): AttachmentKind {
  const type = (file.type || "").toLowerCase()
  const name = file.name.toLowerCase()
  const ext = name.includes(".") ? name.split(".").pop() ?? "" : ""

  if (type.startsWith("image/")) return "image"
  if (type.startsWith("audio/")) return "audio"
  if (type.startsWith("video/")) return "video"

  if (ext === "pdf") return "pdf"
  if (["xls", "xlsx", "csv"].includes(ext)) return "spreadsheet"
  if (["doc", "docx"].includes(ext)) return "document"
  if (["txt", "md", "rtf"].includes(ext)) return "text"

  return "file"
}

function makeAttachment(file: File): Attachment {
  return {
    id: crypto.randomUUID(),
    name: file.name,
    type: file.type,
    size: file.size,
    url: URL.createObjectURL(file),
    kind: getAttachmentKind(file),
  }
}

function revokeTodoAttachments(todo: Todo) {
  for (const a of todo.attachments) URL.revokeObjectURL(a.url)
}

function AttachmentIcon({ kind }: { kind: AttachmentKind }) {
  const className = "h-4 w-4 text-muted-foreground"

  switch (kind) {
    case "image":
      return <ImageIcon className={className} />
    case "audio":
      return <Music className={className} />
    case "video":
      return <Video className={className} />
    case "spreadsheet":
      return <FileSpreadsheet className={className} />
    case "pdf":
    case "document":
    case "text":
      return <FileText className={className} />
    default:
      return <File className={className} />
  }
}

export default function Home() {
  return (
    <div className="mx-auto flex min-h-screen max-w-2xl flex-col gap-6 px-4 py-10">
      <TodoApp />
    </div>
  )
}

function TodoApp() {
  const [todos, setTodos] = React.useState<Todo[]>(initialTodos)
  const [attachTargetTodoId, setAttachTargetTodoId] = React.useState<string | null>(
    null
  )
  const [conflictDueAt, setConflictDueAt] = React.useState<string | null>(null)
  const clearConflictTimerRef = React.useRef<number | null>(null)
  const [filterMode, setFilterMode] = React.useState<"between" | "exact">("between")
  const [filterFromDate, setFilterFromDate] = React.useState<string>("")
  const [filterFromTime, setFilterFromTime] = React.useState<string>("")
  const [filterToDate, setFilterToDate] = React.useState<string>("")
  const [filterToTime, setFilterToTime] = React.useState<string>("")
  const [filterExactDate, setFilterExactDate] = React.useState<string>("")
  const [filterExactTime, setFilterExactTime] = React.useState<string>("")
  const fileInputRef = React.useRef<HTMLInputElement>(null)
  const [pageSize, setPageSize] = React.useState<number>(5)
  const [page, setPage] = React.useState<number>(1)

  const todosRef = React.useRef(todos)
  React.useEffect(() => {
    todosRef.current = todos
  }, [todos])
  React.useEffect(() => {
    return () => {
      for (const t of todosRef.current) revokeTodoAttachments(t)
    }
  }, [])

  const form = useForm<TodoFormValues>({
    resolver: zodResolver(todoSchema),
    defaultValues: { title: "", dueAt: "" },
    mode: "onSubmit",
  })

  const summary = React.useMemo(() => {
    const now = new Date()
    const todayKey = localDateKey(now)
    const tomorrow = addDays(now, 1)
    const tomorrowKey = localDateKey(tomorrow)

    const todays = todos.filter((t) => t.dueAt.startsWith(todayKey))
    const todayCompleted = todays.filter((t) => t.completed).length
    const todayPending = todays.length - todayCompleted

    const labels = [
      "00:00–04:00",
      "04:00–08:00",
      "08:00–12:00",
      "12:00–16:00",
      "16:00–20:00",
      "20:00–24:00",
    ]

    // Tomorrow: same 4-hour windows breakdown
    const tomorrowTasks = todos.filter((t) => t.dueAt.startsWith(tomorrowKey))
    const tomorrowBuckets = Array.from({ length: 6 }, () => 0) as number[]
    for (const t of tomorrowTasks) {
      const ms = parseLocalDateTime(t.dueAt)
      const hour = new Date(ms).getHours()
      const idx = Math.floor(hour / 4)
      tomorrowBuckets[idx] = (tomorrowBuckets[idx] ?? 0) + 1
    }

    // Until next week = next 7 days starting tomorrow (local), grouped into 4-hour windows.
    const rangeStart = startOfDay(tomorrow).getTime()
    const rangeEnd = addDays(startOfDay(tomorrow), 7).getTime()
    const buckets = Array.from({ length: 6 }, () => 0) as number[]

    const upcoming = todos.filter((t) => {
      const ms = parseLocalDateTime(t.dueAt)
      return ms >= rangeStart && ms < rangeEnd
    })

    for (const t of upcoming) {
      const ms = parseLocalDateTime(t.dueAt)
      const hour = new Date(ms).getHours()
      const idx = Math.floor(hour / 4)
      buckets[idx] = (buckets[idx] ?? 0) + 1
    }

    return {
      todayCompleted,
      todayPending,
      tomorrowTotal: tomorrowTasks.length,
      tomorrowBuckets: labels.map((label, i) => ({ label, count: tomorrowBuckets[i] ?? 0 })),
      upcomingTotal: upcoming.length,
      upcomingBuckets: labels.map((label, i) => ({ label, count: buckets[i] ?? 0 })),
    }
  }, [todos])

  const filteredTodos = React.useMemo(() => {
    const withMs = todos.map((t) => ({ ...t, _dueMs: parseLocalDateTime(t.dueAt) }))
    if (filterMode === "exact") {
      // If only date is selected -> show tasks for that date.
      // If time is selected too -> match exact date+time.
      // If only time is selected -> match time-of-day across all dates.
      if (!filterExactDate && !filterExactTime) return withMs

      if (filterExactDate && !filterExactTime) {
        return withMs.filter((t) => getDatePart(t.dueAt) === filterExactDate)
      }

      if (filterExactDate && filterExactTime) {
        const exactMs = parseLocalDateTime(`${filterExactDate}T${filterExactTime}`)
        return withMs.filter((t) => t._dueMs === exactMs)
      }

      // time only
      return withMs.filter((t) => getTimePart(t.dueAt) === filterExactTime)
    }
    // between
    const hasAnyDate = Boolean(filterFromDate || filterToDate)
    const hasAnyTime = Boolean(filterFromTime || filterToTime)

    // Date range (optional)
    const fromDateMs = filterFromDate
      ? startOfDay(parseLocalDateOnly(filterFromDate)).getTime()
      : Number.NEGATIVE_INFINITY
    const toDateMs = filterToDate
      ? endOfDay(parseLocalDateOnly(filterToDate)).getTime()
      : Number.POSITIVE_INFINITY

    // Time-of-day range (optional)
    const fromTimeMin = filterFromTime ? parseLocalTimeToMinutes(filterFromTime) : 0
    const toTimeMin = filterToTime ? parseLocalTimeToMinutes(filterToTime) : 24 * 60 - 1

    return withMs.filter((t) => {
      const ms = t._dueMs
      if (hasAnyDate && (ms < fromDateMs || ms > toDateMs)) return false

      if (hasAnyTime) {
        const time = getTimePart(t.dueAt)
        if (!time) return false
        const mins = parseLocalTimeToMinutes(time)
        // Simple (non-wrapping) range. If you want wrap-around (e.g. 22:00–02:00), tell me.
        if (mins < fromTimeMin || mins > toTimeMin) return false
      }

      // If neither date nor time selected, pass through (handled above anyway)
      return true
    })
  }, [
    todos,
    filterExactDate,
    filterExactTime,
    filterFromDate,
    filterFromTime,
    filterMode,
    filterToDate,
    filterToTime,
  ])

  const sortedFilteredTodos = React.useMemo(
    () =>
      filteredTodos
        .slice()
        .sort((a, b) => parseLocalDateTime(a.dueAt) - parseLocalDateTime(b.dueAt)),
    [filteredTodos]
  )

  // Clamp page when filters/pageSize change.
  React.useEffect(() => {
    const totalPages = Math.max(1, Math.ceil(sortedFilteredTodos.length / pageSize))
    setPage((p) => Math.min(Math.max(1, p), totalPages))
  }, [pageSize, sortedFilteredTodos.length])

  const totalItems = sortedFilteredTodos.length
  const totalPages = Math.max(1, Math.ceil(totalItems / pageSize))
  const showPagination = totalPages > 1

  const pageItems = React.useMemo(() => {
    const start = (page - 1) * pageSize
    return sortedFilteredTodos.slice(start, start + pageSize)
  }, [page, pageSize, sortedFilteredTodos])

  const groupedTodos = React.useMemo(() => {
    const groups: Array<{ date: string; items: typeof pageItems }> = []
    for (const t of pageItems) {
      const date = getDatePart(t.dueAt)
      const last = groups[groups.length - 1]
      if (!last || last.date !== date) groups.push({ date, items: [t] })
      else last.items.push(t)
    }
    return groups
  }, [pageItems])

  const completedCount = filteredTodos.filter((t) => t.completed).length

  function addTodo(values: TodoFormValues) {
    const conflicts = todos.filter((t) => t.dueAt === values.dueAt)
    if (conflicts.length > 0) {
      setConflictDueAt(values.dueAt)
      if (clearConflictTimerRef.current) window.clearTimeout(clearConflictTimerRef.current)
      clearConflictTimerRef.current = window.setTimeout(() => {
        setConflictDueAt(null)
      }, 8000)

      // Make sure the user can see the conflicting tasks even if they were filtered out.
      const [d, time] = values.dueAt.split("T")
      setFilterMode("exact")
      setFilterExactDate(d ?? "")
      setFilterExactTime(time ?? "")
      setPage(1)

      toast.error("Time conflict", {
        description: `You already have ${conflicts.length} task(s) scheduled at ${formatLocalDateTime(
          values.dueAt
        )}.`,
      })
    }

    setTodos((prev) => [
      {
        id: crypto.randomUUID(),
        title: values.title.trim(),
        completed: false,
        dueAt: values.dueAt,
        attachments: [],
      },
      ...prev,
    ])
    form.reset()
  }

  function toggleTodo(id: string, completed: boolean) {
    setTodos((prev) => prev.map((t) => (t.id === id ? { ...t, completed } : t)))
  }

  function requestAttachmentsForTodo(todoId: string) {
    setAttachTargetTodoId(todoId)
    // Let state update before opening picker (some browsers are picky).
    queueMicrotask(() => fileInputRef.current?.click())
  }

  function handleFilesPicked(e: React.ChangeEvent<HTMLInputElement>) {
    const files = Array.from(e.target.files ?? [])
    const targetId = attachTargetTodoId

    // reset input so picking the same file again triggers onChange
    e.target.value = ""
    setAttachTargetTodoId(null)

    if (!targetId || files.length === 0) return

    const attachments = files.map(makeAttachment)

    setTodos((prev) =>
      prev.map((t) =>
        t.id === targetId
          ? { ...t, attachments: [...t.attachments, ...attachments] }
          : t
      )
    )
  }

  function deleteTodo(id: string) {
    setTodos((prev) => {
      const victim = prev.find((t) => t.id === id)
      if (victim) revokeTodoAttachments(victim)
      return prev.filter((t) => t.id !== id)
    })
  }

  function clearCompleted() {
    setTodos((prev) => {
      for (const t of prev) {
        if (t.completed) revokeTodoAttachments(t)
      }
      return prev.filter((t) => !t.completed)
    })
  }

  return (
    <Card>
      <CardHeader className="flex flex-row items-center justify-between gap-4">
        <div className="space-y-1">
          <CardTitle className="text-2xl">To‑Do</CardTitle>
          <p className="text-muted-foreground text-sm">
            {completedCount}/{filteredTodos.length} completed
          </p>
        </div>
        <ModeToggle />
      </CardHeader>

      <CardContent className="space-y-6">
        <input
          ref={fileInputRef}
          type="file"
          multiple
          className="hidden"
          accept={[
            "image/*",
            "audio/*",
            "video/*",
            ".pdf",
            ".doc",
            ".docx",
            ".xls",
            ".xlsx",
            ".csv",
            ".txt",
            ".md",
            ".rtf",
          ].join(",")}
          onChange={handleFilesPicked}
        />

        <div className="grid gap-3 sm:grid-cols-3">
          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Today’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">
              {summary.todayCompleted} completed
            </p>
            <p className="text-muted-foreground text-sm">{summary.todayPending} pending</p>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tomorrow’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">{summary.tomorrowTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.tomorrowBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tasks Until Next Week</p>
            <p className="mt-2 text-2xl font-semibold">{summary.upcomingTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.upcomingBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>
        </div>

        <Form {...form}>
          <form
            onSubmit={form.handleSubmit(addTodo)}
            className="space-y-2"
            noValidate
          >
            <div className="flex flex-col gap-2 sm:flex-row">
              <FormField
                control={form.control}
                name="title"
                render={({ field }) => (
                  <FormItem className="flex-1">
                    <FormControl>
                      <Input
                        placeholder="Add a task…"
                        autoComplete="off"
                        {...field}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="dueAt"
                render={({ field }) => (
                  <FormItem className="sm:w-64">
                    <FormControl>
                      <Input type="datetime-local" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <Button type="submit">Add</Button>
            </div>
          </form>
        </Form>

        <Separator />

        <div className="space-y-3">
          <div className="flex flex-wrap items-center justify-between gap-2">
            <p className="text-sm font-medium">Filter by date & time</p>
            <div className="flex items-center gap-2">
              <Button
                type="button"
                size="sm"
                variant={filterMode === "between" ? "default" : "outline"}
                onClick={() => setFilterMode("between")}
              >
                Between
              </Button>
              <Button
                type="button"
                size="sm"
                variant={filterMode === "exact" ? "default" : "outline"}
                onClick={() => setFilterMode("exact")}
              >
                Exact
              </Button>
              <Button
                type="button"
                size="sm"
                variant="ghost"
                onClick={() => {
                  setFilterFromDate("")
                  setFilterFromTime("")
                  setFilterToDate("")
                  setFilterToTime("")
                  setFilterExactDate("")
                  setFilterExactTime("")
                }}
              >
                Clear
              </Button>
            </div>
          </div>

          {filterMode === "between" ? (
            <div className="grid gap-2 sm:grid-cols-2">
              <div className="grid gap-2 sm:grid-cols-2">
                <Input
                  type="date"
                  value={filterFromDate}
                  onChange={(e) => setFilterFromDate(e.target.value)}
                />
                <Input
                  type="time"
                  value={filterFromTime}
                  onChange={(e) => setFilterFromTime(e.target.value)}
                />
              </div>
              <div className="grid gap-2 sm:grid-cols-2">
                <Input
                  type="date"
                  value={filterToDate}
                  onChange={(e) => setFilterToDate(e.target.value)}
                />
                <Input
                  type="time"
                  value={filterToTime}
                  onChange={(e) => setFilterToTime(e.target.value)}
                />
              </div>
            </div>
          ) : (
            <div className="grid gap-2 sm:grid-cols-2">
              <Input
                type="date"
                value={filterExactDate}
                onChange={(e) => setFilterExactDate(e.target.value)}
              />
              <Input
                type="time"
                value={filterExactTime}
                onChange={(e) => setFilterExactTime(e.target.value)}
              />
            </div>
          )}
        </div>

        <Separator />

        <div className="space-y-2">
          {groupedTodos.length === 0 ? (
            <p className="text-muted-foreground text-sm">No tasks yet.</p>
          ) : (
            groupedTodos.map((group) => (
              <div key={group.date} className="space-y-2">
                <div className="flex items-center gap-3 pt-2">
                  <Separator className="flex-1" />
                  <span className="text-muted-foreground whitespace-nowrap text-xs font-medium">
                    {new Intl.DateTimeFormat(undefined, {
                      weekday: "short",
                      year: "numeric",
                      month: "short",
                      day: "2-digit",
                    }).format(parseLocalDateOnly(group.date))}
                  </span>
                  <Separator className="flex-1" />
                </div>

                {group.items.map((todo) => (
                  <div key={todo.id} className="rounded-lg border px-3 py-2">
                    <div className="flex items-start justify-between gap-3">
                      <label className="flex cursor-pointer items-start gap-3">
                        <Checkbox
                          checked={todo.completed}
                          onCheckedChange={(v) => {
                            const next = Boolean(v)
                            toggleTodo(todo.id, next)
                            if (next && !todo.completed) {
                              requestAttachmentsForTodo(todo.id)
                            }
                          }}
                          aria-label={`Mark "${todo.title}" as ${
                            todo.completed ? "not completed" : "completed"
                          }`}
                          className="mt-0.5"
                        />
                        <span
                          className={cn(
                            "leading-6",
                            todo.completed && "text-muted-foreground line-through"
                          )}
                        >
                          <span className="block">{todo.title}</span>
                          <span className="text-muted-foreground block text-xs">
                            Due: {formatLocalDateTime(todo.dueAt)}
                          </span>
                        </span>
                      </label>

                      <div className="flex items-center gap-1">
                        {todo.completed && (
                          <Button
                            type="button"
                            variant="outline"
                            size="sm"
                            onClick={() => requestAttachmentsForTodo(todo.id)}
                          >
                            Add files
                          </Button>
                        )}
                        <Button
                          type="button"
                          variant="ghost"
                          size="icon"
                          aria-label={`Delete "${todo.title}"`}
                          onClick={() => deleteTodo(todo.id)}
                        >
                          <Trash2 className="h-4 w-4" />
                        </Button>
                      </div>
                    </div>

                    {todo.completed && todo.attachments.length > 0 && (
                      <div className="mt-3 space-y-2">
                        <p className="text-muted-foreground text-xs">Attachments</p>
                        <ul className="space-y-1">
                          {todo.attachments.map((a) => (
                            <li
                              key={a.id}
                              className="flex items-center justify-between gap-3 rounded-md bg-muted/30 px-2 py-1"
                            >
                              <div className="flex min-w-0 items-center gap-2">
                                <AttachmentIcon kind={a.kind} />
                                <span className="truncate text-sm">{a.name}</span>
                              </div>
                              <a
                                href={a.url}
                                download={a.name}
                                className="inline-flex items-center gap-1 text-sm font-medium underline underline-offset-4"
                              >
                                <Download className="h-4 w-4" />
                                Download
                              </a>
                            </li>
                          ))}
                        </ul>
                      </div>
                    )}
                  </div>
                ))}
              </div>
            ))
          )}
        </div>

        {groupedTodos.length > 0 && (
          <div className="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
            <div className="flex items-center gap-2">
              <span className="text-muted-foreground text-sm">Items per page</span>
              <Select
                value={String(pageSize)}
                onValueChange={(v) => {
                  const next = Number(v)
                  setPageSize(next)
                  setPage(1)
                }}
              >
                <SelectTrigger className="w-[110px]">
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="5">5</SelectItem>
                  <SelectItem value="10">10</SelectItem>
                  <SelectItem value="15">15</SelectItem>
                  <SelectItem value="20">20</SelectItem>
                </SelectContent>
              </Select>
            </div>

            {showPagination && (
              <div className="flex items-center justify-between gap-3 sm:justify-end">
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={() => setPage((p) => Math.max(1, p - 1))}
                  disabled={page <= 1}
                >
                  Prev
                </Button>
                <span className="text-muted-foreground text-sm">
                  Page {page} of {totalPages}
                </span>
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={() => setPage((p) => Math.min(totalPages, p + 1))}
                  disabled={page >= totalPages}
                >
                  Next
                </Button>
              </div>
            )}
          </div>
        )}

        <div className="flex items-center justify-between gap-2">
          <Button
            type="button"
            variant="secondary"
            onClick={clearCompleted}
            disabled={completedCount === 0}
          >
            Clear completed
          </Button>
          <span className="text-muted-foreground text-sm">
            Mock data only (no backend)
          </span>
        </div>
      </CardContent>
    </Card>
  )
}

```

```typescriptreact
"use client"

import { zodResolver } from "@hookform/resolvers/zod"
import {
  Download,
  File,
  FileSpreadsheet,
  FileText,
  Image as ImageIcon,
  Music,
  Trash2,
  Video,
} from "lucide-react"
import * as React from "react"
import { useForm } from "react-hook-form"
import { toast } from "sonner"
import { z } from "zod"

import { ModeToggle } from "@/components/mode-toggle"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Checkbox } from "@/components/ui/checkbox"
import { Form, FormControl, FormField, FormItem, FormMessage } from "@/components/ui/form"
import { Input } from "@/components/ui/input"
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select"
import { Separator } from "@/components/ui/separator"
import { cn } from "@/lib/utils"

type AttachmentKind =
  | "image"
  | "audio"
  | "video"
  | "pdf"
  | "spreadsheet"
  | "document"
  | "text"
  | "file"

type Attachment = {
  id: string
  name: string
  type: string
  size: number
  url: string
  kind: AttachmentKind
}

type Todo = {
  id: string
  title: string
  completed: boolean
  // Stored as `datetime-local` string (YYYY-MM-DDTHH:mm) in local time.
  dueAt: string
  attachments: Attachment[]
}

const todoSchema = z.object({
  title: z
    .string()
    .trim()
    .min(1, "Title is required.")
    .max(80, "Keep it under 80 characters."),
  dueAt: z
    .string()
    .min(1, "Due date & time is required.")
    .regex(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}$/, "Invalid date/time."),
})

type TodoFormValues = z.infer<typeof todoSchema>

const initialTodos: Todo[] = [
  {
    id: "1",
    title: "Create a Next.js app",
    completed: true,
    dueAt: "2026-01-16T09:00",
    attachments: [],
  },
  {
    id: "2",
    title: "Add shadcn/ui + dark theme",
    completed: true,
    dueAt: "2026-01-16T10:30",
    attachments: [],
  },
  {
    id: "3",
    title: "Build a mock-data to-do list",
    completed: false,
    dueAt: "2026-01-16T15:00",
    attachments: [],
  },
  {
    id: "4",
    title: "Yesterday: review requirements",
    completed: true,
    dueAt: "2026-01-15T11:15",
    attachments: [],
  },
  {
    id: "5",
    title: "Yesterday: sketch UI layout",
    completed: true,
    dueAt: "2026-01-15T17:45",
    attachments: [],
  },
  {
    id: "6",
    title: "Today: add attachments support",
    completed: false,
    dueAt: "2026-01-16T18:20",
    attachments: [],
  },
  {
    id: "7",
    title: "Tomorrow: QA the filters",
    completed: false,
    dueAt: "2026-01-17T08:05",
    attachments: [],
  },
  {
    id: "8",
    title: "Tomorrow: polish summary cards",
    completed: false,
    dueAt: "2026-01-17T13:30",
    attachments: [],
  },
  {
    id: "9",
    title: "Tomorrow: write small UX notes",
    completed: false,
    dueAt: "2026-01-17T20:10",
    attachments: [],
  },
  {
    id: "10",
    title: "This weekend: add more mock tasks",
    completed: false,
    dueAt: "2026-01-18T10:00",
    attachments: [],
  },
  {
    id: "11",
    title: "This weekend: check time-only filter",
    completed: false,
    dueAt: "2026-01-18T22:15",
    attachments: [],
  },
  {
    id: "12",
    title: "Next week: sync with team",
    completed: false,
    dueAt: "2026-01-19T09:30",
    attachments: [],
  },
  {
    id: "13",
    title: "Next week: test date-only filter",
    completed: false,
    dueAt: "2026-01-20T14:05",
    attachments: [],
  },
  {
    id: "14",
    title: "Next week: test exact date+time filter",
    completed: false,
    dueAt: "2026-01-21T12:00",
    attachments: [],
  },
  {
    id: "15",
    title: "Next week: attach docs to completed tasks",
    completed: false,
    dueAt: "2026-01-22T16:40",
    attachments: [],
  },
  {
    id: "16",
    title: "Next week: final review",
    completed: false,
    dueAt: "2026-01-23T11:00",
    attachments: [],
  },
]

function parseLocalDateTime(value: string): number {
  // value: "YYYY-MM-DDTHH:mm"
  const [datePart, timePart] = value.split("T")
  const [y, m, d] = datePart.split("-").map(Number)
  const [hh, mm] = timePart.split(":").map(Number)
  return new Date(y, m - 1, d, hh, mm, 0, 0).getTime()
}

function pad2(n: number) {
  return String(n).padStart(2, "0")
}

function localDateKey(d: Date) {
  return `${d.getFullYear()}-${pad2(d.getMonth() + 1)}-${pad2(d.getDate())}`
}

function addDays(date: Date, days: number) {
  const d = new Date(date)
  d.setDate(d.getDate() + days)
  return d
}

function startOfDay(date: Date) {
  return new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0, 0)
}

function endOfDay(date: Date) {
  return new Date(
    date.getFullYear(),
    date.getMonth(),
    date.getDate(),
    23,
    59,
    59,
    999
  )
}

function getDatePart(dueAt: string) {
  return dueAt.split("T")[0] ?? ""
}

function getTimePart(dueAt: string) {
  return dueAt.split("T")[1] ?? ""
}

function parseLocalDateOnly(value: string): Date {
  // value: "YYYY-MM-DD"
  const [y, m, d] = value.split("-").map(Number)
  return new Date(y, m - 1, d, 0, 0, 0, 0)
}

function parseLocalTimeToMinutes(value: string): number {
  // value: "HH:mm"
  const [hh, mm] = value.split(":").map(Number)
  return hh * 60 + mm
}

function formatLocalDateTime(value: string): string {
  const ms = parseLocalDateTime(value)
  if (!Number.isFinite(ms)) return value
  return new Intl.DateTimeFormat(undefined, {
    year: "numeric",
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  }).format(new Date(ms))
}

function getAttachmentKind(file: File): AttachmentKind {
  const type = (file.type || "").toLowerCase()
  const name = file.name.toLowerCase()
  const ext = name.includes(".") ? name.split(".").pop() ?? "" : ""

  if (type.startsWith("image/")) return "image"
  if (type.startsWith("audio/")) return "audio"
  if (type.startsWith("video/")) return "video"

  if (ext === "pdf") return "pdf"
  if (["xls", "xlsx", "csv"].includes(ext)) return "spreadsheet"
  if (["doc", "docx"].includes(ext)) return "document"
  if (["txt", "md", "rtf"].includes(ext)) return "text"

  return "file"
}

function makeAttachment(file: File): Attachment {
  return {
    id: crypto.randomUUID(),
    name: file.name,
    type: file.type,
    size: file.size,
    url: URL.createObjectURL(file),
    kind: getAttachmentKind(file),
  }
}

function revokeTodoAttachments(todo: Todo) {
  for (const a of todo.attachments) URL.revokeObjectURL(a.url)
}

function AttachmentIcon({ kind }: { kind: AttachmentKind }) {
  const className = "h-4 w-4 text-muted-foreground"

  switch (kind) {
    case "image":
      return <ImageIcon className={className} />
    case "audio":
      return <Music className={className} />
    case "video":
      return <Video className={className} />
    case "spreadsheet":
      return <FileSpreadsheet className={className} />
    case "pdf":
    case "document":
    case "text":
      return <FileText className={className} />
    default:
      return <File className={className} />
  }
}

export default function Home() {
  return (
    <div className="mx-auto flex min-h-screen max-w-2xl flex-col gap-6 px-4 py-10">
      <TodoApp />
    </div>
  )
}

function TodoApp() {
  const [todos, setTodos] = React.useState<Todo[]>(initialTodos)
  const [attachTargetTodoId, setAttachTargetTodoId] = React.useState<string | null>(
    null
  )
  const [conflictDueAt, setConflictDueAt] = React.useState<string | null>(null)
  const clearConflictTimerRef = React.useRef<number | null>(null)
  const [filterMode, setFilterMode] = React.useState<"between" | "exact">("between")
  const [filterFromDate, setFilterFromDate] = React.useState<string>("")
  const [filterFromTime, setFilterFromTime] = React.useState<string>("")
  const [filterToDate, setFilterToDate] = React.useState<string>("")
  const [filterToTime, setFilterToTime] = React.useState<string>("")
  const [filterExactDate, setFilterExactDate] = React.useState<string>("")
  const [filterExactTime, setFilterExactTime] = React.useState<string>("")
  const fileInputRef = React.useRef<HTMLInputElement>(null)
  const [pageSize, setPageSize] = React.useState<number>(5)
  const [page, setPage] = React.useState<number>(1)

  const todosRef = React.useRef(todos)
  React.useEffect(() => {
    todosRef.current = todos
  }, [todos])
  React.useEffect(() => {
    return () => {
      for (const t of todosRef.current) revokeTodoAttachments(t)
    }
  }, [])

  const form = useForm<TodoFormValues>({
    resolver: zodResolver(todoSchema),
    defaultValues: { title: "", dueAt: "" },
    mode: "onSubmit",
  })

  const summary = React.useMemo(() => {
    const now = new Date()
    const todayKey = localDateKey(now)
    const tomorrow = addDays(now, 1)
    const tomorrowKey = localDateKey(tomorrow)

    const todays = todos.filter((t) => t.dueAt.startsWith(todayKey))
    const todayCompleted = todays.filter((t) => t.completed).length
    const todayPending = todays.length - todayCompleted

    const labels = [
      "00:00–04:00",
      "04:00–08:00",
      "08:00–12:00",
      "12:00–16:00",
      "16:00–20:00",
      "20:00–24:00",
    ]

    // Tomorrow: same 4-hour windows breakdown
    const tomorrowTasks = todos.filter((t) => t.dueAt.startsWith(tomorrowKey))
    const tomorrowBuckets = Array.from({ length: 6 }, () => 0) as number[]
    for (const t of tomorrowTasks) {
      const ms = parseLocalDateTime(t.dueAt)
      const hour = new Date(ms).getHours()
      const idx = Math.floor(hour / 4)
      tomorrowBuckets[idx] = (tomorrowBuckets[idx] ?? 0) + 1
    }

    // Until next week = next 7 days starting tomorrow (local), grouped into 4-hour windows.
    const rangeStart = startOfDay(tomorrow).getTime()
    const rangeEnd = addDays(startOfDay(tomorrow), 7).getTime()
    const buckets = Array.from({ length: 6 }, () => 0) as number[]

    const upcoming = todos.filter((t) => {
      const ms = parseLocalDateTime(t.dueAt)
      return ms >= rangeStart && ms < rangeEnd
    })

    for (const t of upcoming) {
      const ms = parseLocalDateTime(t.dueAt)
      const hour = new Date(ms).getHours()
      const idx = Math.floor(hour / 4)
      buckets[idx] = (buckets[idx] ?? 0) + 1
    }

    return {
      todayCompleted,
      todayPending,
      tomorrowTotal: tomorrowTasks.length,
      tomorrowBuckets: labels.map((label, i) => ({ label, count: tomorrowBuckets[i] ?? 0 })),
      upcomingTotal: upcoming.length,
      upcomingBuckets: labels.map((label, i) => ({ label, count: buckets[i] ?? 0 })),
    }
  }, [todos])

  const filteredTodos = React.useMemo(() => {
    const withMs = todos.map((t) => ({ ...t, _dueMs: parseLocalDateTime(t.dueAt) }))
    if (filterMode === "exact") {
      // If only date is selected -> show tasks for that date.
      // If time is selected too -> match exact date+time.
      // If only time is selected -> match time-of-day across all dates.
      if (!filterExactDate && !filterExactTime) return withMs

      if (filterExactDate && !filterExactTime) {
        return withMs.filter((t) => getDatePart(t.dueAt) === filterExactDate)
      }

      if (filterExactDate && filterExactTime) {
        const exactMs = parseLocalDateTime(`${filterExactDate}T${filterExactTime}`)
        return withMs.filter((t) => t._dueMs === exactMs)
      }

      // time only
      return withMs.filter((t) => getTimePart(t.dueAt) === filterExactTime)
    }
    // between
    const hasAnyDate = Boolean(filterFromDate || filterToDate)
    const hasAnyTime = Boolean(filterFromTime || filterToTime)

    // Date range (optional)
    const fromDateMs = filterFromDate
      ? startOfDay(parseLocalDateOnly(filterFromDate)).getTime()
      : Number.NEGATIVE_INFINITY
    const toDateMs = filterToDate
      ? endOfDay(parseLocalDateOnly(filterToDate)).getTime()
      : Number.POSITIVE_INFINITY

    // Time-of-day range (optional)
    const fromTimeMin = filterFromTime ? parseLocalTimeToMinutes(filterFromTime) : 0
    const toTimeMin = filterToTime ? parseLocalTimeToMinutes(filterToTime) : 24 * 60 - 1

    return withMs.filter((t) => {
      const ms = t._dueMs
      if (hasAnyDate && (ms < fromDateMs || ms > toDateMs)) return false

      if (hasAnyTime) {
        const time = getTimePart(t.dueAt)
        if (!time) return false
        const mins = parseLocalTimeToMinutes(time)
        // Simple (non-wrapping) range. If you want wrap-around (e.g. 22:00–02:00), tell me.
        if (mins < fromTimeMin || mins > toTimeMin) return false
      }

      // If neither date nor time selected, pass through (handled above anyway)
      return true
    })
  }, [
    todos,
    filterExactDate,
    filterExactTime,
    filterFromDate,
    filterFromTime,
    filterMode,
    filterToDate,
    filterToTime,
  ])

  const sortedFilteredTodos = React.useMemo(
    () =>
      filteredTodos
        .slice()
        .sort((a, b) => parseLocalDateTime(a.dueAt) - parseLocalDateTime(b.dueAt)),
    [filteredTodos]
  )

  // Clamp page when filters/pageSize change.
  React.useEffect(() => {
    const totalPages = Math.max(1, Math.ceil(sortedFilteredTodos.length / pageSize))
    setPage((p) => Math.min(Math.max(1, p), totalPages))
  }, [pageSize, sortedFilteredTodos.length])

  const totalItems = sortedFilteredTodos.length
  const totalPages = Math.max(1, Math.ceil(totalItems / pageSize))
  const showPagination = totalPages > 1

  const pageItems = React.useMemo(() => {
    const start = (page - 1) * pageSize
    return sortedFilteredTodos.slice(start, start + pageSize)
  }, [page, pageSize, sortedFilteredTodos])

  const groupedTodos = React.useMemo(() => {
    const groups: Array<{ date: string; items: typeof pageItems }> = []
    for (const t of pageItems) {
      const date = getDatePart(t.dueAt)
      const last = groups[groups.length - 1]
      if (!last || last.date !== date) groups.push({ date, items: [t] })
      else last.items.push(t)
    }
    return groups
  }, [pageItems])

  const completedCount = filteredTodos.filter((t) => t.completed).length

  function addTodo(values: TodoFormValues) {
    const conflicts = todos.filter((t) => t.dueAt === values.dueAt)
    if (conflicts.length > 0) {
      setConflictDueAt(values.dueAt)
      if (clearConflictTimerRef.current) window.clearTimeout(clearConflictTimerRef.current)
      clearConflictTimerRef.current = window.setTimeout(() => {
        setConflictDueAt(null)
      }, 8000)

      // Make sure the user can see the conflicting tasks even if they were filtered out.
      const [d, time] = values.dueAt.split("T")
      setFilterMode("exact")
      setFilterExactDate(d ?? "")
      setFilterExactTime(time ?? "")
      setPage(1)

      toast.error("Time conflict", {
        description: `You already have ${conflicts.length} task(s) scheduled at ${formatLocalDateTime(
          values.dueAt
        )}.`,
      })
    }

    setTodos((prev) => [
      {
        id: crypto.randomUUID(),
        title: values.title.trim(),
        completed: false,
        dueAt: values.dueAt,
        attachments: [],
      },
      ...prev,
    ])
    form.reset()
  }

  function toggleTodo(id: string, completed: boolean) {
    setTodos((prev) => prev.map((t) => (t.id === id ? { ...t, completed } : t)))
  }

  function requestAttachmentsForTodo(todoId: string) {
    setAttachTargetTodoId(todoId)
    // Let state update before opening picker (some browsers are picky).
    queueMicrotask(() => fileInputRef.current?.click())
  }

  function handleFilesPicked(e: React.ChangeEvent<HTMLInputElement>) {
    const files = Array.from(e.target.files ?? [])
    const targetId = attachTargetTodoId

    // reset input so picking the same file again triggers onChange
    e.target.value = ""
    setAttachTargetTodoId(null)

    if (!targetId || files.length === 0) return

    const attachments = files.map(makeAttachment)

    setTodos((prev) =>
      prev.map((t) =>
        t.id === targetId
          ? { ...t, attachments: [...t.attachments, ...attachments] }
          : t
      )
    )
  }

  function deleteTodo(id: string) {
    setTodos((prev) => {
      const victim = prev.find((t) => t.id === id)
      if (victim) revokeTodoAttachments(victim)
      return prev.filter((t) => t.id !== id)
    })
  }

  function clearCompleted() {
    setTodos((prev) => {
      for (const t of prev) {
        if (t.completed) revokeTodoAttachments(t)
      }
      return prev.filter((t) => !t.completed)
    })
  }

  return (
    <Card>
      <CardHeader className="flex flex-row items-center justify-between gap-4">
        <div className="space-y-1">
          <CardTitle className="text-2xl">To‑Do</CardTitle>
          <p className="text-muted-foreground text-sm">
            {completedCount}/{filteredTodos.length} completed
          </p>
        </div>
        <ModeToggle />
      </CardHeader>

      <CardContent className="space-y-6">
        <input
          ref={fileInputRef}
          type="file"
          multiple
          className="hidden"
          accept={[
            "image/*",
            "audio/*",
            "video/*",
            ".pdf",
            ".doc",
            ".docx",
            ".xls",
            ".xlsx",
            ".csv",
            ".txt",
            ".md",
            ".rtf",
          ].join(",")}
          onChange={handleFilesPicked}
        />

        <div className="grid gap-3 sm:grid-cols-3">
          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Today’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">
              {summary.todayCompleted} completed
            </p>
            <p className="text-muted-foreground text-sm">{summary.todayPending} pending</p>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tomorrow’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">{summary.tomorrowTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.tomorrowBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tasks Until Next Week</p>
            <p className="mt-2 text-2xl font-semibold">{summary.upcomingTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.upcomingBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>
        </div>

        <Form {...form}>
          <form
            onSubmit={form.handleSubmit(addTodo)}
            className="space-y-2"
            noValidate
          >
            <div className="flex flex-col gap-2 sm:flex-row">
              <FormField
                control={form.control}
                name="title"
                render={({ field }) => (
                  <FormItem className="flex-1">
                    <FormControl>
                      <Input
                        placeholder="Add a task…"
                        autoComplete="off"
                        {...field}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="dueAt"
                render={({ field }) => (
                  <FormItem className="sm:w-64">
                    <FormControl>
                      <Input type="datetime-local" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <Button type="submit">Add</Button>
            </div>
          </form>
        </Form>

        <Separator />

        <div className="space-y-3">
          <div className="flex flex-wrap items-center justify-between gap-2">
            <p className="text-sm font-medium">Filter by date & time</p>
            <div className="flex items-center gap-2">
              <Button
                type="button"
                size="sm"
                variant={filterMode === "between" ? "default" : "outline"}
                onClick={() => setFilterMode("between")}
              >
                Between
              </Button>
              <Button
                type="button"
                size="sm"
                variant={filterMode === "exact" ? "default" : "outline"}
                onClick={() => setFilterMode("exact")}
              >
                Exact
              </Button>
              <Button
                type="button"
                size="sm"
                variant="ghost"
                onClick={() => {
                  setFilterFromDate("")
                  setFilterFromTime("")
                  setFilterToDate("")
                  setFilterToTime("")
                  setFilterExactDate("")
                  setFilterExactTime("")
                }}
              >
                Clear
              </Button>
            </div>
          </div>

          {filterMode === "between" ? (
            <div className="grid gap-2 sm:grid-cols-2">
              <div className="grid gap-2 sm:grid-cols-2">
                <Input
                  type="date"
                  value={filterFromDate}
                  onChange={(e) => setFilterFromDate(e.target.value)}
                />
                <Input
                  type="time"
                  value={filterFromTime}
                  onChange={(e) => setFilterFromTime(e.target.value)}
                />
              </div>
              <div className="grid gap-2 sm:grid-cols-2">
                <Input
                  type="date"
                  value={filterToDate}
                  onChange={(e) => setFilterToDate(e.target.value)}
                />
                <Input
                  type="time"
                  value={filterToTime}
                  onChange={(e) => setFilterToTime(e.target.value)}
                />
              </div>
            </div>
          ) : (
            <div className="grid gap-2 sm:grid-cols-2">
              <Input
                type="date"
                value={filterExactDate}
                onChange={(e) => setFilterExactDate(e.target.value)}
              />
              <Input
                type="time"
                value={filterExactTime}
                onChange={(e) => setFilterExactTime(e.target.value)}
              />
            </div>
          )}
        </div>

        <Separator />

        <div className="space-y-2">
          {groupedTodos.length === 0 ? (
            <p className="text-muted-foreground text-sm">No tasks yet.</p>
          ) : (
            groupedTodos.map((group) => (
              <div key={group.date} className="space-y-2">
                <div className="flex items-center gap-3 pt-2">
                  <Separator className="flex-1" />
                  <span className="text-muted-foreground whitespace-nowrap text-xs font-medium">
                    {new Intl.DateTimeFormat(undefined, {
                      weekday: "short",
                      year: "numeric",
                      month: "short",
                      day: "2-digit",
                    }).format(parseLocalDateOnly(group.date))}
                  </span>
                  <Separator className="flex-1" />
                </div>

                {group.items.map((todo) => (
                  <div
                    key={todo.id}
                    className={cn(
                      "rounded-lg border px-3 py-2",
                      conflictDueAt &&
                        todo.dueAt === conflictDueAt &&
                        "border-destructive/60 bg-destructive/5 ring-1 ring-destructive/30"
                    )}
                  >
                    <div className="flex items-start justify-between gap-3">
                      <label className="flex cursor-pointer items-start gap-3">
                        <Checkbox
                          checked={todo.completed}
                          onCheckedChange={(v) => {
                            const next = Boolean(v)
                            toggleTodo(todo.id, next)
                            if (next && !todo.completed) {
                              requestAttachmentsForTodo(todo.id)
                            }
                          }}
                          aria-label={`Mark "${todo.title}" as ${
                            todo.completed ? "not completed" : "completed"
                          }`}
                          className="mt-0.5"
                        />
                        <span
                          className={cn(
                            "leading-6",
                            todo.completed && "text-muted-foreground line-through"
                          )}
                        >
                          <span className="block">{todo.title}</span>
                          <span className="text-muted-foreground block text-xs">
                            Due: {formatLocalDateTime(todo.dueAt)}
                          </span>
                        </span>
                      </label>

                      <div className="flex items-center gap-1">
                        {todo.completed && (
                          <Button
                            type="button"
                            variant="outline"
                            size="sm"
                            onClick={() => requestAttachmentsForTodo(todo.id)}
                          >
                            Add files
                          </Button>
                        )}
                        <Button
                          type="button"
                          variant="ghost"
                          size="icon"
                          aria-label={`Delete "${todo.title}"`}
                          onClick={() => deleteTodo(todo.id)}
                        >
                          <Trash2 className="h-4 w-4" />
                        </Button>
                      </div>
                    </div>

                    {todo.completed && todo.attachments.length > 0 && (
                      <div className="mt-3 space-y-2">
                        <p className="text-muted-foreground text-xs">Attachments</p>
                        <ul className="space-y-1">
                          {todo.attachments.map((a) => (
                            <li
                              key={a.id}
                              className="flex items-center justify-between gap-3 rounded-md bg-muted/30 px-2 py-1"
                            >
                              <div className="flex min-w-0 items-center gap-2">
                                <AttachmentIcon kind={a.kind} />
                                <span className="truncate text-sm">{a.name}</span>
                              </div>
                              <a
                                href={a.url}
                                download={a.name}
                                className="inline-flex items-center gap-1 text-sm font-medium underline underline-offset-4"
                              >
                                <Download className="h-4 w-4" />
                                Download
                              </a>
                            </li>
                          ))}
                        </ul>
                      </div>
                    )}
                  </div>
                ))}
              </div>
            ))
          )}
        </div>

        {groupedTodos.length > 0 && (
          <div className="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
            <div className="flex items-center gap-2">
              <span className="text-muted-foreground text-sm">Items per page</span>
              <Select
                value={String(pageSize)}
                onValueChange={(v) => {
                  const next = Number(v)
                  setPageSize(next)
                  setPage(1)
                }}
              >
                <SelectTrigger className="w-[110px]">
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="5">5</SelectItem>
                  <SelectItem value="10">10</SelectItem>
                  <SelectItem value="15">15</SelectItem>
                  <SelectItem value="20">20</SelectItem>
                </SelectContent>
              </Select>
            </div>

            {showPagination && (
              <div className="flex items-center justify-between gap-3 sm:justify-end">
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={() => setPage((p) => Math.max(1, p - 1))}
                  disabled={page <= 1}
                >
                  Prev
                </Button>
                <span className="text-muted-foreground text-sm">
                  Page {page} of {totalPages}
                </span>
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={() => setPage((p) => Math.min(totalPages, p + 1))}
                  disabled={page >= totalPages}
                >
                  Next
                </Button>
              </div>
            )}
          </div>
        )}

        <div className="flex items-center justify-between gap-2">
          <Button
            type="button"
            variant="secondary"
            onClick={clearCompleted}
            disabled={completedCount === 0}
          >
            Clear completed
          </Button>
          <span className="text-muted-foreground text-sm">
            Mock data only (no backend)
          </span>
        </div>
      </CardContent>
    </Card>
  )
}

```

### Time conflict hint added (toast + highlight)
- When you **add a task**, the app checks for existing tasks with the **same `dueAt` (same date + time)**.
- If a conflict exists:
  - Shows a **toast notification** (“Time conflict”)
  - **Highlights** all tasks with that same date+time in the list for ~8 seconds
  - Switches the filter to **Exact** and sets the **same date + time** so the conflicting tasks are visible.

### Files changed
- `src/app/layout.tsx`: added `<Toaster />`
- `src/app/page.tsx`: conflict detection + highlighting + toast
- `src/components/ui/sonner.tsx`: added by shadcn

### Run
```bash
npm run dev
```

```shellscript
npm run dev
```

---

**User**

Add a Focus Mode button that displays only tasks for the next 4 hours based on the current time.

---

**Cursor**

Got it. I’ll add a **Focus Mode** toggle button (near the theme toggle) that temporarily overrides filters to show **only tasks due in the next 4 hours from now**, updating as time passes, and keeping pagination working on that focused subset.

```typescriptreact
"use client"

import { zodResolver } from "@hookform/resolvers/zod"
import {
  Download,
  File,
  FileSpreadsheet,
  FileText,
  Image as ImageIcon,
  Music,
  Trash2,
  Video,
} from "lucide-react"
import * as React from "react"
import { useForm } from "react-hook-form"
import { toast } from "sonner"
import { z } from "zod"

import { ModeToggle } from "@/components/mode-toggle"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Checkbox } from "@/components/ui/checkbox"
import { Form, FormControl, FormField, FormItem, FormMessage } from "@/components/ui/form"
import { Input } from "@/components/ui/input"
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select"
import { Separator } from "@/components/ui/separator"
import { cn } from "@/lib/utils"

type AttachmentKind =
  | "image"
  | "audio"
  | "video"
  | "pdf"
  | "spreadsheet"
  | "document"
  | "text"
  | "file"

type Attachment = {
  id: string
  name: string
  type: string
  size: number
  url: string
  kind: AttachmentKind
}

type Todo = {
  id: string
  title: string
  completed: boolean
  // Stored as `datetime-local` string (YYYY-MM-DDTHH:mm) in local time.
  dueAt: string
  attachments: Attachment[]
}

const todoSchema = z.object({
  title: z
    .string()
    .trim()
    .min(1, "Title is required.")
    .max(80, "Keep it under 80 characters."),
  dueAt: z
    .string()
    .min(1, "Due date & time is required.")
    .regex(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}$/, "Invalid date/time."),
})

type TodoFormValues = z.infer<typeof todoSchema>

const initialTodos: Todo[] = [
  {
    id: "1",
    title: "Create a Next.js app",
    completed: true,
    dueAt: "2026-01-16T09:00",
    attachments: [],
  },
  {
    id: "2",
    title: "Add shadcn/ui + dark theme",
    completed: true,
    dueAt: "2026-01-16T10:30",
    attachments: [],
  },
  {
    id: "3",
    title: "Build a mock-data to-do list",
    completed: false,
    dueAt: "2026-01-16T15:00",
    attachments: [],
  },
  {
    id: "4",
    title: "Yesterday: review requirements",
    completed: true,
    dueAt: "2026-01-15T11:15",
    attachments: [],
  },
  {
    id: "5",
    title: "Yesterday: sketch UI layout",
    completed: true,
    dueAt: "2026-01-15T17:45",
    attachments: [],
  },
  {
    id: "6",
    title: "Today: add attachments support",
    completed: false,
    dueAt: "2026-01-16T18:20",
    attachments: [],
  },
  {
    id: "7",
    title: "Tomorrow: QA the filters",
    completed: false,
    dueAt: "2026-01-17T08:05",
    attachments: [],
  },
  {
    id: "8",
    title: "Tomorrow: polish summary cards",
    completed: false,
    dueAt: "2026-01-17T13:30",
    attachments: [],
  },
  {
    id: "9",
    title: "Tomorrow: write small UX notes",
    completed: false,
    dueAt: "2026-01-17T20:10",
    attachments: [],
  },
  {
    id: "10",
    title: "This weekend: add more mock tasks",
    completed: false,
    dueAt: "2026-01-18T10:00",
    attachments: [],
  },
  {
    id: "11",
    title: "This weekend: check time-only filter",
    completed: false,
    dueAt: "2026-01-18T22:15",
    attachments: [],
  },
  {
    id: "12",
    title: "Next week: sync with team",
    completed: false,
    dueAt: "2026-01-19T09:30",
    attachments: [],
  },
  {
    id: "13",
    title: "Next week: test date-only filter",
    completed: false,
    dueAt: "2026-01-20T14:05",
    attachments: [],
  },
  {
    id: "14",
    title: "Next week: test exact date+time filter",
    completed: false,
    dueAt: "2026-01-21T12:00",
    attachments: [],
  },
  {
    id: "15",
    title: "Next week: attach docs to completed tasks",
    completed: false,
    dueAt: "2026-01-22T16:40",
    attachments: [],
  },
  {
    id: "16",
    title: "Next week: final review",
    completed: false,
    dueAt: "2026-01-23T11:00",
    attachments: [],
  },
]

function parseLocalDateTime(value: string): number {
  // value: "YYYY-MM-DDTHH:mm"
  const [datePart, timePart] = value.split("T")
  const [y, m, d] = datePart.split("-").map(Number)
  const [hh, mm] = timePart.split(":").map(Number)
  return new Date(y, m - 1, d, hh, mm, 0, 0).getTime()
}

function pad2(n: number) {
  return String(n).padStart(2, "0")
}

function localDateKey(d: Date) {
  return `${d.getFullYear()}-${pad2(d.getMonth() + 1)}-${pad2(d.getDate())}`
}

function addDays(date: Date, days: number) {
  const d = new Date(date)
  d.setDate(d.getDate() + days)
  return d
}

function startOfDay(date: Date) {
  return new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0, 0)
}

function endOfDay(date: Date) {
  return new Date(
    date.getFullYear(),
    date.getMonth(),
    date.getDate(),
    23,
    59,
    59,
    999
  )
}

function getDatePart(dueAt: string) {
  return dueAt.split("T")[0] ?? ""
}

function getTimePart(dueAt: string) {
  return dueAt.split("T")[1] ?? ""
}

function parseLocalDateOnly(value: string): Date {
  // value: "YYYY-MM-DD"
  const [y, m, d] = value.split("-").map(Number)
  return new Date(y, m - 1, d, 0, 0, 0, 0)
}

function parseLocalTimeToMinutes(value: string): number {
  // value: "HH:mm"
  const [hh, mm] = value.split(":").map(Number)
  return hh * 60 + mm
}

function formatLocalDateTime(value: string): string {
  const ms = parseLocalDateTime(value)
  if (!Number.isFinite(ms)) return value
  return new Intl.DateTimeFormat(undefined, {
    year: "numeric",
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  }).format(new Date(ms))
}

function formatDateTimeFromMs(ms: number): string {
  return new Intl.DateTimeFormat(undefined, {
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  }).format(new Date(ms))
}

function getAttachmentKind(file: File): AttachmentKind {
  const type = (file.type || "").toLowerCase()
  const name = file.name.toLowerCase()
  const ext = name.includes(".") ? name.split(".").pop() ?? "" : ""

  if (type.startsWith("image/")) return "image"
  if (type.startsWith("audio/")) return "audio"
  if (type.startsWith("video/")) return "video"

  if (ext === "pdf") return "pdf"
  if (["xls", "xlsx", "csv"].includes(ext)) return "spreadsheet"
  if (["doc", "docx"].includes(ext)) return "document"
  if (["txt", "md", "rtf"].includes(ext)) return "text"

  return "file"
}

function makeAttachment(file: File): Attachment {
  return {
    id: crypto.randomUUID(),
    name: file.name,
    type: file.type,
    size: file.size,
    url: URL.createObjectURL(file),
    kind: getAttachmentKind(file),
  }
}

function revokeTodoAttachments(todo: Todo) {
  for (const a of todo.attachments) URL.revokeObjectURL(a.url)
}

function AttachmentIcon({ kind }: { kind: AttachmentKind }) {
  const className = "h-4 w-4 text-muted-foreground"

  switch (kind) {
    case "image":
      return <ImageIcon className={className} />
    case "audio":
      return <Music className={className} />
    case "video":
      return <Video className={className} />
    case "spreadsheet":
      return <FileSpreadsheet className={className} />
    case "pdf":
    case "document":
    case "text":
      return <FileText className={className} />
    default:
      return <File className={className} />
  }
}

export default function Home() {
  return (
    <div className="mx-auto flex min-h-screen max-w-2xl flex-col gap-6 px-4 py-10">
      <TodoApp />
    </div>
  )
}

function TodoApp() {
  const [todos, setTodos] = React.useState<Todo[]>(initialTodos)
  const [attachTargetTodoId, setAttachTargetTodoId] = React.useState<string | null>(
    null
  )
  const [conflictDueAt, setConflictDueAt] = React.useState<string | null>(null)
  const clearConflictTimerRef = React.useRef<number | null>(null)
  const [focusMode, setFocusMode] = React.useState(false)
  const [nowMs, setNowMs] = React.useState(() => Date.now())
  const [filterMode, setFilterMode] = React.useState<"between" | "exact">("between")
  const [filterFromDate, setFilterFromDate] = React.useState<string>("")
  const [filterFromTime, setFilterFromTime] = React.useState<string>("")
  const [filterToDate, setFilterToDate] = React.useState<string>("")
  const [filterToTime, setFilterToTime] = React.useState<string>("")
  const [filterExactDate, setFilterExactDate] = React.useState<string>("")
  const [filterExactTime, setFilterExactTime] = React.useState<string>("")
  const fileInputRef = React.useRef<HTMLInputElement>(null)
  const [pageSize, setPageSize] = React.useState<number>(5)
  const [page, setPage] = React.useState<number>(1)

  const todosRef = React.useRef(todos)
  React.useEffect(() => {
    todosRef.current = todos
  }, [todos])
  React.useEffect(() => {
    return () => {
      for (const t of todosRef.current) revokeTodoAttachments(t)
    }
  }, [])

  React.useEffect(() => {
    if (!focusMode) return
    setNowMs(Date.now())
    const id = window.setInterval(() => setNowMs(Date.now()), 30_000)
    return () => window.clearInterval(id)
  }, [focusMode])

  const form = useForm<TodoFormValues>({
    resolver: zodResolver(todoSchema),
    defaultValues: { title: "", dueAt: "" },
    mode: "onSubmit",
  })

  const summary = React.useMemo(() => {
    const now = new Date()
    const todayKey = localDateKey(now)
    const tomorrow = addDays(now, 1)
    const tomorrowKey = localDateKey(tomorrow)

    const todays = todos.filter((t) => t.dueAt.startsWith(todayKey))
    const todayCompleted = todays.filter((t) => t.completed).length
    const todayPending = todays.length - todayCompleted

    const labels = [
      "00:00–04:00",
      "04:00–08:00",
      "08:00–12:00",
      "12:00–16:00",
      "16:00–20:00",
      "20:00–24:00",
    ]

    // Tomorrow: same 4-hour windows breakdown
    const tomorrowTasks = todos.filter((t) => t.dueAt.startsWith(tomorrowKey))
    const tomorrowBuckets = Array.from({ length: 6 }, () => 0) as number[]
    for (const t of tomorrowTasks) {
      const ms = parseLocalDateTime(t.dueAt)
      const hour = new Date(ms).getHours()
      const idx = Math.floor(hour / 4)
      tomorrowBuckets[idx] = (tomorrowBuckets[idx] ?? 0) + 1
    }

    // Until next week = next 7 days starting tomorrow (local), grouped into 4-hour windows.
    const rangeStart = startOfDay(tomorrow).getTime()
    const rangeEnd = addDays(startOfDay(tomorrow), 7).getTime()
    const buckets = Array.from({ length: 6 }, () => 0) as number[]

    const upcoming = todos.filter((t) => {
      const ms = parseLocalDateTime(t.dueAt)
      return ms >= rangeStart && ms < rangeEnd
    })

    for (const t of upcoming) {
      const ms = parseLocalDateTime(t.dueAt)
      const hour = new Date(ms).getHours()
      const idx = Math.floor(hour / 4)
      buckets[idx] = (buckets[idx] ?? 0) + 1
    }

    return {
      todayCompleted,
      todayPending,
      tomorrowTotal: tomorrowTasks.length,
      tomorrowBuckets: labels.map((label, i) => ({ label, count: tomorrowBuckets[i] ?? 0 })),
      upcomingTotal: upcoming.length,
      upcomingBuckets: labels.map((label, i) => ({ label, count: buckets[i] ?? 0 })),
    }
  }, [todos])

  const filteredTodos = React.useMemo(() => {
    if (focusMode) {
      const endMs = nowMs + 4 * 60 * 60 * 1000
      const withMs = todos.map((t) => ({ ...t, _dueMs: parseLocalDateTime(t.dueAt) }))
      return withMs.filter((t) => t._dueMs >= nowMs && t._dueMs <= endMs)
    }

    const withMs = todos.map((t) => ({ ...t, _dueMs: parseLocalDateTime(t.dueAt) }))
    if (filterMode === "exact") {
      // If only date is selected -> show tasks for that date.
      // If time is selected too -> match exact date+time.
      // If only time is selected -> match time-of-day across all dates.
      if (!filterExactDate && !filterExactTime) return withMs

      if (filterExactDate && !filterExactTime) {
        return withMs.filter((t) => getDatePart(t.dueAt) === filterExactDate)
      }

      if (filterExactDate && filterExactTime) {
        const exactMs = parseLocalDateTime(`${filterExactDate}T${filterExactTime}`)
        return withMs.filter((t) => t._dueMs === exactMs)
      }

      // time only
      return withMs.filter((t) => getTimePart(t.dueAt) === filterExactTime)
    }
    // between
    const hasAnyDate = Boolean(filterFromDate || filterToDate)
    const hasAnyTime = Boolean(filterFromTime || filterToTime)

    // Date range (optional)
    const fromDateMs = filterFromDate
      ? startOfDay(parseLocalDateOnly(filterFromDate)).getTime()
      : Number.NEGATIVE_INFINITY
    const toDateMs = filterToDate
      ? endOfDay(parseLocalDateOnly(filterToDate)).getTime()
      : Number.POSITIVE_INFINITY

    // Time-of-day range (optional)
    const fromTimeMin = filterFromTime ? parseLocalTimeToMinutes(filterFromTime) : 0
    const toTimeMin = filterToTime ? parseLocalTimeToMinutes(filterToTime) : 24 * 60 - 1

    return withMs.filter((t) => {
      const ms = t._dueMs
      if (hasAnyDate && (ms < fromDateMs || ms > toDateMs)) return false

      if (hasAnyTime) {
        const time = getTimePart(t.dueAt)
        if (!time) return false
        const mins = parseLocalTimeToMinutes(time)
        // Simple (non-wrapping) range. If you want wrap-around (e.g. 22:00–02:00), tell me.
        if (mins < fromTimeMin || mins > toTimeMin) return false
      }

      // If neither date nor time selected, pass through (handled above anyway)
      return true
    })
  }, [
    todos,
    focusMode,
    nowMs,
    filterExactDate,
    filterExactTime,
    filterFromDate,
    filterFromTime,
    filterMode,
    filterToDate,
    filterToTime,
  ])

  const sortedFilteredTodos = React.useMemo(
    () =>
      filteredTodos
        .slice()
        .sort((a, b) => parseLocalDateTime(a.dueAt) - parseLocalDateTime(b.dueAt)),
    [filteredTodos]
  )

  // Clamp page when filters/pageSize change.
  React.useEffect(() => {
    const totalPages = Math.max(1, Math.ceil(sortedFilteredTodos.length / pageSize))
    setPage((p) => Math.min(Math.max(1, p), totalPages))
  }, [pageSize, sortedFilteredTodos.length])

  const totalItems = sortedFilteredTodos.length
  const totalPages = Math.max(1, Math.ceil(totalItems / pageSize))
  const showPagination = totalPages > 1

  const pageItems = React.useMemo(() => {
    const start = (page - 1) * pageSize
    return sortedFilteredTodos.slice(start, start + pageSize)
  }, [page, pageSize, sortedFilteredTodos])

  const groupedTodos = React.useMemo(() => {
    const groups: Array<{ date: string; items: typeof pageItems }> = []
    for (const t of pageItems) {
      const date = getDatePart(t.dueAt)
      const last = groups[groups.length - 1]
      if (!last || last.date !== date) groups.push({ date, items: [t] })
      else last.items.push(t)
    }
    return groups
  }, [pageItems])

  const completedCount = filteredTodos.filter((t) => t.completed).length

  function addTodo(values: TodoFormValues) {
    const conflicts = todos.filter((t) => t.dueAt === values.dueAt)
    if (conflicts.length > 0) {
      setConflictDueAt(values.dueAt)
      if (clearConflictTimerRef.current) window.clearTimeout(clearConflictTimerRef.current)
      clearConflictTimerRef.current = window.setTimeout(() => {
        setConflictDueAt(null)
      }, 8000)

      // Make sure the user can see the conflicting tasks even if they were filtered out.
      const [d, time] = values.dueAt.split("T")
      setFilterMode("exact")
      setFilterExactDate(d ?? "")
      setFilterExactTime(time ?? "")
      setPage(1)

      toast.error("Time conflict", {
        description: `You already have ${conflicts.length} task(s) scheduled at ${formatLocalDateTime(
          values.dueAt
        )}.`,
      })
    }

    setTodos((prev) => [
      {
        id: crypto.randomUUID(),
        title: values.title.trim(),
        completed: false,
        dueAt: values.dueAt,
        attachments: [],
      },
      ...prev,
    ])
    form.reset()
  }

  function toggleTodo(id: string, completed: boolean) {
    setTodos((prev) => prev.map((t) => (t.id === id ? { ...t, completed } : t)))
  }

  function requestAttachmentsForTodo(todoId: string) {
    setAttachTargetTodoId(todoId)
    // Let state update before opening picker (some browsers are picky).
    queueMicrotask(() => fileInputRef.current?.click())
  }

  function handleFilesPicked(e: React.ChangeEvent<HTMLInputElement>) {
    const files = Array.from(e.target.files ?? [])
    const targetId = attachTargetTodoId

    // reset input so picking the same file again triggers onChange
    e.target.value = ""
    setAttachTargetTodoId(null)

    if (!targetId || files.length === 0) return

    const attachments = files.map(makeAttachment)

    setTodos((prev) =>
      prev.map((t) =>
        t.id === targetId
          ? { ...t, attachments: [...t.attachments, ...attachments] }
          : t
      )
    )
  }

  function deleteTodo(id: string) {
    setTodos((prev) => {
      const victim = prev.find((t) => t.id === id)
      if (victim) revokeTodoAttachments(victim)
      return prev.filter((t) => t.id !== id)
    })
  }

  function clearCompleted() {
    setTodos((prev) => {
      for (const t of prev) {
        if (t.completed) revokeTodoAttachments(t)
      }
      return prev.filter((t) => !t.completed)
    })
  }

  return (
    <Card>
      <CardHeader className="flex flex-row items-center justify-between gap-4">
        <div className="space-y-1">
          <CardTitle className="text-2xl">To‑Do</CardTitle>
          <p className="text-muted-foreground text-sm">
            {completedCount}/{filteredTodos.length} completed
          </p>
        </div>
        <div className="flex items-center gap-2">
          <Button
            type="button"
            variant={focusMode ? "default" : "outline"}
            size="sm"
            onClick={() => {
              setFocusMode((v) => !v)
              setPage(1)
            }}
          >
            Focus Mode
          </Button>
          <ModeToggle />
        </div>
      </CardHeader>

      <CardContent className="space-y-6">
        <input
          ref={fileInputRef}
          type="file"
          multiple
          className="hidden"
          accept={[
            "image/*",
            "audio/*",
            "video/*",
            ".pdf",
            ".doc",
            ".docx",
            ".xls",
            ".xlsx",
            ".csv",
            ".txt",
            ".md",
            ".rtf",
          ].join(",")}
          onChange={handleFilesPicked}
        />

        <div className="grid gap-3 sm:grid-cols-3">
          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Today’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">
              {summary.todayCompleted} completed
            </p>
            <p className="text-muted-foreground text-sm">{summary.todayPending} pending</p>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tomorrow’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">{summary.tomorrowTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.tomorrowBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tasks Until Next Week</p>
            <p className="mt-2 text-2xl font-semibold">{summary.upcomingTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.upcomingBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>
        </div>

        {focusMode && (
          <div className="flex flex-col gap-1 rounded-lg border bg-muted/20 px-3 py-2 sm:flex-row sm:items-center sm:justify-between">
            <p className="text-sm">
              <span className="font-medium">Focus Mode:</span>{" "}
              showing tasks due in the next 4 hours (until{" "}
              <span className="font-medium">
                {formatDateTimeFromMs(nowMs + 4 * 60 * 60 * 1000)}
              </span>
              )
            </p>
            <Button type="button" variant="ghost" size="sm" onClick={() => setFocusMode(false)}>
              Exit
            </Button>
          </div>
        )}

        <Form {...form}>
          <form
            onSubmit={form.handleSubmit(addTodo)}
            className="space-y-2"
            noValidate
          >
            <div className="flex flex-col gap-2 sm:flex-row">
              <FormField
                control={form.control}
                name="title"
                render={({ field }) => (
                  <FormItem className="flex-1">
                    <FormControl>
                      <Input
                        placeholder="Add a task…"
                        autoComplete="off"
                        {...field}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="dueAt"
                render={({ field }) => (
                  <FormItem className="sm:w-64">
                    <FormControl>
                      <Input type="datetime-local" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <Button type="submit">Add</Button>
            </div>
          </form>
        </Form>

        <Separator />

        <div className="space-y-3">
          <div className="flex flex-wrap items-center justify-between gap-2">
            <p className="text-sm font-medium">Filter by date & time</p>
            <div className="flex items-center gap-2">
              <Button
                type="button"
                size="sm"
                variant={filterMode === "between" ? "default" : "outline"}
                onClick={() => setFilterMode("between")}
              >
                Between
              </Button>
              <Button
                type="button"
                size="sm"
                variant={filterMode === "exact" ? "default" : "outline"}
                onClick={() => setFilterMode("exact")}
              >
                Exact
              </Button>
              <Button
                type="button"
                size="sm"
                variant="ghost"
                onClick={() => {
                  setFilterFromDate("")
                  setFilterFromTime("")
                  setFilterToDate("")
                  setFilterToTime("")
                  setFilterExactDate("")
                  setFilterExactTime("")
                }}
              >
                Clear
              </Button>
            </div>
          </div>

          {filterMode === "between" ? (
            <div className="grid gap-2 sm:grid-cols-2">
              <div className="grid gap-2 sm:grid-cols-2">
                <Input
                  type="date"
                  value={filterFromDate}
                  onChange={(e) => setFilterFromDate(e.target.value)}
                />
                <Input
                  type="time"
                  value={filterFromTime}
                  onChange={(e) => setFilterFromTime(e.target.value)}
                />
              </div>
              <div className="grid gap-2 sm:grid-cols-2">
                <Input
                  type="date"
                  value={filterToDate}
                  onChange={(e) => setFilterToDate(e.target.value)}
                />
                <Input
                  type="time"
                  value={filterToTime}
                  onChange={(e) => setFilterToTime(e.target.value)}
                />
              </div>
            </div>
          ) : (
            <div className="grid gap-2 sm:grid-cols-2">
              <Input
                type="date"
                value={filterExactDate}
                onChange={(e) => setFilterExactDate(e.target.value)}
              />
              <Input
                type="time"
                value={filterExactTime}
                onChange={(e) => setFilterExactTime(e.target.value)}
              />
            </div>
          )}
        </div>

        <Separator />

        <div className="space-y-2">
          {groupedTodos.length === 0 ? (
            <p className="text-muted-foreground text-sm">No tasks yet.</p>
          ) : (
            groupedTodos.map((group) => (
              <div key={group.date} className="space-y-2">
                <div className="flex items-center gap-3 pt-2">
                  <Separator className="flex-1" />
                  <span className="text-muted-foreground whitespace-nowrap text-xs font-medium">
                    {new Intl.DateTimeFormat(undefined, {
                      weekday: "short",
                      year: "numeric",
                      month: "short",
                      day: "2-digit",
                    }).format(parseLocalDateOnly(group.date))}
                  </span>
                  <Separator className="flex-1" />
                </div>

                {group.items.map((todo) => (
                  <div
                    key={todo.id}
                    className={cn(
                      "rounded-lg border px-3 py-2",
                      conflictDueAt &&
                        todo.dueAt === conflictDueAt &&
                        "border-destructive/60 bg-destructive/5 ring-1 ring-destructive/30"
                    )}
                  >
                    <div className="flex items-start justify-between gap-3">
                      <label className="flex cursor-pointer items-start gap-3">
                        <Checkbox
                          checked={todo.completed}
                          onCheckedChange={(v) => {
                            const next = Boolean(v)
                            toggleTodo(todo.id, next)
                            if (next && !todo.completed) {
                              requestAttachmentsForTodo(todo.id)
                            }
                          }}
                          aria-label={`Mark "${todo.title}" as ${
                            todo.completed ? "not completed" : "completed"
                          }`}
                          className="mt-0.5"
                        />
                        <span
                          className={cn(
                            "leading-6",
                            todo.completed && "text-muted-foreground line-through"
                          )}
                        >
                          <span className="block">{todo.title}</span>
                          <span className="text-muted-foreground block text-xs">
                            Due: {formatLocalDateTime(todo.dueAt)}
                          </span>
                        </span>
                      </label>

                      <div className="flex items-center gap-1">
                        {todo.completed && (
                          <Button
                            type="button"
                            variant="outline"
                            size="sm"
                            onClick={() => requestAttachmentsForTodo(todo.id)}
                          >
                            Add files
                          </Button>
                        )}
                        <Button
                          type="button"
                          variant="ghost"
                          size="icon"
                          aria-label={`Delete "${todo.title}"`}
                          onClick={() => deleteTodo(todo.id)}
                        >
                          <Trash2 className="h-4 w-4" />
                        </Button>
                      </div>
                    </div>

                    {todo.completed && todo.attachments.length > 0 && (
                      <div className="mt-3 space-y-2">
                        <p className="text-muted-foreground text-xs">Attachments</p>
                        <ul className="space-y-1">
                          {todo.attachments.map((a) => (
                            <li
                              key={a.id}
                              className="flex items-center justify-between gap-3 rounded-md bg-muted/30 px-2 py-1"
                            >
                              <div className="flex min-w-0 items-center gap-2">
                                <AttachmentIcon kind={a.kind} />
                                <span className="truncate text-sm">{a.name}</span>
                              </div>
                              <a
                                href={a.url}
                                download={a.name}
                                className="inline-flex items-center gap-1 text-sm font-medium underline underline-offset-4"
                              >
                                <Download className="h-4 w-4" />
                                Download
                              </a>
                            </li>
                          ))}
                        </ul>
                      </div>
                    )}
                  </div>
                ))}
              </div>
            ))
          )}
        </div>

        {groupedTodos.length > 0 && (
          <div className="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
            <div className="flex items-center gap-2">
              <span className="text-muted-foreground text-sm">Items per page</span>
              <Select
                value={String(pageSize)}
                onValueChange={(v) => {
                  const next = Number(v)
                  setPageSize(next)
                  setPage(1)
                }}
              >
                <SelectTrigger className="w-[110px]">
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="5">5</SelectItem>
                  <SelectItem value="10">10</SelectItem>
                  <SelectItem value="15">15</SelectItem>
                  <SelectItem value="20">20</SelectItem>
                </SelectContent>
              </Select>
            </div>

            {showPagination && (
              <div className="flex items-center justify-between gap-3 sm:justify-end">
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={() => setPage((p) => Math.max(1, p - 1))}
                  disabled={page <= 1}
                >
                  Prev
                </Button>
                <span className="text-muted-foreground text-sm">
                  Page {page} of {totalPages}
                </span>
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={() => setPage((p) => Math.min(totalPages, p + 1))}
                  disabled={page >= totalPages}
                >
                  Next
                </Button>
              </div>
            )}
          </div>
        )}

        <div className="flex items-center justify-between gap-2">
          <Button
            type="button"
            variant="secondary"
            onClick={clearCompleted}
            disabled={completedCount === 0}
          >
            Clear completed
          </Button>
          <span className="text-muted-foreground text-sm">
            Mock data only (no backend)
          </span>
        </div>
      </CardContent>
    </Card>
  )
}

```

### Focus Mode added (next 4 hours)
- Added a **Focus Mode** button in the header.
- When enabled, the list shows **only tasks due between now and the next 4 hours** (auto-updates every 30 seconds).
- Shows a small banner with the **window end time** and an **Exit** button.
- Pagination still works on the focused list.

### File changed
- `src/app/page.tsx`

### Run
```bash
npm run dev
```

```shellscript
npm run dev
```

---

**User**

Implement Overdue and Visual Task States:
If a task’s date or time has passed and it is not completed, mark it as Overdue and visually distinguish it (e.g., faded style, badge, or icon). Different task states (Planned, In Progress, Completed, Overdue) should be clearly represented using visual cues such as color, opacity, or text decoration, without using disruptive notifications.

---

**Cursor**

Got it. Next I’ll add a small “state badge” to every task (Planned / In Progress / Completed / Overdue), compute **Overdue** based on current time vs `dueAt`, and apply subtle styling (color/opacity/border) so the state is clear with zero popups/toasts. I’ll touch `src/app/page.tsx`, add the shadcn `badge` component, then verify build.

```typescriptreact
"use client"

import { zodResolver } from "@hookform/resolvers/zod"
import {
  AlertTriangle,
  CalendarClock,
  CheckCircle2,
  Download,
  File,
  FileSpreadsheet,
  FileText,
  Image as ImageIcon,
  Music,
  Timer,
  Trash2,
  Video,
} from "lucide-react"
import * as React from "react"
import { useForm } from "react-hook-form"
import { toast } from "sonner"
import { z } from "zod"

import { ModeToggle } from "@/components/mode-toggle"
import { Badge } from "@/components/ui/badge"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Checkbox } from "@/components/ui/checkbox"
import { Form, FormControl, FormField, FormItem, FormMessage } from "@/components/ui/form"
import { Input } from "@/components/ui/input"
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select"
import { Separator } from "@/components/ui/separator"
import { cn } from "@/lib/utils"

type AttachmentKind =
  | "image"
  | "audio"
  | "video"
  | "pdf"
  | "spreadsheet"
  | "document"
  | "text"
  | "file"

type Attachment = {
  id: string
  name: string
  type: string
  size: number
  url: string
  kind: AttachmentKind
}

type Todo = {
  id: string
  title: string
  completed: boolean
  // Stored as `datetime-local` string (YYYY-MM-DDTHH:mm) in local time.
  dueAt: string
  attachments: Attachment[]
}

type TaskState = "planned" | "in_progress" | "completed" | "overdue"

const todoSchema = z.object({
  title: z
    .string()
    .trim()
    .min(1, "Title is required.")
    .max(80, "Keep it under 80 characters."),
  dueAt: z
    .string()
    .min(1, "Due date & time is required.")
    .regex(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}$/, "Invalid date/time."),
})

type TodoFormValues = z.infer<typeof todoSchema>

const initialTodos: Todo[] = [
  {
    id: "1",
    title: "Create a Next.js app",
    completed: true,
    dueAt: "2026-01-16T09:00",
    attachments: [],
  },
  {
    id: "2",
    title: "Add shadcn/ui + dark theme",
    completed: true,
    dueAt: "2026-01-16T10:30",
    attachments: [],
  },
  {
    id: "3",
    title: "Build a mock-data to-do list",
    completed: false,
    dueAt: "2026-01-16T15:00",
    attachments: [],
  },
  {
    id: "4",
    title: "Yesterday: review requirements",
    completed: true,
    dueAt: "2026-01-15T11:15",
    attachments: [],
  },
  {
    id: "5",
    title: "Yesterday: sketch UI layout",
    completed: true,
    dueAt: "2026-01-15T17:45",
    attachments: [],
  },
  {
    id: "6",
    title: "Today: add attachments support",
    completed: false,
    dueAt: "2026-01-16T18:20",
    attachments: [],
  },
  {
    id: "7",
    title: "Tomorrow: QA the filters",
    completed: false,
    dueAt: "2026-01-17T08:05",
    attachments: [],
  },
  {
    id: "8",
    title: "Tomorrow: polish summary cards",
    completed: false,
    dueAt: "2026-01-17T13:30",
    attachments: [],
  },
  {
    id: "9",
    title: "Tomorrow: write small UX notes",
    completed: false,
    dueAt: "2026-01-17T20:10",
    attachments: [],
  },
  {
    id: "10",
    title: "This weekend: add more mock tasks",
    completed: false,
    dueAt: "2026-01-18T10:00",
    attachments: [],
  },
  {
    id: "11",
    title: "This weekend: check time-only filter",
    completed: false,
    dueAt: "2026-01-18T22:15",
    attachments: [],
  },
  {
    id: "12",
    title: "Next week: sync with team",
    completed: false,
    dueAt: "2026-01-19T09:30",
    attachments: [],
  },
  {
    id: "13",
    title: "Next week: test date-only filter",
    completed: false,
    dueAt: "2026-01-20T14:05",
    attachments: [],
  },
  {
    id: "14",
    title: "Next week: test exact date+time filter",
    completed: false,
    dueAt: "2026-01-21T12:00",
    attachments: [],
  },
  {
    id: "15",
    title: "Next week: attach docs to completed tasks",
    completed: false,
    dueAt: "2026-01-22T16:40",
    attachments: [],
  },
  {
    id: "16",
    title: "Next week: final review",
    completed: false,
    dueAt: "2026-01-23T11:00",
    attachments: [],
  },
]

function parseLocalDateTime(value: string): number {
  // value: "YYYY-MM-DDTHH:mm"
  const [datePart, timePart] = value.split("T")
  const [y, m, d] = datePart.split("-").map(Number)
  const [hh, mm] = timePart.split(":").map(Number)
  return new Date(y, m - 1, d, hh, mm, 0, 0).getTime()
}

function pad2(n: number) {
  return String(n).padStart(2, "0")
}

function localDateKey(d: Date) {
  return `${d.getFullYear()}-${pad2(d.getMonth() + 1)}-${pad2(d.getDate())}`
}

function addDays(date: Date, days: number) {
  const d = new Date(date)
  d.setDate(d.getDate() + days)
  return d
}

function startOfDay(date: Date) {
  return new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0, 0)
}

function endOfDay(date: Date) {
  return new Date(
    date.getFullYear(),
    date.getMonth(),
    date.getDate(),
    23,
    59,
    59,
    999
  )
}

function getDatePart(dueAt: string) {
  return dueAt.split("T")[0] ?? ""
}

function getTimePart(dueAt: string) {
  return dueAt.split("T")[1] ?? ""
}

function parseLocalDateOnly(value: string): Date {
  // value: "YYYY-MM-DD"
  const [y, m, d] = value.split("-").map(Number)
  return new Date(y, m - 1, d, 0, 0, 0, 0)
}

function parseLocalTimeToMinutes(value: string): number {
  // value: "HH:mm"
  const [hh, mm] = value.split(":").map(Number)
  return hh * 60 + mm
}

function formatLocalDateTime(value: string): string {
  const ms = parseLocalDateTime(value)
  if (!Number.isFinite(ms)) return value
  return new Intl.DateTimeFormat(undefined, {
    year: "numeric",
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  }).format(new Date(ms))
}

function formatDateTimeFromMs(ms: number): string {
  return new Intl.DateTimeFormat(undefined, {
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  }).format(new Date(ms))
}

function getTaskState(todo: Todo, nowMs: number): TaskState {
  if (todo.completed) return "completed"
  const dueMs = parseLocalDateTime(todo.dueAt)
  if (dueMs < nowMs) return "overdue"
  if (dueMs <= nowMs + 4 * 60 * 60 * 1000) return "in_progress"
  return "planned"
}

function TaskStateBadge({ state }: { state: TaskState }) {
  switch (state) {
    case "completed":
      return (
        <Badge className="gap-1 bg-emerald-600 text-white hover:bg-emerald-600">
          <CheckCircle2 className="h-3.5 w-3.5" />
          Completed
        </Badge>
      )
    case "overdue":
      return (
        <Badge variant="destructive" className="gap-1">
          <AlertTriangle className="h-3.5 w-3.5" />
          Overdue
        </Badge>
      )
    case "in_progress":
      return (
        <Badge variant="secondary" className="gap-1">
          <Timer className="h-3.5 w-3.5" />
          In progress
        </Badge>
      )
    default:
      return (
        <Badge variant="outline" className="gap-1">
          <CalendarClock className="h-3.5 w-3.5" />
          Planned
        </Badge>
      )
  }
}

function getAttachmentKind(file: File): AttachmentKind {
  const type = (file.type || "").toLowerCase()
  const name = file.name.toLowerCase()
  const ext = name.includes(".") ? name.split(".").pop() ?? "" : ""

  if (type.startsWith("image/")) return "image"
  if (type.startsWith("audio/")) return "audio"
  if (type.startsWith("video/")) return "video"

  if (ext === "pdf") return "pdf"
  if (["xls", "xlsx", "csv"].includes(ext)) return "spreadsheet"
  if (["doc", "docx"].includes(ext)) return "document"
  if (["txt", "md", "rtf"].includes(ext)) return "text"

  return "file"
}

function makeAttachment(file: File): Attachment {
  return {
    id: crypto.randomUUID(),
    name: file.name,
    type: file.type,
    size: file.size,
    url: URL.createObjectURL(file),
    kind: getAttachmentKind(file),
  }
}

function revokeTodoAttachments(todo: Todo) {
  for (const a of todo.attachments) URL.revokeObjectURL(a.url)
}

function AttachmentIcon({ kind }: { kind: AttachmentKind }) {
  const className = "h-4 w-4 text-muted-foreground"

  switch (kind) {
    case "image":
      return <ImageIcon className={className} />
    case "audio":
      return <Music className={className} />
    case "video":
      return <Video className={className} />
    case "spreadsheet":
      return <FileSpreadsheet className={className} />
    case "pdf":
    case "document":
    case "text":
      return <FileText className={className} />
    default:
      return <File className={className} />
  }
}

export default function Home() {
  return (
    <div className="mx-auto flex min-h-screen max-w-2xl flex-col gap-6 px-4 py-10">
      <TodoApp />
    </div>
  )
}

function TodoApp() {
  const [todos, setTodos] = React.useState<Todo[]>(initialTodos)
  const [attachTargetTodoId, setAttachTargetTodoId] = React.useState<string | null>(
    null
  )
  const [conflictDueAt, setConflictDueAt] = React.useState<string | null>(null)
  const clearConflictTimerRef = React.useRef<number | null>(null)
  const [focusMode, setFocusMode] = React.useState(false)
  const [nowMs, setNowMs] = React.useState(() => Date.now())
  const [filterMode, setFilterMode] = React.useState<"between" | "exact">("between")
  const [filterFromDate, setFilterFromDate] = React.useState<string>("")
  const [filterFromTime, setFilterFromTime] = React.useState<string>("")
  const [filterToDate, setFilterToDate] = React.useState<string>("")
  const [filterToTime, setFilterToTime] = React.useState<string>("")
  const [filterExactDate, setFilterExactDate] = React.useState<string>("")
  const [filterExactTime, setFilterExactTime] = React.useState<string>("")
  const fileInputRef = React.useRef<HTMLInputElement>(null)
  const [pageSize, setPageSize] = React.useState<number>(5)
  const [page, setPage] = React.useState<number>(1)

  const todosRef = React.useRef(todos)
  React.useEffect(() => {
    todosRef.current = todos
  }, [todos])
  React.useEffect(() => {
    return () => {
      for (const t of todosRef.current) revokeTodoAttachments(t)
    }
  }, [])

  // Keep "now" fresh so overdue/in-progress states stay accurate without user interaction.
  React.useEffect(() => {
    const id = window.setInterval(() => setNowMs(Date.now()), 30_000)
    return () => window.clearInterval(id)
  }, [])

  const form = useForm<TodoFormValues>({
    resolver: zodResolver(todoSchema),
    defaultValues: { title: "", dueAt: "" },
    mode: "onSubmit",
  })

  const summary = React.useMemo(() => {
    const now = new Date()
    const todayKey = localDateKey(now)
    const tomorrow = addDays(now, 1)
    const tomorrowKey = localDateKey(tomorrow)

    const todays = todos.filter((t) => t.dueAt.startsWith(todayKey))
    const todayCompleted = todays.filter((t) => t.completed).length
    const todayPending = todays.length - todayCompleted

    const labels = [
      "00:00–04:00",
      "04:00–08:00",
      "08:00–12:00",
      "12:00–16:00",
      "16:00–20:00",
      "20:00–24:00",
    ]

    // Tomorrow: same 4-hour windows breakdown
    const tomorrowTasks = todos.filter((t) => t.dueAt.startsWith(tomorrowKey))
    const tomorrowBuckets = Array.from({ length: 6 }, () => 0) as number[]
    for (const t of tomorrowTasks) {
      const ms = parseLocalDateTime(t.dueAt)
      const hour = new Date(ms).getHours()
      const idx = Math.floor(hour / 4)
      tomorrowBuckets[idx] = (tomorrowBuckets[idx] ?? 0) + 1
    }

    // Until next week = next 7 days starting tomorrow (local), grouped into 4-hour windows.
    const rangeStart = startOfDay(tomorrow).getTime()
    const rangeEnd = addDays(startOfDay(tomorrow), 7).getTime()
    const buckets = Array.from({ length: 6 }, () => 0) as number[]

    const upcoming = todos.filter((t) => {
      const ms = parseLocalDateTime(t.dueAt)
      return ms >= rangeStart && ms < rangeEnd
    })

    for (const t of upcoming) {
      const ms = parseLocalDateTime(t.dueAt)
      const hour = new Date(ms).getHours()
      const idx = Math.floor(hour / 4)
      buckets[idx] = (buckets[idx] ?? 0) + 1
    }

    return {
      todayCompleted,
      todayPending,
      tomorrowTotal: tomorrowTasks.length,
      tomorrowBuckets: labels.map((label, i) => ({ label, count: tomorrowBuckets[i] ?? 0 })),
      upcomingTotal: upcoming.length,
      upcomingBuckets: labels.map((label, i) => ({ label, count: buckets[i] ?? 0 })),
    }
  }, [todos])

  const filteredTodos = React.useMemo(() => {
    if (focusMode) {
      const endMs = nowMs + 4 * 60 * 60 * 1000
      const withMs = todos.map((t) => ({ ...t, _dueMs: parseLocalDateTime(t.dueAt) }))
      return withMs.filter((t) => t._dueMs >= nowMs && t._dueMs <= endMs)
    }

    const withMs = todos.map((t) => ({ ...t, _dueMs: parseLocalDateTime(t.dueAt) }))
    if (filterMode === "exact") {
      // If only date is selected -> show tasks for that date.
      // If time is selected too -> match exact date+time.
      // If only time is selected -> match time-of-day across all dates.
      if (!filterExactDate && !filterExactTime) return withMs

      if (filterExactDate && !filterExactTime) {
        return withMs.filter((t) => getDatePart(t.dueAt) === filterExactDate)
      }

      if (filterExactDate && filterExactTime) {
        const exactMs = parseLocalDateTime(`${filterExactDate}T${filterExactTime}`)
        return withMs.filter((t) => t._dueMs === exactMs)
      }

      // time only
      return withMs.filter((t) => getTimePart(t.dueAt) === filterExactTime)
    }
    // between
    const hasAnyDate = Boolean(filterFromDate || filterToDate)
    const hasAnyTime = Boolean(filterFromTime || filterToTime)

    // Date range (optional)
    const fromDateMs = filterFromDate
      ? startOfDay(parseLocalDateOnly(filterFromDate)).getTime()
      : Number.NEGATIVE_INFINITY
    const toDateMs = filterToDate
      ? endOfDay(parseLocalDateOnly(filterToDate)).getTime()
      : Number.POSITIVE_INFINITY

    // Time-of-day range (optional)
    const fromTimeMin = filterFromTime ? parseLocalTimeToMinutes(filterFromTime) : 0
    const toTimeMin = filterToTime ? parseLocalTimeToMinutes(filterToTime) : 24 * 60 - 1

    return withMs.filter((t) => {
      const ms = t._dueMs
      if (hasAnyDate && (ms < fromDateMs || ms > toDateMs)) return false

      if (hasAnyTime) {
        const time = getTimePart(t.dueAt)
        if (!time) return false
        const mins = parseLocalTimeToMinutes(time)
        // Simple (non-wrapping) range. If you want wrap-around (e.g. 22:00–02:00), tell me.
        if (mins < fromTimeMin || mins > toTimeMin) return false
      }

      // If neither date nor time selected, pass through (handled above anyway)
      return true
    })
  }, [
    todos,
    focusMode,
    nowMs,
    filterExactDate,
    filterExactTime,
    filterFromDate,
    filterFromTime,
    filterMode,
    filterToDate,
    filterToTime,
  ])

  const sortedFilteredTodos = React.useMemo(
    () =>
      filteredTodos
        .slice()
        .sort((a, b) => parseLocalDateTime(a.dueAt) - parseLocalDateTime(b.dueAt)),
    [filteredTodos]
  )

  // Clamp page when filters/pageSize change.
  React.useEffect(() => {
    const totalPages = Math.max(1, Math.ceil(sortedFilteredTodos.length / pageSize))
    setPage((p) => Math.min(Math.max(1, p), totalPages))
  }, [pageSize, sortedFilteredTodos.length])

  const totalItems = sortedFilteredTodos.length
  const totalPages = Math.max(1, Math.ceil(totalItems / pageSize))
  const showPagination = totalPages > 1

  const pageItems = React.useMemo(() => {
    const start = (page - 1) * pageSize
    return sortedFilteredTodos.slice(start, start + pageSize)
  }, [page, pageSize, sortedFilteredTodos])

  const groupedTodos = React.useMemo(() => {
    const groups: Array<{ date: string; items: typeof pageItems }> = []
    for (const t of pageItems) {
      const date = getDatePart(t.dueAt)
      const last = groups[groups.length - 1]
      if (!last || last.date !== date) groups.push({ date, items: [t] })
      else last.items.push(t)
    }
    return groups
  }, [pageItems])

  const completedCount = filteredTodos.filter((t) => t.completed).length

  function addTodo(values: TodoFormValues) {
    const conflicts = todos.filter((t) => t.dueAt === values.dueAt)
    if (conflicts.length > 0) {
      setConflictDueAt(values.dueAt)
      if (clearConflictTimerRef.current) window.clearTimeout(clearConflictTimerRef.current)
      clearConflictTimerRef.current = window.setTimeout(() => {
        setConflictDueAt(null)
      }, 8000)

      // Make sure the user can see the conflicting tasks even if they were filtered out.
      const [d, time] = values.dueAt.split("T")
      setFilterMode("exact")
      setFilterExactDate(d ?? "")
      setFilterExactTime(time ?? "")
      setPage(1)

      toast.error("Time conflict", {
        description: `You already have ${conflicts.length} task(s) scheduled at ${formatLocalDateTime(
          values.dueAt
        )}.`,
      })
    }

    setTodos((prev) => [
      {
        id: crypto.randomUUID(),
        title: values.title.trim(),
        completed: false,
        dueAt: values.dueAt,
        attachments: [],
      },
      ...prev,
    ])
    form.reset()
  }

  function toggleTodo(id: string, completed: boolean) {
    setTodos((prev) => prev.map((t) => (t.id === id ? { ...t, completed } : t)))
  }

  function requestAttachmentsForTodo(todoId: string) {
    setAttachTargetTodoId(todoId)
    // Let state update before opening picker (some browsers are picky).
    queueMicrotask(() => fileInputRef.current?.click())
  }

  function handleFilesPicked(e: React.ChangeEvent<HTMLInputElement>) {
    const files = Array.from(e.target.files ?? [])
    const targetId = attachTargetTodoId

    // reset input so picking the same file again triggers onChange
    e.target.value = ""
    setAttachTargetTodoId(null)

    if (!targetId || files.length === 0) return

    const attachments = files.map(makeAttachment)

    setTodos((prev) =>
      prev.map((t) =>
        t.id === targetId
          ? { ...t, attachments: [...t.attachments, ...attachments] }
          : t
      )
    )
  }

  function deleteTodo(id: string) {
    setTodos((prev) => {
      const victim = prev.find((t) => t.id === id)
      if (victim) revokeTodoAttachments(victim)
      return prev.filter((t) => t.id !== id)
    })
  }

  function clearCompleted() {
    setTodos((prev) => {
      for (const t of prev) {
        if (t.completed) revokeTodoAttachments(t)
      }
      return prev.filter((t) => !t.completed)
    })
  }

  return (
    <Card>
      <CardHeader className="flex flex-row items-center justify-between gap-4">
        <div className="space-y-1">
          <CardTitle className="text-2xl">To‑Do</CardTitle>
          <p className="text-muted-foreground text-sm">
            {completedCount}/{filteredTodos.length} completed
          </p>
        </div>
        <div className="flex items-center gap-2">
          <Button
            type="button"
            variant={focusMode ? "default" : "outline"}
            size="sm"
            onClick={() => {
              setFocusMode((v) => !v)
              setPage(1)
            }}
          >
            Focus Mode
          </Button>
          <ModeToggle />
        </div>
      </CardHeader>

      <CardContent className="space-y-6">
        <input
          ref={fileInputRef}
          type="file"
          multiple
          className="hidden"
          accept={[
            "image/*",
            "audio/*",
            "video/*",
            ".pdf",
            ".doc",
            ".docx",
            ".xls",
            ".xlsx",
            ".csv",
            ".txt",
            ".md",
            ".rtf",
          ].join(",")}
          onChange={handleFilesPicked}
        />

        <div className="grid gap-3 sm:grid-cols-3">
          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Today’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">
              {summary.todayCompleted} completed
            </p>
            <p className="text-muted-foreground text-sm">{summary.todayPending} pending</p>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tomorrow’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">{summary.tomorrowTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.tomorrowBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tasks Until Next Week</p>
            <p className="mt-2 text-2xl font-semibold">{summary.upcomingTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.upcomingBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>
        </div>

        {focusMode && (
          <div className="flex flex-col gap-1 rounded-lg border bg-muted/20 px-3 py-2 sm:flex-row sm:items-center sm:justify-between">
            <p className="text-sm">
              <span className="font-medium">Focus Mode:</span>{" "}
              showing tasks due in the next 4 hours (until{" "}
              <span className="font-medium">
                {formatDateTimeFromMs(nowMs + 4 * 60 * 60 * 1000)}
              </span>
              )
            </p>
            <Button type="button" variant="ghost" size="sm" onClick={() => setFocusMode(false)}>
              Exit
            </Button>
          </div>
        )}

        <Form {...form}>
          <form
            onSubmit={form.handleSubmit(addTodo)}
            className="space-y-2"
            noValidate
          >
            <div className="flex flex-col gap-2 sm:flex-row">
              <FormField
                control={form.control}
                name="title"
                render={({ field }) => (
                  <FormItem className="flex-1">
                    <FormControl>
                      <Input
                        placeholder="Add a task…"
                        autoComplete="off"
                        {...field}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="dueAt"
                render={({ field }) => (
                  <FormItem className="sm:w-64">
                    <FormControl>
                      <Input type="datetime-local" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <Button type="submit">Add</Button>
            </div>
          </form>
        </Form>

        <Separator />

        <div className="space-y-3">
          <div className="flex flex-wrap items-center justify-between gap-2">
            <p className="text-sm font-medium">Filter by date & time</p>
            <div className="flex items-center gap-2">
              <Button
                type="button"
                size="sm"
                variant={filterMode === "between" ? "default" : "outline"}
                onClick={() => setFilterMode("between")}
              >
                Between
              </Button>
              <Button
                type="button"
                size="sm"
                variant={filterMode === "exact" ? "default" : "outline"}
                onClick={() => setFilterMode("exact")}
              >
                Exact
              </Button>
              <Button
                type="button"
                size="sm"
                variant="ghost"
                onClick={() => {
                  setFilterFromDate("")
                  setFilterFromTime("")
                  setFilterToDate("")
                  setFilterToTime("")
                  setFilterExactDate("")
                  setFilterExactTime("")
                }}
              >
                Clear
              </Button>
            </div>
          </div>

          {filterMode === "between" ? (
            <div className="grid gap-2 sm:grid-cols-2">
              <div className="grid gap-2 sm:grid-cols-2">
                <Input
                  type="date"
                  value={filterFromDate}
                  onChange={(e) => setFilterFromDate(e.target.value)}
                />
                <Input
                  type="time"
                  value={filterFromTime}
                  onChange={(e) => setFilterFromTime(e.target.value)}
                />
              </div>
              <div className="grid gap-2 sm:grid-cols-2">
                <Input
                  type="date"
                  value={filterToDate}
                  onChange={(e) => setFilterToDate(e.target.value)}
                />
                <Input
                  type="time"
                  value={filterToTime}
                  onChange={(e) => setFilterToTime(e.target.value)}
                />
              </div>
            </div>
          ) : (
            <div className="grid gap-2 sm:grid-cols-2">
              <Input
                type="date"
                value={filterExactDate}
                onChange={(e) => setFilterExactDate(e.target.value)}
              />
              <Input
                type="time"
                value={filterExactTime}
                onChange={(e) => setFilterExactTime(e.target.value)}
              />
            </div>
          )}
        </div>

        <Separator />

        <div className="space-y-2">
          {groupedTodos.length === 0 ? (
            <p className="text-muted-foreground text-sm">No tasks yet.</p>
          ) : (
            groupedTodos.map((group) => (
              <div key={group.date} className="space-y-2">
                <div className="flex items-center gap-3 pt-2">
                  <Separator className="flex-1" />
                  <span className="text-muted-foreground whitespace-nowrap text-xs font-medium">
                    {new Intl.DateTimeFormat(undefined, {
                      weekday: "short",
                      year: "numeric",
                      month: "short",
                      day: "2-digit",
                    }).format(parseLocalDateOnly(group.date))}
                  </span>
                  <Separator className="flex-1" />
                </div>

                {group.items.map((todo) => (
                  const state = getTaskState(todo, nowMs)
                  <div
                    key={todo.id}
                    className={cn(
                      "rounded-lg border px-3 py-2",
                      state === "completed" && "opacity-75",
                      state === "overdue" &&
                        "border-destructive/40 bg-destructive/5 text-muted-foreground",
                      state === "in_progress" &&
                        "border-primary/30 bg-primary/5",
                      conflictDueAt &&
                        todo.dueAt === conflictDueAt &&
                        "border-destructive/60 bg-destructive/5 ring-1 ring-destructive/30"
                    )}
                  >
                    <div className="flex items-start justify-between gap-3">
                      <label className="flex cursor-pointer items-start gap-3">
                        <Checkbox
                          checked={todo.completed}
                          onCheckedChange={(v) => {
                            const next = Boolean(v)
                            toggleTodo(todo.id, next)
                            if (next && !todo.completed) {
                              requestAttachmentsForTodo(todo.id)
                            }
                          }}
                          aria-label={`Mark "${todo.title}" as ${
                            todo.completed ? "not completed" : "completed"
                          }`}
                          className="mt-0.5"
                        />
                        <span
                          className={cn(
                            "leading-6",
                            todo.completed && "text-muted-foreground line-through"
                          )}
                        >
                          <span className="flex flex-wrap items-center gap-2">
                            <span className="block">{todo.title}</span>
                            <TaskStateBadge state={state} />
                          </span>
                          <span className="text-muted-foreground block text-xs">
                            Due: {formatLocalDateTime(todo.dueAt)}
                          </span>
                        </span>
                      </label>

                      <div className="flex items-center gap-1">
                        {todo.completed && (
                          <Button
                            type="button"
                            variant="outline"
                            size="sm"
                            onClick={() => requestAttachmentsForTodo(todo.id)}
                          >
                            Add files
                          </Button>
                        )}
                        <Button
                          type="button"
                          variant="ghost"
                          size="icon"
                          aria-label={`Delete "${todo.title}"`}
                          onClick={() => deleteTodo(todo.id)}
                        >
                          <Trash2 className="h-4 w-4" />
                        </Button>
                      </div>
                    </div>

                    {todo.completed && todo.attachments.length > 0 && (
                      <div className="mt-3 space-y-2">
                        <p className="text-muted-foreground text-xs">Attachments</p>
                        <ul className="space-y-1">
                          {todo.attachments.map((a) => (
                            <li
                              key={a.id}
                              className="flex items-center justify-between gap-3 rounded-md bg-muted/30 px-2 py-1"
                            >
                              <div className="flex min-w-0 items-center gap-2">
                                <AttachmentIcon kind={a.kind} />
                                <span className="truncate text-sm">{a.name}</span>
                              </div>
                              <a
                                href={a.url}
                                download={a.name}
                                className="inline-flex items-center gap-1 text-sm font-medium underline underline-offset-4"
                              >
                                <Download className="h-4 w-4" />
                                Download
                              </a>
                            </li>
                          ))}
                        </ul>
                      </div>
                    )}
                  </div>
                ))}
              </div>
            ))
          )}
        </div>

        {groupedTodos.length > 0 && (
          <div className="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
            <div className="flex items-center gap-2">
              <span className="text-muted-foreground text-sm">Items per page</span>
              <Select
                value={String(pageSize)}
                onValueChange={(v) => {
                  const next = Number(v)
                  setPageSize(next)
                  setPage(1)
                }}
              >
                <SelectTrigger className="w-[110px]">
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="5">5</SelectItem>
                  <SelectItem value="10">10</SelectItem>
                  <SelectItem value="15">15</SelectItem>
                  <SelectItem value="20">20</SelectItem>
                </SelectContent>
              </Select>
            </div>

            {showPagination && (
              <div className="flex items-center justify-between gap-3 sm:justify-end">
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={() => setPage((p) => Math.max(1, p - 1))}
                  disabled={page <= 1}
                >
                  Prev
                </Button>
                <span className="text-muted-foreground text-sm">
                  Page {page} of {totalPages}
                </span>
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={() => setPage((p) => Math.min(totalPages, p + 1))}
                  disabled={page >= totalPages}
                >
                  Next
                </Button>
              </div>
            )}
          </div>
        )}

        <div className="flex items-center justify-between gap-2">
          <Button
            type="button"
            variant="secondary"
            onClick={clearCompleted}
            disabled={completedCount === 0}
          >
            Clear completed
          </Button>
          <span className="text-muted-foreground text-sm">
            Mock data only (no backend)
          </span>
        </div>
      </CardContent>
    </Card>
  )
}

```

Good catch: I accidentally inserted a `const state = ...` directly inside JSX, which will break parsing. Next I’ll refactor the `map()` to use a block body so we can compute `state` safely, then re-run build to confirm task badges render correctly.

```typescriptreact
"use client"

import { zodResolver } from "@hookform/resolvers/zod"
import {
  AlertTriangle,
  CalendarClock,
  CheckCircle2,
  Download,
  File,
  FileSpreadsheet,
  FileText,
  Image as ImageIcon,
  Music,
  Timer,
  Trash2,
  Video,
} from "lucide-react"
import * as React from "react"
import { useForm } from "react-hook-form"
import { toast } from "sonner"
import { z } from "zod"

import { ModeToggle } from "@/components/mode-toggle"
import { Badge } from "@/components/ui/badge"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Checkbox } from "@/components/ui/checkbox"
import { Form, FormControl, FormField, FormItem, FormMessage } from "@/components/ui/form"
import { Input } from "@/components/ui/input"
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select"
import { Separator } from "@/components/ui/separator"
import { cn } from "@/lib/utils"

type AttachmentKind =
  | "image"
  | "audio"
  | "video"
  | "pdf"
  | "spreadsheet"
  | "document"
  | "text"
  | "file"

type Attachment = {
  id: string
  name: string
  type: string
  size: number
  url: string
  kind: AttachmentKind
}

type Todo = {
  id: string
  title: string
  completed: boolean
  // Stored as `datetime-local` string (YYYY-MM-DDTHH:mm) in local time.
  dueAt: string
  attachments: Attachment[]
}

type TaskState = "planned" | "in_progress" | "completed" | "overdue"

const todoSchema = z.object({
  title: z
    .string()
    .trim()
    .min(1, "Title is required.")
    .max(80, "Keep it under 80 characters."),
  dueAt: z
    .string()
    .min(1, "Due date & time is required.")
    .regex(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}$/, "Invalid date/time."),
})

type TodoFormValues = z.infer<typeof todoSchema>

const initialTodos: Todo[] = [
  {
    id: "1",
    title: "Create a Next.js app",
    completed: true,
    dueAt: "2026-01-16T09:00",
    attachments: [],
  },
  {
    id: "2",
    title: "Add shadcn/ui + dark theme",
    completed: true,
    dueAt: "2026-01-16T10:30",
    attachments: [],
  },
  {
    id: "3",
    title: "Build a mock-data to-do list",
    completed: false,
    dueAt: "2026-01-16T15:00",
    attachments: [],
  },
  {
    id: "4",
    title: "Yesterday: review requirements",
    completed: true,
    dueAt: "2026-01-15T11:15",
    attachments: [],
  },
  {
    id: "5",
    title: "Yesterday: sketch UI layout",
    completed: true,
    dueAt: "2026-01-15T17:45",
    attachments: [],
  },
  {
    id: "6",
    title: "Today: add attachments support",
    completed: false,
    dueAt: "2026-01-16T18:20",
    attachments: [],
  },
  {
    id: "7",
    title: "Tomorrow: QA the filters",
    completed: false,
    dueAt: "2026-01-17T08:05",
    attachments: [],
  },
  {
    id: "8",
    title: "Tomorrow: polish summary cards",
    completed: false,
    dueAt: "2026-01-17T13:30",
    attachments: [],
  },
  {
    id: "9",
    title: "Tomorrow: write small UX notes",
    completed: false,
    dueAt: "2026-01-17T20:10",
    attachments: [],
  },
  {
    id: "10",
    title: "This weekend: add more mock tasks",
    completed: false,
    dueAt: "2026-01-18T10:00",
    attachments: [],
  },
  {
    id: "11",
    title: "This weekend: check time-only filter",
    completed: false,
    dueAt: "2026-01-18T22:15",
    attachments: [],
  },
  {
    id: "12",
    title: "Next week: sync with team",
    completed: false,
    dueAt: "2026-01-19T09:30",
    attachments: [],
  },
  {
    id: "13",
    title: "Next week: test date-only filter",
    completed: false,
    dueAt: "2026-01-20T14:05",
    attachments: [],
  },
  {
    id: "14",
    title: "Next week: test exact date+time filter",
    completed: false,
    dueAt: "2026-01-21T12:00",
    attachments: [],
  },
  {
    id: "15",
    title: "Next week: attach docs to completed tasks",
    completed: false,
    dueAt: "2026-01-22T16:40",
    attachments: [],
  },
  {
    id: "16",
    title: "Next week: final review",
    completed: false,
    dueAt: "2026-01-23T11:00",
    attachments: [],
  },
]

function parseLocalDateTime(value: string): number {
  // value: "YYYY-MM-DDTHH:mm"
  const [datePart, timePart] = value.split("T")
  const [y, m, d] = datePart.split("-").map(Number)
  const [hh, mm] = timePart.split(":").map(Number)
  return new Date(y, m - 1, d, hh, mm, 0, 0).getTime()
}

function pad2(n: number) {
  return String(n).padStart(2, "0")
}

function localDateKey(d: Date) {
  return `${d.getFullYear()}-${pad2(d.getMonth() + 1)}-${pad2(d.getDate())}`
}

function addDays(date: Date, days: number) {
  const d = new Date(date)
  d.setDate(d.getDate() + days)
  return d
}

function startOfDay(date: Date) {
  return new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0, 0)
}

function endOfDay(date: Date) {
  return new Date(
    date.getFullYear(),
    date.getMonth(),
    date.getDate(),
    23,
    59,
    59,
    999
  )
}

function getDatePart(dueAt: string) {
  return dueAt.split("T")[0] ?? ""
}

function getTimePart(dueAt: string) {
  return dueAt.split("T")[1] ?? ""
}

function parseLocalDateOnly(value: string): Date {
  // value: "YYYY-MM-DD"
  const [y, m, d] = value.split("-").map(Number)
  return new Date(y, m - 1, d, 0, 0, 0, 0)
}

function parseLocalTimeToMinutes(value: string): number {
  // value: "HH:mm"
  const [hh, mm] = value.split(":").map(Number)
  return hh * 60 + mm
}

function formatLocalDateTime(value: string): string {
  const ms = parseLocalDateTime(value)
  if (!Number.isFinite(ms)) return value
  return new Intl.DateTimeFormat(undefined, {
    year: "numeric",
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  }).format(new Date(ms))
}

function formatDateTimeFromMs(ms: number): string {
  return new Intl.DateTimeFormat(undefined, {
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  }).format(new Date(ms))
}

function getTaskState(todo: Todo, nowMs: number): TaskState {
  if (todo.completed) return "completed"
  const dueMs = parseLocalDateTime(todo.dueAt)
  if (dueMs < nowMs) return "overdue"
  if (dueMs <= nowMs + 4 * 60 * 60 * 1000) return "in_progress"
  return "planned"
}

function TaskStateBadge({ state }: { state: TaskState }) {
  switch (state) {
    case "completed":
      return (
        <Badge className="gap-1 bg-emerald-600 text-white hover:bg-emerald-600">
          <CheckCircle2 className="h-3.5 w-3.5" />
          Completed
        </Badge>
      )
    case "overdue":
      return (
        <Badge variant="destructive" className="gap-1">
          <AlertTriangle className="h-3.5 w-3.5" />
          Overdue
        </Badge>
      )
    case "in_progress":
      return (
        <Badge variant="secondary" className="gap-1">
          <Timer className="h-3.5 w-3.5" />
          In progress
        </Badge>
      )
    default:
      return (
        <Badge variant="outline" className="gap-1">
          <CalendarClock className="h-3.5 w-3.5" />
          Planned
        </Badge>
      )
  }
}

function getAttachmentKind(file: File): AttachmentKind {
  const type = (file.type || "").toLowerCase()
  const name = file.name.toLowerCase()
  const ext = name.includes(".") ? name.split(".").pop() ?? "" : ""

  if (type.startsWith("image/")) return "image"
  if (type.startsWith("audio/")) return "audio"
  if (type.startsWith("video/")) return "video"

  if (ext === "pdf") return "pdf"
  if (["xls", "xlsx", "csv"].includes(ext)) return "spreadsheet"
  if (["doc", "docx"].includes(ext)) return "document"
  if (["txt", "md", "rtf"].includes(ext)) return "text"

  return "file"
}

function makeAttachment(file: File): Attachment {
  return {
    id: crypto.randomUUID(),
    name: file.name,
    type: file.type,
    size: file.size,
    url: URL.createObjectURL(file),
    kind: getAttachmentKind(file),
  }
}

function revokeTodoAttachments(todo: Todo) {
  for (const a of todo.attachments) URL.revokeObjectURL(a.url)
}

function AttachmentIcon({ kind }: { kind: AttachmentKind }) {
  const className = "h-4 w-4 text-muted-foreground"

  switch (kind) {
    case "image":
      return <ImageIcon className={className} />
    case "audio":
      return <Music className={className} />
    case "video":
      return <Video className={className} />
    case "spreadsheet":
      return <FileSpreadsheet className={className} />
    case "pdf":
    case "document":
    case "text":
      return <FileText className={className} />
    default:
      return <File className={className} />
  }
}

export default function Home() {
  return (
    <div className="mx-auto flex min-h-screen max-w-2xl flex-col gap-6 px-4 py-10">
      <TodoApp />
    </div>
  )
}

function TodoApp() {
  const [todos, setTodos] = React.useState<Todo[]>(initialTodos)
  const [attachTargetTodoId, setAttachTargetTodoId] = React.useState<string | null>(
    null
  )
  const [conflictDueAt, setConflictDueAt] = React.useState<string | null>(null)
  const clearConflictTimerRef = React.useRef<number | null>(null)
  const [focusMode, setFocusMode] = React.useState(false)
  const [nowMs, setNowMs] = React.useState(() => Date.now())
  const [filterMode, setFilterMode] = React.useState<"between" | "exact">("between")
  const [filterFromDate, setFilterFromDate] = React.useState<string>("")
  const [filterFromTime, setFilterFromTime] = React.useState<string>("")
  const [filterToDate, setFilterToDate] = React.useState<string>("")
  const [filterToTime, setFilterToTime] = React.useState<string>("")
  const [filterExactDate, setFilterExactDate] = React.useState<string>("")
  const [filterExactTime, setFilterExactTime] = React.useState<string>("")
  const fileInputRef = React.useRef<HTMLInputElement>(null)
  const [pageSize, setPageSize] = React.useState<number>(5)
  const [page, setPage] = React.useState<number>(1)

  const todosRef = React.useRef(todos)
  React.useEffect(() => {
    todosRef.current = todos
  }, [todos])
  React.useEffect(() => {
    return () => {
      for (const t of todosRef.current) revokeTodoAttachments(t)
    }
  }, [])

  // Keep "now" fresh so overdue/in-progress states stay accurate without user interaction.
  React.useEffect(() => {
    const id = window.setInterval(() => setNowMs(Date.now()), 30_000)
    return () => window.clearInterval(id)
  }, [])

  const form = useForm<TodoFormValues>({
    resolver: zodResolver(todoSchema),
    defaultValues: { title: "", dueAt: "" },
    mode: "onSubmit",
  })

  const summary = React.useMemo(() => {
    const now = new Date()
    const todayKey = localDateKey(now)
    const tomorrow = addDays(now, 1)
    const tomorrowKey = localDateKey(tomorrow)

    const todays = todos.filter((t) => t.dueAt.startsWith(todayKey))
    const todayCompleted = todays.filter((t) => t.completed).length
    const todayPending = todays.length - todayCompleted

    const labels = [
      "00:00–04:00",
      "04:00–08:00",
      "08:00–12:00",
      "12:00–16:00",
      "16:00–20:00",
      "20:00–24:00",
    ]

    // Tomorrow: same 4-hour windows breakdown
    const tomorrowTasks = todos.filter((t) => t.dueAt.startsWith(tomorrowKey))
    const tomorrowBuckets = Array.from({ length: 6 }, () => 0) as number[]
    for (const t of tomorrowTasks) {
      const ms = parseLocalDateTime(t.dueAt)
      const hour = new Date(ms).getHours()
      const idx = Math.floor(hour / 4)
      tomorrowBuckets[idx] = (tomorrowBuckets[idx] ?? 0) + 1
    }

    // Until next week = next 7 days starting tomorrow (local), grouped into 4-hour windows.
    const rangeStart = startOfDay(tomorrow).getTime()
    const rangeEnd = addDays(startOfDay(tomorrow), 7).getTime()
    const buckets = Array.from({ length: 6 }, () => 0) as number[]

    const upcoming = todos.filter((t) => {
      const ms = parseLocalDateTime(t.dueAt)
      return ms >= rangeStart && ms < rangeEnd
    })

    for (const t of upcoming) {
      const ms = parseLocalDateTime(t.dueAt)
      const hour = new Date(ms).getHours()
      const idx = Math.floor(hour / 4)
      buckets[idx] = (buckets[idx] ?? 0) + 1
    }

    return {
      todayCompleted,
      todayPending,
      tomorrowTotal: tomorrowTasks.length,
      tomorrowBuckets: labels.map((label, i) => ({ label, count: tomorrowBuckets[i] ?? 0 })),
      upcomingTotal: upcoming.length,
      upcomingBuckets: labels.map((label, i) => ({ label, count: buckets[i] ?? 0 })),
    }
  }, [todos])

  const filteredTodos = React.useMemo(() => {
    if (focusMode) {
      const endMs = nowMs + 4 * 60 * 60 * 1000
      const withMs = todos.map((t) => ({ ...t, _dueMs: parseLocalDateTime(t.dueAt) }))
      return withMs.filter((t) => t._dueMs >= nowMs && t._dueMs <= endMs)
    }

    const withMs = todos.map((t) => ({ ...t, _dueMs: parseLocalDateTime(t.dueAt) }))
    if (filterMode === "exact") {
      // If only date is selected -> show tasks for that date.
      // If time is selected too -> match exact date+time.
      // If only time is selected -> match time-of-day across all dates.
      if (!filterExactDate && !filterExactTime) return withMs

      if (filterExactDate && !filterExactTime) {
        return withMs.filter((t) => getDatePart(t.dueAt) === filterExactDate)
      }

      if (filterExactDate && filterExactTime) {
        const exactMs = parseLocalDateTime(`${filterExactDate}T${filterExactTime}`)
        return withMs.filter((t) => t._dueMs === exactMs)
      }

      // time only
      return withMs.filter((t) => getTimePart(t.dueAt) === filterExactTime)
    }
    // between
    const hasAnyDate = Boolean(filterFromDate || filterToDate)
    const hasAnyTime = Boolean(filterFromTime || filterToTime)

    // Date range (optional)
    const fromDateMs = filterFromDate
      ? startOfDay(parseLocalDateOnly(filterFromDate)).getTime()
      : Number.NEGATIVE_INFINITY
    const toDateMs = filterToDate
      ? endOfDay(parseLocalDateOnly(filterToDate)).getTime()
      : Number.POSITIVE_INFINITY

    // Time-of-day range (optional)
    const fromTimeMin = filterFromTime ? parseLocalTimeToMinutes(filterFromTime) : 0
    const toTimeMin = filterToTime ? parseLocalTimeToMinutes(filterToTime) : 24 * 60 - 1

    return withMs.filter((t) => {
      const ms = t._dueMs
      if (hasAnyDate && (ms < fromDateMs || ms > toDateMs)) return false

      if (hasAnyTime) {
        const time = getTimePart(t.dueAt)
        if (!time) return false
        const mins = parseLocalTimeToMinutes(time)
        // Simple (non-wrapping) range. If you want wrap-around (e.g. 22:00–02:00), tell me.
        if (mins < fromTimeMin || mins > toTimeMin) return false
      }

      // If neither date nor time selected, pass through (handled above anyway)
      return true
    })
  }, [
    todos,
    focusMode,
    nowMs,
    filterExactDate,
    filterExactTime,
    filterFromDate,
    filterFromTime,
    filterMode,
    filterToDate,
    filterToTime,
  ])

  const sortedFilteredTodos = React.useMemo(
    () =>
      filteredTodos
        .slice()
        .sort((a, b) => parseLocalDateTime(a.dueAt) - parseLocalDateTime(b.dueAt)),
    [filteredTodos]
  )

  // Clamp page when filters/pageSize change.
  React.useEffect(() => {
    const totalPages = Math.max(1, Math.ceil(sortedFilteredTodos.length / pageSize))
    setPage((p) => Math.min(Math.max(1, p), totalPages))
  }, [pageSize, sortedFilteredTodos.length])

  const totalItems = sortedFilteredTodos.length
  const totalPages = Math.max(1, Math.ceil(totalItems / pageSize))
  const showPagination = totalPages > 1

  const pageItems = React.useMemo(() => {
    const start = (page - 1) * pageSize
    return sortedFilteredTodos.slice(start, start + pageSize)
  }, [page, pageSize, sortedFilteredTodos])

  const groupedTodos = React.useMemo(() => {
    const groups: Array<{ date: string; items: typeof pageItems }> = []
    for (const t of pageItems) {
      const date = getDatePart(t.dueAt)
      const last = groups[groups.length - 1]
      if (!last || last.date !== date) groups.push({ date, items: [t] })
      else last.items.push(t)
    }
    return groups
  }, [pageItems])

  const completedCount = filteredTodos.filter((t) => t.completed).length

  function addTodo(values: TodoFormValues) {
    const conflicts = todos.filter((t) => t.dueAt === values.dueAt)
    if (conflicts.length > 0) {
      setConflictDueAt(values.dueAt)
      if (clearConflictTimerRef.current) window.clearTimeout(clearConflictTimerRef.current)
      clearConflictTimerRef.current = window.setTimeout(() => {
        setConflictDueAt(null)
      }, 8000)

      // Make sure the user can see the conflicting tasks even if they were filtered out.
      const [d, time] = values.dueAt.split("T")
      setFilterMode("exact")
      setFilterExactDate(d ?? "")
      setFilterExactTime(time ?? "")
      setPage(1)

      toast.error("Time conflict", {
        description: `You already have ${conflicts.length} task(s) scheduled at ${formatLocalDateTime(
          values.dueAt
        )}.`,
      })
    }

    setTodos((prev) => [
      {
        id: crypto.randomUUID(),
        title: values.title.trim(),
        completed: false,
        dueAt: values.dueAt,
        attachments: [],
      },
      ...prev,
    ])
    form.reset()
  }

  function toggleTodo(id: string, completed: boolean) {
    setTodos((prev) => prev.map((t) => (t.id === id ? { ...t, completed } : t)))
  }

  function requestAttachmentsForTodo(todoId: string) {
    setAttachTargetTodoId(todoId)
    // Let state update before opening picker (some browsers are picky).
    queueMicrotask(() => fileInputRef.current?.click())
  }

  function handleFilesPicked(e: React.ChangeEvent<HTMLInputElement>) {
    const files = Array.from(e.target.files ?? [])
    const targetId = attachTargetTodoId

    // reset input so picking the same file again triggers onChange
    e.target.value = ""
    setAttachTargetTodoId(null)

    if (!targetId || files.length === 0) return

    const attachments = files.map(makeAttachment)

    setTodos((prev) =>
      prev.map((t) =>
        t.id === targetId
          ? { ...t, attachments: [...t.attachments, ...attachments] }
          : t
      )
    )
  }

  function deleteTodo(id: string) {
    setTodos((prev) => {
      const victim = prev.find((t) => t.id === id)
      if (victim) revokeTodoAttachments(victim)
      return prev.filter((t) => t.id !== id)
    })
  }

  function clearCompleted() {
    setTodos((prev) => {
      for (const t of prev) {
        if (t.completed) revokeTodoAttachments(t)
      }
      return prev.filter((t) => !t.completed)
    })
  }

  return (
    <Card>
      <CardHeader className="flex flex-row items-center justify-between gap-4">
        <div className="space-y-1">
          <CardTitle className="text-2xl">To‑Do</CardTitle>
          <p className="text-muted-foreground text-sm">
            {completedCount}/{filteredTodos.length} completed
          </p>
        </div>
        <div className="flex items-center gap-2">
          <Button
            type="button"
            variant={focusMode ? "default" : "outline"}
            size="sm"
            onClick={() => {
              setFocusMode((v) => !v)
              setPage(1)
            }}
          >
            Focus Mode
          </Button>
          <ModeToggle />
        </div>
      </CardHeader>

      <CardContent className="space-y-6">
        <input
          ref={fileInputRef}
          type="file"
          multiple
          className="hidden"
          accept={[
            "image/*",
            "audio/*",
            "video/*",
            ".pdf",
            ".doc",
            ".docx",
            ".xls",
            ".xlsx",
            ".csv",
            ".txt",
            ".md",
            ".rtf",
          ].join(",")}
          onChange={handleFilesPicked}
        />

        <div className="grid gap-3 sm:grid-cols-3">
          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Today’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">
              {summary.todayCompleted} completed
            </p>
            <p className="text-muted-foreground text-sm">{summary.todayPending} pending</p>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tomorrow’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">{summary.tomorrowTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.tomorrowBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tasks Until Next Week</p>
            <p className="mt-2 text-2xl font-semibold">{summary.upcomingTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.upcomingBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>
        </div>

        {focusMode && (
          <div className="flex flex-col gap-1 rounded-lg border bg-muted/20 px-3 py-2 sm:flex-row sm:items-center sm:justify-between">
            <p className="text-sm">
              <span className="font-medium">Focus Mode:</span>{" "}
              showing tasks due in the next 4 hours (until{" "}
              <span className="font-medium">
                {formatDateTimeFromMs(nowMs + 4 * 60 * 60 * 1000)}
              </span>
              )
            </p>
            <Button type="button" variant="ghost" size="sm" onClick={() => setFocusMode(false)}>
              Exit
            </Button>
          </div>
        )}

        <Form {...form}>
          <form
            onSubmit={form.handleSubmit(addTodo)}
            className="space-y-2"
            noValidate
          >
            <div className="flex flex-col gap-2 sm:flex-row">
              <FormField
                control={form.control}
                name="title"
                render={({ field }) => (
                  <FormItem className="flex-1">
                    <FormControl>
                      <Input
                        placeholder="Add a task…"
                        autoComplete="off"
                        {...field}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="dueAt"
                render={({ field }) => (
                  <FormItem className="sm:w-64">
                    <FormControl>
                      <Input type="datetime-local" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <Button type="submit">Add</Button>
            </div>
          </form>
        </Form>

        <Separator />

        <div className="space-y-3">
          <div className="flex flex-wrap items-center justify-between gap-2">
            <p className="text-sm font-medium">Filter by date & time</p>
            <div className="flex items-center gap-2">
              <Button
                type="button"
                size="sm"
                variant={filterMode === "between" ? "default" : "outline"}
                onClick={() => setFilterMode("between")}
              >
                Between
              </Button>
              <Button
                type="button"
                size="sm"
                variant={filterMode === "exact" ? "default" : "outline"}
                onClick={() => setFilterMode("exact")}
              >
                Exact
              </Button>
              <Button
                type="button"
                size="sm"
                variant="ghost"
                onClick={() => {
                  setFilterFromDate("")
                  setFilterFromTime("")
                  setFilterToDate("")
                  setFilterToTime("")
                  setFilterExactDate("")
                  setFilterExactTime("")
                }}
              >
                Clear
              </Button>
            </div>
          </div>

          {filterMode === "between" ? (
            <div className="grid gap-2 sm:grid-cols-2">
              <div className="grid gap-2 sm:grid-cols-2">
                <Input
                  type="date"
                  value={filterFromDate}
                  onChange={(e) => setFilterFromDate(e.target.value)}
                />
                <Input
                  type="time"
                  value={filterFromTime}
                  onChange={(e) => setFilterFromTime(e.target.value)}
                />
              </div>
              <div className="grid gap-2 sm:grid-cols-2">
                <Input
                  type="date"
                  value={filterToDate}
                  onChange={(e) => setFilterToDate(e.target.value)}
                />
                <Input
                  type="time"
                  value={filterToTime}
                  onChange={(e) => setFilterToTime(e.target.value)}
                />
              </div>
            </div>
          ) : (
            <div className="grid gap-2 sm:grid-cols-2">
              <Input
                type="date"
                value={filterExactDate}
                onChange={(e) => setFilterExactDate(e.target.value)}
              />
              <Input
                type="time"
                value={filterExactTime}
                onChange={(e) => setFilterExactTime(e.target.value)}
              />
            </div>
          )}
        </div>

        <Separator />

        <div className="space-y-2">
          {groupedTodos.length === 0 ? (
            <p className="text-muted-foreground text-sm">No tasks yet.</p>
          ) : (
            groupedTodos.map((group) => (
              <div key={group.date} className="space-y-2">
                <div className="flex items-center gap-3 pt-2">
                  <Separator className="flex-1" />
                  <span className="text-muted-foreground whitespace-nowrap text-xs font-medium">
                    {new Intl.DateTimeFormat(undefined, {
                      weekday: "short",
                      year: "numeric",
                      month: "short",
                      day: "2-digit",
                    }).format(parseLocalDateOnly(group.date))}
                  </span>
                  <Separator className="flex-1" />
                </div>

                {group.items.map((todo) => {
                  const state = getTaskState(todo, nowMs)

                  return (
                    <div
                      key={todo.id}
                      className={cn(
                        "rounded-lg border px-3 py-2",
                        state === "completed" && "opacity-75",
                        state === "overdue" &&
                          "border-destructive/40 bg-destructive/5 text-muted-foreground",
                        state === "in_progress" && "border-primary/30 bg-primary/5",
                        conflictDueAt &&
                          todo.dueAt === conflictDueAt &&
                          "border-destructive/60 bg-destructive/5 ring-1 ring-destructive/30"
                      )}
                    >
                      <div className="flex items-start justify-between gap-3">
                        <label className="flex cursor-pointer items-start gap-3">
                        <Checkbox
                          checked={todo.completed}
                          onCheckedChange={(v) => {
                            const next = Boolean(v)
                            toggleTodo(todo.id, next)
                            if (next && !todo.completed) {
                              requestAttachmentsForTodo(todo.id)
                            }
                          }}
                          aria-label={`Mark "${todo.title}" as ${
                            todo.completed ? "not completed" : "completed"
                          }`}
                          className="mt-0.5"
                        />
                        <span
                          className={cn(
                            "leading-6",
                            todo.completed && "text-muted-foreground line-through"
                          )}
                        >
                          <span className="flex flex-wrap items-center gap-2">
                            <span className="block">{todo.title}</span>
                            <TaskStateBadge state={state} />
                          </span>
                          <span className="text-muted-foreground block text-xs">
                            Due: {formatLocalDateTime(todo.dueAt)}
                          </span>
                        </span>
                      </label>

                      <div className="flex items-center gap-1">
                        {todo.completed && (
                          <Button
                            type="button"
                            variant="outline"
                            size="sm"
                            onClick={() => requestAttachmentsForTodo(todo.id)}
                          >
                            Add files
                          </Button>
                        )}
                        <Button
                          type="button"
                          variant="ghost"
                          size="icon"
                          aria-label={`Delete "${todo.title}"`}
                          onClick={() => deleteTodo(todo.id)}
                        >
                          <Trash2 className="h-4 w-4" />
                        </Button>
                      </div>
                    </div>

                    {todo.completed && todo.attachments.length > 0 && (
                      <div className="mt-3 space-y-2">
                        <p className="text-muted-foreground text-xs">Attachments</p>
                        <ul className="space-y-1">
                          {todo.attachments.map((a) => (
                            <li
                              key={a.id}
                              className="flex items-center justify-between gap-3 rounded-md bg-muted/30 px-2 py-1"
                            >
                              <div className="flex min-w-0 items-center gap-2">
                                <AttachmentIcon kind={a.kind} />
                                <span className="truncate text-sm">{a.name}</span>
                              </div>
                              <a
                                href={a.url}
                                download={a.name}
                                className="inline-flex items-center gap-1 text-sm font-medium underline underline-offset-4"
                              >
                                <Download className="h-4 w-4" />
                                Download
                              </a>
                            </li>
                          ))}
                        </ul>
                      </div>
                    )}
                  </div>
                  )
                })}
              </div>
            ))
          )}
        </div>

        {groupedTodos.length > 0 && (
          <div className="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
            <div className="flex items-center gap-2">
              <span className="text-muted-foreground text-sm">Items per page</span>
              <Select
                value={String(pageSize)}
                onValueChange={(v) => {
                  const next = Number(v)
                  setPageSize(next)
                  setPage(1)
                }}
              >
                <SelectTrigger className="w-[110px]">
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="5">5</SelectItem>
                  <SelectItem value="10">10</SelectItem>
                  <SelectItem value="15">15</SelectItem>
                  <SelectItem value="20">20</SelectItem>
                </SelectContent>
              </Select>
            </div>

            {showPagination && (
              <div className="flex items-center justify-between gap-3 sm:justify-end">
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={() => setPage((p) => Math.max(1, p - 1))}
                  disabled={page <= 1}
                >
                  Prev
                </Button>
                <span className="text-muted-foreground text-sm">
                  Page {page} of {totalPages}
                </span>
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={() => setPage((p) => Math.min(totalPages, p + 1))}
                  disabled={page >= totalPages}
                >
                  Next
                </Button>
              </div>
            )}
          </div>
        )}

        <div className="flex items-center justify-between gap-2">
          <Button
            type="button"
            variant="secondary"
            onClick={clearCompleted}
            disabled={completedCount === 0}
          >
            Clear completed
          </Button>
          <span className="text-muted-foreground text-sm">
            Mock data only (no backend)
          </span>
    </div>
      </CardContent>
    </Card>
  )
}

```

### Overdue + visual task states implemented
- Added **4 states** with clear visual cues (no popups):
  - **Planned**: outline badge
  - **In progress**: highlighted border/background + badge
  - **Completed**: green badge + slightly faded row + existing line-through
  - **Overdue**: red “Overdue” badge + faded red-tinted row (only when **not completed** and `dueAt` is in the past)
- The UI updates automatically (checks “now” every ~30 seconds) so tasks become **Overdue** / **In progress** without refresh.

### Files changed
- **New**: `src/components/ui/badge.tsx`
- **Updated**: `src/app/page.tsx`

---

**User**

Implement a Daily Load Indicator at the top of the page that shows whether the day is Light, Balanced, or Heavy, based on the number of tasks and their scheduled time ranges.

---

**Cursor**

Makes sense. Next I’ll compute a **Daily Load** score for a target day (by default **today**, or the **selected date** if you’ve filtered by date), based on total tasks and how “packed” the 4‑hour time windows are, then show a small indicator badge (Light/Balanced/Heavy) at the top of the page.

Got it—next I’ll add a small “Daily Load” indicator (Light/Balanced/Heavy) above the cards. I’ll base it on tasks scheduled for the chosen day and how concentrated they are in 4‑hour buckets, then validate via build.

Plan: add a daily-load computation (target day = today unless a date filter is set), bucket tasks into 4‑hour windows, classify Light/Balanced/Heavy, then render a compact indicator badge + quick stats above the summary cards. Then I’ll run lint/build to ensure it’s solid.

```typescriptreact
"use client"

import { zodResolver } from "@hookform/resolvers/zod"
import {
  AlertTriangle,
  CalendarClock,
  CheckCircle2,
  Download,
  File,
  FileSpreadsheet,
  FileText,
  Image as ImageIcon,
  Music,
  Timer,
  Trash2,
  Video,
} from "lucide-react"
import * as React from "react"
import { useForm } from "react-hook-form"
import { toast } from "sonner"
import { z } from "zod"

import { ModeToggle } from "@/components/mode-toggle"
import { Badge } from "@/components/ui/badge"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Checkbox } from "@/components/ui/checkbox"
import { Form, FormControl, FormField, FormItem, FormMessage } from "@/components/ui/form"
import { Input } from "@/components/ui/input"
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select"
import { Separator } from "@/components/ui/separator"
import { cn } from "@/lib/utils"

type AttachmentKind =
  | "image"
  | "audio"
  | "video"
  | "pdf"
  | "spreadsheet"
  | "document"
  | "text"
  | "file"

type Attachment = {
  id: string
  name: string
  type: string
  size: number
  url: string
  kind: AttachmentKind
}

type Todo = {
  id: string
  title: string
  completed: boolean
  // Stored as `datetime-local` string (YYYY-MM-DDTHH:mm) in local time.
  dueAt: string
  attachments: Attachment[]
}

type TaskState = "planned" | "in_progress" | "completed" | "overdue"
type DailyLoad = "light" | "balanced" | "heavy"

const todoSchema = z.object({
  title: z
    .string()
    .trim()
    .min(1, "Title is required.")
    .max(80, "Keep it under 80 characters."),
  dueAt: z
    .string()
    .min(1, "Due date & time is required.")
    .regex(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}$/, "Invalid date/time."),
})

type TodoFormValues = z.infer<typeof todoSchema>

const initialTodos: Todo[] = [
  {
    id: "1",
    title: "Create a Next.js app",
    completed: true,
    dueAt: "2026-01-16T09:00",
    attachments: [],
  },
  {
    id: "2",
    title: "Add shadcn/ui + dark theme",
    completed: true,
    dueAt: "2026-01-16T10:30",
    attachments: [],
  },
  {
    id: "3",
    title: "Build a mock-data to-do list",
    completed: false,
    dueAt: "2026-01-16T15:00",
    attachments: [],
  },
  {
    id: "4",
    title: "Yesterday: review requirements",
    completed: true,
    dueAt: "2026-01-15T11:15",
    attachments: [],
  },
  {
    id: "5",
    title: "Yesterday: sketch UI layout",
    completed: true,
    dueAt: "2026-01-15T17:45",
    attachments: [],
  },
  {
    id: "6",
    title: "Today: add attachments support",
    completed: false,
    dueAt: "2026-01-16T18:20",
    attachments: [],
  },
  {
    id: "7",
    title: "Tomorrow: QA the filters",
    completed: false,
    dueAt: "2026-01-17T08:05",
    attachments: [],
  },
  {
    id: "8",
    title: "Tomorrow: polish summary cards",
    completed: false,
    dueAt: "2026-01-17T13:30",
    attachments: [],
  },
  {
    id: "9",
    title: "Tomorrow: write small UX notes",
    completed: false,
    dueAt: "2026-01-17T20:10",
    attachments: [],
  },
  {
    id: "10",
    title: "This weekend: add more mock tasks",
    completed: false,
    dueAt: "2026-01-18T10:00",
    attachments: [],
  },
  {
    id: "11",
    title: "This weekend: check time-only filter",
    completed: false,
    dueAt: "2026-01-18T22:15",
    attachments: [],
  },
  {
    id: "12",
    title: "Next week: sync with team",
    completed: false,
    dueAt: "2026-01-19T09:30",
    attachments: [],
  },
  {
    id: "13",
    title: "Next week: test date-only filter",
    completed: false,
    dueAt: "2026-01-20T14:05",
    attachments: [],
  },
  {
    id: "14",
    title: "Next week: test exact date+time filter",
    completed: false,
    dueAt: "2026-01-21T12:00",
    attachments: [],
  },
  {
    id: "15",
    title: "Next week: attach docs to completed tasks",
    completed: false,
    dueAt: "2026-01-22T16:40",
    attachments: [],
  },
  {
    id: "16",
    title: "Next week: final review",
    completed: false,
    dueAt: "2026-01-23T11:00",
    attachments: [],
  },
]

function parseLocalDateTime(value: string): number {
  // value: "YYYY-MM-DDTHH:mm"
  const [datePart, timePart] = value.split("T")
  const [y, m, d] = datePart.split("-").map(Number)
  const [hh, mm] = timePart.split(":").map(Number)
  return new Date(y, m - 1, d, hh, mm, 0, 0).getTime()
}

function pad2(n: number) {
  return String(n).padStart(2, "0")
}

function localDateKey(d: Date) {
  return `${d.getFullYear()}-${pad2(d.getMonth() + 1)}-${pad2(d.getDate())}`
}

function addDays(date: Date, days: number) {
  const d = new Date(date)
  d.setDate(d.getDate() + days)
  return d
}

function startOfDay(date: Date) {
  return new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0, 0)
}

function endOfDay(date: Date) {
  return new Date(
    date.getFullYear(),
    date.getMonth(),
    date.getDate(),
    23,
    59,
    59,
    999
  )
}

function getDatePart(dueAt: string) {
  return dueAt.split("T")[0] ?? ""
}

function getTimePart(dueAt: string) {
  return dueAt.split("T")[1] ?? ""
}

function parseLocalDateOnly(value: string): Date {
  // value: "YYYY-MM-DD"
  const [y, m, d] = value.split("-").map(Number)
  return new Date(y, m - 1, d, 0, 0, 0, 0)
}

function parseLocalTimeToMinutes(value: string): number {
  // value: "HH:mm"
  const [hh, mm] = value.split(":").map(Number)
  return hh * 60 + mm
}

function formatLocalDateTime(value: string): string {
  const ms = parseLocalDateTime(value)
  if (!Number.isFinite(ms)) return value
  return new Intl.DateTimeFormat(undefined, {
    year: "numeric",
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  }).format(new Date(ms))
}

function formatDateTimeFromMs(ms: number): string {
  return new Intl.DateTimeFormat(undefined, {
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  }).format(new Date(ms))
}

function getTaskState(todo: Todo, nowMs: number): TaskState {
  if (todo.completed) return "completed"
  const dueMs = parseLocalDateTime(todo.dueAt)
  if (dueMs < nowMs) return "overdue"
  if (dueMs <= nowMs + 4 * 60 * 60 * 1000) return "in_progress"
  return "planned"
}

function getDailyLoad(todosForDay: Todo[]) {
  // 4-hour windows across the day (local).
  const labels = [
    "00:00–04:00",
    "04:00–08:00",
    "08:00–12:00",
    "12:00–16:00",
    "16:00–20:00",
    "20:00–24:00",
  ]
  const buckets = Array.from({ length: 6 }, () => 0) as number[]
  for (const t of todosForDay) {
    const ms = parseLocalDateTime(t.dueAt)
    const hour = new Date(ms).getHours()
    const idx = Math.floor(hour / 4)
    buckets[idx] = (buckets[idx] ?? 0) + 1
  }

  const total = todosForDay.length
  const peak = Math.max(0, ...buckets)
  const spread = buckets.filter((c) => c > 0).length
  const busiestIdx = buckets.findIndex((c) => c === peak)
  const busiestWindow = busiestIdx >= 0 ? labels[busiestIdx] : labels[0]

  // Heuristic: more tasks + higher concentration in one window => heavier day.
  const score = total + peak * 1.5 + Math.max(0, spread - 1) * 0.5
  const load: DailyLoad = score <= 5 ? "light" : score <= 10 ? "balanced" : "heavy"

  return { load, total, peak, spread, busiestWindow }
}

function DailyLoadBadge({ load }: { load: DailyLoad }) {
  if (load === "heavy") return <Badge variant="destructive">Heavy</Badge>
  if (load === "balanced") return <Badge variant="secondary">Balanced</Badge>
  return <Badge variant="outline">Light</Badge>
}

function TaskStateBadge({ state }: { state: TaskState }) {
  switch (state) {
    case "completed":
      return (
        <Badge className="gap-1 bg-emerald-600 text-white hover:bg-emerald-600">
          <CheckCircle2 className="h-3.5 w-3.5" />
          Completed
        </Badge>
      )
    case "overdue":
      return (
        <Badge variant="destructive" className="gap-1">
          <AlertTriangle className="h-3.5 w-3.5" />
          Overdue
        </Badge>
      )
    case "in_progress":
      return (
        <Badge variant="secondary" className="gap-1">
          <Timer className="h-3.5 w-3.5" />
          In progress
        </Badge>
      )
    default:
      return (
        <Badge variant="outline" className="gap-1">
          <CalendarClock className="h-3.5 w-3.5" />
          Planned
        </Badge>
      )
  }
}

function getAttachmentKind(file: File): AttachmentKind {
  const type = (file.type || "").toLowerCase()
  const name = file.name.toLowerCase()
  const ext = name.includes(".") ? name.split(".").pop() ?? "" : ""

  if (type.startsWith("image/")) return "image"
  if (type.startsWith("audio/")) return "audio"
  if (type.startsWith("video/")) return "video"

  if (ext === "pdf") return "pdf"
  if (["xls", "xlsx", "csv"].includes(ext)) return "spreadsheet"
  if (["doc", "docx"].includes(ext)) return "document"
  if (["txt", "md", "rtf"].includes(ext)) return "text"

  return "file"
}

function makeAttachment(file: File): Attachment {
  return {
    id: crypto.randomUUID(),
    name: file.name,
    type: file.type,
    size: file.size,
    url: URL.createObjectURL(file),
    kind: getAttachmentKind(file),
  }
}

function revokeTodoAttachments(todo: Todo) {
  for (const a of todo.attachments) URL.revokeObjectURL(a.url)
}

function AttachmentIcon({ kind }: { kind: AttachmentKind }) {
  const className = "h-4 w-4 text-muted-foreground"

  switch (kind) {
    case "image":
      return <ImageIcon className={className} />
    case "audio":
      return <Music className={className} />
    case "video":
      return <Video className={className} />
    case "spreadsheet":
      return <FileSpreadsheet className={className} />
    case "pdf":
    case "document":
    case "text":
      return <FileText className={className} />
    default:
      return <File className={className} />
  }
}

export default function Home() {
  return (
    <div className="mx-auto flex min-h-screen max-w-2xl flex-col gap-6 px-4 py-10">
      <TodoApp />
    </div>
  )
}

function TodoApp() {
  const [todos, setTodos] = React.useState<Todo[]>(initialTodos)
  const [attachTargetTodoId, setAttachTargetTodoId] = React.useState<string | null>(
    null
  )
  const [conflictDueAt, setConflictDueAt] = React.useState<string | null>(null)
  const clearConflictTimerRef = React.useRef<number | null>(null)
  const [focusMode, setFocusMode] = React.useState(false)
  const [nowMs, setNowMs] = React.useState(() => Date.now())
  const [filterMode, setFilterMode] = React.useState<"between" | "exact">("between")
  const [filterFromDate, setFilterFromDate] = React.useState<string>("")
  const [filterFromTime, setFilterFromTime] = React.useState<string>("")
  const [filterToDate, setFilterToDate] = React.useState<string>("")
  const [filterToTime, setFilterToTime] = React.useState<string>("")
  const [filterExactDate, setFilterExactDate] = React.useState<string>("")
  const [filterExactTime, setFilterExactTime] = React.useState<string>("")
  const fileInputRef = React.useRef<HTMLInputElement>(null)
  const [pageSize, setPageSize] = React.useState<number>(5)
  const [page, setPage] = React.useState<number>(1)

  const todosRef = React.useRef(todos)
  React.useEffect(() => {
    todosRef.current = todos
  }, [todos])
  React.useEffect(() => {
    return () => {
      for (const t of todosRef.current) revokeTodoAttachments(t)
    }
  }, [])

  // Keep "now" fresh so overdue/in-progress states stay accurate without user interaction.
  React.useEffect(() => {
    const id = window.setInterval(() => setNowMs(Date.now()), 30_000)
    return () => window.clearInterval(id)
  }, [])

  const form = useForm<TodoFormValues>({
    resolver: zodResolver(todoSchema),
    defaultValues: { title: "", dueAt: "" },
    mode: "onSubmit",
  })

  const summary = React.useMemo(() => {
    const now = new Date()
    const todayKey = localDateKey(now)
    const tomorrow = addDays(now, 1)
    const tomorrowKey = localDateKey(tomorrow)

    const todays = todos.filter((t) => t.dueAt.startsWith(todayKey))
    const todayCompleted = todays.filter((t) => t.completed).length
    const todayPending = todays.length - todayCompleted

    const labels = [
      "00:00–04:00",
      "04:00–08:00",
      "08:00–12:00",
      "12:00–16:00",
      "16:00–20:00",
      "20:00–24:00",
    ]

    // Tomorrow: same 4-hour windows breakdown
    const tomorrowTasks = todos.filter((t) => t.dueAt.startsWith(tomorrowKey))
    const tomorrowBuckets = Array.from({ length: 6 }, () => 0) as number[]
    for (const t of tomorrowTasks) {
      const ms = parseLocalDateTime(t.dueAt)
      const hour = new Date(ms).getHours()
      const idx = Math.floor(hour / 4)
      tomorrowBuckets[idx] = (tomorrowBuckets[idx] ?? 0) + 1
    }

    // Until next week = next 7 days starting tomorrow (local), grouped into 4-hour windows.
    const rangeStart = startOfDay(tomorrow).getTime()
    const rangeEnd = addDays(startOfDay(tomorrow), 7).getTime()
    const buckets = Array.from({ length: 6 }, () => 0) as number[]

    const upcoming = todos.filter((t) => {
      const ms = parseLocalDateTime(t.dueAt)
      return ms >= rangeStart && ms < rangeEnd
    })

    for (const t of upcoming) {
      const ms = parseLocalDateTime(t.dueAt)
      const hour = new Date(ms).getHours()
      const idx = Math.floor(hour / 4)
      buckets[idx] = (buckets[idx] ?? 0) + 1
    }

    return {
      todayCompleted,
      todayPending,
      tomorrowTotal: tomorrowTasks.length,
      tomorrowBuckets: labels.map((label, i) => ({ label, count: tomorrowBuckets[i] ?? 0 })),
      upcomingTotal: upcoming.length,
      upcomingBuckets: labels.map((label, i) => ({ label, count: buckets[i] ?? 0 })),
    }
  }, [todos])

  const loadDayKey = React.useMemo(() => {
    // Prefer an explicitly selected date from filters; otherwise use today.
    if (filterMode === "exact" && filterExactDate) return filterExactDate
    if (filterFromDate && !filterToDate) return filterFromDate
    if (filterFromDate && filterToDate && filterFromDate === filterToDate) return filterFromDate
    if (!filterFromDate && filterToDate) return filterToDate
    return localDateKey(new Date(nowMs))
  }, [filterExactDate, filterFromDate, filterMode, filterToDate, nowMs])

  const dailyLoad = React.useMemo(() => {
    const dayTodos = todos.filter((t) => getDatePart(t.dueAt) === loadDayKey)
    return getDailyLoad(dayTodos)
  }, [loadDayKey, todos])

  const filteredTodos = React.useMemo(() => {
    if (focusMode) {
      const endMs = nowMs + 4 * 60 * 60 * 1000
      const withMs = todos.map((t) => ({ ...t, _dueMs: parseLocalDateTime(t.dueAt) }))
      return withMs.filter((t) => t._dueMs >= nowMs && t._dueMs <= endMs)
    }

    const withMs = todos.map((t) => ({ ...t, _dueMs: parseLocalDateTime(t.dueAt) }))
    if (filterMode === "exact") {
      // If only date is selected -> show tasks for that date.
      // If time is selected too -> match exact date+time.
      // If only time is selected -> match time-of-day across all dates.
      if (!filterExactDate && !filterExactTime) return withMs

      if (filterExactDate && !filterExactTime) {
        return withMs.filter((t) => getDatePart(t.dueAt) === filterExactDate)
      }

      if (filterExactDate && filterExactTime) {
        const exactMs = parseLocalDateTime(`${filterExactDate}T${filterExactTime}`)
        return withMs.filter((t) => t._dueMs === exactMs)
      }

      // time only
      return withMs.filter((t) => getTimePart(t.dueAt) === filterExactTime)
    }
    // between
    const hasAnyDate = Boolean(filterFromDate || filterToDate)
    const hasAnyTime = Boolean(filterFromTime || filterToTime)

    // Date range (optional)
    const fromDateMs = filterFromDate
      ? startOfDay(parseLocalDateOnly(filterFromDate)).getTime()
      : Number.NEGATIVE_INFINITY
    const toDateMs = filterToDate
      ? endOfDay(parseLocalDateOnly(filterToDate)).getTime()
      : Number.POSITIVE_INFINITY

    // Time-of-day range (optional)
    const fromTimeMin = filterFromTime ? parseLocalTimeToMinutes(filterFromTime) : 0
    const toTimeMin = filterToTime ? parseLocalTimeToMinutes(filterToTime) : 24 * 60 - 1

    return withMs.filter((t) => {
      const ms = t._dueMs
      if (hasAnyDate && (ms < fromDateMs || ms > toDateMs)) return false

      if (hasAnyTime) {
        const time = getTimePart(t.dueAt)
        if (!time) return false
        const mins = parseLocalTimeToMinutes(time)
        // Simple (non-wrapping) range. If you want wrap-around (e.g. 22:00–02:00), tell me.
        if (mins < fromTimeMin || mins > toTimeMin) return false
      }

      // If neither date nor time selected, pass through (handled above anyway)
      return true
    })
  }, [
    todos,
    focusMode,
    nowMs,
    filterExactDate,
    filterExactTime,
    filterFromDate,
    filterFromTime,
    filterMode,
    filterToDate,
    filterToTime,
  ])

  const sortedFilteredTodos = React.useMemo(
    () =>
      filteredTodos
        .slice()
        .sort((a, b) => parseLocalDateTime(a.dueAt) - parseLocalDateTime(b.dueAt)),
    [filteredTodos]
  )

  // Clamp page when filters/pageSize change.
  React.useEffect(() => {
    const totalPages = Math.max(1, Math.ceil(sortedFilteredTodos.length / pageSize))
    setPage((p) => Math.min(Math.max(1, p), totalPages))
  }, [pageSize, sortedFilteredTodos.length])

  const totalItems = sortedFilteredTodos.length
  const totalPages = Math.max(1, Math.ceil(totalItems / pageSize))
  const showPagination = totalPages > 1

  const pageItems = React.useMemo(() => {
    const start = (page - 1) * pageSize
    return sortedFilteredTodos.slice(start, start + pageSize)
  }, [page, pageSize, sortedFilteredTodos])

  const groupedTodos = React.useMemo(() => {
    const groups: Array<{ date: string; items: typeof pageItems }> = []
    for (const t of pageItems) {
      const date = getDatePart(t.dueAt)
      const last = groups[groups.length - 1]
      if (!last || last.date !== date) groups.push({ date, items: [t] })
      else last.items.push(t)
    }
    return groups
  }, [pageItems])

  const completedCount = filteredTodos.filter((t) => t.completed).length

  function addTodo(values: TodoFormValues) {
    const conflicts = todos.filter((t) => t.dueAt === values.dueAt)
    if (conflicts.length > 0) {
      setConflictDueAt(values.dueAt)
      if (clearConflictTimerRef.current) window.clearTimeout(clearConflictTimerRef.current)
      clearConflictTimerRef.current = window.setTimeout(() => {
        setConflictDueAt(null)
      }, 8000)

      // Make sure the user can see the conflicting tasks even if they were filtered out.
      const [d, time] = values.dueAt.split("T")
      setFilterMode("exact")
      setFilterExactDate(d ?? "")
      setFilterExactTime(time ?? "")
      setPage(1)

      toast.error("Time conflict", {
        description: `You already have ${conflicts.length} task(s) scheduled at ${formatLocalDateTime(
          values.dueAt
        )}.`,
      })
    }

    setTodos((prev) => [
      {
        id: crypto.randomUUID(),
        title: values.title.trim(),
        completed: false,
        dueAt: values.dueAt,
        attachments: [],
      },
      ...prev,
    ])
    form.reset()
  }

  function toggleTodo(id: string, completed: boolean) {
    setTodos((prev) => prev.map((t) => (t.id === id ? { ...t, completed } : t)))
  }

  function requestAttachmentsForTodo(todoId: string) {
    setAttachTargetTodoId(todoId)
    // Let state update before opening picker (some browsers are picky).
    queueMicrotask(() => fileInputRef.current?.click())
  }

  function handleFilesPicked(e: React.ChangeEvent<HTMLInputElement>) {
    const files = Array.from(e.target.files ?? [])
    const targetId = attachTargetTodoId

    // reset input so picking the same file again triggers onChange
    e.target.value = ""
    setAttachTargetTodoId(null)

    if (!targetId || files.length === 0) return

    const attachments = files.map(makeAttachment)

    setTodos((prev) =>
      prev.map((t) =>
        t.id === targetId
          ? { ...t, attachments: [...t.attachments, ...attachments] }
          : t
      )
    )
  }

  function deleteTodo(id: string) {
    setTodos((prev) => {
      const victim = prev.find((t) => t.id === id)
      if (victim) revokeTodoAttachments(victim)
      return prev.filter((t) => t.id !== id)
    })
  }

  function clearCompleted() {
    setTodos((prev) => {
      for (const t of prev) {
        if (t.completed) revokeTodoAttachments(t)
      }
      return prev.filter((t) => !t.completed)
    })
  }

  return (
    <Card>
      <CardHeader className="flex flex-row items-center justify-between gap-4">
        <div className="space-y-1">
          <CardTitle className="text-2xl">To‑Do</CardTitle>
          <p className="text-muted-foreground text-sm">
            {completedCount}/{filteredTodos.length} completed
          </p>
        </div>
        <div className="flex items-center gap-2">
          <Button
            type="button"
            variant={focusMode ? "default" : "outline"}
            size="sm"
            onClick={() => {
              setFocusMode((v) => !v)
              setPage(1)
            }}
          >
            Focus Mode
          </Button>
          <ModeToggle />
        </div>
      </CardHeader>

      <CardContent className="space-y-6">
        <input
          ref={fileInputRef}
          type="file"
          multiple
          className="hidden"
          accept={[
            "image/*",
            "audio/*",
            "video/*",
            ".pdf",
            ".doc",
            ".docx",
            ".xls",
            ".xlsx",
            ".csv",
            ".txt",
            ".md",
            ".rtf",
          ].join(",")}
          onChange={handleFilesPicked}
        />

        <div className="rounded-xl border bg-card p-4">
          <div className="flex flex-wrap items-center justify-between gap-2">
            <p className="text-sm font-medium">
              Daily load{" "}
              <span className="text-muted-foreground font-normal">
                ({new Intl.DateTimeFormat(undefined, {
                  weekday: "short",
                  year: "numeric",
                  month: "short",
                  day: "2-digit",
                }).format(parseLocalDateOnly(loadDayKey))})
              </span>
            </p>
            <DailyLoadBadge load={dailyLoad.load} />
          </div>
          <p className="text-muted-foreground mt-2 text-sm">
            {dailyLoad.total} task(s) · busiest window {dailyLoad.busiestWindow} ({dailyLoad.peak})
          </p>
        </div>

        <div className="grid gap-3 sm:grid-cols-3">
          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Today’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">
              {summary.todayCompleted} completed
            </p>
            <p className="text-muted-foreground text-sm">{summary.todayPending} pending</p>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tomorrow’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">{summary.tomorrowTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.tomorrowBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tasks Until Next Week</p>
            <p className="mt-2 text-2xl font-semibold">{summary.upcomingTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.upcomingBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>
        </div>

        {focusMode && (
          <div className="flex flex-col gap-1 rounded-lg border bg-muted/20 px-3 py-2 sm:flex-row sm:items-center sm:justify-between">
            <p className="text-sm">
              <span className="font-medium">Focus Mode:</span>{" "}
              showing tasks due in the next 4 hours (until{" "}
              <span className="font-medium">
                {formatDateTimeFromMs(nowMs + 4 * 60 * 60 * 1000)}
              </span>
              )
            </p>
            <Button type="button" variant="ghost" size="sm" onClick={() => setFocusMode(false)}>
              Exit
            </Button>
          </div>
        )}

        <Form {...form}>
          <form
            onSubmit={form.handleSubmit(addTodo)}
            className="space-y-2"
            noValidate
          >
            <div className="flex flex-col gap-2 sm:flex-row">
              <FormField
                control={form.control}
                name="title"
                render={({ field }) => (
                  <FormItem className="flex-1">
                    <FormControl>
                      <Input
                        placeholder="Add a task…"
                        autoComplete="off"
                        {...field}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="dueAt"
                render={({ field }) => (
                  <FormItem className="sm:w-64">
                    <FormControl>
                      <Input type="datetime-local" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <Button type="submit">Add</Button>
            </div>
          </form>
        </Form>

        <Separator />

        <div className="space-y-3">
          <div className="flex flex-wrap items-center justify-between gap-2">
            <p className="text-sm font-medium">Filter by date & time</p>
            <div className="flex items-center gap-2">
              <Button
                type="button"
                size="sm"
                variant={filterMode === "between" ? "default" : "outline"}
                onClick={() => setFilterMode("between")}
              >
                Between
              </Button>
              <Button
                type="button"
                size="sm"
                variant={filterMode === "exact" ? "default" : "outline"}
                onClick={() => setFilterMode("exact")}
              >
                Exact
              </Button>
              <Button
                type="button"
                size="sm"
                variant="ghost"
                onClick={() => {
                  setFilterFromDate("")
                  setFilterFromTime("")
                  setFilterToDate("")
                  setFilterToTime("")
                  setFilterExactDate("")
                  setFilterExactTime("")
                }}
              >
                Clear
              </Button>
            </div>
          </div>

          {filterMode === "between" ? (
            <div className="grid gap-2 sm:grid-cols-2">
              <div className="grid gap-2 sm:grid-cols-2">
                <Input
                  type="date"
                  value={filterFromDate}
                  onChange={(e) => setFilterFromDate(e.target.value)}
                />
                <Input
                  type="time"
                  value={filterFromTime}
                  onChange={(e) => setFilterFromTime(e.target.value)}
                />
              </div>
              <div className="grid gap-2 sm:grid-cols-2">
                <Input
                  type="date"
                  value={filterToDate}
                  onChange={(e) => setFilterToDate(e.target.value)}
                />
                <Input
                  type="time"
                  value={filterToTime}
                  onChange={(e) => setFilterToTime(e.target.value)}
                />
              </div>
            </div>
          ) : (
            <div className="grid gap-2 sm:grid-cols-2">
              <Input
                type="date"
                value={filterExactDate}
                onChange={(e) => setFilterExactDate(e.target.value)}
              />
              <Input
                type="time"
                value={filterExactTime}
                onChange={(e) => setFilterExactTime(e.target.value)}
              />
            </div>
          )}
        </div>

        <Separator />

        <div className="space-y-2">
          {groupedTodos.length === 0 ? (
            <p className="text-muted-foreground text-sm">No tasks yet.</p>
          ) : (
            groupedTodos.map((group) => (
              <div key={group.date} className="space-y-2">
                <div className="flex items-center gap-3 pt-2">
                  <Separator className="flex-1" />
                  <span className="text-muted-foreground whitespace-nowrap text-xs font-medium">
                    {new Intl.DateTimeFormat(undefined, {
                      weekday: "short",
                      year: "numeric",
                      month: "short",
                      day: "2-digit",
                    }).format(parseLocalDateOnly(group.date))}
                  </span>
                  <Separator className="flex-1" />
                </div>

                {group.items.map((todo) => {
                  const state = getTaskState(todo, nowMs)

                  return (
                    <div
                      key={todo.id}
                      className={cn(
                        "rounded-lg border px-3 py-2",
                        state === "completed" && "opacity-75",
                        state === "overdue" &&
                          "border-destructive/40 bg-destructive/5 text-muted-foreground",
                        state === "in_progress" && "border-primary/30 bg-primary/5",
                        conflictDueAt &&
                          todo.dueAt === conflictDueAt &&
                          "border-destructive/60 bg-destructive/5 ring-1 ring-destructive/30"
                      )}
                    >
                      <div className="flex items-start justify-between gap-3">
                        <label className="flex cursor-pointer items-start gap-3">
                        <Checkbox
                          checked={todo.completed}
                          onCheckedChange={(v) => {
                            const next = Boolean(v)
                            toggleTodo(todo.id, next)
                            if (next && !todo.completed) {
                              requestAttachmentsForTodo(todo.id)
                            }
                          }}
                          aria-label={`Mark "${todo.title}" as ${
                            todo.completed ? "not completed" : "completed"
                          }`}
                          className="mt-0.5"
                        />
                        <span
                          className={cn(
                            "leading-6",
                            todo.completed && "text-muted-foreground line-through"
                          )}
                        >
                          <span className="flex flex-wrap items-center gap-2">
                            <span className="block">{todo.title}</span>
                            <TaskStateBadge state={state} />
                          </span>
                          <span className="text-muted-foreground block text-xs">
                            Due: {formatLocalDateTime(todo.dueAt)}
                          </span>
                        </span>
                      </label>

                      <div className="flex items-center gap-1">
                        {todo.completed && (
                          <Button
                            type="button"
                            variant="outline"
                            size="sm"
                            onClick={() => requestAttachmentsForTodo(todo.id)}
                          >
                            Add files
                          </Button>
                        )}
                        <Button
                          type="button"
                          variant="ghost"
                          size="icon"
                          aria-label={`Delete "${todo.title}"`}
                          onClick={() => deleteTodo(todo.id)}
                        >
                          <Trash2 className="h-4 w-4" />
                        </Button>
                      </div>
                    </div>

                    {todo.completed && todo.attachments.length > 0 && (
                      <div className="mt-3 space-y-2">
                        <p className="text-muted-foreground text-xs">Attachments</p>
                        <ul className="space-y-1">
                          {todo.attachments.map((a) => (
                            <li
                              key={a.id}
                              className="flex items-center justify-between gap-3 rounded-md bg-muted/30 px-2 py-1"
                            >
                              <div className="flex min-w-0 items-center gap-2">
                                <AttachmentIcon kind={a.kind} />
                                <span className="truncate text-sm">{a.name}</span>
                              </div>
                              <a
                                href={a.url}
                                download={a.name}
                                className="inline-flex items-center gap-1 text-sm font-medium underline underline-offset-4"
                              >
                                <Download className="h-4 w-4" />
                                Download
                              </a>
                            </li>
                          ))}
                        </ul>
                      </div>
                    )}
                  </div>
                  )
                })}
              </div>
            ))
          )}
        </div>

        {groupedTodos.length > 0 && (
          <div className="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
            <div className="flex items-center gap-2">
              <span className="text-muted-foreground text-sm">Items per page</span>
              <Select
                value={String(pageSize)}
                onValueChange={(v) => {
                  const next = Number(v)
                  setPageSize(next)
                  setPage(1)
                }}
              >
                <SelectTrigger className="w-[110px]">
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="5">5</SelectItem>
                  <SelectItem value="10">10</SelectItem>
                  <SelectItem value="15">15</SelectItem>
                  <SelectItem value="20">20</SelectItem>
                </SelectContent>
              </Select>
            </div>

            {showPagination && (
              <div className="flex items-center justify-between gap-3 sm:justify-end">
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={() => setPage((p) => Math.max(1, p - 1))}
                  disabled={page <= 1}
                >
                  Prev
                </Button>
                <span className="text-muted-foreground text-sm">
                  Page {page} of {totalPages}
                </span>
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={() => setPage((p) => Math.min(totalPages, p + 1))}
                  disabled={page >= totalPages}
                >
                  Next
                </Button>
              </div>
            )}
          </div>
        )}

        <div className="flex items-center justify-between gap-2">
          <Button
            type="button"
            variant="secondary"
            onClick={clearCompleted}
            disabled={completedCount === 0}
          >
            Clear completed
          </Button>
          <span className="text-muted-foreground text-sm">
            Mock data only (no backend)
          </span>
    </div>
      </CardContent>
    </Card>
  )
}

```

### Daily Load Indicator added
- Added a **Daily Load** panel at the top of the page showing **Light / Balanced / Heavy**.
- It’s calculated from tasks on the selected day using **4‑hour time buckets** (how many tasks + how concentrated they are).
- The indicator uses:
  - **Today** by default
  - If you select a date in filters, it uses that **date** as the “target day”
- Also shows quick details: **total tasks** + **busiest 4‑hour window** and its count.

### File updated
- `src/app/page.tsx`

---

**User**

Show a non-intrusive in-app reminder as the next task start time approaches.

---

**Cursor**

Makes sense. I’ll implement a small **in-app reminder banner** (no toast) that appears when the **next upcoming, not-completed task** is within a short “approaching” window (e.g., 15 minutes). It’ll auto-update with time and allow a simple **Dismiss** per task. Next I’ll add shadcn’s `Alert` component and wire the reminder into `src/app/page.tsx`.

```typescriptreact
"use client"

import { zodResolver } from "@hookform/resolvers/zod"
import {
  AlertTriangle,
  CalendarClock,
  CheckCircle2,
  Download,
  File,
  FileSpreadsheet,
  FileText,
  Image as ImageIcon,
  Music,
  Bell,
  Timer,
  Trash2,
  Video,
} from "lucide-react"
import * as React from "react"
import { useForm } from "react-hook-form"
import { toast } from "sonner"
import { z } from "zod"

import { ModeToggle } from "@/components/mode-toggle"
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert"
import { Badge } from "@/components/ui/badge"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Checkbox } from "@/components/ui/checkbox"
import { Form, FormControl, FormField, FormItem, FormMessage } from "@/components/ui/form"
import { Input } from "@/components/ui/input"
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select"
import { Separator } from "@/components/ui/separator"
import { cn } from "@/lib/utils"

type AttachmentKind =
  | "image"
  | "audio"
  | "video"
  | "pdf"
  | "spreadsheet"
  | "document"
  | "text"
  | "file"

type Attachment = {
  id: string
  name: string
  type: string
  size: number
  url: string
  kind: AttachmentKind
}

type Todo = {
  id: string
  title: string
  completed: boolean
  // Stored as `datetime-local` string (YYYY-MM-DDTHH:mm) in local time.
  dueAt: string
  attachments: Attachment[]
}

type TaskState = "planned" | "in_progress" | "completed" | "overdue"
type DailyLoad = "light" | "balanced" | "heavy"

const todoSchema = z.object({
  title: z
    .string()
    .trim()
    .min(1, "Title is required.")
    .max(80, "Keep it under 80 characters."),
  dueAt: z
    .string()
    .min(1, "Due date & time is required.")
    .regex(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}$/, "Invalid date/time."),
})

type TodoFormValues = z.infer<typeof todoSchema>

const initialTodos: Todo[] = [
  {
    id: "1",
    title: "Create a Next.js app",
    completed: true,
    dueAt: "2026-01-16T09:00",
    attachments: [],
  },
  {
    id: "2",
    title: "Add shadcn/ui + dark theme",
    completed: true,
    dueAt: "2026-01-16T10:30",
    attachments: [],
  },
  {
    id: "3",
    title: "Build a mock-data to-do list",
    completed: false,
    dueAt: "2026-01-16T15:00",
    attachments: [],
  },
  {
    id: "4",
    title: "Yesterday: review requirements",
    completed: true,
    dueAt: "2026-01-15T11:15",
    attachments: [],
  },
  {
    id: "5",
    title: "Yesterday: sketch UI layout",
    completed: true,
    dueAt: "2026-01-15T17:45",
    attachments: [],
  },
  {
    id: "6",
    title: "Today: add attachments support",
    completed: false,
    dueAt: "2026-01-16T18:20",
    attachments: [],
  },
  {
    id: "7",
    title: "Tomorrow: QA the filters",
    completed: false,
    dueAt: "2026-01-17T08:05",
    attachments: [],
  },
  {
    id: "8",
    title: "Tomorrow: polish summary cards",
    completed: false,
    dueAt: "2026-01-17T13:30",
    attachments: [],
  },
  {
    id: "9",
    title: "Tomorrow: write small UX notes",
    completed: false,
    dueAt: "2026-01-17T20:10",
    attachments: [],
  },
  {
    id: "10",
    title: "This weekend: add more mock tasks",
    completed: false,
    dueAt: "2026-01-18T10:00",
    attachments: [],
  },
  {
    id: "11",
    title: "This weekend: check time-only filter",
    completed: false,
    dueAt: "2026-01-18T22:15",
    attachments: [],
  },
  {
    id: "12",
    title: "Next week: sync with team",
    completed: false,
    dueAt: "2026-01-19T09:30",
    attachments: [],
  },
  {
    id: "13",
    title: "Next week: test date-only filter",
    completed: false,
    dueAt: "2026-01-20T14:05",
    attachments: [],
  },
  {
    id: "14",
    title: "Next week: test exact date+time filter",
    completed: false,
    dueAt: "2026-01-21T12:00",
    attachments: [],
  },
  {
    id: "15",
    title: "Next week: attach docs to completed tasks",
    completed: false,
    dueAt: "2026-01-22T16:40",
    attachments: [],
  },
  {
    id: "16",
    title: "Next week: final review",
    completed: false,
    dueAt: "2026-01-23T11:00",
    attachments: [],
  },
]

function parseLocalDateTime(value: string): number {
  // value: "YYYY-MM-DDTHH:mm"
  const [datePart, timePart] = value.split("T")
  const [y, m, d] = datePart.split("-").map(Number)
  const [hh, mm] = timePart.split(":").map(Number)
  return new Date(y, m - 1, d, hh, mm, 0, 0).getTime()
}

function pad2(n: number) {
  return String(n).padStart(2, "0")
}

function localDateKey(d: Date) {
  return `${d.getFullYear()}-${pad2(d.getMonth() + 1)}-${pad2(d.getDate())}`
}

function addDays(date: Date, days: number) {
  const d = new Date(date)
  d.setDate(d.getDate() + days)
  return d
}

function startOfDay(date: Date) {
  return new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0, 0)
}

function endOfDay(date: Date) {
  return new Date(
    date.getFullYear(),
    date.getMonth(),
    date.getDate(),
    23,
    59,
    59,
    999
  )
}

function getDatePart(dueAt: string) {
  return dueAt.split("T")[0] ?? ""
}

function getTimePart(dueAt: string) {
  return dueAt.split("T")[1] ?? ""
}

function parseLocalDateOnly(value: string): Date {
  // value: "YYYY-MM-DD"
  const [y, m, d] = value.split("-").map(Number)
  return new Date(y, m - 1, d, 0, 0, 0, 0)
}

function parseLocalTimeToMinutes(value: string): number {
  // value: "HH:mm"
  const [hh, mm] = value.split(":").map(Number)
  return hh * 60 + mm
}

function formatLocalDateTime(value: string): string {
  const ms = parseLocalDateTime(value)
  if (!Number.isFinite(ms)) return value
  return new Intl.DateTimeFormat(undefined, {
    year: "numeric",
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  }).format(new Date(ms))
}

function formatDateTimeFromMs(ms: number): string {
  return new Intl.DateTimeFormat(undefined, {
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  }).format(new Date(ms))
}

function minutesUntil(targetMs: number, nowMs: number) {
  return Math.ceil((targetMs - nowMs) / 60_000)
}

function getTaskState(todo: Todo, nowMs: number): TaskState {
  if (todo.completed) return "completed"
  const dueMs = parseLocalDateTime(todo.dueAt)
  if (dueMs < nowMs) return "overdue"
  if (dueMs <= nowMs + 4 * 60 * 60 * 1000) return "in_progress"
  return "planned"
}

function getDailyLoad(todosForDay: Todo[]) {
  // 4-hour windows across the day (local).
  const labels = [
    "00:00–04:00",
    "04:00–08:00",
    "08:00–12:00",
    "12:00–16:00",
    "16:00–20:00",
    "20:00–24:00",
  ]
  const buckets = Array.from({ length: 6 }, () => 0) as number[]
  for (const t of todosForDay) {
    const ms = parseLocalDateTime(t.dueAt)
    const hour = new Date(ms).getHours()
    const idx = Math.floor(hour / 4)
    buckets[idx] = (buckets[idx] ?? 0) + 1
  }

  const total = todosForDay.length
  const peak = Math.max(0, ...buckets)
  const spread = buckets.filter((c) => c > 0).length
  const busiestIdx = buckets.findIndex((c) => c === peak)
  const busiestWindow = busiestIdx >= 0 ? labels[busiestIdx] : labels[0]

  // Heuristic: more tasks + higher concentration in one window => heavier day.
  const score = total + peak * 1.5 + Math.max(0, spread - 1) * 0.5
  const load: DailyLoad = score <= 5 ? "light" : score <= 10 ? "balanced" : "heavy"

  return { load, total, peak, spread, busiestWindow }
}

function DailyLoadBadge({ load }: { load: DailyLoad }) {
  if (load === "heavy") return <Badge variant="destructive">Heavy</Badge>
  if (load === "balanced") return <Badge variant="secondary">Balanced</Badge>
  return <Badge variant="outline">Light</Badge>
}

function TaskStateBadge({ state }: { state: TaskState }) {
  switch (state) {
    case "completed":
      return (
        <Badge className="gap-1 bg-emerald-600 text-white hover:bg-emerald-600">
          <CheckCircle2 className="h-3.5 w-3.5" />
          Completed
        </Badge>
      )
    case "overdue":
      return (
        <Badge variant="destructive" className="gap-1">
          <AlertTriangle className="h-3.5 w-3.5" />
          Overdue
        </Badge>
      )
    case "in_progress":
      return (
        <Badge variant="secondary" className="gap-1">
          <Timer className="h-3.5 w-3.5" />
          In progress
        </Badge>
      )
    default:
      return (
        <Badge variant="outline" className="gap-1">
          <CalendarClock className="h-3.5 w-3.5" />
          Planned
        </Badge>
      )
  }
}

function getAttachmentKind(file: File): AttachmentKind {
  const type = (file.type || "").toLowerCase()
  const name = file.name.toLowerCase()
  const ext = name.includes(".") ? name.split(".").pop() ?? "" : ""

  if (type.startsWith("image/")) return "image"
  if (type.startsWith("audio/")) return "audio"
  if (type.startsWith("video/")) return "video"

  if (ext === "pdf") return "pdf"
  if (["xls", "xlsx", "csv"].includes(ext)) return "spreadsheet"
  if (["doc", "docx"].includes(ext)) return "document"
  if (["txt", "md", "rtf"].includes(ext)) return "text"

  return "file"
}

function makeAttachment(file: File): Attachment {
  return {
    id: crypto.randomUUID(),
    name: file.name,
    type: file.type,
    size: file.size,
    url: URL.createObjectURL(file),
    kind: getAttachmentKind(file),
  }
}

function revokeTodoAttachments(todo: Todo) {
  for (const a of todo.attachments) URL.revokeObjectURL(a.url)
}

function AttachmentIcon({ kind }: { kind: AttachmentKind }) {
  const className = "h-4 w-4 text-muted-foreground"

  switch (kind) {
    case "image":
      return <ImageIcon className={className} />
    case "audio":
      return <Music className={className} />
    case "video":
      return <Video className={className} />
    case "spreadsheet":
      return <FileSpreadsheet className={className} />
    case "pdf":
    case "document":
    case "text":
      return <FileText className={className} />
    default:
      return <File className={className} />
  }
}

export default function Home() {
  return (
    <div className="mx-auto flex min-h-screen max-w-2xl flex-col gap-6 px-4 py-10">
      <TodoApp />
    </div>
  )
}

function TodoApp() {
  const [todos, setTodos] = React.useState<Todo[]>(initialTodos)
  const [attachTargetTodoId, setAttachTargetTodoId] = React.useState<string | null>(
    null
  )
  const [conflictDueAt, setConflictDueAt] = React.useState<string | null>(null)
  const clearConflictTimerRef = React.useRef<number | null>(null)
  const [focusMode, setFocusMode] = React.useState(false)
  const [nowMs, setNowMs] = React.useState(() => Date.now())
  const [dismissedReminderTaskId, setDismissedReminderTaskId] = React.useState<
    string | null
  >(null)
  const [filterMode, setFilterMode] = React.useState<"between" | "exact">("between")
  const [filterFromDate, setFilterFromDate] = React.useState<string>("")
  const [filterFromTime, setFilterFromTime] = React.useState<string>("")
  const [filterToDate, setFilterToDate] = React.useState<string>("")
  const [filterToTime, setFilterToTime] = React.useState<string>("")
  const [filterExactDate, setFilterExactDate] = React.useState<string>("")
  const [filterExactTime, setFilterExactTime] = React.useState<string>("")
  const fileInputRef = React.useRef<HTMLInputElement>(null)
  const [pageSize, setPageSize] = React.useState<number>(5)
  const [page, setPage] = React.useState<number>(1)

  const todosRef = React.useRef(todos)
  React.useEffect(() => {
    todosRef.current = todos
  }, [todos])
  React.useEffect(() => {
    return () => {
      for (const t of todosRef.current) revokeTodoAttachments(t)
    }
  }, [])

  // Keep "now" fresh so overdue/in-progress states stay accurate without user interaction.
  React.useEffect(() => {
    const id = window.setInterval(() => setNowMs(Date.now()), 30_000)
    return () => window.clearInterval(id)
  }, [])

  const nextUpcoming = React.useMemo(() => {
    const upcoming = todos
      .filter((t) => !t.completed)
      .map((t) => ({ todo: t, dueMs: parseLocalDateTime(t.dueAt) }))
      .filter((x) => x.dueMs >= nowMs)
      .sort((a, b) => a.dueMs - b.dueMs)[0]
    return upcoming ?? null
  }, [nowMs, todos])

  React.useEffect(() => {
    // If "next upcoming" changed, allow reminder again (dismiss is per-task).
    if (nextUpcoming && nextUpcoming.todo.id !== dismissedReminderTaskId) return
    if (!nextUpcoming) setDismissedReminderTaskId(null)
  }, [dismissedReminderTaskId, nextUpcoming])

  const reminder = React.useMemo(() => {
    const REMINDER_WINDOW_MIN = 15
    if (!nextUpcoming) return null
    if (dismissedReminderTaskId === nextUpcoming.todo.id) return null
    const mins = minutesUntil(nextUpcoming.dueMs, nowMs)
    if (mins < 0 || mins > REMINDER_WINDOW_MIN) return null
    return { ...nextUpcoming, mins }
  }, [dismissedReminderTaskId, nextUpcoming, nowMs])

  const form = useForm<TodoFormValues>({
    resolver: zodResolver(todoSchema),
    defaultValues: { title: "", dueAt: "" },
    mode: "onSubmit",
  })

  const summary = React.useMemo(() => {
    const now = new Date()
    const todayKey = localDateKey(now)
    const tomorrow = addDays(now, 1)
    const tomorrowKey = localDateKey(tomorrow)

    const todays = todos.filter((t) => t.dueAt.startsWith(todayKey))
    const todayCompleted = todays.filter((t) => t.completed).length
    const todayPending = todays.length - todayCompleted

    const labels = [
      "00:00–04:00",
      "04:00–08:00",
      "08:00–12:00",
      "12:00–16:00",
      "16:00–20:00",
      "20:00–24:00",
    ]

    // Tomorrow: same 4-hour windows breakdown
    const tomorrowTasks = todos.filter((t) => t.dueAt.startsWith(tomorrowKey))
    const tomorrowBuckets = Array.from({ length: 6 }, () => 0) as number[]
    for (const t of tomorrowTasks) {
      const ms = parseLocalDateTime(t.dueAt)
      const hour = new Date(ms).getHours()
      const idx = Math.floor(hour / 4)
      tomorrowBuckets[idx] = (tomorrowBuckets[idx] ?? 0) + 1
    }

    // Until next week = next 7 days starting tomorrow (local), grouped into 4-hour windows.
    const rangeStart = startOfDay(tomorrow).getTime()
    const rangeEnd = addDays(startOfDay(tomorrow), 7).getTime()
    const buckets = Array.from({ length: 6 }, () => 0) as number[]

    const upcoming = todos.filter((t) => {
      const ms = parseLocalDateTime(t.dueAt)
      return ms >= rangeStart && ms < rangeEnd
    })

    for (const t of upcoming) {
      const ms = parseLocalDateTime(t.dueAt)
      const hour = new Date(ms).getHours()
      const idx = Math.floor(hour / 4)
      buckets[idx] = (buckets[idx] ?? 0) + 1
    }

    return {
      todayCompleted,
      todayPending,
      tomorrowTotal: tomorrowTasks.length,
      tomorrowBuckets: labels.map((label, i) => ({ label, count: tomorrowBuckets[i] ?? 0 })),
      upcomingTotal: upcoming.length,
      upcomingBuckets: labels.map((label, i) => ({ label, count: buckets[i] ?? 0 })),
    }
  }, [todos])

  const loadDayKey = React.useMemo(() => {
    // Prefer an explicitly selected date from filters; otherwise use today.
    if (filterMode === "exact" && filterExactDate) return filterExactDate
    if (filterFromDate && !filterToDate) return filterFromDate
    if (filterFromDate && filterToDate && filterFromDate === filterToDate) return filterFromDate
    if (!filterFromDate && filterToDate) return filterToDate
    return localDateKey(new Date(nowMs))
  }, [filterExactDate, filterFromDate, filterMode, filterToDate, nowMs])

  const dailyLoad = React.useMemo(() => {
    const dayTodos = todos.filter((t) => getDatePart(t.dueAt) === loadDayKey)
    return getDailyLoad(dayTodos)
  }, [loadDayKey, todos])

  const filteredTodos = React.useMemo(() => {
    if (focusMode) {
      const endMs = nowMs + 4 * 60 * 60 * 1000
      const withMs = todos.map((t) => ({ ...t, _dueMs: parseLocalDateTime(t.dueAt) }))
      return withMs.filter((t) => t._dueMs >= nowMs && t._dueMs <= endMs)
    }

    const withMs = todos.map((t) => ({ ...t, _dueMs: parseLocalDateTime(t.dueAt) }))
    if (filterMode === "exact") {
      // If only date is selected -> show tasks for that date.
      // If time is selected too -> match exact date+time.
      // If only time is selected -> match time-of-day across all dates.
      if (!filterExactDate && !filterExactTime) return withMs

      if (filterExactDate && !filterExactTime) {
        return withMs.filter((t) => getDatePart(t.dueAt) === filterExactDate)
      }

      if (filterExactDate && filterExactTime) {
        const exactMs = parseLocalDateTime(`${filterExactDate}T${filterExactTime}`)
        return withMs.filter((t) => t._dueMs === exactMs)
      }

      // time only
      return withMs.filter((t) => getTimePart(t.dueAt) === filterExactTime)
    }
    // between
    const hasAnyDate = Boolean(filterFromDate || filterToDate)
    const hasAnyTime = Boolean(filterFromTime || filterToTime)

    // Date range (optional)
    const fromDateMs = filterFromDate
      ? startOfDay(parseLocalDateOnly(filterFromDate)).getTime()
      : Number.NEGATIVE_INFINITY
    const toDateMs = filterToDate
      ? endOfDay(parseLocalDateOnly(filterToDate)).getTime()
      : Number.POSITIVE_INFINITY

    // Time-of-day range (optional)
    const fromTimeMin = filterFromTime ? parseLocalTimeToMinutes(filterFromTime) : 0
    const toTimeMin = filterToTime ? parseLocalTimeToMinutes(filterToTime) : 24 * 60 - 1

    return withMs.filter((t) => {
      const ms = t._dueMs
      if (hasAnyDate && (ms < fromDateMs || ms > toDateMs)) return false

      if (hasAnyTime) {
        const time = getTimePart(t.dueAt)
        if (!time) return false
        const mins = parseLocalTimeToMinutes(time)
        // Simple (non-wrapping) range. If you want wrap-around (e.g. 22:00–02:00), tell me.
        if (mins < fromTimeMin || mins > toTimeMin) return false
      }

      // If neither date nor time selected, pass through (handled above anyway)
      return true
    })
  }, [
    todos,
    focusMode,
    nowMs,
    filterExactDate,
    filterExactTime,
    filterFromDate,
    filterFromTime,
    filterMode,
    filterToDate,
    filterToTime,
  ])

  const sortedFilteredTodos = React.useMemo(
    () =>
      filteredTodos
        .slice()
        .sort((a, b) => parseLocalDateTime(a.dueAt) - parseLocalDateTime(b.dueAt)),
    [filteredTodos]
  )

  // Clamp page when filters/pageSize change.
  React.useEffect(() => {
    const totalPages = Math.max(1, Math.ceil(sortedFilteredTodos.length / pageSize))
    setPage((p) => Math.min(Math.max(1, p), totalPages))
  }, [pageSize, sortedFilteredTodos.length])

  const totalItems = sortedFilteredTodos.length
  const totalPages = Math.max(1, Math.ceil(totalItems / pageSize))
  const showPagination = totalPages > 1

  const pageItems = React.useMemo(() => {
    const start = (page - 1) * pageSize
    return sortedFilteredTodos.slice(start, start + pageSize)
  }, [page, pageSize, sortedFilteredTodos])

  const groupedTodos = React.useMemo(() => {
    const groups: Array<{ date: string; items: typeof pageItems }> = []
    for (const t of pageItems) {
      const date = getDatePart(t.dueAt)
      const last = groups[groups.length - 1]
      if (!last || last.date !== date) groups.push({ date, items: [t] })
      else last.items.push(t)
    }
    return groups
  }, [pageItems])

  const completedCount = filteredTodos.filter((t) => t.completed).length

  function addTodo(values: TodoFormValues) {
    const conflicts = todos.filter((t) => t.dueAt === values.dueAt)
    if (conflicts.length > 0) {
      setConflictDueAt(values.dueAt)
      if (clearConflictTimerRef.current) window.clearTimeout(clearConflictTimerRef.current)
      clearConflictTimerRef.current = window.setTimeout(() => {
        setConflictDueAt(null)
      }, 8000)

      // Make sure the user can see the conflicting tasks even if they were filtered out.
      const [d, time] = values.dueAt.split("T")
      setFilterMode("exact")
      setFilterExactDate(d ?? "")
      setFilterExactTime(time ?? "")
      setPage(1)

      toast.error("Time conflict", {
        description: `You already have ${conflicts.length} task(s) scheduled at ${formatLocalDateTime(
          values.dueAt
        )}.`,
      })
    }

    setTodos((prev) => [
      {
        id: crypto.randomUUID(),
        title: values.title.trim(),
        completed: false,
        dueAt: values.dueAt,
        attachments: [],
      },
      ...prev,
    ])
    form.reset()
  }

  function toggleTodo(id: string, completed: boolean) {
    setTodos((prev) => prev.map((t) => (t.id === id ? { ...t, completed } : t)))
  }

  function requestAttachmentsForTodo(todoId: string) {
    setAttachTargetTodoId(todoId)
    // Let state update before opening picker (some browsers are picky).
    queueMicrotask(() => fileInputRef.current?.click())
  }

  function handleFilesPicked(e: React.ChangeEvent<HTMLInputElement>) {
    const files = Array.from(e.target.files ?? [])
    const targetId = attachTargetTodoId

    // reset input so picking the same file again triggers onChange
    e.target.value = ""
    setAttachTargetTodoId(null)

    if (!targetId || files.length === 0) return

    const attachments = files.map(makeAttachment)

    setTodos((prev) =>
      prev.map((t) =>
        t.id === targetId
          ? { ...t, attachments: [...t.attachments, ...attachments] }
          : t
      )
    )
  }

  function deleteTodo(id: string) {
    setTodos((prev) => {
      const victim = prev.find((t) => t.id === id)
      if (victim) revokeTodoAttachments(victim)
      return prev.filter((t) => t.id !== id)
    })
  }

  function clearCompleted() {
    setTodos((prev) => {
      for (const t of prev) {
        if (t.completed) revokeTodoAttachments(t)
      }
      return prev.filter((t) => !t.completed)
    })
  }

  return (
    <Card>
      <CardHeader className="flex flex-row items-center justify-between gap-4">
        <div className="space-y-1">
          <CardTitle className="text-2xl">To‑Do</CardTitle>
          <p className="text-muted-foreground text-sm">
            {completedCount}/{filteredTodos.length} completed
          </p>
        </div>
        <div className="flex items-center gap-2">
          <Button
            type="button"
            variant={focusMode ? "default" : "outline"}
            size="sm"
            onClick={() => {
              setFocusMode((v) => !v)
              setPage(1)
            }}
          >
            Focus Mode
          </Button>
          <ModeToggle />
        </div>
      </CardHeader>

      <CardContent className="space-y-6">
        <input
          ref={fileInputRef}
          type="file"
          multiple
          className="hidden"
          accept={[
            "image/*",
            "audio/*",
            "video/*",
            ".pdf",
            ".doc",
            ".docx",
            ".xls",
            ".xlsx",
            ".csv",
            ".txt",
            ".md",
            ".rtf",
          ].join(",")}
          onChange={handleFilesPicked}
        />

        {reminder && (
          <Alert className="border-primary/30 bg-primary/5">
            <Bell className="h-4 w-4" />
            <div className="flex flex-1 flex-col gap-1">
              <div className="flex flex-wrap items-center justify-between gap-2">
                <AlertTitle className="text-sm">
                  Next task starts in {reminder.mins} minute{reminder.mins === 1 ? "" : "s"}
                </AlertTitle>
                <Button
                  type="button"
                  variant="ghost"
                  size="sm"
                  onClick={() => setDismissedReminderTaskId(reminder.todo.id)}
                >
                  Dismiss
                </Button>
              </div>
              <AlertDescription className="text-sm">
                <span className="font-medium">{reminder.todo.title}</span> ·{" "}
                {formatDateTimeFromMs(reminder.dueMs)}
              </AlertDescription>
            </div>
          </Alert>
        )}

        <div className="rounded-xl border bg-card p-4">
          <div className="flex flex-wrap items-center justify-between gap-2">
            <p className="text-sm font-medium">
              Daily load{" "}
              <span className="text-muted-foreground font-normal">
                ({new Intl.DateTimeFormat(undefined, {
                  weekday: "short",
                  year: "numeric",
                  month: "short",
                  day: "2-digit",
                }).format(parseLocalDateOnly(loadDayKey))})
              </span>
            </p>
            <DailyLoadBadge load={dailyLoad.load} />
          </div>
          <p className="text-muted-foreground mt-2 text-sm">
            {dailyLoad.total} task(s) · busiest window {dailyLoad.busiestWindow} ({dailyLoad.peak})
          </p>
        </div>

        <div className="grid gap-3 sm:grid-cols-3">
          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Today’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">
              {summary.todayCompleted} completed
            </p>
            <p className="text-muted-foreground text-sm">{summary.todayPending} pending</p>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tomorrow’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">{summary.tomorrowTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.tomorrowBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tasks Until Next Week</p>
            <p className="mt-2 text-2xl font-semibold">{summary.upcomingTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.upcomingBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>
        </div>

        {focusMode && (
          <div className="flex flex-col gap-1 rounded-lg border bg-muted/20 px-3 py-2 sm:flex-row sm:items-center sm:justify-between">
            <p className="text-sm">
              <span className="font-medium">Focus Mode:</span>{" "}
              showing tasks due in the next 4 hours (until{" "}
              <span className="font-medium">
                {formatDateTimeFromMs(nowMs + 4 * 60 * 60 * 1000)}
              </span>
              )
            </p>
            <Button type="button" variant="ghost" size="sm" onClick={() => setFocusMode(false)}>
              Exit
            </Button>
          </div>
        )}

        <Form {...form}>
          <form
            onSubmit={form.handleSubmit(addTodo)}
            className="space-y-2"
            noValidate
          >
            <div className="flex flex-col gap-2 sm:flex-row">
              <FormField
                control={form.control}
                name="title"
                render={({ field }) => (
                  <FormItem className="flex-1">
                    <FormControl>
                      <Input
                        placeholder="Add a task…"
                        autoComplete="off"
                        {...field}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="dueAt"
                render={({ field }) => (
                  <FormItem className="sm:w-64">
                    <FormControl>
                      <Input type="datetime-local" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <Button type="submit">Add</Button>
            </div>
          </form>
        </Form>

        <Separator />

        <div className="space-y-3">
          <div className="flex flex-wrap items-center justify-between gap-2">
            <p className="text-sm font-medium">Filter by date & time</p>
            <div className="flex items-center gap-2">
              <Button
                type="button"
                size="sm"
                variant={filterMode === "between" ? "default" : "outline"}
                onClick={() => setFilterMode("between")}
              >
                Between
              </Button>
              <Button
                type="button"
                size="sm"
                variant={filterMode === "exact" ? "default" : "outline"}
                onClick={() => setFilterMode("exact")}
              >
                Exact
              </Button>
              <Button
                type="button"
                size="sm"
                variant="ghost"
                onClick={() => {
                  setFilterFromDate("")
                  setFilterFromTime("")
                  setFilterToDate("")
                  setFilterToTime("")
                  setFilterExactDate("")
                  setFilterExactTime("")
                }}
              >
                Clear
              </Button>
            </div>
          </div>

          {filterMode === "between" ? (
            <div className="grid gap-2 sm:grid-cols-2">
              <div className="grid gap-2 sm:grid-cols-2">
                <Input
                  type="date"
                  value={filterFromDate}
                  onChange={(e) => setFilterFromDate(e.target.value)}
                />
                <Input
                  type="time"
                  value={filterFromTime}
                  onChange={(e) => setFilterFromTime(e.target.value)}
                />
              </div>
              <div className="grid gap-2 sm:grid-cols-2">
                <Input
                  type="date"
                  value={filterToDate}
                  onChange={(e) => setFilterToDate(e.target.value)}
                />
                <Input
                  type="time"
                  value={filterToTime}
                  onChange={(e) => setFilterToTime(e.target.value)}
                />
              </div>
            </div>
          ) : (
            <div className="grid gap-2 sm:grid-cols-2">
              <Input
                type="date"
                value={filterExactDate}
                onChange={(e) => setFilterExactDate(e.target.value)}
              />
              <Input
                type="time"
                value={filterExactTime}
                onChange={(e) => setFilterExactTime(e.target.value)}
              />
            </div>
          )}
        </div>

        <Separator />

        <div className="space-y-2">
          {groupedTodos.length === 0 ? (
            <p className="text-muted-foreground text-sm">No tasks yet.</p>
          ) : (
            groupedTodos.map((group) => (
              <div key={group.date} className="space-y-2">
                <div className="flex items-center gap-3 pt-2">
                  <Separator className="flex-1" />
                  <span className="text-muted-foreground whitespace-nowrap text-xs font-medium">
                    {new Intl.DateTimeFormat(undefined, {
                      weekday: "short",
                      year: "numeric",
                      month: "short",
                      day: "2-digit",
                    }).format(parseLocalDateOnly(group.date))}
                  </span>
                  <Separator className="flex-1" />
                </div>

                {group.items.map((todo) => {
                  const state = getTaskState(todo, nowMs)

                  return (
                    <div
                      key={todo.id}
                      className={cn(
                        "rounded-lg border px-3 py-2",
                        state === "completed" && "opacity-75",
                        state === "overdue" &&
                          "border-destructive/40 bg-destructive/5 text-muted-foreground",
                        state === "in_progress" && "border-primary/30 bg-primary/5",
                        conflictDueAt &&
                          todo.dueAt === conflictDueAt &&
                          "border-destructive/60 bg-destructive/5 ring-1 ring-destructive/30"
                      )}
                    >
                      <div className="flex items-start justify-between gap-3">
                        <label className="flex cursor-pointer items-start gap-3">
                        <Checkbox
                          checked={todo.completed}
                          onCheckedChange={(v) => {
                            const next = Boolean(v)
                            toggleTodo(todo.id, next)
                            if (next && !todo.completed) {
                              requestAttachmentsForTodo(todo.id)
                            }
                          }}
                          aria-label={`Mark "${todo.title}" as ${
                            todo.completed ? "not completed" : "completed"
                          }`}
                          className="mt-0.5"
                        />
                        <span
                          className={cn(
                            "leading-6",
                            todo.completed && "text-muted-foreground line-through"
                          )}
                        >
                          <span className="flex flex-wrap items-center gap-2">
                            <span className="block">{todo.title}</span>
                            <TaskStateBadge state={state} />
                          </span>
                          <span className="text-muted-foreground block text-xs">
                            Due: {formatLocalDateTime(todo.dueAt)}
                          </span>
                        </span>
                      </label>

                      <div className="flex items-center gap-1">
                        {todo.completed && (
                          <Button
                            type="button"
                            variant="outline"
                            size="sm"
                            onClick={() => requestAttachmentsForTodo(todo.id)}
                          >
                            Add files
                          </Button>
                        )}
                        <Button
                          type="button"
                          variant="ghost"
                          size="icon"
                          aria-label={`Delete "${todo.title}"`}
                          onClick={() => deleteTodo(todo.id)}
                        >
                          <Trash2 className="h-4 w-4" />
                        </Button>
                      </div>
                    </div>

                    {todo.completed && todo.attachments.length > 0 && (
                      <div className="mt-3 space-y-2">
                        <p className="text-muted-foreground text-xs">Attachments</p>
                        <ul className="space-y-1">
                          {todo.attachments.map((a) => (
                            <li
                              key={a.id}
                              className="flex items-center justify-between gap-3 rounded-md bg-muted/30 px-2 py-1"
                            >
                              <div className="flex min-w-0 items-center gap-2">
                                <AttachmentIcon kind={a.kind} />
                                <span className="truncate text-sm">{a.name}</span>
                              </div>
                              <a
                                href={a.url}
                                download={a.name}
                                className="inline-flex items-center gap-1 text-sm font-medium underline underline-offset-4"
                              >
                                <Download className="h-4 w-4" />
                                Download
                              </a>
                            </li>
                          ))}
                        </ul>
                      </div>
                    )}
                  </div>
                  )
                })}
              </div>
            ))
          )}
        </div>

        {groupedTodos.length > 0 && (
          <div className="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
            <div className="flex items-center gap-2">
              <span className="text-muted-foreground text-sm">Items per page</span>
              <Select
                value={String(pageSize)}
                onValueChange={(v) => {
                  const next = Number(v)
                  setPageSize(next)
                  setPage(1)
                }}
              >
                <SelectTrigger className="w-[110px]">
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="5">5</SelectItem>
                  <SelectItem value="10">10</SelectItem>
                  <SelectItem value="15">15</SelectItem>
                  <SelectItem value="20">20</SelectItem>
                </SelectContent>
              </Select>
            </div>

            {showPagination && (
              <div className="flex items-center justify-between gap-3 sm:justify-end">
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={() => setPage((p) => Math.max(1, p - 1))}
                  disabled={page <= 1}
                >
                  Prev
                </Button>
                <span className="text-muted-foreground text-sm">
                  Page {page} of {totalPages}
                </span>
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={() => setPage((p) => Math.min(totalPages, p + 1))}
                  disabled={page >= totalPages}
                >
                  Next
                </Button>
              </div>
            )}
          </div>
        )}

        <div className="flex items-center justify-between gap-2">
          <Button
            type="button"
            variant="secondary"
            onClick={clearCompleted}
            disabled={completedCount === 0}
          >
            Clear completed
          </Button>
          <span className="text-muted-foreground text-sm">
            Mock data only (no backend)
          </span>
    </div>
      </CardContent>
    </Card>
  )
}

```

### In-app reminder (non-intrusive) added
- Shows a small **banner at the top** when the **next upcoming (not completed) task** is within **15 minutes**.
- Banner includes:
  - **“Next task starts in X minutes”**
  - task title + scheduled time
  - **Dismiss** button (dismisses for that task)
- No toasts/notifications used for this.

### Files updated
- **New**: `src/components/ui/alert.tsx`
- **Updated**: `src/app/page.tsx`

### Run
```bash
npm run dev
```

```shellscript
npm run dev
```

---

**User**

Implement an In Progress task state.
Allow users to mark a task as In Progress to indicate the task they are currently working on. This state should be visually distinct from Planned, Completed, and Overdue tasks, and only one task can be In Progress at a time.

---

**Cursor**

Plan: I’ll switch the current “In progress” state from being time-based to being **user-controlled** (only one task at a time), add a **Start/Stop** control on each task row, and ensure the state auto-clears if that task is completed, deleted, or becomes overdue. Then I’ll run a build to confirm everything compiles.

```typescriptreact
*** Begin Patch
*** Update File: src/app/page.tsx
@@
 import { zodResolver } from "@hookform/resolvers/zod"
 import {
   AlertTriangle,
+  CirclePlay,
+  CircleStop,
   CalendarClock,
   CheckCircle2,
   Download,
   File,
   FileSpreadsheet,
@@
   const [conflictDueAt, setConflictDueAt] = React.useState<string | null>(null)
   const clearConflictTimerRef = React.useRef<number | null>(null)
   const [focusMode, setFocusMode] = React.useState(false)
   const [nowMs, setNowMs] = React.useState(() => Date.now())
+  const [inProgressTaskId, setInProgressTaskId] = React.useState<string | null>(null)
   const [dismissedReminderTaskId, setDismissedReminderTaskId] = React.useState<
     string | null
   >(null)
@@
 function getTaskState(todo: Todo, nowMs: number): TaskState {
   if (todo.completed) return "completed"
   const dueMs = parseLocalDateTime(todo.dueAt)
   if (dueMs < nowMs) return "overdue"
-  if (dueMs <= nowMs + 4 * 60 * 60 * 1000) return "in_progress"
   return "planned"
 }
 
+function getTaskStateWithInProgress(
+  todo: Todo,
+  nowMs: number,
+  inProgressTaskId: string | null
+): TaskState {
+  const base = getTaskState(todo, nowMs)
+  if (base !== "planned") return base
+  return inProgressTaskId === todo.id ? "in_progress" : "planned"
+}
+
 function getDailyLoad(todosForDay: Todo[]) {
@@
 function TaskStateBadge({ state }: { state: TaskState }) {
   switch (state) {
     case "completed":
       return (
@@
     case "overdue":
       return (
         <Badge variant="destructive" className="gap-1">
           <AlertTriangle className="h-3.5 w-3.5" />
           Overdue
         </Badge>
       )
     case "in_progress":
       return (
-        <Badge variant="secondary" className="gap-1">
-          <Timer className="h-3.5 w-3.5" />
+        <Badge className="gap-1 bg-sky-600 text-white hover:bg-sky-600">
+          <Timer className="h-3.5 w-3.5 text-white" />
           In progress
         </Badge>
       )
     default:
       return (
         <Badge variant="outline" className="gap-1">
@@
   // Keep "now" fresh so overdue/in-progress states stay accurate without user interaction.
   React.useEffect(() => {
     const id = window.setInterval(() => setNowMs(Date.now()), 30_000)
     return () => window.clearInterval(id)
   }, [])
 
+  // Ensure "only one" in-progress task, and auto-clear it if it becomes invalid.
+  React.useEffect(() => {
+    if (!inProgressTaskId) return
+    const t = todos.find((x) => x.id === inProgressTaskId)
+    if (!t) {
+      setInProgressTaskId(null)
+      return
+    }
+    if (t.completed) {
+      setInProgressTaskId(null)
+      return
+    }
+    const dueMs = parseLocalDateTime(t.dueAt)
+    if (dueMs < nowMs) {
+      setInProgressTaskId(null)
+    }
+  }, [inProgressTaskId, nowMs, todos])
+
@@
   function deleteTodo(id: string) {
     setTodos((prev) => {
       const victim = prev.find((t) => t.id === id)
       if (victim) revokeTodoAttachments(victim)
       return prev.filter((t) => t.id !== id)
     })
+    setInProgressTaskId((cur) => (cur === id ? null : cur))
   }
@@
   function toggleTodo(id: string, completed: boolean) {
     setTodos((prev) => prev.map((t) => (t.id === id ? { ...t, completed } : t)))
+    if (completed) setInProgressTaskId((cur) => (cur === id ? null : cur))
   }
@@
                 {group.items.map((todo) => {
-                  const state = getTaskState(todo, nowMs)
+                  const state = getTaskStateWithInProgress(todo, nowMs, inProgressTaskId)
 
                   return (
                     <div
                       key={todo.id}
                       className={cn(
                         "rounded-lg border px-3 py-2",
                         state === "completed" && "opacity-75",
                         state === "overdue" &&
                           "border-destructive/40 bg-destructive/5 text-muted-foreground",
-                        state === "in_progress" && "border-primary/30 bg-primary/5",
+                        state === "in_progress" && "border-sky-500/40 bg-sky-500/10",
                         conflictDueAt &&
                           todo.dueAt === conflictDueAt &&
                           "border-destructive/60 bg-destructive/5 ring-1 ring-destructive/30"
                       )}
                     >
                       <div className="flex items-start justify-between gap-3">
@@
                       </label>
 
                       <div className="flex items-center gap-1">
+                        {!todo.completed && state !== "overdue" && (
+                          <Button
+                            type="button"
+                            variant={state === "in_progress" ? "default" : "outline"}
+                            size="sm"
+                            onClick={() =>
+                              setInProgressTaskId((cur) =>
+                                cur === todo.id ? null : todo.id
+                              )
+                            }
+                            className={cn(
+                              state === "in_progress" && "bg-sky-600 hover:bg-sky-600"
+                            )}
+                          >
+                            {state === "in_progress" ? (
+                              <>
+                                <CircleStop className="mr-1 h-4 w-4" />
+                                Stop
+                              </>
+                            ) : (
+                              <>
+                                <CirclePlay className="mr-1 h-4 w-4" />
+                                Start
+                              </>
+                            )}
+                          </Button>
+                        )}
                         {todo.completed && (
                           <Button
                             type="button"
                             variant="outline"
                             size="sm"
*** End Patch
```

Nice—this is mostly a refactor of the existing state logic. Next I’ll re-apply the changes in smaller, correctly-ordered patches: imports/icons first, then the task-state helpers, then the `TodoApp` state + handlers, and finally the task row UI (Start/Stop button + styling).

```typescriptreact
"use client"

import { zodResolver } from "@hookform/resolvers/zod"
import {
  AlertTriangle,
  CirclePlay,
  CircleStop,
  CalendarClock,
  CheckCircle2,
  Download,
  File,
  FileSpreadsheet,
  FileText,
  Image as ImageIcon,
  Music,
  Bell,
  Timer,
  Trash2,
  Video,
} from "lucide-react"
import * as React from "react"
import { useForm } from "react-hook-form"
import { toast } from "sonner"
import { z } from "zod"

import { ModeToggle } from "@/components/mode-toggle"
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert"
import { Badge } from "@/components/ui/badge"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Checkbox } from "@/components/ui/checkbox"
import { Form, FormControl, FormField, FormItem, FormMessage } from "@/components/ui/form"
import { Input } from "@/components/ui/input"
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select"
import { Separator } from "@/components/ui/separator"
import { cn } from "@/lib/utils"

type AttachmentKind =
  | "image"
  | "audio"
  | "video"
  | "pdf"
  | "spreadsheet"
  | "document"
  | "text"
  | "file"

type Attachment = {
  id: string
  name: string
  type: string
  size: number
  url: string
  kind: AttachmentKind
}

type Todo = {
  id: string
  title: string
  completed: boolean
  // Stored as `datetime-local` string (YYYY-MM-DDTHH:mm) in local time.
  dueAt: string
  attachments: Attachment[]
}

type TaskState = "planned" | "in_progress" | "completed" | "overdue"
type DailyLoad = "light" | "balanced" | "heavy"

const todoSchema = z.object({
  title: z
    .string()
    .trim()
    .min(1, "Title is required.")
    .max(80, "Keep it under 80 characters."),
  dueAt: z
    .string()
    .min(1, "Due date & time is required.")
    .regex(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}$/, "Invalid date/time."),
})

type TodoFormValues = z.infer<typeof todoSchema>

const initialTodos: Todo[] = [
  {
    id: "1",
    title: "Create a Next.js app",
    completed: true,
    dueAt: "2026-01-16T09:00",
    attachments: [],
  },
  {
    id: "2",
    title: "Add shadcn/ui + dark theme",
    completed: true,
    dueAt: "2026-01-16T10:30",
    attachments: [],
  },
  {
    id: "3",
    title: "Build a mock-data to-do list",
    completed: false,
    dueAt: "2026-01-16T15:00",
    attachments: [],
  },
  {
    id: "4",
    title: "Yesterday: review requirements",
    completed: true,
    dueAt: "2026-01-15T11:15",
    attachments: [],
  },
  {
    id: "5",
    title: "Yesterday: sketch UI layout",
    completed: true,
    dueAt: "2026-01-15T17:45",
    attachments: [],
  },
  {
    id: "6",
    title: "Today: add attachments support",
    completed: false,
    dueAt: "2026-01-16T18:20",
    attachments: [],
  },
  {
    id: "7",
    title: "Tomorrow: QA the filters",
    completed: false,
    dueAt: "2026-01-17T08:05",
    attachments: [],
  },
  {
    id: "8",
    title: "Tomorrow: polish summary cards",
    completed: false,
    dueAt: "2026-01-17T13:30",
    attachments: [],
  },
  {
    id: "9",
    title: "Tomorrow: write small UX notes",
    completed: false,
    dueAt: "2026-01-17T20:10",
    attachments: [],
  },
  {
    id: "10",
    title: "This weekend: add more mock tasks",
    completed: false,
    dueAt: "2026-01-18T10:00",
    attachments: [],
  },
  {
    id: "11",
    title: "This weekend: check time-only filter",
    completed: false,
    dueAt: "2026-01-18T22:15",
    attachments: [],
  },
  {
    id: "12",
    title: "Next week: sync with team",
    completed: false,
    dueAt: "2026-01-19T09:30",
    attachments: [],
  },
  {
    id: "13",
    title: "Next week: test date-only filter",
    completed: false,
    dueAt: "2026-01-20T14:05",
    attachments: [],
  },
  {
    id: "14",
    title: "Next week: test exact date+time filter",
    completed: false,
    dueAt: "2026-01-21T12:00",
    attachments: [],
  },
  {
    id: "15",
    title: "Next week: attach docs to completed tasks",
    completed: false,
    dueAt: "2026-01-22T16:40",
    attachments: [],
  },
  {
    id: "16",
    title: "Next week: final review",
    completed: false,
    dueAt: "2026-01-23T11:00",
    attachments: [],
  },
]

function parseLocalDateTime(value: string): number {
  // value: "YYYY-MM-DDTHH:mm"
  const [datePart, timePart] = value.split("T")
  const [y, m, d] = datePart.split("-").map(Number)
  const [hh, mm] = timePart.split(":").map(Number)
  return new Date(y, m - 1, d, hh, mm, 0, 0).getTime()
}

function pad2(n: number) {
  return String(n).padStart(2, "0")
}

function localDateKey(d: Date) {
  return `${d.getFullYear()}-${pad2(d.getMonth() + 1)}-${pad2(d.getDate())}`
}

function addDays(date: Date, days: number) {
  const d = new Date(date)
  d.setDate(d.getDate() + days)
  return d
}

function startOfDay(date: Date) {
  return new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0, 0)
}

function endOfDay(date: Date) {
  return new Date(
    date.getFullYear(),
    date.getMonth(),
    date.getDate(),
    23,
    59,
    59,
    999
  )
}

function getDatePart(dueAt: string) {
  return dueAt.split("T")[0] ?? ""
}

function getTimePart(dueAt: string) {
  return dueAt.split("T")[1] ?? ""
}

function parseLocalDateOnly(value: string): Date {
  // value: "YYYY-MM-DD"
  const [y, m, d] = value.split("-").map(Number)
  return new Date(y, m - 1, d, 0, 0, 0, 0)
}

function parseLocalTimeToMinutes(value: string): number {
  // value: "HH:mm"
  const [hh, mm] = value.split(":").map(Number)
  return hh * 60 + mm
}

function formatLocalDateTime(value: string): string {
  const ms = parseLocalDateTime(value)
  if (!Number.isFinite(ms)) return value
  return new Intl.DateTimeFormat(undefined, {
    year: "numeric",
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  }).format(new Date(ms))
}

function formatDateTimeFromMs(ms: number): string {
  return new Intl.DateTimeFormat(undefined, {
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  }).format(new Date(ms))
}

function minutesUntil(targetMs: number, nowMs: number) {
  return Math.ceil((targetMs - nowMs) / 60_000)
}

function getTaskState(todo: Todo, nowMs: number): TaskState {
  if (todo.completed) return "completed"
  const dueMs = parseLocalDateTime(todo.dueAt)
  if (dueMs < nowMs) return "overdue"
  return "planned"
}

function getTaskStateWithInProgress(
  todo: Todo,
  nowMs: number,
  inProgressTaskId: string | null
): TaskState {
  const base = getTaskState(todo, nowMs)
  if (base !== "planned") return base
  return inProgressTaskId === todo.id ? "in_progress" : "planned"
}

function getDailyLoad(todosForDay: Todo[]) {
  // 4-hour windows across the day (local).
  const labels = [
    "00:00–04:00",
    "04:00–08:00",
    "08:00–12:00",
    "12:00–16:00",
    "16:00–20:00",
    "20:00–24:00",
  ]
  const buckets = Array.from({ length: 6 }, () => 0) as number[]
  for (const t of todosForDay) {
    const ms = parseLocalDateTime(t.dueAt)
    const hour = new Date(ms).getHours()
    const idx = Math.floor(hour / 4)
    buckets[idx] = (buckets[idx] ?? 0) + 1
  }

  const total = todosForDay.length
  const peak = Math.max(0, ...buckets)
  const spread = buckets.filter((c) => c > 0).length
  const busiestIdx = buckets.findIndex((c) => c === peak)
  const busiestWindow = busiestIdx >= 0 ? labels[busiestIdx] : labels[0]

  // Heuristic: more tasks + higher concentration in one window => heavier day.
  const score = total + peak * 1.5 + Math.max(0, spread - 1) * 0.5
  const load: DailyLoad = score <= 5 ? "light" : score <= 10 ? "balanced" : "heavy"

  return { load, total, peak, spread, busiestWindow }
}

function DailyLoadBadge({ load }: { load: DailyLoad }) {
  if (load === "heavy") return <Badge variant="destructive">Heavy</Badge>
  if (load === "balanced") return <Badge variant="secondary">Balanced</Badge>
  return <Badge variant="outline">Light</Badge>
}

function TaskStateBadge({ state }: { state: TaskState }) {
  switch (state) {
    case "completed":
      return (
        <Badge className="gap-1 bg-emerald-600 text-white hover:bg-emerald-600">
          <CheckCircle2 className="h-3.5 w-3.5" />
          Completed
        </Badge>
      )
    case "overdue":
      return (
        <Badge variant="destructive" className="gap-1">
          <AlertTriangle className="h-3.5 w-3.5" />
          Overdue
        </Badge>
      )
    case "in_progress":
      return (
        <Badge className="gap-1 bg-sky-600 text-white hover:bg-sky-600">
          <Timer className="h-3.5 w-3.5 text-white" />
          In progress
        </Badge>
      )
    default:
      return (
        <Badge variant="outline" className="gap-1">
          <CalendarClock className="h-3.5 w-3.5" />
          Planned
        </Badge>
      )
  }
}

function getAttachmentKind(file: File): AttachmentKind {
  const type = (file.type || "").toLowerCase()
  const name = file.name.toLowerCase()
  const ext = name.includes(".") ? name.split(".").pop() ?? "" : ""

  if (type.startsWith("image/")) return "image"
  if (type.startsWith("audio/")) return "audio"
  if (type.startsWith("video/")) return "video"

  if (ext === "pdf") return "pdf"
  if (["xls", "xlsx", "csv"].includes(ext)) return "spreadsheet"
  if (["doc", "docx"].includes(ext)) return "document"
  if (["txt", "md", "rtf"].includes(ext)) return "text"

  return "file"
}

function makeAttachment(file: File): Attachment {
  return {
    id: crypto.randomUUID(),
    name: file.name,
    type: file.type,
    size: file.size,
    url: URL.createObjectURL(file),
    kind: getAttachmentKind(file),
  }
}

function revokeTodoAttachments(todo: Todo) {
  for (const a of todo.attachments) URL.revokeObjectURL(a.url)
}

function AttachmentIcon({ kind }: { kind: AttachmentKind }) {
  const className = "h-4 w-4 text-muted-foreground"

  switch (kind) {
    case "image":
      return <ImageIcon className={className} />
    case "audio":
      return <Music className={className} />
    case "video":
      return <Video className={className} />
    case "spreadsheet":
      return <FileSpreadsheet className={className} />
    case "pdf":
    case "document":
    case "text":
      return <FileText className={className} />
    default:
      return <File className={className} />
  }
}

export default function Home() {
  return (
    <div className="mx-auto flex min-h-screen max-w-2xl flex-col gap-6 px-4 py-10">
      <TodoApp />
    </div>
  )
}

function TodoApp() {
  const [todos, setTodos] = React.useState<Todo[]>(initialTodos)
  const [attachTargetTodoId, setAttachTargetTodoId] = React.useState<string | null>(
    null
  )
  const [conflictDueAt, setConflictDueAt] = React.useState<string | null>(null)
  const clearConflictTimerRef = React.useRef<number | null>(null)
  const [focusMode, setFocusMode] = React.useState(false)
  const [nowMs, setNowMs] = React.useState(() => Date.now())
  const [inProgressTaskId, setInProgressTaskId] = React.useState<string | null>(null)
  const [dismissedReminderTaskId, setDismissedReminderTaskId] = React.useState<
    string | null
  >(null)
  const [filterMode, setFilterMode] = React.useState<"between" | "exact">("between")
  const [filterFromDate, setFilterFromDate] = React.useState<string>("")
  const [filterFromTime, setFilterFromTime] = React.useState<string>("")
  const [filterToDate, setFilterToDate] = React.useState<string>("")
  const [filterToTime, setFilterToTime] = React.useState<string>("")
  const [filterExactDate, setFilterExactDate] = React.useState<string>("")
  const [filterExactTime, setFilterExactTime] = React.useState<string>("")
  const fileInputRef = React.useRef<HTMLInputElement>(null)
  const [pageSize, setPageSize] = React.useState<number>(5)
  const [page, setPage] = React.useState<number>(1)

  const todosRef = React.useRef(todos)
  React.useEffect(() => {
    todosRef.current = todos
  }, [todos])
  React.useEffect(() => {
    return () => {
      for (const t of todosRef.current) revokeTodoAttachments(t)
    }
  }, [])

  // Keep "now" fresh so overdue/in-progress states stay accurate without user interaction.
  React.useEffect(() => {
    const id = window.setInterval(() => setNowMs(Date.now()), 30_000)
    return () => window.clearInterval(id)
  }, [])

  // Only one task can be "In Progress"; auto-clear if completed, deleted, or overdue.
  React.useEffect(() => {
    if (!inProgressTaskId) return
    const t = todos.find((x) => x.id === inProgressTaskId)
    if (!t || t.completed) {
      setInProgressTaskId(null)
      return
    }
    if (parseLocalDateTime(t.dueAt) < nowMs) setInProgressTaskId(null)
  }, [inProgressTaskId, nowMs, todos])

  const nextUpcoming = React.useMemo(() => {
    const upcoming = todos
      .filter((t) => !t.completed)
      .map((t) => ({ todo: t, dueMs: parseLocalDateTime(t.dueAt) }))
      .filter((x) => x.dueMs >= nowMs)
      .sort((a, b) => a.dueMs - b.dueMs)[0]
    return upcoming ?? null
  }, [nowMs, todos])

  React.useEffect(() => {
    // If "next upcoming" changed, allow reminder again (dismiss is per-task).
    if (nextUpcoming && nextUpcoming.todo.id !== dismissedReminderTaskId) return
    if (!nextUpcoming) setDismissedReminderTaskId(null)
  }, [dismissedReminderTaskId, nextUpcoming])

  const reminder = React.useMemo(() => {
    const REMINDER_WINDOW_MIN = 15
    if (!nextUpcoming) return null
    if (dismissedReminderTaskId === nextUpcoming.todo.id) return null
    const mins = minutesUntil(nextUpcoming.dueMs, nowMs)
    if (mins < 0 || mins > REMINDER_WINDOW_MIN) return null
    return { ...nextUpcoming, mins }
  }, [dismissedReminderTaskId, nextUpcoming, nowMs])

  const form = useForm<TodoFormValues>({
    resolver: zodResolver(todoSchema),
    defaultValues: { title: "", dueAt: "" },
    mode: "onSubmit",
  })

  const summary = React.useMemo(() => {
    const now = new Date()
    const todayKey = localDateKey(now)
    const tomorrow = addDays(now, 1)
    const tomorrowKey = localDateKey(tomorrow)

    const todays = todos.filter((t) => t.dueAt.startsWith(todayKey))
    const todayCompleted = todays.filter((t) => t.completed).length
    const todayPending = todays.length - todayCompleted

    const labels = [
      "00:00–04:00",
      "04:00–08:00",
      "08:00–12:00",
      "12:00–16:00",
      "16:00–20:00",
      "20:00–24:00",
    ]

    // Tomorrow: same 4-hour windows breakdown
    const tomorrowTasks = todos.filter((t) => t.dueAt.startsWith(tomorrowKey))
    const tomorrowBuckets = Array.from({ length: 6 }, () => 0) as number[]
    for (const t of tomorrowTasks) {
      const ms = parseLocalDateTime(t.dueAt)
      const hour = new Date(ms).getHours()
      const idx = Math.floor(hour / 4)
      tomorrowBuckets[idx] = (tomorrowBuckets[idx] ?? 0) + 1
    }

    // Until next week = next 7 days starting tomorrow (local), grouped into 4-hour windows.
    const rangeStart = startOfDay(tomorrow).getTime()
    const rangeEnd = addDays(startOfDay(tomorrow), 7).getTime()
    const buckets = Array.from({ length: 6 }, () => 0) as number[]

    const upcoming = todos.filter((t) => {
      const ms = parseLocalDateTime(t.dueAt)
      return ms >= rangeStart && ms < rangeEnd
    })

    for (const t of upcoming) {
      const ms = parseLocalDateTime(t.dueAt)
      const hour = new Date(ms).getHours()
      const idx = Math.floor(hour / 4)
      buckets[idx] = (buckets[idx] ?? 0) + 1
    }

    return {
      todayCompleted,
      todayPending,
      tomorrowTotal: tomorrowTasks.length,
      tomorrowBuckets: labels.map((label, i) => ({ label, count: tomorrowBuckets[i] ?? 0 })),
      upcomingTotal: upcoming.length,
      upcomingBuckets: labels.map((label, i) => ({ label, count: buckets[i] ?? 0 })),
    }
  }, [todos])

  const loadDayKey = React.useMemo(() => {
    // Prefer an explicitly selected date from filters; otherwise use today.
    if (filterMode === "exact" && filterExactDate) return filterExactDate
    if (filterFromDate && !filterToDate) return filterFromDate
    if (filterFromDate && filterToDate && filterFromDate === filterToDate) return filterFromDate
    if (!filterFromDate && filterToDate) return filterToDate
    return localDateKey(new Date(nowMs))
  }, [filterExactDate, filterFromDate, filterMode, filterToDate, nowMs])

  const dailyLoad = React.useMemo(() => {
    const dayTodos = todos.filter((t) => getDatePart(t.dueAt) === loadDayKey)
    return getDailyLoad(dayTodos)
  }, [loadDayKey, todos])

  const filteredTodos = React.useMemo(() => {
    if (focusMode) {
      const endMs = nowMs + 4 * 60 * 60 * 1000
      const withMs = todos.map((t) => ({ ...t, _dueMs: parseLocalDateTime(t.dueAt) }))
      return withMs.filter((t) => t._dueMs >= nowMs && t._dueMs <= endMs)
    }

    const withMs = todos.map((t) => ({ ...t, _dueMs: parseLocalDateTime(t.dueAt) }))
    if (filterMode === "exact") {
      // If only date is selected -> show tasks for that date.
      // If time is selected too -> match exact date+time.
      // If only time is selected -> match time-of-day across all dates.
      if (!filterExactDate && !filterExactTime) return withMs

      if (filterExactDate && !filterExactTime) {
        return withMs.filter((t) => getDatePart(t.dueAt) === filterExactDate)
      }

      if (filterExactDate && filterExactTime) {
        const exactMs = parseLocalDateTime(`${filterExactDate}T${filterExactTime}`)
        return withMs.filter((t) => t._dueMs === exactMs)
      }

      // time only
      return withMs.filter((t) => getTimePart(t.dueAt) === filterExactTime)
    }
    // between
    const hasAnyDate = Boolean(filterFromDate || filterToDate)
    const hasAnyTime = Boolean(filterFromTime || filterToTime)

    // Date range (optional)
    const fromDateMs = filterFromDate
      ? startOfDay(parseLocalDateOnly(filterFromDate)).getTime()
      : Number.NEGATIVE_INFINITY
    const toDateMs = filterToDate
      ? endOfDay(parseLocalDateOnly(filterToDate)).getTime()
      : Number.POSITIVE_INFINITY

    // Time-of-day range (optional)
    const fromTimeMin = filterFromTime ? parseLocalTimeToMinutes(filterFromTime) : 0
    const toTimeMin = filterToTime ? parseLocalTimeToMinutes(filterToTime) : 24 * 60 - 1

    return withMs.filter((t) => {
      const ms = t._dueMs
      if (hasAnyDate && (ms < fromDateMs || ms > toDateMs)) return false

      if (hasAnyTime) {
        const time = getTimePart(t.dueAt)
        if (!time) return false
        const mins = parseLocalTimeToMinutes(time)
        // Simple (non-wrapping) range. If you want wrap-around (e.g. 22:00–02:00), tell me.
        if (mins < fromTimeMin || mins > toTimeMin) return false
      }

      // If neither date nor time selected, pass through (handled above anyway)
      return true
    })
  }, [
    todos,
    focusMode,
    nowMs,
    filterExactDate,
    filterExactTime,
    filterFromDate,
    filterFromTime,
    filterMode,
    filterToDate,
    filterToTime,
  ])

  const sortedFilteredTodos = React.useMemo(
    () =>
      filteredTodos
        .slice()
        .sort((a, b) => parseLocalDateTime(a.dueAt) - parseLocalDateTime(b.dueAt)),
    [filteredTodos]
  )

  // Clamp page when filters/pageSize change.
  React.useEffect(() => {
    const totalPages = Math.max(1, Math.ceil(sortedFilteredTodos.length / pageSize))
    setPage((p) => Math.min(Math.max(1, p), totalPages))
  }, [pageSize, sortedFilteredTodos.length])

  const totalItems = sortedFilteredTodos.length
  const totalPages = Math.max(1, Math.ceil(totalItems / pageSize))
  const showPagination = totalPages > 1

  const pageItems = React.useMemo(() => {
    const start = (page - 1) * pageSize
    return sortedFilteredTodos.slice(start, start + pageSize)
  }, [page, pageSize, sortedFilteredTodos])

  const groupedTodos = React.useMemo(() => {
    const groups: Array<{ date: string; items: typeof pageItems }> = []
    for (const t of pageItems) {
      const date = getDatePart(t.dueAt)
      const last = groups[groups.length - 1]
      if (!last || last.date !== date) groups.push({ date, items: [t] })
      else last.items.push(t)
    }
    return groups
  }, [pageItems])

  const completedCount = filteredTodos.filter((t) => t.completed).length

  function addTodo(values: TodoFormValues) {
    const conflicts = todos.filter((t) => t.dueAt === values.dueAt)
    if (conflicts.length > 0) {
      setConflictDueAt(values.dueAt)
      if (clearConflictTimerRef.current) window.clearTimeout(clearConflictTimerRef.current)
      clearConflictTimerRef.current = window.setTimeout(() => {
        setConflictDueAt(null)
      }, 8000)

      // Make sure the user can see the conflicting tasks even if they were filtered out.
      const [d, time] = values.dueAt.split("T")
      setFilterMode("exact")
      setFilterExactDate(d ?? "")
      setFilterExactTime(time ?? "")
      setPage(1)

      toast.error("Time conflict", {
        description: `You already have ${conflicts.length} task(s) scheduled at ${formatLocalDateTime(
          values.dueAt
        )}.`,
      })
    }

    setTodos((prev) => [
      {
        id: crypto.randomUUID(),
        title: values.title.trim(),
        completed: false,
        dueAt: values.dueAt,
        attachments: [],
      },
      ...prev,
    ])
    form.reset()
  }

  function toggleTodo(id: string, completed: boolean) {
    setTodos((prev) => prev.map((t) => (t.id === id ? { ...t, completed } : t)))
    if (completed) setInProgressTaskId((cur) => (cur === id ? null : cur))
  }

  function requestAttachmentsForTodo(todoId: string) {
    setAttachTargetTodoId(todoId)
    // Let state update before opening picker (some browsers are picky).
    queueMicrotask(() => fileInputRef.current?.click())
  }

  function handleFilesPicked(e: React.ChangeEvent<HTMLInputElement>) {
    const files = Array.from(e.target.files ?? [])
    const targetId = attachTargetTodoId

    // reset input so picking the same file again triggers onChange
    e.target.value = ""
    setAttachTargetTodoId(null)

    if (!targetId || files.length === 0) return

    const attachments = files.map(makeAttachment)

    setTodos((prev) =>
      prev.map((t) =>
        t.id === targetId
          ? { ...t, attachments: [...t.attachments, ...attachments] }
          : t
      )
    )
  }

  function deleteTodo(id: string) {
    setTodos((prev) => {
      const victim = prev.find((t) => t.id === id)
      if (victim) revokeTodoAttachments(victim)
      return prev.filter((t) => t.id !== id)
    })
    setInProgressTaskId((cur) => (cur === id ? null : cur))
  }

  function clearCompleted() {
    setTodos((prev) => {
      for (const t of prev) {
        if (t.completed) revokeTodoAttachments(t)
      }
      return prev.filter((t) => !t.completed)
    })
  }

  return (
    <Card>
      <CardHeader className="flex flex-row items-center justify-between gap-4">
        <div className="space-y-1">
          <CardTitle className="text-2xl">To‑Do</CardTitle>
          <p className="text-muted-foreground text-sm">
            {completedCount}/{filteredTodos.length} completed
          </p>
        </div>
        <div className="flex items-center gap-2">
          <Button
            type="button"
            variant={focusMode ? "default" : "outline"}
            size="sm"
            onClick={() => {
              setFocusMode((v) => !v)
              setPage(1)
            }}
          >
            Focus Mode
          </Button>
          <ModeToggle />
        </div>
      </CardHeader>

      <CardContent className="space-y-6">
        <input
          ref={fileInputRef}
          type="file"
          multiple
          className="hidden"
          accept={[
            "image/*",
            "audio/*",
            "video/*",
            ".pdf",
            ".doc",
            ".docx",
            ".xls",
            ".xlsx",
            ".csv",
            ".txt",
            ".md",
            ".rtf",
          ].join(",")}
          onChange={handleFilesPicked}
        />

        {reminder && (
          <Alert className="border-primary/30 bg-primary/5">
            <Bell className="h-4 w-4" />
            <div className="flex flex-1 flex-col gap-1">
              <div className="flex flex-wrap items-center justify-between gap-2">
                <AlertTitle className="text-sm">
                  Next task starts in {reminder.mins} minute{reminder.mins === 1 ? "" : "s"}
                </AlertTitle>
                <Button
                  type="button"
                  variant="ghost"
                  size="sm"
                  onClick={() => setDismissedReminderTaskId(reminder.todo.id)}
                >
                  Dismiss
                </Button>
              </div>
              <AlertDescription className="text-sm">
                <span className="font-medium">{reminder.todo.title}</span> ·{" "}
                {formatDateTimeFromMs(reminder.dueMs)}
              </AlertDescription>
            </div>
          </Alert>
        )}

        <div className="rounded-xl border bg-card p-4">
          <div className="flex flex-wrap items-center justify-between gap-2">
            <p className="text-sm font-medium">
              Daily load{" "}
              <span className="text-muted-foreground font-normal">
                ({new Intl.DateTimeFormat(undefined, {
                  weekday: "short",
                  year: "numeric",
                  month: "short",
                  day: "2-digit",
                }).format(parseLocalDateOnly(loadDayKey))})
              </span>
            </p>
            <DailyLoadBadge load={dailyLoad.load} />
          </div>
          <p className="text-muted-foreground mt-2 text-sm">
            {dailyLoad.total} task(s) · busiest window {dailyLoad.busiestWindow} ({dailyLoad.peak})
          </p>
        </div>

        <div className="grid gap-3 sm:grid-cols-3">
          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Today’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">
              {summary.todayCompleted} completed
            </p>
            <p className="text-muted-foreground text-sm">{summary.todayPending} pending</p>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tomorrow’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">{summary.tomorrowTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.tomorrowBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tasks Until Next Week</p>
            <p className="mt-2 text-2xl font-semibold">{summary.upcomingTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.upcomingBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>
        </div>

        {focusMode && (
          <div className="flex flex-col gap-1 rounded-lg border bg-muted/20 px-3 py-2 sm:flex-row sm:items-center sm:justify-between">
            <p className="text-sm">
              <span className="font-medium">Focus Mode:</span>{" "}
              showing tasks due in the next 4 hours (until{" "}
              <span className="font-medium">
                {formatDateTimeFromMs(nowMs + 4 * 60 * 60 * 1000)}
              </span>
              )
            </p>
            <Button type="button" variant="ghost" size="sm" onClick={() => setFocusMode(false)}>
              Exit
            </Button>
          </div>
        )}

        <Form {...form}>
          <form
            onSubmit={form.handleSubmit(addTodo)}
            className="space-y-2"
            noValidate
          >
            <div className="flex flex-col gap-2 sm:flex-row">
              <FormField
                control={form.control}
                name="title"
                render={({ field }) => (
                  <FormItem className="flex-1">
                    <FormControl>
                      <Input
                        placeholder="Add a task…"
                        autoComplete="off"
                        {...field}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="dueAt"
                render={({ field }) => (
                  <FormItem className="sm:w-64">
                    <FormControl>
                      <Input type="datetime-local" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <Button type="submit">Add</Button>
            </div>
          </form>
        </Form>

        <Separator />

        <div className="space-y-3">
          <div className="flex flex-wrap items-center justify-between gap-2">
            <p className="text-sm font-medium">Filter by date & time</p>
            <div className="flex items-center gap-2">
              <Button
                type="button"
                size="sm"
                variant={filterMode === "between" ? "default" : "outline"}
                onClick={() => setFilterMode("between")}
              >
                Between
              </Button>
              <Button
                type="button"
                size="sm"
                variant={filterMode === "exact" ? "default" : "outline"}
                onClick={() => setFilterMode("exact")}
              >
                Exact
              </Button>
              <Button
                type="button"
                size="sm"
                variant="ghost"
                onClick={() => {
                  setFilterFromDate("")
                  setFilterFromTime("")
                  setFilterToDate("")
                  setFilterToTime("")
                  setFilterExactDate("")
                  setFilterExactTime("")
                }}
              >
                Clear
              </Button>
            </div>
          </div>

          {filterMode === "between" ? (
            <div className="grid gap-2 sm:grid-cols-2">
              <div className="grid gap-2 sm:grid-cols-2">
                <Input
                  type="date"
                  value={filterFromDate}
                  onChange={(e) => setFilterFromDate(e.target.value)}
                />
                <Input
                  type="time"
                  value={filterFromTime}
                  onChange={(e) => setFilterFromTime(e.target.value)}
                />
              </div>
              <div className="grid gap-2 sm:grid-cols-2">
                <Input
                  type="date"
                  value={filterToDate}
                  onChange={(e) => setFilterToDate(e.target.value)}
                />
                <Input
                  type="time"
                  value={filterToTime}
                  onChange={(e) => setFilterToTime(e.target.value)}
                />
              </div>
            </div>
          ) : (
            <div className="grid gap-2 sm:grid-cols-2">
              <Input
                type="date"
                value={filterExactDate}
                onChange={(e) => setFilterExactDate(e.target.value)}
              />
              <Input
                type="time"
                value={filterExactTime}
                onChange={(e) => setFilterExactTime(e.target.value)}
              />
            </div>
          )}
        </div>

        <Separator />

        <div className="space-y-2">
          {groupedTodos.length === 0 ? (
            <p className="text-muted-foreground text-sm">No tasks yet.</p>
          ) : (
            groupedTodos.map((group) => (
              <div key={group.date} className="space-y-2">
                <div className="flex items-center gap-3 pt-2">
                  <Separator className="flex-1" />
                  <span className="text-muted-foreground whitespace-nowrap text-xs font-medium">
                    {new Intl.DateTimeFormat(undefined, {
                      weekday: "short",
                      year: "numeric",
                      month: "short",
                      day: "2-digit",
                    }).format(parseLocalDateOnly(group.date))}
                  </span>
                  <Separator className="flex-1" />
                </div>

                {group.items.map((todo) => {
                  const state = getTaskState(todo, nowMs)

                  return (
                    <div
                      key={todo.id}
                      className={cn(
                        "rounded-lg border px-3 py-2",
                        state === "completed" && "opacity-75",
                        state === "overdue" &&
                          "border-destructive/40 bg-destructive/5 text-muted-foreground",
                        state === "in_progress" && "border-primary/30 bg-primary/5",
                        conflictDueAt &&
                          todo.dueAt === conflictDueAt &&
                          "border-destructive/60 bg-destructive/5 ring-1 ring-destructive/30"
                      )}
                    >
                      <div className="flex items-start justify-between gap-3">
                        <label className="flex cursor-pointer items-start gap-3">
                        <Checkbox
                          checked={todo.completed}
                          onCheckedChange={(v) => {
                            const next = Boolean(v)
                            toggleTodo(todo.id, next)
                            if (next && !todo.completed) {
                              requestAttachmentsForTodo(todo.id)
                            }
                          }}
                          aria-label={`Mark "${todo.title}" as ${
                            todo.completed ? "not completed" : "completed"
                          }`}
                          className="mt-0.5"
                        />
                        <span
                          className={cn(
                            "leading-6",
                            todo.completed && "text-muted-foreground line-through"
                          )}
                        >
                          <span className="flex flex-wrap items-center gap-2">
                            <span className="block">{todo.title}</span>
                            <TaskStateBadge state={state} />
                          </span>
                          <span className="text-muted-foreground block text-xs">
                            Due: {formatLocalDateTime(todo.dueAt)}
                          </span>
                        </span>
                      </label>

                      <div className="flex items-center gap-1">
                        {todo.completed && (
                          <Button
                            type="button"
                            variant="outline"
                            size="sm"
                            onClick={() => requestAttachmentsForTodo(todo.id)}
                          >
                            Add files
                          </Button>
                        )}
                        <Button
                          type="button"
                          variant="ghost"
                          size="icon"
                          aria-label={`Delete "${todo.title}"`}
                          onClick={() => deleteTodo(todo.id)}
                        >
                          <Trash2 className="h-4 w-4" />
                        </Button>
                      </div>
                    </div>

                    {todo.completed && todo.attachments.length > 0 && (
                      <div className="mt-3 space-y-2">
                        <p className="text-muted-foreground text-xs">Attachments</p>
                        <ul className="space-y-1">
                          {todo.attachments.map((a) => (
                            <li
                              key={a.id}
                              className="flex items-center justify-between gap-3 rounded-md bg-muted/30 px-2 py-1"
                            >
                              <div className="flex min-w-0 items-center gap-2">
                                <AttachmentIcon kind={a.kind} />
                                <span className="truncate text-sm">{a.name}</span>
                              </div>
                              <a
                                href={a.url}
                                download={a.name}
                                className="inline-flex items-center gap-1 text-sm font-medium underline underline-offset-4"
                              >
                                <Download className="h-4 w-4" />
                                Download
                              </a>
                            </li>
                          ))}
                        </ul>
                      </div>
                    )}
                  </div>
                  )
                })}
              </div>
            ))
          )}
        </div>

        {groupedTodos.length > 0 && (
          <div className="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
            <div className="flex items-center gap-2">
              <span className="text-muted-foreground text-sm">Items per page</span>
              <Select
                value={String(pageSize)}
                onValueChange={(v) => {
                  const next = Number(v)
                  setPageSize(next)
                  setPage(1)
                }}
              >
                <SelectTrigger className="w-[110px]">
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="5">5</SelectItem>
                  <SelectItem value="10">10</SelectItem>
                  <SelectItem value="15">15</SelectItem>
                  <SelectItem value="20">20</SelectItem>
                </SelectContent>
              </Select>
            </div>

            {showPagination && (
              <div className="flex items-center justify-between gap-3 sm:justify-end">
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={() => setPage((p) => Math.max(1, p - 1))}
                  disabled={page <= 1}
                >
                  Prev
                </Button>
                <span className="text-muted-foreground text-sm">
                  Page {page} of {totalPages}
                </span>
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={() => setPage((p) => Math.min(totalPages, p + 1))}
                  disabled={page >= totalPages}
                >
                  Next
                </Button>
              </div>
            )}
          </div>
        )}

        <div className="flex items-center justify-between gap-2">
          <Button
            type="button"
            variant="secondary"
            onClick={clearCompleted}
            disabled={completedCount === 0}
          >
            Clear completed
          </Button>
          <span className="text-muted-foreground text-sm">
            Mock data only (no backend)
          </span>
    </div>
      </CardContent>
    </Card>
  )
}

```

```typescriptreact
"use client"

import { zodResolver } from "@hookform/resolvers/zod"
import {
  AlertTriangle,
  CirclePlay,
  CircleStop,
  CalendarClock,
  CheckCircle2,
  Download,
  File,
  FileSpreadsheet,
  FileText,
  Image as ImageIcon,
  Music,
  Bell,
  Timer,
  Trash2,
  Video,
} from "lucide-react"
import * as React from "react"
import { useForm } from "react-hook-form"
import { toast } from "sonner"
import { z } from "zod"

import { ModeToggle } from "@/components/mode-toggle"
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert"
import { Badge } from "@/components/ui/badge"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Checkbox } from "@/components/ui/checkbox"
import { Form, FormControl, FormField, FormItem, FormMessage } from "@/components/ui/form"
import { Input } from "@/components/ui/input"
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select"
import { Separator } from "@/components/ui/separator"
import { cn } from "@/lib/utils"

type AttachmentKind =
  | "image"
  | "audio"
  | "video"
  | "pdf"
  | "spreadsheet"
  | "document"
  | "text"
  | "file"

type Attachment = {
  id: string
  name: string
  type: string
  size: number
  url: string
  kind: AttachmentKind
}

type Todo = {
  id: string
  title: string
  completed: boolean
  // Stored as `datetime-local` string (YYYY-MM-DDTHH:mm) in local time.
  dueAt: string
  attachments: Attachment[]
}

type TaskState = "planned" | "in_progress" | "completed" | "overdue"
type DailyLoad = "light" | "balanced" | "heavy"

const todoSchema = z.object({
  title: z
    .string()
    .trim()
    .min(1, "Title is required.")
    .max(80, "Keep it under 80 characters."),
  dueAt: z
    .string()
    .min(1, "Due date & time is required.")
    .regex(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}$/, "Invalid date/time."),
})

type TodoFormValues = z.infer<typeof todoSchema>

const initialTodos: Todo[] = [
  {
    id: "1",
    title: "Create a Next.js app",
    completed: true,
    dueAt: "2026-01-16T09:00",
    attachments: [],
  },
  {
    id: "2",
    title: "Add shadcn/ui + dark theme",
    completed: true,
    dueAt: "2026-01-16T10:30",
    attachments: [],
  },
  {
    id: "3",
    title: "Build a mock-data to-do list",
    completed: false,
    dueAt: "2026-01-16T15:00",
    attachments: [],
  },
  {
    id: "4",
    title: "Yesterday: review requirements",
    completed: true,
    dueAt: "2026-01-15T11:15",
    attachments: [],
  },
  {
    id: "5",
    title: "Yesterday: sketch UI layout",
    completed: true,
    dueAt: "2026-01-15T17:45",
    attachments: [],
  },
  {
    id: "6",
    title: "Today: add attachments support",
    completed: false,
    dueAt: "2026-01-16T18:20",
    attachments: [],
  },
  {
    id: "7",
    title: "Tomorrow: QA the filters",
    completed: false,
    dueAt: "2026-01-17T08:05",
    attachments: [],
  },
  {
    id: "8",
    title: "Tomorrow: polish summary cards",
    completed: false,
    dueAt: "2026-01-17T13:30",
    attachments: [],
  },
  {
    id: "9",
    title: "Tomorrow: write small UX notes",
    completed: false,
    dueAt: "2026-01-17T20:10",
    attachments: [],
  },
  {
    id: "10",
    title: "This weekend: add more mock tasks",
    completed: false,
    dueAt: "2026-01-18T10:00",
    attachments: [],
  },
  {
    id: "11",
    title: "This weekend: check time-only filter",
    completed: false,
    dueAt: "2026-01-18T22:15",
    attachments: [],
  },
  {
    id: "12",
    title: "Next week: sync with team",
    completed: false,
    dueAt: "2026-01-19T09:30",
    attachments: [],
  },
  {
    id: "13",
    title: "Next week: test date-only filter",
    completed: false,
    dueAt: "2026-01-20T14:05",
    attachments: [],
  },
  {
    id: "14",
    title: "Next week: test exact date+time filter",
    completed: false,
    dueAt: "2026-01-21T12:00",
    attachments: [],
  },
  {
    id: "15",
    title: "Next week: attach docs to completed tasks",
    completed: false,
    dueAt: "2026-01-22T16:40",
    attachments: [],
  },
  {
    id: "16",
    title: "Next week: final review",
    completed: false,
    dueAt: "2026-01-23T11:00",
    attachments: [],
  },
]

function parseLocalDateTime(value: string): number {
  // value: "YYYY-MM-DDTHH:mm"
  const [datePart, timePart] = value.split("T")
  const [y, m, d] = datePart.split("-").map(Number)
  const [hh, mm] = timePart.split(":").map(Number)
  return new Date(y, m - 1, d, hh, mm, 0, 0).getTime()
}

function pad2(n: number) {
  return String(n).padStart(2, "0")
}

function localDateKey(d: Date) {
  return `${d.getFullYear()}-${pad2(d.getMonth() + 1)}-${pad2(d.getDate())}`
}

function addDays(date: Date, days: number) {
  const d = new Date(date)
  d.setDate(d.getDate() + days)
  return d
}

function startOfDay(date: Date) {
  return new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0, 0)
}

function endOfDay(date: Date) {
  return new Date(
    date.getFullYear(),
    date.getMonth(),
    date.getDate(),
    23,
    59,
    59,
    999
  )
}

function getDatePart(dueAt: string) {
  return dueAt.split("T")[0] ?? ""
}

function getTimePart(dueAt: string) {
  return dueAt.split("T")[1] ?? ""
}

function parseLocalDateOnly(value: string): Date {
  // value: "YYYY-MM-DD"
  const [y, m, d] = value.split("-").map(Number)
  return new Date(y, m - 1, d, 0, 0, 0, 0)
}

function parseLocalTimeToMinutes(value: string): number {
  // value: "HH:mm"
  const [hh, mm] = value.split(":").map(Number)
  return hh * 60 + mm
}

function formatLocalDateTime(value: string): string {
  const ms = parseLocalDateTime(value)
  if (!Number.isFinite(ms)) return value
  return new Intl.DateTimeFormat(undefined, {
    year: "numeric",
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  }).format(new Date(ms))
}

function formatDateTimeFromMs(ms: number): string {
  return new Intl.DateTimeFormat(undefined, {
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  }).format(new Date(ms))
}

function minutesUntil(targetMs: number, nowMs: number) {
  return Math.ceil((targetMs - nowMs) / 60_000)
}

function getTaskState(todo: Todo, nowMs: number): TaskState {
  if (todo.completed) return "completed"
  const dueMs = parseLocalDateTime(todo.dueAt)
  if (dueMs < nowMs) return "overdue"
  return "planned"
}

function getTaskStateWithInProgress(
  todo: Todo,
  nowMs: number,
  inProgressTaskId: string | null
): TaskState {
  const base = getTaskState(todo, nowMs)
  if (base !== "planned") return base
  return inProgressTaskId === todo.id ? "in_progress" : "planned"
}

function getDailyLoad(todosForDay: Todo[]) {
  // 4-hour windows across the day (local).
  const labels = [
    "00:00–04:00",
    "04:00–08:00",
    "08:00–12:00",
    "12:00–16:00",
    "16:00–20:00",
    "20:00–24:00",
  ]
  const buckets = Array.from({ length: 6 }, () => 0) as number[]
  for (const t of todosForDay) {
    const ms = parseLocalDateTime(t.dueAt)
    const hour = new Date(ms).getHours()
    const idx = Math.floor(hour / 4)
    buckets[idx] = (buckets[idx] ?? 0) + 1
  }

  const total = todosForDay.length
  const peak = Math.max(0, ...buckets)
  const spread = buckets.filter((c) => c > 0).length
  const busiestIdx = buckets.findIndex((c) => c === peak)
  const busiestWindow = busiestIdx >= 0 ? labels[busiestIdx] : labels[0]

  // Heuristic: more tasks + higher concentration in one window => heavier day.
  const score = total + peak * 1.5 + Math.max(0, spread - 1) * 0.5
  const load: DailyLoad = score <= 5 ? "light" : score <= 10 ? "balanced" : "heavy"

  return { load, total, peak, spread, busiestWindow }
}

function DailyLoadBadge({ load }: { load: DailyLoad }) {
  if (load === "heavy") return <Badge variant="destructive">Heavy</Badge>
  if (load === "balanced") return <Badge variant="secondary">Balanced</Badge>
  return <Badge variant="outline">Light</Badge>
}

function TaskStateBadge({ state }: { state: TaskState }) {
  switch (state) {
    case "completed":
      return (
        <Badge className="gap-1 bg-emerald-600 text-white hover:bg-emerald-600">
          <CheckCircle2 className="h-3.5 w-3.5" />
          Completed
        </Badge>
      )
    case "overdue":
      return (
        <Badge variant="destructive" className="gap-1">
          <AlertTriangle className="h-3.5 w-3.5" />
          Overdue
        </Badge>
      )
    case "in_progress":
      return (
        <Badge className="gap-1 bg-sky-600 text-white hover:bg-sky-600">
          <Timer className="h-3.5 w-3.5 text-white" />
          In progress
        </Badge>
      )
    default:
      return (
        <Badge variant="outline" className="gap-1">
          <CalendarClock className="h-3.5 w-3.5" />
          Planned
        </Badge>
      )
  }
}

function getAttachmentKind(file: File): AttachmentKind {
  const type = (file.type || "").toLowerCase()
  const name = file.name.toLowerCase()
  const ext = name.includes(".") ? name.split(".").pop() ?? "" : ""

  if (type.startsWith("image/")) return "image"
  if (type.startsWith("audio/")) return "audio"
  if (type.startsWith("video/")) return "video"

  if (ext === "pdf") return "pdf"
  if (["xls", "xlsx", "csv"].includes(ext)) return "spreadsheet"
  if (["doc", "docx"].includes(ext)) return "document"
  if (["txt", "md", "rtf"].includes(ext)) return "text"

  return "file"
}

function makeAttachment(file: File): Attachment {
  return {
    id: crypto.randomUUID(),
    name: file.name,
    type: file.type,
    size: file.size,
    url: URL.createObjectURL(file),
    kind: getAttachmentKind(file),
  }
}

function revokeTodoAttachments(todo: Todo) {
  for (const a of todo.attachments) URL.revokeObjectURL(a.url)
}

function AttachmentIcon({ kind }: { kind: AttachmentKind }) {
  const className = "h-4 w-4 text-muted-foreground"

  switch (kind) {
    case "image":
      return <ImageIcon className={className} />
    case "audio":
      return <Music className={className} />
    case "video":
      return <Video className={className} />
    case "spreadsheet":
      return <FileSpreadsheet className={className} />
    case "pdf":
    case "document":
    case "text":
      return <FileText className={className} />
    default:
      return <File className={className} />
  }
}

export default function Home() {
  return (
    <div className="mx-auto flex min-h-screen max-w-2xl flex-col gap-6 px-4 py-10">
      <TodoApp />
    </div>
  )
}

function TodoApp() {
  const [todos, setTodos] = React.useState<Todo[]>(initialTodos)
  const [attachTargetTodoId, setAttachTargetTodoId] = React.useState<string | null>(
    null
  )
  const [conflictDueAt, setConflictDueAt] = React.useState<string | null>(null)
  const clearConflictTimerRef = React.useRef<number | null>(null)
  const [focusMode, setFocusMode] = React.useState(false)
  const [nowMs, setNowMs] = React.useState(() => Date.now())
  const [inProgressTaskId, setInProgressTaskId] = React.useState<string | null>(null)
  const [dismissedReminderTaskId, setDismissedReminderTaskId] = React.useState<
    string | null
  >(null)
  const [filterMode, setFilterMode] = React.useState<"between" | "exact">("between")
  const [filterFromDate, setFilterFromDate] = React.useState<string>("")
  const [filterFromTime, setFilterFromTime] = React.useState<string>("")
  const [filterToDate, setFilterToDate] = React.useState<string>("")
  const [filterToTime, setFilterToTime] = React.useState<string>("")
  const [filterExactDate, setFilterExactDate] = React.useState<string>("")
  const [filterExactTime, setFilterExactTime] = React.useState<string>("")
  const fileInputRef = React.useRef<HTMLInputElement>(null)
  const [pageSize, setPageSize] = React.useState<number>(5)
  const [page, setPage] = React.useState<number>(1)

  const todosRef = React.useRef(todos)
  React.useEffect(() => {
    todosRef.current = todos
  }, [todos])
  React.useEffect(() => {
    return () => {
      for (const t of todosRef.current) revokeTodoAttachments(t)
    }
  }, [])

  // Keep "now" fresh so overdue/in-progress states stay accurate without user interaction.
  React.useEffect(() => {
    const id = window.setInterval(() => setNowMs(Date.now()), 30_000)
    return () => window.clearInterval(id)
  }, [])

  // Only one task can be "In Progress"; auto-clear if completed, deleted, or overdue.
  React.useEffect(() => {
    if (!inProgressTaskId) return
    const t = todos.find((x) => x.id === inProgressTaskId)
    if (!t || t.completed) {
      setInProgressTaskId(null)
      return
    }
    if (parseLocalDateTime(t.dueAt) < nowMs) setInProgressTaskId(null)
  }, [inProgressTaskId, nowMs, todos])

  const nextUpcoming = React.useMemo(() => {
    const upcoming = todos
      .filter((t) => !t.completed)
      .map((t) => ({ todo: t, dueMs: parseLocalDateTime(t.dueAt) }))
      .filter((x) => x.dueMs >= nowMs)
      .sort((a, b) => a.dueMs - b.dueMs)[0]
    return upcoming ?? null
  }, [nowMs, todos])

  React.useEffect(() => {
    // If "next upcoming" changed, allow reminder again (dismiss is per-task).
    if (nextUpcoming && nextUpcoming.todo.id !== dismissedReminderTaskId) return
    if (!nextUpcoming) setDismissedReminderTaskId(null)
  }, [dismissedReminderTaskId, nextUpcoming])

  const reminder = React.useMemo(() => {
    const REMINDER_WINDOW_MIN = 15
    if (!nextUpcoming) return null
    if (dismissedReminderTaskId === nextUpcoming.todo.id) return null
    const mins = minutesUntil(nextUpcoming.dueMs, nowMs)
    if (mins < 0 || mins > REMINDER_WINDOW_MIN) return null
    return { ...nextUpcoming, mins }
  }, [dismissedReminderTaskId, nextUpcoming, nowMs])

  const form = useForm<TodoFormValues>({
    resolver: zodResolver(todoSchema),
    defaultValues: { title: "", dueAt: "" },
    mode: "onSubmit",
  })

  const summary = React.useMemo(() => {
    const now = new Date()
    const todayKey = localDateKey(now)
    const tomorrow = addDays(now, 1)
    const tomorrowKey = localDateKey(tomorrow)

    const todays = todos.filter((t) => t.dueAt.startsWith(todayKey))
    const todayCompleted = todays.filter((t) => t.completed).length
    const todayPending = todays.length - todayCompleted

    const labels = [
      "00:00–04:00",
      "04:00–08:00",
      "08:00–12:00",
      "12:00–16:00",
      "16:00–20:00",
      "20:00–24:00",
    ]

    // Tomorrow: same 4-hour windows breakdown
    const tomorrowTasks = todos.filter((t) => t.dueAt.startsWith(tomorrowKey))
    const tomorrowBuckets = Array.from({ length: 6 }, () => 0) as number[]
    for (const t of tomorrowTasks) {
      const ms = parseLocalDateTime(t.dueAt)
      const hour = new Date(ms).getHours()
      const idx = Math.floor(hour / 4)
      tomorrowBuckets[idx] = (tomorrowBuckets[idx] ?? 0) + 1
    }

    // Until next week = next 7 days starting tomorrow (local), grouped into 4-hour windows.
    const rangeStart = startOfDay(tomorrow).getTime()
    const rangeEnd = addDays(startOfDay(tomorrow), 7).getTime()
    const buckets = Array.from({ length: 6 }, () => 0) as number[]

    const upcoming = todos.filter((t) => {
      const ms = parseLocalDateTime(t.dueAt)
      return ms >= rangeStart && ms < rangeEnd
    })

    for (const t of upcoming) {
      const ms = parseLocalDateTime(t.dueAt)
      const hour = new Date(ms).getHours()
      const idx = Math.floor(hour / 4)
      buckets[idx] = (buckets[idx] ?? 0) + 1
    }

    return {
      todayCompleted,
      todayPending,
      tomorrowTotal: tomorrowTasks.length,
      tomorrowBuckets: labels.map((label, i) => ({ label, count: tomorrowBuckets[i] ?? 0 })),
      upcomingTotal: upcoming.length,
      upcomingBuckets: labels.map((label, i) => ({ label, count: buckets[i] ?? 0 })),
    }
  }, [todos])

  const loadDayKey = React.useMemo(() => {
    // Prefer an explicitly selected date from filters; otherwise use today.
    if (filterMode === "exact" && filterExactDate) return filterExactDate
    if (filterFromDate && !filterToDate) return filterFromDate
    if (filterFromDate && filterToDate && filterFromDate === filterToDate) return filterFromDate
    if (!filterFromDate && filterToDate) return filterToDate
    return localDateKey(new Date(nowMs))
  }, [filterExactDate, filterFromDate, filterMode, filterToDate, nowMs])

  const dailyLoad = React.useMemo(() => {
    const dayTodos = todos.filter((t) => getDatePart(t.dueAt) === loadDayKey)
    return getDailyLoad(dayTodos)
  }, [loadDayKey, todos])

  const filteredTodos = React.useMemo(() => {
    if (focusMode) {
      const endMs = nowMs + 4 * 60 * 60 * 1000
      const withMs = todos.map((t) => ({ ...t, _dueMs: parseLocalDateTime(t.dueAt) }))
      return withMs.filter((t) => t._dueMs >= nowMs && t._dueMs <= endMs)
    }

    const withMs = todos.map((t) => ({ ...t, _dueMs: parseLocalDateTime(t.dueAt) }))
    if (filterMode === "exact") {
      // If only date is selected -> show tasks for that date.
      // If time is selected too -> match exact date+time.
      // If only time is selected -> match time-of-day across all dates.
      if (!filterExactDate && !filterExactTime) return withMs

      if (filterExactDate && !filterExactTime) {
        return withMs.filter((t) => getDatePart(t.dueAt) === filterExactDate)
      }

      if (filterExactDate && filterExactTime) {
        const exactMs = parseLocalDateTime(`${filterExactDate}T${filterExactTime}`)
        return withMs.filter((t) => t._dueMs === exactMs)
      }

      // time only
      return withMs.filter((t) => getTimePart(t.dueAt) === filterExactTime)
    }
    // between
    const hasAnyDate = Boolean(filterFromDate || filterToDate)
    const hasAnyTime = Boolean(filterFromTime || filterToTime)

    // Date range (optional)
    const fromDateMs = filterFromDate
      ? startOfDay(parseLocalDateOnly(filterFromDate)).getTime()
      : Number.NEGATIVE_INFINITY
    const toDateMs = filterToDate
      ? endOfDay(parseLocalDateOnly(filterToDate)).getTime()
      : Number.POSITIVE_INFINITY

    // Time-of-day range (optional)
    const fromTimeMin = filterFromTime ? parseLocalTimeToMinutes(filterFromTime) : 0
    const toTimeMin = filterToTime ? parseLocalTimeToMinutes(filterToTime) : 24 * 60 - 1

    return withMs.filter((t) => {
      const ms = t._dueMs
      if (hasAnyDate && (ms < fromDateMs || ms > toDateMs)) return false

      if (hasAnyTime) {
        const time = getTimePart(t.dueAt)
        if (!time) return false
        const mins = parseLocalTimeToMinutes(time)
        // Simple (non-wrapping) range. If you want wrap-around (e.g. 22:00–02:00), tell me.
        if (mins < fromTimeMin || mins > toTimeMin) return false
      }

      // If neither date nor time selected, pass through (handled above anyway)
      return true
    })
  }, [
    todos,
    focusMode,
    nowMs,
    filterExactDate,
    filterExactTime,
    filterFromDate,
    filterFromTime,
    filterMode,
    filterToDate,
    filterToTime,
  ])

  const sortedFilteredTodos = React.useMemo(
    () =>
      filteredTodos
        .slice()
        .sort((a, b) => parseLocalDateTime(a.dueAt) - parseLocalDateTime(b.dueAt)),
    [filteredTodos]
  )

  // Clamp page when filters/pageSize change.
  React.useEffect(() => {
    const totalPages = Math.max(1, Math.ceil(sortedFilteredTodos.length / pageSize))
    setPage((p) => Math.min(Math.max(1, p), totalPages))
  }, [pageSize, sortedFilteredTodos.length])

  const totalItems = sortedFilteredTodos.length
  const totalPages = Math.max(1, Math.ceil(totalItems / pageSize))
  const showPagination = totalPages > 1

  const pageItems = React.useMemo(() => {
    const start = (page - 1) * pageSize
    return sortedFilteredTodos.slice(start, start + pageSize)
  }, [page, pageSize, sortedFilteredTodos])

  const groupedTodos = React.useMemo(() => {
    const groups: Array<{ date: string; items: typeof pageItems }> = []
    for (const t of pageItems) {
      const date = getDatePart(t.dueAt)
      const last = groups[groups.length - 1]
      if (!last || last.date !== date) groups.push({ date, items: [t] })
      else last.items.push(t)
    }
    return groups
  }, [pageItems])

  const completedCount = filteredTodos.filter((t) => t.completed).length

  function addTodo(values: TodoFormValues) {
    const conflicts = todos.filter((t) => t.dueAt === values.dueAt)
    if (conflicts.length > 0) {
      setConflictDueAt(values.dueAt)
      if (clearConflictTimerRef.current) window.clearTimeout(clearConflictTimerRef.current)
      clearConflictTimerRef.current = window.setTimeout(() => {
        setConflictDueAt(null)
      }, 8000)

      // Make sure the user can see the conflicting tasks even if they were filtered out.
      const [d, time] = values.dueAt.split("T")
      setFilterMode("exact")
      setFilterExactDate(d ?? "")
      setFilterExactTime(time ?? "")
      setPage(1)

      toast.error("Time conflict", {
        description: `You already have ${conflicts.length} task(s) scheduled at ${formatLocalDateTime(
          values.dueAt
        )}.`,
      })
    }

    setTodos((prev) => [
      {
        id: crypto.randomUUID(),
        title: values.title.trim(),
        completed: false,
        dueAt: values.dueAt,
        attachments: [],
      },
      ...prev,
    ])
    form.reset()
  }

  function toggleTodo(id: string, completed: boolean) {
    setTodos((prev) => prev.map((t) => (t.id === id ? { ...t, completed } : t)))
    if (completed) setInProgressTaskId((cur) => (cur === id ? null : cur))
  }

  function requestAttachmentsForTodo(todoId: string) {
    setAttachTargetTodoId(todoId)
    // Let state update before opening picker (some browsers are picky).
    queueMicrotask(() => fileInputRef.current?.click())
  }

  function handleFilesPicked(e: React.ChangeEvent<HTMLInputElement>) {
    const files = Array.from(e.target.files ?? [])
    const targetId = attachTargetTodoId

    // reset input so picking the same file again triggers onChange
    e.target.value = ""
    setAttachTargetTodoId(null)

    if (!targetId || files.length === 0) return

    const attachments = files.map(makeAttachment)

    setTodos((prev) =>
      prev.map((t) =>
        t.id === targetId
          ? { ...t, attachments: [...t.attachments, ...attachments] }
          : t
      )
    )
  }

  function deleteTodo(id: string) {
    setTodos((prev) => {
      const victim = prev.find((t) => t.id === id)
      if (victim) revokeTodoAttachments(victim)
      return prev.filter((t) => t.id !== id)
    })
    setInProgressTaskId((cur) => (cur === id ? null : cur))
  }

  function clearCompleted() {
    setTodos((prev) => {
      for (const t of prev) {
        if (t.completed) revokeTodoAttachments(t)
      }
      return prev.filter((t) => !t.completed)
    })
  }

  return (
    <Card>
      <CardHeader className="flex flex-row items-center justify-between gap-4">
        <div className="space-y-1">
          <CardTitle className="text-2xl">To‑Do</CardTitle>
          <p className="text-muted-foreground text-sm">
            {completedCount}/{filteredTodos.length} completed
          </p>
        </div>
        <div className="flex items-center gap-2">
          <Button
            type="button"
            variant={focusMode ? "default" : "outline"}
            size="sm"
            onClick={() => {
              setFocusMode((v) => !v)
              setPage(1)
            }}
          >
            Focus Mode
          </Button>
          <ModeToggle />
        </div>
      </CardHeader>

      <CardContent className="space-y-6">
        <input
          ref={fileInputRef}
          type="file"
          multiple
          className="hidden"
          accept={[
            "image/*",
            "audio/*",
            "video/*",
            ".pdf",
            ".doc",
            ".docx",
            ".xls",
            ".xlsx",
            ".csv",
            ".txt",
            ".md",
            ".rtf",
          ].join(",")}
          onChange={handleFilesPicked}
        />

        {reminder && (
          <Alert className="border-primary/30 bg-primary/5">
            <Bell className="h-4 w-4" />
            <div className="flex flex-1 flex-col gap-1">
              <div className="flex flex-wrap items-center justify-between gap-2">
                <AlertTitle className="text-sm">
                  Next task starts in {reminder.mins} minute{reminder.mins === 1 ? "" : "s"}
                </AlertTitle>
                <Button
                  type="button"
                  variant="ghost"
                  size="sm"
                  onClick={() => setDismissedReminderTaskId(reminder.todo.id)}
                >
                  Dismiss
                </Button>
              </div>
              <AlertDescription className="text-sm">
                <span className="font-medium">{reminder.todo.title}</span> ·{" "}
                {formatDateTimeFromMs(reminder.dueMs)}
              </AlertDescription>
            </div>
          </Alert>
        )}

        <div className="rounded-xl border bg-card p-4">
          <div className="flex flex-wrap items-center justify-between gap-2">
            <p className="text-sm font-medium">
              Daily load{" "}
              <span className="text-muted-foreground font-normal">
                ({new Intl.DateTimeFormat(undefined, {
                  weekday: "short",
                  year: "numeric",
                  month: "short",
                  day: "2-digit",
                }).format(parseLocalDateOnly(loadDayKey))})
              </span>
            </p>
            <DailyLoadBadge load={dailyLoad.load} />
          </div>
          <p className="text-muted-foreground mt-2 text-sm">
            {dailyLoad.total} task(s) · busiest window {dailyLoad.busiestWindow} ({dailyLoad.peak})
          </p>
        </div>

        <div className="grid gap-3 sm:grid-cols-3">
          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Today’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">
              {summary.todayCompleted} completed
            </p>
            <p className="text-muted-foreground text-sm">{summary.todayPending} pending</p>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tomorrow’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">{summary.tomorrowTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.tomorrowBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tasks Until Next Week</p>
            <p className="mt-2 text-2xl font-semibold">{summary.upcomingTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.upcomingBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>
        </div>

        {focusMode && (
          <div className="flex flex-col gap-1 rounded-lg border bg-muted/20 px-3 py-2 sm:flex-row sm:items-center sm:justify-between">
            <p className="text-sm">
              <span className="font-medium">Focus Mode:</span>{" "}
              showing tasks due in the next 4 hours (until{" "}
              <span className="font-medium">
                {formatDateTimeFromMs(nowMs + 4 * 60 * 60 * 1000)}
              </span>
              )
            </p>
            <Button type="button" variant="ghost" size="sm" onClick={() => setFocusMode(false)}>
              Exit
            </Button>
          </div>
        )}

        <Form {...form}>
          <form
            onSubmit={form.handleSubmit(addTodo)}
            className="space-y-2"
            noValidate
          >
            <div className="flex flex-col gap-2 sm:flex-row">
              <FormField
                control={form.control}
                name="title"
                render={({ field }) => (
                  <FormItem className="flex-1">
                    <FormControl>
                      <Input
                        placeholder="Add a task…"
                        autoComplete="off"
                        {...field}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="dueAt"
                render={({ field }) => (
                  <FormItem className="sm:w-64">
                    <FormControl>
                      <Input type="datetime-local" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <Button type="submit">Add</Button>
            </div>
          </form>
        </Form>

        <Separator />

        <div className="space-y-3">
          <div className="flex flex-wrap items-center justify-between gap-2">
            <p className="text-sm font-medium">Filter by date & time</p>
            <div className="flex items-center gap-2">
              <Button
                type="button"
                size="sm"
                variant={filterMode === "between" ? "default" : "outline"}
                onClick={() => setFilterMode("between")}
              >
                Between
              </Button>
              <Button
                type="button"
                size="sm"
                variant={filterMode === "exact" ? "default" : "outline"}
                onClick={() => setFilterMode("exact")}
              >
                Exact
              </Button>
              <Button
                type="button"
                size="sm"
                variant="ghost"
                onClick={() => {
                  setFilterFromDate("")
                  setFilterFromTime("")
                  setFilterToDate("")
                  setFilterToTime("")
                  setFilterExactDate("")
                  setFilterExactTime("")
                }}
              >
                Clear
              </Button>
            </div>
          </div>

          {filterMode === "between" ? (
            <div className="grid gap-2 sm:grid-cols-2">
              <div className="grid gap-2 sm:grid-cols-2">
                <Input
                  type="date"
                  value={filterFromDate}
                  onChange={(e) => setFilterFromDate(e.target.value)}
                />
                <Input
                  type="time"
                  value={filterFromTime}
                  onChange={(e) => setFilterFromTime(e.target.value)}
                />
              </div>
              <div className="grid gap-2 sm:grid-cols-2">
                <Input
                  type="date"
                  value={filterToDate}
                  onChange={(e) => setFilterToDate(e.target.value)}
                />
                <Input
                  type="time"
                  value={filterToTime}
                  onChange={(e) => setFilterToTime(e.target.value)}
                />
              </div>
            </div>
          ) : (
            <div className="grid gap-2 sm:grid-cols-2">
              <Input
                type="date"
                value={filterExactDate}
                onChange={(e) => setFilterExactDate(e.target.value)}
              />
              <Input
                type="time"
                value={filterExactTime}
                onChange={(e) => setFilterExactTime(e.target.value)}
              />
            </div>
          )}
        </div>

        <Separator />

        <div className="space-y-2">
          {groupedTodos.length === 0 ? (
            <p className="text-muted-foreground text-sm">No tasks yet.</p>
          ) : (
            groupedTodos.map((group) => (
              <div key={group.date} className="space-y-2">
                <div className="flex items-center gap-3 pt-2">
                  <Separator className="flex-1" />
                  <span className="text-muted-foreground whitespace-nowrap text-xs font-medium">
                    {new Intl.DateTimeFormat(undefined, {
                      weekday: "short",
                      year: "numeric",
                      month: "short",
                      day: "2-digit",
                    }).format(parseLocalDateOnly(group.date))}
                  </span>
                  <Separator className="flex-1" />
                </div>

                {group.items.map((todo) => {
                  const state = getTaskStateWithInProgress(todo, nowMs, inProgressTaskId)

                  return (
                    <div
                      key={todo.id}
                      className={cn(
                        "rounded-lg border px-3 py-2",
                        state === "completed" && "opacity-75",
                        state === "overdue" &&
                          "border-destructive/40 bg-destructive/5 text-muted-foreground",
                        state === "in_progress" && "border-sky-500/40 bg-sky-500/10",
                        conflictDueAt &&
                          todo.dueAt === conflictDueAt &&
                          "border-destructive/60 bg-destructive/5 ring-1 ring-destructive/30"
                      )}
                    >
                      <div className="flex items-start justify-between gap-3">
                        <label className="flex cursor-pointer items-start gap-3">
                        <Checkbox
                          checked={todo.completed}
                          onCheckedChange={(v) => {
                            const next = Boolean(v)
                            toggleTodo(todo.id, next)
                            if (next && !todo.completed) {
                              requestAttachmentsForTodo(todo.id)
                            }
                          }}
                          aria-label={`Mark "${todo.title}" as ${
                            todo.completed ? "not completed" : "completed"
                          }`}
                          className="mt-0.5"
                        />
                        <span
                          className={cn(
                            "leading-6",
                            todo.completed && "text-muted-foreground line-through"
                          )}
                        >
                          <span className="flex flex-wrap items-center gap-2">
                            <span className="block">{todo.title}</span>
                            <TaskStateBadge state={state} />
                          </span>
                          <span className="text-muted-foreground block text-xs">
                            Due: {formatLocalDateTime(todo.dueAt)}
                          </span>
                        </span>
                      </label>

                      <div className="flex items-center gap-1">
                        {!todo.completed && state !== "overdue" && (
                          <Button
                            type="button"
                            variant={state === "in_progress" ? "default" : "outline"}
                            size="sm"
                            onClick={() =>
                              setInProgressTaskId((cur) =>
                                cur === todo.id ? null : todo.id
                              )
                            }
                            className={cn(
                              state === "in_progress" && "bg-sky-600 hover:bg-sky-600"
                            )}
                          >
                            {state === "in_progress" ? (
                              <>
                                <CircleStop className="mr-1 h-4 w-4" />
                                Stop
                              </>
                            ) : (
                              <>
                                <CirclePlay className="mr-1 h-4 w-4" />
                                Start
                              </>
                            )}
                          </Button>
                        )}
                        {todo.completed && (
                          <Button
                            type="button"
                            variant="outline"
                            size="sm"
                            onClick={() => requestAttachmentsForTodo(todo.id)}
                          >
                            Add files
                          </Button>
                        )}
                        <Button
                          type="button"
                          variant="ghost"
                          size="icon"
                          aria-label={`Delete "${todo.title}"`}
                          onClick={() => deleteTodo(todo.id)}
                        >
                          <Trash2 className="h-4 w-4" />
                        </Button>
                      </div>
                    </div>

                    {todo.completed && todo.attachments.length > 0 && (
                      <div className="mt-3 space-y-2">
                        <p className="text-muted-foreground text-xs">Attachments</p>
                        <ul className="space-y-1">
                          {todo.attachments.map((a) => (
                            <li
                              key={a.id}
                              className="flex items-center justify-between gap-3 rounded-md bg-muted/30 px-2 py-1"
                            >
                              <div className="flex min-w-0 items-center gap-2">
                                <AttachmentIcon kind={a.kind} />
                                <span className="truncate text-sm">{a.name}</span>
                              </div>
                              <a
                                href={a.url}
                                download={a.name}
                                className="inline-flex items-center gap-1 text-sm font-medium underline underline-offset-4"
                              >
                                <Download className="h-4 w-4" />
                                Download
                              </a>
                            </li>
                          ))}
                        </ul>
                      </div>
                    )}
                  </div>
                  )
                })}
              </div>
            ))
          )}
        </div>

        {groupedTodos.length > 0 && (
          <div className="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
            <div className="flex items-center gap-2">
              <span className="text-muted-foreground text-sm">Items per page</span>
              <Select
                value={String(pageSize)}
                onValueChange={(v) => {
                  const next = Number(v)
                  setPageSize(next)
                  setPage(1)
                }}
              >
                <SelectTrigger className="w-[110px]">
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="5">5</SelectItem>
                  <SelectItem value="10">10</SelectItem>
                  <SelectItem value="15">15</SelectItem>
                  <SelectItem value="20">20</SelectItem>
                </SelectContent>
              </Select>
            </div>

            {showPagination && (
              <div className="flex items-center justify-between gap-3 sm:justify-end">
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={() => setPage((p) => Math.max(1, p - 1))}
                  disabled={page <= 1}
                >
                  Prev
                </Button>
                <span className="text-muted-foreground text-sm">
                  Page {page} of {totalPages}
                </span>
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={() => setPage((p) => Math.min(totalPages, p + 1))}
                  disabled={page >= totalPages}
                >
                  Next
                </Button>
              </div>
            )}
          </div>
        )}

        <div className="flex items-center justify-between gap-2">
          <Button
            type="button"
            variant="secondary"
            onClick={clearCompleted}
            disabled={completedCount === 0}
          >
            Clear completed
          </Button>
          <span className="text-muted-foreground text-sm">
            Mock data only (no backend)
          </span>
    </div>
      </CardContent>
    </Card>
  )
}

```

### Manual **In Progress** state (one at a time) implemented
- Added a **Start/Stop** button on each task row.
- **Only one task can be In Progress** at a time (starting a new one replaces the previous).
- **Auto-clears** In Progress if that task is **completed**, **deleted**, or becomes **overdue**.
- Visually distinct:
  - **In Progress** badge + blue-tinted row styling (different from Planned/Completed/Overdue).

### File changed
- `src/app/page.tsx`

### Run
```bash
npm run dev
```

```shellscript
npm run dev
```

---

**User**

Allow users to mark an Overdue task as In Progress. The Overdue state should remain time-based and automatic, while In Progress reflects the user’s current focus. Both states can be displayed simultaneously.

---

**Cursor**

Got it — we’ll decouple “Overdue” (automatic/time-based) from “In Progress” (manual focus). Next I’ll adjust the task-state helpers so a task can be **both Overdue + In Progress**, update the row styling/badges to display both, and remove the auto-clear that was turning off In Progress when a task becomes overdue.

```typescriptreact
"use client"

import { zodResolver } from "@hookform/resolvers/zod"
import {
  AlertTriangle,
  CirclePlay,
  CircleStop,
  CalendarClock,
  CheckCircle2,
  Download,
  File,
  FileSpreadsheet,
  FileText,
  Image as ImageIcon,
  Music,
  Bell,
  Timer,
  Trash2,
  Video,
} from "lucide-react"
import * as React from "react"
import { useForm } from "react-hook-form"
import { toast } from "sonner"
import { z } from "zod"

import { ModeToggle } from "@/components/mode-toggle"
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert"
import { Badge } from "@/components/ui/badge"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Checkbox } from "@/components/ui/checkbox"
import { Form, FormControl, FormField, FormItem, FormMessage } from "@/components/ui/form"
import { Input } from "@/components/ui/input"
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select"
import { Separator } from "@/components/ui/separator"
import { cn } from "@/lib/utils"

type AttachmentKind =
  | "image"
  | "audio"
  | "video"
  | "pdf"
  | "spreadsheet"
  | "document"
  | "text"
  | "file"

type Attachment = {
  id: string
  name: string
  type: string
  size: number
  url: string
  kind: AttachmentKind
}

type Todo = {
  id: string
  title: string
  completed: boolean
  // Stored as `datetime-local` string (YYYY-MM-DDTHH:mm) in local time.
  dueAt: string
  attachments: Attachment[]
}

type TaskState = "planned" | "in_progress" | "completed" | "overdue"
type DailyLoad = "light" | "balanced" | "heavy"

const todoSchema = z.object({
  title: z
    .string()
    .trim()
    .min(1, "Title is required.")
    .max(80, "Keep it under 80 characters."),
  dueAt: z
    .string()
    .min(1, "Due date & time is required.")
    .regex(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}$/, "Invalid date/time."),
})

type TodoFormValues = z.infer<typeof todoSchema>

const initialTodos: Todo[] = [
  {
    id: "1",
    title: "Create a Next.js app",
    completed: true,
    dueAt: "2026-01-16T09:00",
    attachments: [],
  },
  {
    id: "2",
    title: "Add shadcn/ui + dark theme",
    completed: true,
    dueAt: "2026-01-16T10:30",
    attachments: [],
  },
  {
    id: "3",
    title: "Build a mock-data to-do list",
    completed: false,
    dueAt: "2026-01-16T15:00",
    attachments: [],
  },
  {
    id: "4",
    title: "Yesterday: review requirements",
    completed: true,
    dueAt: "2026-01-15T11:15",
    attachments: [],
  },
  {
    id: "5",
    title: "Yesterday: sketch UI layout",
    completed: true,
    dueAt: "2026-01-15T17:45",
    attachments: [],
  },
  {
    id: "6",
    title: "Today: add attachments support",
    completed: false,
    dueAt: "2026-01-16T18:20",
    attachments: [],
  },
  {
    id: "7",
    title: "Tomorrow: QA the filters",
    completed: false,
    dueAt: "2026-01-17T08:05",
    attachments: [],
  },
  {
    id: "8",
    title: "Tomorrow: polish summary cards",
    completed: false,
    dueAt: "2026-01-17T13:30",
    attachments: [],
  },
  {
    id: "9",
    title: "Tomorrow: write small UX notes",
    completed: false,
    dueAt: "2026-01-17T20:10",
    attachments: [],
  },
  {
    id: "10",
    title: "This weekend: add more mock tasks",
    completed: false,
    dueAt: "2026-01-18T10:00",
    attachments: [],
  },
  {
    id: "11",
    title: "This weekend: check time-only filter",
    completed: false,
    dueAt: "2026-01-18T22:15",
    attachments: [],
  },
  {
    id: "12",
    title: "Next week: sync with team",
    completed: false,
    dueAt: "2026-01-19T09:30",
    attachments: [],
  },
  {
    id: "13",
    title: "Next week: test date-only filter",
    completed: false,
    dueAt: "2026-01-20T14:05",
    attachments: [],
  },
  {
    id: "14",
    title: "Next week: test exact date+time filter",
    completed: false,
    dueAt: "2026-01-21T12:00",
    attachments: [],
  },
  {
    id: "15",
    title: "Next week: attach docs to completed tasks",
    completed: false,
    dueAt: "2026-01-22T16:40",
    attachments: [],
  },
  {
    id: "16",
    title: "Next week: final review",
    completed: false,
    dueAt: "2026-01-23T11:00",
    attachments: [],
  },
]

function parseLocalDateTime(value: string): number {
  // value: "YYYY-MM-DDTHH:mm"
  const [datePart, timePart] = value.split("T")
  const [y, m, d] = datePart.split("-").map(Number)
  const [hh, mm] = timePart.split(":").map(Number)
  return new Date(y, m - 1, d, hh, mm, 0, 0).getTime()
}

function pad2(n: number) {
  return String(n).padStart(2, "0")
}

function localDateKey(d: Date) {
  return `${d.getFullYear()}-${pad2(d.getMonth() + 1)}-${pad2(d.getDate())}`
}

function addDays(date: Date, days: number) {
  const d = new Date(date)
  d.setDate(d.getDate() + days)
  return d
}

function startOfDay(date: Date) {
  return new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0, 0)
}

function endOfDay(date: Date) {
  return new Date(
    date.getFullYear(),
    date.getMonth(),
    date.getDate(),
    23,
    59,
    59,
    999
  )
}

function getDatePart(dueAt: string) {
  return dueAt.split("T")[0] ?? ""
}

function getTimePart(dueAt: string) {
  return dueAt.split("T")[1] ?? ""
}

function parseLocalDateOnly(value: string): Date {
  // value: "YYYY-MM-DD"
  const [y, m, d] = value.split("-").map(Number)
  return new Date(y, m - 1, d, 0, 0, 0, 0)
}

function parseLocalTimeToMinutes(value: string): number {
  // value: "HH:mm"
  const [hh, mm] = value.split(":").map(Number)
  return hh * 60 + mm
}

function formatLocalDateTime(value: string): string {
  const ms = parseLocalDateTime(value)
  if (!Number.isFinite(ms)) return value
  return new Intl.DateTimeFormat(undefined, {
    year: "numeric",
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  }).format(new Date(ms))
}

function formatDateTimeFromMs(ms: number): string {
  return new Intl.DateTimeFormat(undefined, {
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  }).format(new Date(ms))
}

function minutesUntil(targetMs: number, nowMs: number) {
  return Math.ceil((targetMs - nowMs) / 60_000)
}

function getTaskFlags(todo: Todo, nowMs: number, inProgressTaskId: string | null) {
  const completed = todo.completed
  const dueMs = parseLocalDateTime(todo.dueAt)
  const overdue = !completed && dueMs < nowMs
  const inProgress = !completed && inProgressTaskId === todo.id
  const planned = !completed && !overdue && !inProgress
  return { completed, overdue, inProgress, planned }
}

function getDailyLoad(todosForDay: Todo[]) {
  // 4-hour windows across the day (local).
  const labels = [
    "00:00–04:00",
    "04:00–08:00",
    "08:00–12:00",
    "12:00–16:00",
    "16:00–20:00",
    "20:00–24:00",
  ]
  const buckets = Array.from({ length: 6 }, () => 0) as number[]
  for (const t of todosForDay) {
    const ms = parseLocalDateTime(t.dueAt)
    const hour = new Date(ms).getHours()
    const idx = Math.floor(hour / 4)
    buckets[idx] = (buckets[idx] ?? 0) + 1
  }

  const total = todosForDay.length
  const peak = Math.max(0, ...buckets)
  const spread = buckets.filter((c) => c > 0).length
  const busiestIdx = buckets.findIndex((c) => c === peak)
  const busiestWindow = busiestIdx >= 0 ? labels[busiestIdx] : labels[0]

  // Heuristic: more tasks + higher concentration in one window => heavier day.
  const score = total + peak * 1.5 + Math.max(0, spread - 1) * 0.5
  const load: DailyLoad = score <= 5 ? "light" : score <= 10 ? "balanced" : "heavy"

  return { load, total, peak, spread, busiestWindow }
}

function DailyLoadBadge({ load }: { load: DailyLoad }) {
  if (load === "heavy") return <Badge variant="destructive">Heavy</Badge>
  if (load === "balanced") return <Badge variant="secondary">Balanced</Badge>
  return <Badge variant="outline">Light</Badge>
}

function TaskBadges({
  completed,
  overdue,
  inProgress,
  planned,
}: {
  completed: boolean
  overdue: boolean
  inProgress: boolean
  planned: boolean
}) {
  if (completed) {
    return (
      <Badge className="gap-1 bg-emerald-600 text-white hover:bg-emerald-600">
        <CheckCircle2 className="h-3.5 w-3.5" />
        Completed
      </Badge>
    )
  }

  return (
    <>
      {inProgress && (
        <Badge className="gap-1 bg-sky-600 text-white hover:bg-sky-600">
          <Timer className="h-3.5 w-3.5 text-white" />
          In progress
        </Badge>
      )}
      {overdue && (
        <Badge variant="destructive" className="gap-1">
          <AlertTriangle className="h-3.5 w-3.5" />
          Overdue
        </Badge>
      )}
      {planned && (
        <Badge variant="outline" className="gap-1">
          <CalendarClock className="h-3.5 w-3.5" />
          Planned
        </Badge>
      )}
    </>
  )
}

function getAttachmentKind(file: File): AttachmentKind {
  const type = (file.type || "").toLowerCase()
  const name = file.name.toLowerCase()
  const ext = name.includes(".") ? name.split(".").pop() ?? "" : ""

  if (type.startsWith("image/")) return "image"
  if (type.startsWith("audio/")) return "audio"
  if (type.startsWith("video/")) return "video"

  if (ext === "pdf") return "pdf"
  if (["xls", "xlsx", "csv"].includes(ext)) return "spreadsheet"
  if (["doc", "docx"].includes(ext)) return "document"
  if (["txt", "md", "rtf"].includes(ext)) return "text"

  return "file"
}

function makeAttachment(file: File): Attachment {
  return {
    id: crypto.randomUUID(),
    name: file.name,
    type: file.type,
    size: file.size,
    url: URL.createObjectURL(file),
    kind: getAttachmentKind(file),
  }
}

function revokeTodoAttachments(todo: Todo) {
  for (const a of todo.attachments) URL.revokeObjectURL(a.url)
}

function AttachmentIcon({ kind }: { kind: AttachmentKind }) {
  const className = "h-4 w-4 text-muted-foreground"

  switch (kind) {
    case "image":
      return <ImageIcon className={className} />
    case "audio":
      return <Music className={className} />
    case "video":
      return <Video className={className} />
    case "spreadsheet":
      return <FileSpreadsheet className={className} />
    case "pdf":
    case "document":
    case "text":
      return <FileText className={className} />
    default:
      return <File className={className} />
  }
}

export default function Home() {
  return (
    <div className="mx-auto flex min-h-screen max-w-2xl flex-col gap-6 px-4 py-10">
      <TodoApp />
    </div>
  )
}

function TodoApp() {
  const [todos, setTodos] = React.useState<Todo[]>(initialTodos)
  const [attachTargetTodoId, setAttachTargetTodoId] = React.useState<string | null>(
    null
  )
  const [conflictDueAt, setConflictDueAt] = React.useState<string | null>(null)
  const clearConflictTimerRef = React.useRef<number | null>(null)
  const [focusMode, setFocusMode] = React.useState(false)
  const [nowMs, setNowMs] = React.useState(() => Date.now())
  const [inProgressTaskId, setInProgressTaskId] = React.useState<string | null>(null)
  const [dismissedReminderTaskId, setDismissedReminderTaskId] = React.useState<
    string | null
  >(null)
  const [filterMode, setFilterMode] = React.useState<"between" | "exact">("between")
  const [filterFromDate, setFilterFromDate] = React.useState<string>("")
  const [filterFromTime, setFilterFromTime] = React.useState<string>("")
  const [filterToDate, setFilterToDate] = React.useState<string>("")
  const [filterToTime, setFilterToTime] = React.useState<string>("")
  const [filterExactDate, setFilterExactDate] = React.useState<string>("")
  const [filterExactTime, setFilterExactTime] = React.useState<string>("")
  const fileInputRef = React.useRef<HTMLInputElement>(null)
  const [pageSize, setPageSize] = React.useState<number>(5)
  const [page, setPage] = React.useState<number>(1)

  const todosRef = React.useRef(todos)
  React.useEffect(() => {
    todosRef.current = todos
  }, [todos])
  React.useEffect(() => {
    return () => {
      for (const t of todosRef.current) revokeTodoAttachments(t)
    }
  }, [])

  // Keep "now" fresh so overdue/in-progress states stay accurate without user interaction.
  React.useEffect(() => {
    const id = window.setInterval(() => setNowMs(Date.now()), 30_000)
    return () => window.clearInterval(id)
  }, [])

  // Only one task can be "In Progress"; auto-clear if completed, deleted, or overdue.
  React.useEffect(() => {
    if (!inProgressTaskId) return
    const t = todos.find((x) => x.id === inProgressTaskId)
    if (!t || t.completed) {
      setInProgressTaskId(null)
      return
    }
    if (parseLocalDateTime(t.dueAt) < nowMs) setInProgressTaskId(null)
  }, [inProgressTaskId, nowMs, todos])

  const nextUpcoming = React.useMemo(() => {
    const upcoming = todos
      .filter((t) => !t.completed)
      .map((t) => ({ todo: t, dueMs: parseLocalDateTime(t.dueAt) }))
      .filter((x) => x.dueMs >= nowMs)
      .sort((a, b) => a.dueMs - b.dueMs)[0]
    return upcoming ?? null
  }, [nowMs, todos])

  React.useEffect(() => {
    // If "next upcoming" changed, allow reminder again (dismiss is per-task).
    if (nextUpcoming && nextUpcoming.todo.id !== dismissedReminderTaskId) return
    if (!nextUpcoming) setDismissedReminderTaskId(null)
  }, [dismissedReminderTaskId, nextUpcoming])

  const reminder = React.useMemo(() => {
    const REMINDER_WINDOW_MIN = 15
    if (!nextUpcoming) return null
    if (dismissedReminderTaskId === nextUpcoming.todo.id) return null
    const mins = minutesUntil(nextUpcoming.dueMs, nowMs)
    if (mins < 0 || mins > REMINDER_WINDOW_MIN) return null
    return { ...nextUpcoming, mins }
  }, [dismissedReminderTaskId, nextUpcoming, nowMs])

  const form = useForm<TodoFormValues>({
    resolver: zodResolver(todoSchema),
    defaultValues: { title: "", dueAt: "" },
    mode: "onSubmit",
  })

  const summary = React.useMemo(() => {
    const now = new Date()
    const todayKey = localDateKey(now)
    const tomorrow = addDays(now, 1)
    const tomorrowKey = localDateKey(tomorrow)

    const todays = todos.filter((t) => t.dueAt.startsWith(todayKey))
    const todayCompleted = todays.filter((t) => t.completed).length
    const todayPending = todays.length - todayCompleted

    const labels = [
      "00:00–04:00",
      "04:00–08:00",
      "08:00–12:00",
      "12:00–16:00",
      "16:00–20:00",
      "20:00–24:00",
    ]

    // Tomorrow: same 4-hour windows breakdown
    const tomorrowTasks = todos.filter((t) => t.dueAt.startsWith(tomorrowKey))
    const tomorrowBuckets = Array.from({ length: 6 }, () => 0) as number[]
    for (const t of tomorrowTasks) {
      const ms = parseLocalDateTime(t.dueAt)
      const hour = new Date(ms).getHours()
      const idx = Math.floor(hour / 4)
      tomorrowBuckets[idx] = (tomorrowBuckets[idx] ?? 0) + 1
    }

    // Until next week = next 7 days starting tomorrow (local), grouped into 4-hour windows.
    const rangeStart = startOfDay(tomorrow).getTime()
    const rangeEnd = addDays(startOfDay(tomorrow), 7).getTime()
    const buckets = Array.from({ length: 6 }, () => 0) as number[]

    const upcoming = todos.filter((t) => {
      const ms = parseLocalDateTime(t.dueAt)
      return ms >= rangeStart && ms < rangeEnd
    })

    for (const t of upcoming) {
      const ms = parseLocalDateTime(t.dueAt)
      const hour = new Date(ms).getHours()
      const idx = Math.floor(hour / 4)
      buckets[idx] = (buckets[idx] ?? 0) + 1
    }

    return {
      todayCompleted,
      todayPending,
      tomorrowTotal: tomorrowTasks.length,
      tomorrowBuckets: labels.map((label, i) => ({ label, count: tomorrowBuckets[i] ?? 0 })),
      upcomingTotal: upcoming.length,
      upcomingBuckets: labels.map((label, i) => ({ label, count: buckets[i] ?? 0 })),
    }
  }, [todos])

  const loadDayKey = React.useMemo(() => {
    // Prefer an explicitly selected date from filters; otherwise use today.
    if (filterMode === "exact" && filterExactDate) return filterExactDate
    if (filterFromDate && !filterToDate) return filterFromDate
    if (filterFromDate && filterToDate && filterFromDate === filterToDate) return filterFromDate
    if (!filterFromDate && filterToDate) return filterToDate
    return localDateKey(new Date(nowMs))
  }, [filterExactDate, filterFromDate, filterMode, filterToDate, nowMs])

  const dailyLoad = React.useMemo(() => {
    const dayTodos = todos.filter((t) => getDatePart(t.dueAt) === loadDayKey)
    return getDailyLoad(dayTodos)
  }, [loadDayKey, todos])

  const filteredTodos = React.useMemo(() => {
    if (focusMode) {
      const endMs = nowMs + 4 * 60 * 60 * 1000
      const withMs = todos.map((t) => ({ ...t, _dueMs: parseLocalDateTime(t.dueAt) }))
      return withMs.filter((t) => t._dueMs >= nowMs && t._dueMs <= endMs)
    }

    const withMs = todos.map((t) => ({ ...t, _dueMs: parseLocalDateTime(t.dueAt) }))
    if (filterMode === "exact") {
      // If only date is selected -> show tasks for that date.
      // If time is selected too -> match exact date+time.
      // If only time is selected -> match time-of-day across all dates.
      if (!filterExactDate && !filterExactTime) return withMs

      if (filterExactDate && !filterExactTime) {
        return withMs.filter((t) => getDatePart(t.dueAt) === filterExactDate)
      }

      if (filterExactDate && filterExactTime) {
        const exactMs = parseLocalDateTime(`${filterExactDate}T${filterExactTime}`)
        return withMs.filter((t) => t._dueMs === exactMs)
      }

      // time only
      return withMs.filter((t) => getTimePart(t.dueAt) === filterExactTime)
    }
    // between
    const hasAnyDate = Boolean(filterFromDate || filterToDate)
    const hasAnyTime = Boolean(filterFromTime || filterToTime)

    // Date range (optional)
    const fromDateMs = filterFromDate
      ? startOfDay(parseLocalDateOnly(filterFromDate)).getTime()
      : Number.NEGATIVE_INFINITY
    const toDateMs = filterToDate
      ? endOfDay(parseLocalDateOnly(filterToDate)).getTime()
      : Number.POSITIVE_INFINITY

    // Time-of-day range (optional)
    const fromTimeMin = filterFromTime ? parseLocalTimeToMinutes(filterFromTime) : 0
    const toTimeMin = filterToTime ? parseLocalTimeToMinutes(filterToTime) : 24 * 60 - 1

    return withMs.filter((t) => {
      const ms = t._dueMs
      if (hasAnyDate && (ms < fromDateMs || ms > toDateMs)) return false

      if (hasAnyTime) {
        const time = getTimePart(t.dueAt)
        if (!time) return false
        const mins = parseLocalTimeToMinutes(time)
        // Simple (non-wrapping) range. If you want wrap-around (e.g. 22:00–02:00), tell me.
        if (mins < fromTimeMin || mins > toTimeMin) return false
      }

      // If neither date nor time selected, pass through (handled above anyway)
      return true
    })
  }, [
    todos,
    focusMode,
    nowMs,
    filterExactDate,
    filterExactTime,
    filterFromDate,
    filterFromTime,
    filterMode,
    filterToDate,
    filterToTime,
  ])

  const sortedFilteredTodos = React.useMemo(
    () =>
      filteredTodos
        .slice()
        .sort((a, b) => parseLocalDateTime(a.dueAt) - parseLocalDateTime(b.dueAt)),
    [filteredTodos]
  )

  // Clamp page when filters/pageSize change.
  React.useEffect(() => {
    const totalPages = Math.max(1, Math.ceil(sortedFilteredTodos.length / pageSize))
    setPage((p) => Math.min(Math.max(1, p), totalPages))
  }, [pageSize, sortedFilteredTodos.length])

  const totalItems = sortedFilteredTodos.length
  const totalPages = Math.max(1, Math.ceil(totalItems / pageSize))
  const showPagination = totalPages > 1

  const pageItems = React.useMemo(() => {
    const start = (page - 1) * pageSize
    return sortedFilteredTodos.slice(start, start + pageSize)
  }, [page, pageSize, sortedFilteredTodos])

  const groupedTodos = React.useMemo(() => {
    const groups: Array<{ date: string; items: typeof pageItems }> = []
    for (const t of pageItems) {
      const date = getDatePart(t.dueAt)
      const last = groups[groups.length - 1]
      if (!last || last.date !== date) groups.push({ date, items: [t] })
      else last.items.push(t)
    }
    return groups
  }, [pageItems])

  const completedCount = filteredTodos.filter((t) => t.completed).length

  function addTodo(values: TodoFormValues) {
    const conflicts = todos.filter((t) => t.dueAt === values.dueAt)
    if (conflicts.length > 0) {
      setConflictDueAt(values.dueAt)
      if (clearConflictTimerRef.current) window.clearTimeout(clearConflictTimerRef.current)
      clearConflictTimerRef.current = window.setTimeout(() => {
        setConflictDueAt(null)
      }, 8000)

      // Make sure the user can see the conflicting tasks even if they were filtered out.
      const [d, time] = values.dueAt.split("T")
      setFilterMode("exact")
      setFilterExactDate(d ?? "")
      setFilterExactTime(time ?? "")
      setPage(1)

      toast.error("Time conflict", {
        description: `You already have ${conflicts.length} task(s) scheduled at ${formatLocalDateTime(
          values.dueAt
        )}.`,
      })
    }

    setTodos((prev) => [
      {
        id: crypto.randomUUID(),
        title: values.title.trim(),
        completed: false,
        dueAt: values.dueAt,
        attachments: [],
      },
      ...prev,
    ])
    form.reset()
  }

  function toggleTodo(id: string, completed: boolean) {
    setTodos((prev) => prev.map((t) => (t.id === id ? { ...t, completed } : t)))
    if (completed) setInProgressTaskId((cur) => (cur === id ? null : cur))
  }

  function requestAttachmentsForTodo(todoId: string) {
    setAttachTargetTodoId(todoId)
    // Let state update before opening picker (some browsers are picky).
    queueMicrotask(() => fileInputRef.current?.click())
  }

  function handleFilesPicked(e: React.ChangeEvent<HTMLInputElement>) {
    const files = Array.from(e.target.files ?? [])
    const targetId = attachTargetTodoId

    // reset input so picking the same file again triggers onChange
    e.target.value = ""
    setAttachTargetTodoId(null)

    if (!targetId || files.length === 0) return

    const attachments = files.map(makeAttachment)

    setTodos((prev) =>
      prev.map((t) =>
        t.id === targetId
          ? { ...t, attachments: [...t.attachments, ...attachments] }
          : t
      )
    )
  }

  function deleteTodo(id: string) {
    setTodos((prev) => {
      const victim = prev.find((t) => t.id === id)
      if (victim) revokeTodoAttachments(victim)
      return prev.filter((t) => t.id !== id)
    })
    setInProgressTaskId((cur) => (cur === id ? null : cur))
  }

  function clearCompleted() {
    setTodos((prev) => {
      for (const t of prev) {
        if (t.completed) revokeTodoAttachments(t)
      }
      return prev.filter((t) => !t.completed)
    })
  }

  return (
    <Card>
      <CardHeader className="flex flex-row items-center justify-between gap-4">
        <div className="space-y-1">
          <CardTitle className="text-2xl">To‑Do</CardTitle>
          <p className="text-muted-foreground text-sm">
            {completedCount}/{filteredTodos.length} completed
          </p>
        </div>
        <div className="flex items-center gap-2">
          <Button
            type="button"
            variant={focusMode ? "default" : "outline"}
            size="sm"
            onClick={() => {
              setFocusMode((v) => !v)
              setPage(1)
            }}
          >
            Focus Mode
          </Button>
          <ModeToggle />
        </div>
      </CardHeader>

      <CardContent className="space-y-6">
        <input
          ref={fileInputRef}
          type="file"
          multiple
          className="hidden"
          accept={[
            "image/*",
            "audio/*",
            "video/*",
            ".pdf",
            ".doc",
            ".docx",
            ".xls",
            ".xlsx",
            ".csv",
            ".txt",
            ".md",
            ".rtf",
          ].join(",")}
          onChange={handleFilesPicked}
        />

        {reminder && (
          <Alert className="border-primary/30 bg-primary/5">
            <Bell className="h-4 w-4" />
            <div className="flex flex-1 flex-col gap-1">
              <div className="flex flex-wrap items-center justify-between gap-2">
                <AlertTitle className="text-sm">
                  Next task starts in {reminder.mins} minute{reminder.mins === 1 ? "" : "s"}
                </AlertTitle>
                <Button
                  type="button"
                  variant="ghost"
                  size="sm"
                  onClick={() => setDismissedReminderTaskId(reminder.todo.id)}
                >
                  Dismiss
                </Button>
              </div>
              <AlertDescription className="text-sm">
                <span className="font-medium">{reminder.todo.title}</span> ·{" "}
                {formatDateTimeFromMs(reminder.dueMs)}
              </AlertDescription>
            </div>
          </Alert>
        )}

        <div className="rounded-xl border bg-card p-4">
          <div className="flex flex-wrap items-center justify-between gap-2">
            <p className="text-sm font-medium">
              Daily load{" "}
              <span className="text-muted-foreground font-normal">
                ({new Intl.DateTimeFormat(undefined, {
                  weekday: "short",
                  year: "numeric",
                  month: "short",
                  day: "2-digit",
                }).format(parseLocalDateOnly(loadDayKey))})
              </span>
            </p>
            <DailyLoadBadge load={dailyLoad.load} />
          </div>
          <p className="text-muted-foreground mt-2 text-sm">
            {dailyLoad.total} task(s) · busiest window {dailyLoad.busiestWindow} ({dailyLoad.peak})
          </p>
        </div>

        <div className="grid gap-3 sm:grid-cols-3">
          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Today’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">
              {summary.todayCompleted} completed
            </p>
            <p className="text-muted-foreground text-sm">{summary.todayPending} pending</p>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tomorrow’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">{summary.tomorrowTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.tomorrowBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tasks Until Next Week</p>
            <p className="mt-2 text-2xl font-semibold">{summary.upcomingTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.upcomingBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>
        </div>

        {focusMode && (
          <div className="flex flex-col gap-1 rounded-lg border bg-muted/20 px-3 py-2 sm:flex-row sm:items-center sm:justify-between">
            <p className="text-sm">
              <span className="font-medium">Focus Mode:</span>{" "}
              showing tasks due in the next 4 hours (until{" "}
              <span className="font-medium">
                {formatDateTimeFromMs(nowMs + 4 * 60 * 60 * 1000)}
              </span>
              )
            </p>
            <Button type="button" variant="ghost" size="sm" onClick={() => setFocusMode(false)}>
              Exit
            </Button>
          </div>
        )}

        <Form {...form}>
          <form
            onSubmit={form.handleSubmit(addTodo)}
            className="space-y-2"
            noValidate
          >
            <div className="flex flex-col gap-2 sm:flex-row">
              <FormField
                control={form.control}
                name="title"
                render={({ field }) => (
                  <FormItem className="flex-1">
                    <FormControl>
                      <Input
                        placeholder="Add a task…"
                        autoComplete="off"
                        {...field}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="dueAt"
                render={({ field }) => (
                  <FormItem className="sm:w-64">
                    <FormControl>
                      <Input type="datetime-local" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <Button type="submit">Add</Button>
            </div>
          </form>
        </Form>

        <Separator />

        <div className="space-y-3">
          <div className="flex flex-wrap items-center justify-between gap-2">
            <p className="text-sm font-medium">Filter by date & time</p>
            <div className="flex items-center gap-2">
              <Button
                type="button"
                size="sm"
                variant={filterMode === "between" ? "default" : "outline"}
                onClick={() => setFilterMode("between")}
              >
                Between
              </Button>
              <Button
                type="button"
                size="sm"
                variant={filterMode === "exact" ? "default" : "outline"}
                onClick={() => setFilterMode("exact")}
              >
                Exact
              </Button>
              <Button
                type="button"
                size="sm"
                variant="ghost"
                onClick={() => {
                  setFilterFromDate("")
                  setFilterFromTime("")
                  setFilterToDate("")
                  setFilterToTime("")
                  setFilterExactDate("")
                  setFilterExactTime("")
                }}
              >
                Clear
              </Button>
            </div>
          </div>

          {filterMode === "between" ? (
            <div className="grid gap-2 sm:grid-cols-2">
              <div className="grid gap-2 sm:grid-cols-2">
                <Input
                  type="date"
                  value={filterFromDate}
                  onChange={(e) => setFilterFromDate(e.target.value)}
                />
                <Input
                  type="time"
                  value={filterFromTime}
                  onChange={(e) => setFilterFromTime(e.target.value)}
                />
              </div>
              <div className="grid gap-2 sm:grid-cols-2">
                <Input
                  type="date"
                  value={filterToDate}
                  onChange={(e) => setFilterToDate(e.target.value)}
                />
                <Input
                  type="time"
                  value={filterToTime}
                  onChange={(e) => setFilterToTime(e.target.value)}
                />
              </div>
            </div>
          ) : (
            <div className="grid gap-2 sm:grid-cols-2">
              <Input
                type="date"
                value={filterExactDate}
                onChange={(e) => setFilterExactDate(e.target.value)}
              />
              <Input
                type="time"
                value={filterExactTime}
                onChange={(e) => setFilterExactTime(e.target.value)}
              />
            </div>
          )}
        </div>

        <Separator />

        <div className="space-y-2">
          {groupedTodos.length === 0 ? (
            <p className="text-muted-foreground text-sm">No tasks yet.</p>
          ) : (
            groupedTodos.map((group) => (
              <div key={group.date} className="space-y-2">
                <div className="flex items-center gap-3 pt-2">
                  <Separator className="flex-1" />
                  <span className="text-muted-foreground whitespace-nowrap text-xs font-medium">
                    {new Intl.DateTimeFormat(undefined, {
                      weekday: "short",
                      year: "numeric",
                      month: "short",
                      day: "2-digit",
                    }).format(parseLocalDateOnly(group.date))}
                  </span>
                  <Separator className="flex-1" />
                </div>

                {group.items.map((todo) => {
                  const state = getTaskStateWithInProgress(todo, nowMs, inProgressTaskId)

                  return (
                    <div
                      key={todo.id}
                      className={cn(
                        "rounded-lg border px-3 py-2",
                        state === "completed" && "opacity-75",
                        state === "overdue" &&
                          "border-destructive/40 bg-destructive/5 text-muted-foreground",
                        state === "in_progress" && "border-sky-500/40 bg-sky-500/10",
                        conflictDueAt &&
                          todo.dueAt === conflictDueAt &&
                          "border-destructive/60 bg-destructive/5 ring-1 ring-destructive/30"
                      )}
                    >
                      <div className="flex items-start justify-between gap-3">
                        <label className="flex cursor-pointer items-start gap-3">
                        <Checkbox
                          checked={todo.completed}
                          onCheckedChange={(v) => {
                            const next = Boolean(v)
                            toggleTodo(todo.id, next)
                            if (next && !todo.completed) {
                              requestAttachmentsForTodo(todo.id)
                            }
                          }}
                          aria-label={`Mark "${todo.title}" as ${
                            todo.completed ? "not completed" : "completed"
                          }`}
                          className="mt-0.5"
                        />
                        <span
                          className={cn(
                            "leading-6",
                            todo.completed && "text-muted-foreground line-through"
                          )}
                        >
                          <span className="flex flex-wrap items-center gap-2">
                            <span className="block">{todo.title}</span>
                            <TaskStateBadge state={state} />
                          </span>
                          <span className="text-muted-foreground block text-xs">
                            Due: {formatLocalDateTime(todo.dueAt)}
                          </span>
                        </span>
                      </label>

                      <div className="flex items-center gap-1">
                        {!todo.completed && state !== "overdue" && (
                          <Button
                            type="button"
                            variant={state === "in_progress" ? "default" : "outline"}
                            size="sm"
                            onClick={() =>
                              setInProgressTaskId((cur) =>
                                cur === todo.id ? null : todo.id
                              )
                            }
                            className={cn(
                              state === "in_progress" && "bg-sky-600 hover:bg-sky-600"
                            )}
                          >
                            {state === "in_progress" ? (
                              <>
                                <CircleStop className="mr-1 h-4 w-4" />
                                Stop
                              </>
                            ) : (
                              <>
                                <CirclePlay className="mr-1 h-4 w-4" />
                                Start
                              </>
                            )}
                          </Button>
                        )}
                        {todo.completed && (
                          <Button
                            type="button"
                            variant="outline"
                            size="sm"
                            onClick={() => requestAttachmentsForTodo(todo.id)}
                          >
                            Add files
                          </Button>
                        )}
                        <Button
                          type="button"
                          variant="ghost"
                          size="icon"
                          aria-label={`Delete "${todo.title}"`}
                          onClick={() => deleteTodo(todo.id)}
                        >
                          <Trash2 className="h-4 w-4" />
                        </Button>
                      </div>
                    </div>

                    {todo.completed && todo.attachments.length > 0 && (
                      <div className="mt-3 space-y-2">
                        <p className="text-muted-foreground text-xs">Attachments</p>
                        <ul className="space-y-1">
                          {todo.attachments.map((a) => (
                            <li
                              key={a.id}
                              className="flex items-center justify-between gap-3 rounded-md bg-muted/30 px-2 py-1"
                            >
                              <div className="flex min-w-0 items-center gap-2">
                                <AttachmentIcon kind={a.kind} />
                                <span className="truncate text-sm">{a.name}</span>
                              </div>
                              <a
                                href={a.url}
                                download={a.name}
                                className="inline-flex items-center gap-1 text-sm font-medium underline underline-offset-4"
                              >
                                <Download className="h-4 w-4" />
                                Download
                              </a>
                            </li>
                          ))}
                        </ul>
                      </div>
                    )}
                  </div>
                  )
                })}
              </div>
            ))
          )}
        </div>

        {groupedTodos.length > 0 && (
          <div className="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
            <div className="flex items-center gap-2">
              <span className="text-muted-foreground text-sm">Items per page</span>
              <Select
                value={String(pageSize)}
                onValueChange={(v) => {
                  const next = Number(v)
                  setPageSize(next)
                  setPage(1)
                }}
              >
                <SelectTrigger className="w-[110px]">
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="5">5</SelectItem>
                  <SelectItem value="10">10</SelectItem>
                  <SelectItem value="15">15</SelectItem>
                  <SelectItem value="20">20</SelectItem>
                </SelectContent>
              </Select>
            </div>

            {showPagination && (
              <div className="flex items-center justify-between gap-3 sm:justify-end">
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={() => setPage((p) => Math.max(1, p - 1))}
                  disabled={page <= 1}
                >
                  Prev
                </Button>
                <span className="text-muted-foreground text-sm">
                  Page {page} of {totalPages}
                </span>
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={() => setPage((p) => Math.min(totalPages, p + 1))}
                  disabled={page >= totalPages}
                >
                  Next
                </Button>
              </div>
            )}
          </div>
        )}

        <div className="flex items-center justify-between gap-2">
          <Button
            type="button"
            variant="secondary"
            onClick={clearCompleted}
            disabled={completedCount === 0}
          >
            Clear completed
          </Button>
          <span className="text-muted-foreground text-sm">
            Mock data only (no backend)
          </span>
    </div>
      </CardContent>
    </Card>
  )
}

```

```typescriptreact
"use client"

import { zodResolver } from "@hookform/resolvers/zod"
import {
  AlertTriangle,
  CirclePlay,
  CircleStop,
  CalendarClock,
  CheckCircle2,
  Download,
  File,
  FileSpreadsheet,
  FileText,
  Image as ImageIcon,
  Music,
  Bell,
  Timer,
  Trash2,
  Video,
} from "lucide-react"
import * as React from "react"
import { useForm } from "react-hook-form"
import { toast } from "sonner"
import { z } from "zod"

import { ModeToggle } from "@/components/mode-toggle"
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert"
import { Badge } from "@/components/ui/badge"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Checkbox } from "@/components/ui/checkbox"
import { Form, FormControl, FormField, FormItem, FormMessage } from "@/components/ui/form"
import { Input } from "@/components/ui/input"
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select"
import { Separator } from "@/components/ui/separator"
import { cn } from "@/lib/utils"

type AttachmentKind =
  | "image"
  | "audio"
  | "video"
  | "pdf"
  | "spreadsheet"
  | "document"
  | "text"
  | "file"

type Attachment = {
  id: string
  name: string
  type: string
  size: number
  url: string
  kind: AttachmentKind
}

type Todo = {
  id: string
  title: string
  completed: boolean
  // Stored as `datetime-local` string (YYYY-MM-DDTHH:mm) in local time.
  dueAt: string
  attachments: Attachment[]
}

type TaskState = "planned" | "in_progress" | "completed" | "overdue"
type DailyLoad = "light" | "balanced" | "heavy"

const todoSchema = z.object({
  title: z
    .string()
    .trim()
    .min(1, "Title is required.")
    .max(80, "Keep it under 80 characters."),
  dueAt: z
    .string()
    .min(1, "Due date & time is required.")
    .regex(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}$/, "Invalid date/time."),
})

type TodoFormValues = z.infer<typeof todoSchema>

const initialTodos: Todo[] = [
  {
    id: "1",
    title: "Create a Next.js app",
    completed: true,
    dueAt: "2026-01-16T09:00",
    attachments: [],
  },
  {
    id: "2",
    title: "Add shadcn/ui + dark theme",
    completed: true,
    dueAt: "2026-01-16T10:30",
    attachments: [],
  },
  {
    id: "3",
    title: "Build a mock-data to-do list",
    completed: false,
    dueAt: "2026-01-16T15:00",
    attachments: [],
  },
  {
    id: "4",
    title: "Yesterday: review requirements",
    completed: true,
    dueAt: "2026-01-15T11:15",
    attachments: [],
  },
  {
    id: "5",
    title: "Yesterday: sketch UI layout",
    completed: true,
    dueAt: "2026-01-15T17:45",
    attachments: [],
  },
  {
    id: "6",
    title: "Today: add attachments support",
    completed: false,
    dueAt: "2026-01-16T18:20",
    attachments: [],
  },
  {
    id: "7",
    title: "Tomorrow: QA the filters",
    completed: false,
    dueAt: "2026-01-17T08:05",
    attachments: [],
  },
  {
    id: "8",
    title: "Tomorrow: polish summary cards",
    completed: false,
    dueAt: "2026-01-17T13:30",
    attachments: [],
  },
  {
    id: "9",
    title: "Tomorrow: write small UX notes",
    completed: false,
    dueAt: "2026-01-17T20:10",
    attachments: [],
  },
  {
    id: "10",
    title: "This weekend: add more mock tasks",
    completed: false,
    dueAt: "2026-01-18T10:00",
    attachments: [],
  },
  {
    id: "11",
    title: "This weekend: check time-only filter",
    completed: false,
    dueAt: "2026-01-18T22:15",
    attachments: [],
  },
  {
    id: "12",
    title: "Next week: sync with team",
    completed: false,
    dueAt: "2026-01-19T09:30",
    attachments: [],
  },
  {
    id: "13",
    title: "Next week: test date-only filter",
    completed: false,
    dueAt: "2026-01-20T14:05",
    attachments: [],
  },
  {
    id: "14",
    title: "Next week: test exact date+time filter",
    completed: false,
    dueAt: "2026-01-21T12:00",
    attachments: [],
  },
  {
    id: "15",
    title: "Next week: attach docs to completed tasks",
    completed: false,
    dueAt: "2026-01-22T16:40",
    attachments: [],
  },
  {
    id: "16",
    title: "Next week: final review",
    completed: false,
    dueAt: "2026-01-23T11:00",
    attachments: [],
  },
]

function parseLocalDateTime(value: string): number {
  // value: "YYYY-MM-DDTHH:mm"
  const [datePart, timePart] = value.split("T")
  const [y, m, d] = datePart.split("-").map(Number)
  const [hh, mm] = timePart.split(":").map(Number)
  return new Date(y, m - 1, d, hh, mm, 0, 0).getTime()
}

function pad2(n: number) {
  return String(n).padStart(2, "0")
}

function localDateKey(d: Date) {
  return `${d.getFullYear()}-${pad2(d.getMonth() + 1)}-${pad2(d.getDate())}`
}

function addDays(date: Date, days: number) {
  const d = new Date(date)
  d.setDate(d.getDate() + days)
  return d
}

function startOfDay(date: Date) {
  return new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0, 0)
}

function endOfDay(date: Date) {
  return new Date(
    date.getFullYear(),
    date.getMonth(),
    date.getDate(),
    23,
    59,
    59,
    999
  )
}

function getDatePart(dueAt: string) {
  return dueAt.split("T")[0] ?? ""
}

function getTimePart(dueAt: string) {
  return dueAt.split("T")[1] ?? ""
}

function parseLocalDateOnly(value: string): Date {
  // value: "YYYY-MM-DD"
  const [y, m, d] = value.split("-").map(Number)
  return new Date(y, m - 1, d, 0, 0, 0, 0)
}

function parseLocalTimeToMinutes(value: string): number {
  // value: "HH:mm"
  const [hh, mm] = value.split(":").map(Number)
  return hh * 60 + mm
}

function formatLocalDateTime(value: string): string {
  const ms = parseLocalDateTime(value)
  if (!Number.isFinite(ms)) return value
  return new Intl.DateTimeFormat(undefined, {
    year: "numeric",
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  }).format(new Date(ms))
}

function formatDateTimeFromMs(ms: number): string {
  return new Intl.DateTimeFormat(undefined, {
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  }).format(new Date(ms))
}

function minutesUntil(targetMs: number, nowMs: number) {
  return Math.ceil((targetMs - nowMs) / 60_000)
}

function getTaskFlags(todo: Todo, nowMs: number, inProgressTaskId: string | null) {
  const completed = todo.completed
  const dueMs = parseLocalDateTime(todo.dueAt)
  const overdue = !completed && dueMs < nowMs
  const inProgress = !completed && inProgressTaskId === todo.id
  const planned = !completed && !overdue && !inProgress
  return { completed, overdue, inProgress, planned }
}

function getDailyLoad(todosForDay: Todo[]) {
  // 4-hour windows across the day (local).
  const labels = [
    "00:00–04:00",
    "04:00–08:00",
    "08:00–12:00",
    "12:00–16:00",
    "16:00–20:00",
    "20:00–24:00",
  ]
  const buckets = Array.from({ length: 6 }, () => 0) as number[]
  for (const t of todosForDay) {
    const ms = parseLocalDateTime(t.dueAt)
    const hour = new Date(ms).getHours()
    const idx = Math.floor(hour / 4)
    buckets[idx] = (buckets[idx] ?? 0) + 1
  }

  const total = todosForDay.length
  const peak = Math.max(0, ...buckets)
  const spread = buckets.filter((c) => c > 0).length
  const busiestIdx = buckets.findIndex((c) => c === peak)
  const busiestWindow = busiestIdx >= 0 ? labels[busiestIdx] : labels[0]

  // Heuristic: more tasks + higher concentration in one window => heavier day.
  const score = total + peak * 1.5 + Math.max(0, spread - 1) * 0.5
  const load: DailyLoad = score <= 5 ? "light" : score <= 10 ? "balanced" : "heavy"

  return { load, total, peak, spread, busiestWindow }
}

function DailyLoadBadge({ load }: { load: DailyLoad }) {
  if (load === "heavy") return <Badge variant="destructive">Heavy</Badge>
  if (load === "balanced") return <Badge variant="secondary">Balanced</Badge>
  return <Badge variant="outline">Light</Badge>
}

function TaskBadges({
  completed,
  overdue,
  inProgress,
  planned,
}: {
  completed: boolean
  overdue: boolean
  inProgress: boolean
  planned: boolean
}) {
  if (completed) {
    return (
      <Badge className="gap-1 bg-emerald-600 text-white hover:bg-emerald-600">
        <CheckCircle2 className="h-3.5 w-3.5" />
        Completed
      </Badge>
    )
  }

  return (
    <>
      {inProgress && (
        <Badge className="gap-1 bg-sky-600 text-white hover:bg-sky-600">
          <Timer className="h-3.5 w-3.5 text-white" />
          In progress
        </Badge>
      )}
      {overdue && (
        <Badge variant="destructive" className="gap-1">
          <AlertTriangle className="h-3.5 w-3.5" />
          Overdue
        </Badge>
      )}
      {planned && (
        <Badge variant="outline" className="gap-1">
          <CalendarClock className="h-3.5 w-3.5" />
          Planned
        </Badge>
      )}
    </>
  )
}

function getAttachmentKind(file: File): AttachmentKind {
  const type = (file.type || "").toLowerCase()
  const name = file.name.toLowerCase()
  const ext = name.includes(".") ? name.split(".").pop() ?? "" : ""

  if (type.startsWith("image/")) return "image"
  if (type.startsWith("audio/")) return "audio"
  if (type.startsWith("video/")) return "video"

  if (ext === "pdf") return "pdf"
  if (["xls", "xlsx", "csv"].includes(ext)) return "spreadsheet"
  if (["doc", "docx"].includes(ext)) return "document"
  if (["txt", "md", "rtf"].includes(ext)) return "text"

  return "file"
}

function makeAttachment(file: File): Attachment {
  return {
    id: crypto.randomUUID(),
    name: file.name,
    type: file.type,
    size: file.size,
    url: URL.createObjectURL(file),
    kind: getAttachmentKind(file),
  }
}

function revokeTodoAttachments(todo: Todo) {
  for (const a of todo.attachments) URL.revokeObjectURL(a.url)
}

function AttachmentIcon({ kind }: { kind: AttachmentKind }) {
  const className = "h-4 w-4 text-muted-foreground"

  switch (kind) {
    case "image":
      return <ImageIcon className={className} />
    case "audio":
      return <Music className={className} />
    case "video":
      return <Video className={className} />
    case "spreadsheet":
      return <FileSpreadsheet className={className} />
    case "pdf":
    case "document":
    case "text":
      return <FileText className={className} />
    default:
      return <File className={className} />
  }
}

export default function Home() {
  return (
    <div className="mx-auto flex min-h-screen max-w-2xl flex-col gap-6 px-4 py-10">
      <TodoApp />
    </div>
  )
}

function TodoApp() {
  const [todos, setTodos] = React.useState<Todo[]>(initialTodos)
  const [attachTargetTodoId, setAttachTargetTodoId] = React.useState<string | null>(
    null
  )
  const [conflictDueAt, setConflictDueAt] = React.useState<string | null>(null)
  const clearConflictTimerRef = React.useRef<number | null>(null)
  const [focusMode, setFocusMode] = React.useState(false)
  const [nowMs, setNowMs] = React.useState(() => Date.now())
  const [inProgressTaskId, setInProgressTaskId] = React.useState<string | null>(null)
  const [dismissedReminderTaskId, setDismissedReminderTaskId] = React.useState<
    string | null
  >(null)
  const [filterMode, setFilterMode] = React.useState<"between" | "exact">("between")
  const [filterFromDate, setFilterFromDate] = React.useState<string>("")
  const [filterFromTime, setFilterFromTime] = React.useState<string>("")
  const [filterToDate, setFilterToDate] = React.useState<string>("")
  const [filterToTime, setFilterToTime] = React.useState<string>("")
  const [filterExactDate, setFilterExactDate] = React.useState<string>("")
  const [filterExactTime, setFilterExactTime] = React.useState<string>("")
  const fileInputRef = React.useRef<HTMLInputElement>(null)
  const [pageSize, setPageSize] = React.useState<number>(5)
  const [page, setPage] = React.useState<number>(1)

  const todosRef = React.useRef(todos)
  React.useEffect(() => {
    todosRef.current = todos
  }, [todos])
  React.useEffect(() => {
    return () => {
      for (const t of todosRef.current) revokeTodoAttachments(t)
    }
  }, [])

  // Keep "now" fresh so overdue/in-progress states stay accurate without user interaction.
  React.useEffect(() => {
    const id = window.setInterval(() => setNowMs(Date.now()), 30_000)
    return () => window.clearInterval(id)
  }, [])

  // Only one task can be "In Progress"; auto-clear if completed, deleted, or overdue.
  React.useEffect(() => {
    if (!inProgressTaskId) return
    const t = todos.find((x) => x.id === inProgressTaskId)
    if (!t || t.completed) {
      setInProgressTaskId(null)
      return
    }
  }, [inProgressTaskId, nowMs, todos])

  const nextUpcoming = React.useMemo(() => {
    const upcoming = todos
      .filter((t) => !t.completed)
      .map((t) => ({ todo: t, dueMs: parseLocalDateTime(t.dueAt) }))
      .filter((x) => x.dueMs >= nowMs)
      .sort((a, b) => a.dueMs - b.dueMs)[0]
    return upcoming ?? null
  }, [nowMs, todos])

  React.useEffect(() => {
    // If "next upcoming" changed, allow reminder again (dismiss is per-task).
    if (nextUpcoming && nextUpcoming.todo.id !== dismissedReminderTaskId) return
    if (!nextUpcoming) setDismissedReminderTaskId(null)
  }, [dismissedReminderTaskId, nextUpcoming])

  const reminder = React.useMemo(() => {
    const REMINDER_WINDOW_MIN = 15
    if (!nextUpcoming) return null
    if (dismissedReminderTaskId === nextUpcoming.todo.id) return null
    const mins = minutesUntil(nextUpcoming.dueMs, nowMs)
    if (mins < 0 || mins > REMINDER_WINDOW_MIN) return null
    return { ...nextUpcoming, mins }
  }, [dismissedReminderTaskId, nextUpcoming, nowMs])

  const form = useForm<TodoFormValues>({
    resolver: zodResolver(todoSchema),
    defaultValues: { title: "", dueAt: "" },
    mode: "onSubmit",
  })

  const summary = React.useMemo(() => {
    const now = new Date()
    const todayKey = localDateKey(now)
    const tomorrow = addDays(now, 1)
    const tomorrowKey = localDateKey(tomorrow)

    const todays = todos.filter((t) => t.dueAt.startsWith(todayKey))
    const todayCompleted = todays.filter((t) => t.completed).length
    const todayPending = todays.length - todayCompleted

    const labels = [
      "00:00–04:00",
      "04:00–08:00",
      "08:00–12:00",
      "12:00–16:00",
      "16:00–20:00",
      "20:00–24:00",
    ]

    // Tomorrow: same 4-hour windows breakdown
    const tomorrowTasks = todos.filter((t) => t.dueAt.startsWith(tomorrowKey))
    const tomorrowBuckets = Array.from({ length: 6 }, () => 0) as number[]
    for (const t of tomorrowTasks) {
      const ms = parseLocalDateTime(t.dueAt)
      const hour = new Date(ms).getHours()
      const idx = Math.floor(hour / 4)
      tomorrowBuckets[idx] = (tomorrowBuckets[idx] ?? 0) + 1
    }

    // Until next week = next 7 days starting tomorrow (local), grouped into 4-hour windows.
    const rangeStart = startOfDay(tomorrow).getTime()
    const rangeEnd = addDays(startOfDay(tomorrow), 7).getTime()
    const buckets = Array.from({ length: 6 }, () => 0) as number[]

    const upcoming = todos.filter((t) => {
      const ms = parseLocalDateTime(t.dueAt)
      return ms >= rangeStart && ms < rangeEnd
    })

    for (const t of upcoming) {
      const ms = parseLocalDateTime(t.dueAt)
      const hour = new Date(ms).getHours()
      const idx = Math.floor(hour / 4)
      buckets[idx] = (buckets[idx] ?? 0) + 1
    }

    return {
      todayCompleted,
      todayPending,
      tomorrowTotal: tomorrowTasks.length,
      tomorrowBuckets: labels.map((label, i) => ({ label, count: tomorrowBuckets[i] ?? 0 })),
      upcomingTotal: upcoming.length,
      upcomingBuckets: labels.map((label, i) => ({ label, count: buckets[i] ?? 0 })),
    }
  }, [todos])

  const loadDayKey = React.useMemo(() => {
    // Prefer an explicitly selected date from filters; otherwise use today.
    if (filterMode === "exact" && filterExactDate) return filterExactDate
    if (filterFromDate && !filterToDate) return filterFromDate
    if (filterFromDate && filterToDate && filterFromDate === filterToDate) return filterFromDate
    if (!filterFromDate && filterToDate) return filterToDate
    return localDateKey(new Date(nowMs))
  }, [filterExactDate, filterFromDate, filterMode, filterToDate, nowMs])

  const dailyLoad = React.useMemo(() => {
    const dayTodos = todos.filter((t) => getDatePart(t.dueAt) === loadDayKey)
    return getDailyLoad(dayTodos)
  }, [loadDayKey, todos])

  const filteredTodos = React.useMemo(() => {
    if (focusMode) {
      const endMs = nowMs + 4 * 60 * 60 * 1000
      const withMs = todos.map((t) => ({ ...t, _dueMs: parseLocalDateTime(t.dueAt) }))
      return withMs.filter((t) => t._dueMs >= nowMs && t._dueMs <= endMs)
    }

    const withMs = todos.map((t) => ({ ...t, _dueMs: parseLocalDateTime(t.dueAt) }))
    if (filterMode === "exact") {
      // If only date is selected -> show tasks for that date.
      // If time is selected too -> match exact date+time.
      // If only time is selected -> match time-of-day across all dates.
      if (!filterExactDate && !filterExactTime) return withMs

      if (filterExactDate && !filterExactTime) {
        return withMs.filter((t) => getDatePart(t.dueAt) === filterExactDate)
      }

      if (filterExactDate && filterExactTime) {
        const exactMs = parseLocalDateTime(`${filterExactDate}T${filterExactTime}`)
        return withMs.filter((t) => t._dueMs === exactMs)
      }

      // time only
      return withMs.filter((t) => getTimePart(t.dueAt) === filterExactTime)
    }
    // between
    const hasAnyDate = Boolean(filterFromDate || filterToDate)
    const hasAnyTime = Boolean(filterFromTime || filterToTime)

    // Date range (optional)
    const fromDateMs = filterFromDate
      ? startOfDay(parseLocalDateOnly(filterFromDate)).getTime()
      : Number.NEGATIVE_INFINITY
    const toDateMs = filterToDate
      ? endOfDay(parseLocalDateOnly(filterToDate)).getTime()
      : Number.POSITIVE_INFINITY

    // Time-of-day range (optional)
    const fromTimeMin = filterFromTime ? parseLocalTimeToMinutes(filterFromTime) : 0
    const toTimeMin = filterToTime ? parseLocalTimeToMinutes(filterToTime) : 24 * 60 - 1

    return withMs.filter((t) => {
      const ms = t._dueMs
      if (hasAnyDate && (ms < fromDateMs || ms > toDateMs)) return false

      if (hasAnyTime) {
        const time = getTimePart(t.dueAt)
        if (!time) return false
        const mins = parseLocalTimeToMinutes(time)
        // Simple (non-wrapping) range. If you want wrap-around (e.g. 22:00–02:00), tell me.
        if (mins < fromTimeMin || mins > toTimeMin) return false
      }

      // If neither date nor time selected, pass through (handled above anyway)
      return true
    })
  }, [
    todos,
    focusMode,
    nowMs,
    filterExactDate,
    filterExactTime,
    filterFromDate,
    filterFromTime,
    filterMode,
    filterToDate,
    filterToTime,
  ])

  const sortedFilteredTodos = React.useMemo(
    () =>
      filteredTodos
        .slice()
        .sort((a, b) => parseLocalDateTime(a.dueAt) - parseLocalDateTime(b.dueAt)),
    [filteredTodos]
  )

  // Clamp page when filters/pageSize change.
  React.useEffect(() => {
    const totalPages = Math.max(1, Math.ceil(sortedFilteredTodos.length / pageSize))
    setPage((p) => Math.min(Math.max(1, p), totalPages))
  }, [pageSize, sortedFilteredTodos.length])

  const totalItems = sortedFilteredTodos.length
  const totalPages = Math.max(1, Math.ceil(totalItems / pageSize))
  const showPagination = totalPages > 1

  const pageItems = React.useMemo(() => {
    const start = (page - 1) * pageSize
    return sortedFilteredTodos.slice(start, start + pageSize)
  }, [page, pageSize, sortedFilteredTodos])

  const groupedTodos = React.useMemo(() => {
    const groups: Array<{ date: string; items: typeof pageItems }> = []
    for (const t of pageItems) {
      const date = getDatePart(t.dueAt)
      const last = groups[groups.length - 1]
      if (!last || last.date !== date) groups.push({ date, items: [t] })
      else last.items.push(t)
    }
    return groups
  }, [pageItems])

  const completedCount = filteredTodos.filter((t) => t.completed).length

  function addTodo(values: TodoFormValues) {
    const conflicts = todos.filter((t) => t.dueAt === values.dueAt)
    if (conflicts.length > 0) {
      setConflictDueAt(values.dueAt)
      if (clearConflictTimerRef.current) window.clearTimeout(clearConflictTimerRef.current)
      clearConflictTimerRef.current = window.setTimeout(() => {
        setConflictDueAt(null)
      }, 8000)

      // Make sure the user can see the conflicting tasks even if they were filtered out.
      const [d, time] = values.dueAt.split("T")
      setFilterMode("exact")
      setFilterExactDate(d ?? "")
      setFilterExactTime(time ?? "")
      setPage(1)

      toast.error("Time conflict", {
        description: `You already have ${conflicts.length} task(s) scheduled at ${formatLocalDateTime(
          values.dueAt
        )}.`,
      })
    }

    setTodos((prev) => [
      {
        id: crypto.randomUUID(),
        title: values.title.trim(),
        completed: false,
        dueAt: values.dueAt,
        attachments: [],
      },
      ...prev,
    ])
    form.reset()
  }

  function toggleTodo(id: string, completed: boolean) {
    setTodos((prev) => prev.map((t) => (t.id === id ? { ...t, completed } : t)))
    if (completed) setInProgressTaskId((cur) => (cur === id ? null : cur))
  }

  function requestAttachmentsForTodo(todoId: string) {
    setAttachTargetTodoId(todoId)
    // Let state update before opening picker (some browsers are picky).
    queueMicrotask(() => fileInputRef.current?.click())
  }

  function handleFilesPicked(e: React.ChangeEvent<HTMLInputElement>) {
    const files = Array.from(e.target.files ?? [])
    const targetId = attachTargetTodoId

    // reset input so picking the same file again triggers onChange
    e.target.value = ""
    setAttachTargetTodoId(null)

    if (!targetId || files.length === 0) return

    const attachments = files.map(makeAttachment)

    setTodos((prev) =>
      prev.map((t) =>
        t.id === targetId
          ? { ...t, attachments: [...t.attachments, ...attachments] }
          : t
      )
    )
  }

  function deleteTodo(id: string) {
    setTodos((prev) => {
      const victim = prev.find((t) => t.id === id)
      if (victim) revokeTodoAttachments(victim)
      return prev.filter((t) => t.id !== id)
    })
    setInProgressTaskId((cur) => (cur === id ? null : cur))
  }

  function clearCompleted() {
    setTodos((prev) => {
      for (const t of prev) {
        if (t.completed) revokeTodoAttachments(t)
      }
      return prev.filter((t) => !t.completed)
    })
  }

  return (
    <Card>
      <CardHeader className="flex flex-row items-center justify-between gap-4">
        <div className="space-y-1">
          <CardTitle className="text-2xl">To‑Do</CardTitle>
          <p className="text-muted-foreground text-sm">
            {completedCount}/{filteredTodos.length} completed
          </p>
        </div>
        <div className="flex items-center gap-2">
          <Button
            type="button"
            variant={focusMode ? "default" : "outline"}
            size="sm"
            onClick={() => {
              setFocusMode((v) => !v)
              setPage(1)
            }}
          >
            Focus Mode
          </Button>
          <ModeToggle />
        </div>
      </CardHeader>

      <CardContent className="space-y-6">
        <input
          ref={fileInputRef}
          type="file"
          multiple
          className="hidden"
          accept={[
            "image/*",
            "audio/*",
            "video/*",
            ".pdf",
            ".doc",
            ".docx",
            ".xls",
            ".xlsx",
            ".csv",
            ".txt",
            ".md",
            ".rtf",
          ].join(",")}
          onChange={handleFilesPicked}
        />

        {reminder && (
          <Alert className="border-primary/30 bg-primary/5">
            <Bell className="h-4 w-4" />
            <div className="flex flex-1 flex-col gap-1">
              <div className="flex flex-wrap items-center justify-between gap-2">
                <AlertTitle className="text-sm">
                  Next task starts in {reminder.mins} minute{reminder.mins === 1 ? "" : "s"}
                </AlertTitle>
                <Button
                  type="button"
                  variant="ghost"
                  size="sm"
                  onClick={() => setDismissedReminderTaskId(reminder.todo.id)}
                >
                  Dismiss
                </Button>
              </div>
              <AlertDescription className="text-sm">
                <span className="font-medium">{reminder.todo.title}</span> ·{" "}
                {formatDateTimeFromMs(reminder.dueMs)}
              </AlertDescription>
            </div>
          </Alert>
        )}

        <div className="rounded-xl border bg-card p-4">
          <div className="flex flex-wrap items-center justify-between gap-2">
            <p className="text-sm font-medium">
              Daily load{" "}
              <span className="text-muted-foreground font-normal">
                ({new Intl.DateTimeFormat(undefined, {
                  weekday: "short",
                  year: "numeric",
                  month: "short",
                  day: "2-digit",
                }).format(parseLocalDateOnly(loadDayKey))})
              </span>
            </p>
            <DailyLoadBadge load={dailyLoad.load} />
          </div>
          <p className="text-muted-foreground mt-2 text-sm">
            {dailyLoad.total} task(s) · busiest window {dailyLoad.busiestWindow} ({dailyLoad.peak})
          </p>
        </div>

        <div className="grid gap-3 sm:grid-cols-3">
          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Today’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">
              {summary.todayCompleted} completed
            </p>
            <p className="text-muted-foreground text-sm">{summary.todayPending} pending</p>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tomorrow’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">{summary.tomorrowTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.tomorrowBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tasks Until Next Week</p>
            <p className="mt-2 text-2xl font-semibold">{summary.upcomingTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.upcomingBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>
        </div>

        {focusMode && (
          <div className="flex flex-col gap-1 rounded-lg border bg-muted/20 px-3 py-2 sm:flex-row sm:items-center sm:justify-between">
            <p className="text-sm">
              <span className="font-medium">Focus Mode:</span>{" "}
              showing tasks due in the next 4 hours (until{" "}
              <span className="font-medium">
                {formatDateTimeFromMs(nowMs + 4 * 60 * 60 * 1000)}
              </span>
              )
            </p>
            <Button type="button" variant="ghost" size="sm" onClick={() => setFocusMode(false)}>
              Exit
            </Button>
          </div>
        )}

        <Form {...form}>
          <form
            onSubmit={form.handleSubmit(addTodo)}
            className="space-y-2"
            noValidate
          >
            <div className="flex flex-col gap-2 sm:flex-row">
              <FormField
                control={form.control}
                name="title"
                render={({ field }) => (
                  <FormItem className="flex-1">
                    <FormControl>
                      <Input
                        placeholder="Add a task…"
                        autoComplete="off"
                        {...field}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="dueAt"
                render={({ field }) => (
                  <FormItem className="sm:w-64">
                    <FormControl>
                      <Input type="datetime-local" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <Button type="submit">Add</Button>
            </div>
          </form>
        </Form>

        <Separator />

        <div className="space-y-3">
          <div className="flex flex-wrap items-center justify-between gap-2">
            <p className="text-sm font-medium">Filter by date & time</p>
            <div className="flex items-center gap-2">
              <Button
                type="button"
                size="sm"
                variant={filterMode === "between" ? "default" : "outline"}
                onClick={() => setFilterMode("between")}
              >
                Between
              </Button>
              <Button
                type="button"
                size="sm"
                variant={filterMode === "exact" ? "default" : "outline"}
                onClick={() => setFilterMode("exact")}
              >
                Exact
              </Button>
              <Button
                type="button"
                size="sm"
                variant="ghost"
                onClick={() => {
                  setFilterFromDate("")
                  setFilterFromTime("")
                  setFilterToDate("")
                  setFilterToTime("")
                  setFilterExactDate("")
                  setFilterExactTime("")
                }}
              >
                Clear
              </Button>
            </div>
          </div>

          {filterMode === "between" ? (
            <div className="grid gap-2 sm:grid-cols-2">
              <div className="grid gap-2 sm:grid-cols-2">
                <Input
                  type="date"
                  value={filterFromDate}
                  onChange={(e) => setFilterFromDate(e.target.value)}
                />
                <Input
                  type="time"
                  value={filterFromTime}
                  onChange={(e) => setFilterFromTime(e.target.value)}
                />
              </div>
              <div className="grid gap-2 sm:grid-cols-2">
                <Input
                  type="date"
                  value={filterToDate}
                  onChange={(e) => setFilterToDate(e.target.value)}
                />
                <Input
                  type="time"
                  value={filterToTime}
                  onChange={(e) => setFilterToTime(e.target.value)}
                />
              </div>
            </div>
          ) : (
            <div className="grid gap-2 sm:grid-cols-2">
              <Input
                type="date"
                value={filterExactDate}
                onChange={(e) => setFilterExactDate(e.target.value)}
              />
              <Input
                type="time"
                value={filterExactTime}
                onChange={(e) => setFilterExactTime(e.target.value)}
              />
            </div>
          )}
        </div>

        <Separator />

        <div className="space-y-2">
          {groupedTodos.length === 0 ? (
            <p className="text-muted-foreground text-sm">No tasks yet.</p>
          ) : (
            groupedTodos.map((group) => (
              <div key={group.date} className="space-y-2">
                <div className="flex items-center gap-3 pt-2">
                  <Separator className="flex-1" />
                  <span className="text-muted-foreground whitespace-nowrap text-xs font-medium">
                    {new Intl.DateTimeFormat(undefined, {
                      weekday: "short",
                      year: "numeric",
                      month: "short",
                      day: "2-digit",
                    }).format(parseLocalDateOnly(group.date))}
                  </span>
                  <Separator className="flex-1" />
                </div>

                {group.items.map((todo) => {
                  const state = getTaskStateWithInProgress(todo, nowMs, inProgressTaskId)

                  return (
                    <div
                      key={todo.id}
                      className={cn(
                        "rounded-lg border px-3 py-2",
                        state === "completed" && "opacity-75",
                        state === "overdue" &&
                          "border-destructive/40 bg-destructive/5 text-muted-foreground",
                        state === "in_progress" && "border-sky-500/40 bg-sky-500/10",
                        conflictDueAt &&
                          todo.dueAt === conflictDueAt &&
                          "border-destructive/60 bg-destructive/5 ring-1 ring-destructive/30"
                      )}
                    >
                      <div className="flex items-start justify-between gap-3">
                        <label className="flex cursor-pointer items-start gap-3">
                        <Checkbox
                          checked={todo.completed}
                          onCheckedChange={(v) => {
                            const next = Boolean(v)
                            toggleTodo(todo.id, next)
                            if (next && !todo.completed) {
                              requestAttachmentsForTodo(todo.id)
                            }
                          }}
                          aria-label={`Mark "${todo.title}" as ${
                            todo.completed ? "not completed" : "completed"
                          }`}
                          className="mt-0.5"
                        />
                        <span
                          className={cn(
                            "leading-6",
                            todo.completed && "text-muted-foreground line-through"
                          )}
                        >
                          <span className="flex flex-wrap items-center gap-2">
                            <span className="block">{todo.title}</span>
                            <TaskStateBadge state={state} />
                          </span>
                          <span className="text-muted-foreground block text-xs">
                            Due: {formatLocalDateTime(todo.dueAt)}
                          </span>
                        </span>
                      </label>

                      <div className="flex items-center gap-1">
                        {!todo.completed && state !== "overdue" && (
                          <Button
                            type="button"
                            variant={state === "in_progress" ? "default" : "outline"}
                            size="sm"
                            onClick={() =>
                              setInProgressTaskId((cur) =>
                                cur === todo.id ? null : todo.id
                              )
                            }
                            className={cn(
                              state === "in_progress" && "bg-sky-600 hover:bg-sky-600"
                            )}
                          >
                            {state === "in_progress" ? (
                              <>
                                <CircleStop className="mr-1 h-4 w-4" />
                                Stop
                              </>
                            ) : (
                              <>
                                <CirclePlay className="mr-1 h-4 w-4" />
                                Start
                              </>
                            )}
                          </Button>
                        )}
                        {todo.completed && (
                          <Button
                            type="button"
                            variant="outline"
                            size="sm"
                            onClick={() => requestAttachmentsForTodo(todo.id)}
                          >
                            Add files
                          </Button>
                        )}
                        <Button
                          type="button"
                          variant="ghost"
                          size="icon"
                          aria-label={`Delete "${todo.title}"`}
                          onClick={() => deleteTodo(todo.id)}
                        >
                          <Trash2 className="h-4 w-4" />
                        </Button>
                      </div>
                    </div>

                    {todo.completed && todo.attachments.length > 0 && (
                      <div className="mt-3 space-y-2">
                        <p className="text-muted-foreground text-xs">Attachments</p>
                        <ul className="space-y-1">
                          {todo.attachments.map((a) => (
                            <li
                              key={a.id}
                              className="flex items-center justify-between gap-3 rounded-md bg-muted/30 px-2 py-1"
                            >
                              <div className="flex min-w-0 items-center gap-2">
                                <AttachmentIcon kind={a.kind} />
                                <span className="truncate text-sm">{a.name}</span>
                              </div>
                              <a
                                href={a.url}
                                download={a.name}
                                className="inline-flex items-center gap-1 text-sm font-medium underline underline-offset-4"
                              >
                                <Download className="h-4 w-4" />
                                Download
                              </a>
                            </li>
                          ))}
                        </ul>
                      </div>
                    )}
                  </div>
                  )
                })}
              </div>
            ))
          )}
        </div>

        {groupedTodos.length > 0 && (
          <div className="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
            <div className="flex items-center gap-2">
              <span className="text-muted-foreground text-sm">Items per page</span>
              <Select
                value={String(pageSize)}
                onValueChange={(v) => {
                  const next = Number(v)
                  setPageSize(next)
                  setPage(1)
                }}
              >
                <SelectTrigger className="w-[110px]">
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="5">5</SelectItem>
                  <SelectItem value="10">10</SelectItem>
                  <SelectItem value="15">15</SelectItem>
                  <SelectItem value="20">20</SelectItem>
                </SelectContent>
              </Select>
            </div>

            {showPagination && (
              <div className="flex items-center justify-between gap-3 sm:justify-end">
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={() => setPage((p) => Math.max(1, p - 1))}
                  disabled={page <= 1}
                >
                  Prev
                </Button>
                <span className="text-muted-foreground text-sm">
                  Page {page} of {totalPages}
                </span>
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={() => setPage((p) => Math.min(totalPages, p + 1))}
                  disabled={page >= totalPages}
                >
                  Next
                </Button>
              </div>
            )}
          </div>
        )}

        <div className="flex items-center justify-between gap-2">
          <Button
            type="button"
            variant="secondary"
            onClick={clearCompleted}
            disabled={completedCount === 0}
          >
            Clear completed
          </Button>
          <span className="text-muted-foreground text-sm">
            Mock data only (no backend)
          </span>
    </div>
      </CardContent>
    </Card>
  )
}

```

```typescriptreact
"use client"

import { zodResolver } from "@hookform/resolvers/zod"
import {
  AlertTriangle,
  CirclePlay,
  CircleStop,
  CalendarClock,
  CheckCircle2,
  Download,
  File,
  FileSpreadsheet,
  FileText,
  Image as ImageIcon,
  Music,
  Bell,
  Timer,
  Trash2,
  Video,
} from "lucide-react"
import * as React from "react"
import { useForm } from "react-hook-form"
import { toast } from "sonner"
import { z } from "zod"

import { ModeToggle } from "@/components/mode-toggle"
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert"
import { Badge } from "@/components/ui/badge"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Checkbox } from "@/components/ui/checkbox"
import { Form, FormControl, FormField, FormItem, FormMessage } from "@/components/ui/form"
import { Input } from "@/components/ui/input"
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select"
import { Separator } from "@/components/ui/separator"
import { cn } from "@/lib/utils"

type AttachmentKind =
  | "image"
  | "audio"
  | "video"
  | "pdf"
  | "spreadsheet"
  | "document"
  | "text"
  | "file"

type Attachment = {
  id: string
  name: string
  type: string
  size: number
  url: string
  kind: AttachmentKind
}

type Todo = {
  id: string
  title: string
  completed: boolean
  // Stored as `datetime-local` string (YYYY-MM-DDTHH:mm) in local time.
  dueAt: string
  attachments: Attachment[]
}

type TaskState = "planned" | "in_progress" | "completed" | "overdue"
type DailyLoad = "light" | "balanced" | "heavy"

const todoSchema = z.object({
  title: z
    .string()
    .trim()
    .min(1, "Title is required.")
    .max(80, "Keep it under 80 characters."),
  dueAt: z
    .string()
    .min(1, "Due date & time is required.")
    .regex(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}$/, "Invalid date/time."),
})

type TodoFormValues = z.infer<typeof todoSchema>

const initialTodos: Todo[] = [
  {
    id: "1",
    title: "Create a Next.js app",
    completed: true,
    dueAt: "2026-01-16T09:00",
    attachments: [],
  },
  {
    id: "2",
    title: "Add shadcn/ui + dark theme",
    completed: true,
    dueAt: "2026-01-16T10:30",
    attachments: [],
  },
  {
    id: "3",
    title: "Build a mock-data to-do list",
    completed: false,
    dueAt: "2026-01-16T15:00",
    attachments: [],
  },
  {
    id: "4",
    title: "Yesterday: review requirements",
    completed: true,
    dueAt: "2026-01-15T11:15",
    attachments: [],
  },
  {
    id: "5",
    title: "Yesterday: sketch UI layout",
    completed: true,
    dueAt: "2026-01-15T17:45",
    attachments: [],
  },
  {
    id: "6",
    title: "Today: add attachments support",
    completed: false,
    dueAt: "2026-01-16T18:20",
    attachments: [],
  },
  {
    id: "7",
    title: "Tomorrow: QA the filters",
    completed: false,
    dueAt: "2026-01-17T08:05",
    attachments: [],
  },
  {
    id: "8",
    title: "Tomorrow: polish summary cards",
    completed: false,
    dueAt: "2026-01-17T13:30",
    attachments: [],
  },
  {
    id: "9",
    title: "Tomorrow: write small UX notes",
    completed: false,
    dueAt: "2026-01-17T20:10",
    attachments: [],
  },
  {
    id: "10",
    title: "This weekend: add more mock tasks",
    completed: false,
    dueAt: "2026-01-18T10:00",
    attachments: [],
  },
  {
    id: "11",
    title: "This weekend: check time-only filter",
    completed: false,
    dueAt: "2026-01-18T22:15",
    attachments: [],
  },
  {
    id: "12",
    title: "Next week: sync with team",
    completed: false,
    dueAt: "2026-01-19T09:30",
    attachments: [],
  },
  {
    id: "13",
    title: "Next week: test date-only filter",
    completed: false,
    dueAt: "2026-01-20T14:05",
    attachments: [],
  },
  {
    id: "14",
    title: "Next week: test exact date+time filter",
    completed: false,
    dueAt: "2026-01-21T12:00",
    attachments: [],
  },
  {
    id: "15",
    title: "Next week: attach docs to completed tasks",
    completed: false,
    dueAt: "2026-01-22T16:40",
    attachments: [],
  },
  {
    id: "16",
    title: "Next week: final review",
    completed: false,
    dueAt: "2026-01-23T11:00",
    attachments: [],
  },
]

function parseLocalDateTime(value: string): number {
  // value: "YYYY-MM-DDTHH:mm"
  const [datePart, timePart] = value.split("T")
  const [y, m, d] = datePart.split("-").map(Number)
  const [hh, mm] = timePart.split(":").map(Number)
  return new Date(y, m - 1, d, hh, mm, 0, 0).getTime()
}

function pad2(n: number) {
  return String(n).padStart(2, "0")
}

function localDateKey(d: Date) {
  return `${d.getFullYear()}-${pad2(d.getMonth() + 1)}-${pad2(d.getDate())}`
}

function addDays(date: Date, days: number) {
  const d = new Date(date)
  d.setDate(d.getDate() + days)
  return d
}

function startOfDay(date: Date) {
  return new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0, 0)
}

function endOfDay(date: Date) {
  return new Date(
    date.getFullYear(),
    date.getMonth(),
    date.getDate(),
    23,
    59,
    59,
    999
  )
}

function getDatePart(dueAt: string) {
  return dueAt.split("T")[0] ?? ""
}

function getTimePart(dueAt: string) {
  return dueAt.split("T")[1] ?? ""
}

function parseLocalDateOnly(value: string): Date {
  // value: "YYYY-MM-DD"
  const [y, m, d] = value.split("-").map(Number)
  return new Date(y, m - 1, d, 0, 0, 0, 0)
}

function parseLocalTimeToMinutes(value: string): number {
  // value: "HH:mm"
  const [hh, mm] = value.split(":").map(Number)
  return hh * 60 + mm
}

function formatLocalDateTime(value: string): string {
  const ms = parseLocalDateTime(value)
  if (!Number.isFinite(ms)) return value
  return new Intl.DateTimeFormat(undefined, {
    year: "numeric",
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  }).format(new Date(ms))
}

function formatDateTimeFromMs(ms: number): string {
  return new Intl.DateTimeFormat(undefined, {
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  }).format(new Date(ms))
}

function minutesUntil(targetMs: number, nowMs: number) {
  return Math.ceil((targetMs - nowMs) / 60_000)
}

function getTaskFlags(todo: Todo, nowMs: number, inProgressTaskId: string | null) {
  const completed = todo.completed
  const dueMs = parseLocalDateTime(todo.dueAt)
  const overdue = !completed && dueMs < nowMs
  const inProgress = !completed && inProgressTaskId === todo.id
  const planned = !completed && !overdue && !inProgress
  return { completed, overdue, inProgress, planned }
}

function getDailyLoad(todosForDay: Todo[]) {
  // 4-hour windows across the day (local).
  const labels = [
    "00:00–04:00",
    "04:00–08:00",
    "08:00–12:00",
    "12:00–16:00",
    "16:00–20:00",
    "20:00–24:00",
  ]
  const buckets = Array.from({ length: 6 }, () => 0) as number[]
  for (const t of todosForDay) {
    const ms = parseLocalDateTime(t.dueAt)
    const hour = new Date(ms).getHours()
    const idx = Math.floor(hour / 4)
    buckets[idx] = (buckets[idx] ?? 0) + 1
  }

  const total = todosForDay.length
  const peak = Math.max(0, ...buckets)
  const spread = buckets.filter((c) => c > 0).length
  const busiestIdx = buckets.findIndex((c) => c === peak)
  const busiestWindow = busiestIdx >= 0 ? labels[busiestIdx] : labels[0]

  // Heuristic: more tasks + higher concentration in one window => heavier day.
  const score = total + peak * 1.5 + Math.max(0, spread - 1) * 0.5
  const load: DailyLoad = score <= 5 ? "light" : score <= 10 ? "balanced" : "heavy"

  return { load, total, peak, spread, busiestWindow }
}

function DailyLoadBadge({ load }: { load: DailyLoad }) {
  if (load === "heavy") return <Badge variant="destructive">Heavy</Badge>
  if (load === "balanced") return <Badge variant="secondary">Balanced</Badge>
  return <Badge variant="outline">Light</Badge>
}

function TaskBadges({
  completed,
  overdue,
  inProgress,
  planned,
}: {
  completed: boolean
  overdue: boolean
  inProgress: boolean
  planned: boolean
}) {
  if (completed) {
    return (
      <Badge className="gap-1 bg-emerald-600 text-white hover:bg-emerald-600">
        <CheckCircle2 className="h-3.5 w-3.5" />
        Completed
      </Badge>
    )
  }

  return (
    <>
      {inProgress && (
        <Badge className="gap-1 bg-sky-600 text-white hover:bg-sky-600">
          <Timer className="h-3.5 w-3.5 text-white" />
          In progress
        </Badge>
      )}
      {overdue && (
        <Badge variant="destructive" className="gap-1">
          <AlertTriangle className="h-3.5 w-3.5" />
          Overdue
        </Badge>
      )}
      {planned && (
        <Badge variant="outline" className="gap-1">
          <CalendarClock className="h-3.5 w-3.5" />
          Planned
        </Badge>
      )}
    </>
  )
}

function getAttachmentKind(file: File): AttachmentKind {
  const type = (file.type || "").toLowerCase()
  const name = file.name.toLowerCase()
  const ext = name.includes(".") ? name.split(".").pop() ?? "" : ""

  if (type.startsWith("image/")) return "image"
  if (type.startsWith("audio/")) return "audio"
  if (type.startsWith("video/")) return "video"

  if (ext === "pdf") return "pdf"
  if (["xls", "xlsx", "csv"].includes(ext)) return "spreadsheet"
  if (["doc", "docx"].includes(ext)) return "document"
  if (["txt", "md", "rtf"].includes(ext)) return "text"

  return "file"
}

function makeAttachment(file: File): Attachment {
  return {
    id: crypto.randomUUID(),
    name: file.name,
    type: file.type,
    size: file.size,
    url: URL.createObjectURL(file),
    kind: getAttachmentKind(file),
  }
}

function revokeTodoAttachments(todo: Todo) {
  for (const a of todo.attachments) URL.revokeObjectURL(a.url)
}

function AttachmentIcon({ kind }: { kind: AttachmentKind }) {
  const className = "h-4 w-4 text-muted-foreground"

  switch (kind) {
    case "image":
      return <ImageIcon className={className} />
    case "audio":
      return <Music className={className} />
    case "video":
      return <Video className={className} />
    case "spreadsheet":
      return <FileSpreadsheet className={className} />
    case "pdf":
    case "document":
    case "text":
      return <FileText className={className} />
    default:
      return <File className={className} />
  }
}

export default function Home() {
  return (
    <div className="mx-auto flex min-h-screen max-w-2xl flex-col gap-6 px-4 py-10">
      <TodoApp />
    </div>
  )
}

function TodoApp() {
  const [todos, setTodos] = React.useState<Todo[]>(initialTodos)
  const [attachTargetTodoId, setAttachTargetTodoId] = React.useState<string | null>(
    null
  )
  const [conflictDueAt, setConflictDueAt] = React.useState<string | null>(null)
  const clearConflictTimerRef = React.useRef<number | null>(null)
  const [focusMode, setFocusMode] = React.useState(false)
  const [nowMs, setNowMs] = React.useState(() => Date.now())
  const [inProgressTaskId, setInProgressTaskId] = React.useState<string | null>(null)
  const [dismissedReminderTaskId, setDismissedReminderTaskId] = React.useState<
    string | null
  >(null)
  const [filterMode, setFilterMode] = React.useState<"between" | "exact">("between")
  const [filterFromDate, setFilterFromDate] = React.useState<string>("")
  const [filterFromTime, setFilterFromTime] = React.useState<string>("")
  const [filterToDate, setFilterToDate] = React.useState<string>("")
  const [filterToTime, setFilterToTime] = React.useState<string>("")
  const [filterExactDate, setFilterExactDate] = React.useState<string>("")
  const [filterExactTime, setFilterExactTime] = React.useState<string>("")
  const fileInputRef = React.useRef<HTMLInputElement>(null)
  const [pageSize, setPageSize] = React.useState<number>(5)
  const [page, setPage] = React.useState<number>(1)

  const todosRef = React.useRef(todos)
  React.useEffect(() => {
    todosRef.current = todos
  }, [todos])
  React.useEffect(() => {
    return () => {
      for (const t of todosRef.current) revokeTodoAttachments(t)
    }
  }, [])

  // Keep "now" fresh so overdue/in-progress states stay accurate without user interaction.
  React.useEffect(() => {
    const id = window.setInterval(() => setNowMs(Date.now()), 30_000)
    return () => window.clearInterval(id)
  }, [])

  // Only one task can be "In Progress"; auto-clear if completed, deleted, or overdue.
  React.useEffect(() => {
    if (!inProgressTaskId) return
    const t = todos.find((x) => x.id === inProgressTaskId)
    if (!t || t.completed) {
      setInProgressTaskId(null)
      return
    }
  }, [inProgressTaskId, nowMs, todos])

  const nextUpcoming = React.useMemo(() => {
    const upcoming = todos
      .filter((t) => !t.completed)
      .map((t) => ({ todo: t, dueMs: parseLocalDateTime(t.dueAt) }))
      .filter((x) => x.dueMs >= nowMs)
      .sort((a, b) => a.dueMs - b.dueMs)[0]
    return upcoming ?? null
  }, [nowMs, todos])

  React.useEffect(() => {
    // If "next upcoming" changed, allow reminder again (dismiss is per-task).
    if (nextUpcoming && nextUpcoming.todo.id !== dismissedReminderTaskId) return
    if (!nextUpcoming) setDismissedReminderTaskId(null)
  }, [dismissedReminderTaskId, nextUpcoming])

  const reminder = React.useMemo(() => {
    const REMINDER_WINDOW_MIN = 15
    if (!nextUpcoming) return null
    if (dismissedReminderTaskId === nextUpcoming.todo.id) return null
    const mins = minutesUntil(nextUpcoming.dueMs, nowMs)
    if (mins < 0 || mins > REMINDER_WINDOW_MIN) return null
    return { ...nextUpcoming, mins }
  }, [dismissedReminderTaskId, nextUpcoming, nowMs])

  const form = useForm<TodoFormValues>({
    resolver: zodResolver(todoSchema),
    defaultValues: { title: "", dueAt: "" },
    mode: "onSubmit",
  })

  const summary = React.useMemo(() => {
    const now = new Date()
    const todayKey = localDateKey(now)
    const tomorrow = addDays(now, 1)
    const tomorrowKey = localDateKey(tomorrow)

    const todays = todos.filter((t) => t.dueAt.startsWith(todayKey))
    const todayCompleted = todays.filter((t) => t.completed).length
    const todayPending = todays.length - todayCompleted

    const labels = [
      "00:00–04:00",
      "04:00–08:00",
      "08:00–12:00",
      "12:00–16:00",
      "16:00–20:00",
      "20:00–24:00",
    ]

    // Tomorrow: same 4-hour windows breakdown
    const tomorrowTasks = todos.filter((t) => t.dueAt.startsWith(tomorrowKey))
    const tomorrowBuckets = Array.from({ length: 6 }, () => 0) as number[]
    for (const t of tomorrowTasks) {
      const ms = parseLocalDateTime(t.dueAt)
      const hour = new Date(ms).getHours()
      const idx = Math.floor(hour / 4)
      tomorrowBuckets[idx] = (tomorrowBuckets[idx] ?? 0) + 1
    }

    // Until next week = next 7 days starting tomorrow (local), grouped into 4-hour windows.
    const rangeStart = startOfDay(tomorrow).getTime()
    const rangeEnd = addDays(startOfDay(tomorrow), 7).getTime()
    const buckets = Array.from({ length: 6 }, () => 0) as number[]

    const upcoming = todos.filter((t) => {
      const ms = parseLocalDateTime(t.dueAt)
      return ms >= rangeStart && ms < rangeEnd
    })

    for (const t of upcoming) {
      const ms = parseLocalDateTime(t.dueAt)
      const hour = new Date(ms).getHours()
      const idx = Math.floor(hour / 4)
      buckets[idx] = (buckets[idx] ?? 0) + 1
    }

    return {
      todayCompleted,
      todayPending,
      tomorrowTotal: tomorrowTasks.length,
      tomorrowBuckets: labels.map((label, i) => ({ label, count: tomorrowBuckets[i] ?? 0 })),
      upcomingTotal: upcoming.length,
      upcomingBuckets: labels.map((label, i) => ({ label, count: buckets[i] ?? 0 })),
    }
  }, [todos])

  const loadDayKey = React.useMemo(() => {
    // Prefer an explicitly selected date from filters; otherwise use today.
    if (filterMode === "exact" && filterExactDate) return filterExactDate
    if (filterFromDate && !filterToDate) return filterFromDate
    if (filterFromDate && filterToDate && filterFromDate === filterToDate) return filterFromDate
    if (!filterFromDate && filterToDate) return filterToDate
    return localDateKey(new Date(nowMs))
  }, [filterExactDate, filterFromDate, filterMode, filterToDate, nowMs])

  const dailyLoad = React.useMemo(() => {
    const dayTodos = todos.filter((t) => getDatePart(t.dueAt) === loadDayKey)
    return getDailyLoad(dayTodos)
  }, [loadDayKey, todos])

  const filteredTodos = React.useMemo(() => {
    if (focusMode) {
      const endMs = nowMs + 4 * 60 * 60 * 1000
      const withMs = todos.map((t) => ({ ...t, _dueMs: parseLocalDateTime(t.dueAt) }))
      return withMs.filter((t) => t._dueMs >= nowMs && t._dueMs <= endMs)
    }

    const withMs = todos.map((t) => ({ ...t, _dueMs: parseLocalDateTime(t.dueAt) }))
    if (filterMode === "exact") {
      // If only date is selected -> show tasks for that date.
      // If time is selected too -> match exact date+time.
      // If only time is selected -> match time-of-day across all dates.
      if (!filterExactDate && !filterExactTime) return withMs

      if (filterExactDate && !filterExactTime) {
        return withMs.filter((t) => getDatePart(t.dueAt) === filterExactDate)
      }

      if (filterExactDate && filterExactTime) {
        const exactMs = parseLocalDateTime(`${filterExactDate}T${filterExactTime}`)
        return withMs.filter((t) => t._dueMs === exactMs)
      }

      // time only
      return withMs.filter((t) => getTimePart(t.dueAt) === filterExactTime)
    }
    // between
    const hasAnyDate = Boolean(filterFromDate || filterToDate)
    const hasAnyTime = Boolean(filterFromTime || filterToTime)

    // Date range (optional)
    const fromDateMs = filterFromDate
      ? startOfDay(parseLocalDateOnly(filterFromDate)).getTime()
      : Number.NEGATIVE_INFINITY
    const toDateMs = filterToDate
      ? endOfDay(parseLocalDateOnly(filterToDate)).getTime()
      : Number.POSITIVE_INFINITY

    // Time-of-day range (optional)
    const fromTimeMin = filterFromTime ? parseLocalTimeToMinutes(filterFromTime) : 0
    const toTimeMin = filterToTime ? parseLocalTimeToMinutes(filterToTime) : 24 * 60 - 1

    return withMs.filter((t) => {
      const ms = t._dueMs
      if (hasAnyDate && (ms < fromDateMs || ms > toDateMs)) return false

      if (hasAnyTime) {
        const time = getTimePart(t.dueAt)
        if (!time) return false
        const mins = parseLocalTimeToMinutes(time)
        // Simple (non-wrapping) range. If you want wrap-around (e.g. 22:00–02:00), tell me.
        if (mins < fromTimeMin || mins > toTimeMin) return false
      }

      // If neither date nor time selected, pass through (handled above anyway)
      return true
    })
  }, [
    todos,
    focusMode,
    nowMs,
    filterExactDate,
    filterExactTime,
    filterFromDate,
    filterFromTime,
    filterMode,
    filterToDate,
    filterToTime,
  ])

  const sortedFilteredTodos = React.useMemo(
    () =>
      filteredTodos
        .slice()
        .sort((a, b) => parseLocalDateTime(a.dueAt) - parseLocalDateTime(b.dueAt)),
    [filteredTodos]
  )

  // Clamp page when filters/pageSize change.
  React.useEffect(() => {
    const totalPages = Math.max(1, Math.ceil(sortedFilteredTodos.length / pageSize))
    setPage((p) => Math.min(Math.max(1, p), totalPages))
  }, [pageSize, sortedFilteredTodos.length])

  const totalItems = sortedFilteredTodos.length
  const totalPages = Math.max(1, Math.ceil(totalItems / pageSize))
  const showPagination = totalPages > 1

  const pageItems = React.useMemo(() => {
    const start = (page - 1) * pageSize
    return sortedFilteredTodos.slice(start, start + pageSize)
  }, [page, pageSize, sortedFilteredTodos])

  const groupedTodos = React.useMemo(() => {
    const groups: Array<{ date: string; items: typeof pageItems }> = []
    for (const t of pageItems) {
      const date = getDatePart(t.dueAt)
      const last = groups[groups.length - 1]
      if (!last || last.date !== date) groups.push({ date, items: [t] })
      else last.items.push(t)
    }
    return groups
  }, [pageItems])

  const completedCount = filteredTodos.filter((t) => t.completed).length

  function addTodo(values: TodoFormValues) {
    const conflicts = todos.filter((t) => t.dueAt === values.dueAt)
    if (conflicts.length > 0) {
      setConflictDueAt(values.dueAt)
      if (clearConflictTimerRef.current) window.clearTimeout(clearConflictTimerRef.current)
      clearConflictTimerRef.current = window.setTimeout(() => {
        setConflictDueAt(null)
      }, 8000)

      // Make sure the user can see the conflicting tasks even if they were filtered out.
      const [d, time] = values.dueAt.split("T")
      setFilterMode("exact")
      setFilterExactDate(d ?? "")
      setFilterExactTime(time ?? "")
      setPage(1)

      toast.error("Time conflict", {
        description: `You already have ${conflicts.length} task(s) scheduled at ${formatLocalDateTime(
          values.dueAt
        )}.`,
      })
    }

    setTodos((prev) => [
      {
        id: crypto.randomUUID(),
        title: values.title.trim(),
        completed: false,
        dueAt: values.dueAt,
        attachments: [],
      },
      ...prev,
    ])
    form.reset()
  }

  function toggleTodo(id: string, completed: boolean) {
    setTodos((prev) => prev.map((t) => (t.id === id ? { ...t, completed } : t)))
    if (completed) setInProgressTaskId((cur) => (cur === id ? null : cur))
  }

  function requestAttachmentsForTodo(todoId: string) {
    setAttachTargetTodoId(todoId)
    // Let state update before opening picker (some browsers are picky).
    queueMicrotask(() => fileInputRef.current?.click())
  }

  function handleFilesPicked(e: React.ChangeEvent<HTMLInputElement>) {
    const files = Array.from(e.target.files ?? [])
    const targetId = attachTargetTodoId

    // reset input so picking the same file again triggers onChange
    e.target.value = ""
    setAttachTargetTodoId(null)

    if (!targetId || files.length === 0) return

    const attachments = files.map(makeAttachment)

    setTodos((prev) =>
      prev.map((t) =>
        t.id === targetId
          ? { ...t, attachments: [...t.attachments, ...attachments] }
          : t
      )
    )
  }

  function deleteTodo(id: string) {
    setTodos((prev) => {
      const victim = prev.find((t) => t.id === id)
      if (victim) revokeTodoAttachments(victim)
      return prev.filter((t) => t.id !== id)
    })
    setInProgressTaskId((cur) => (cur === id ? null : cur))
  }

  function clearCompleted() {
    setTodos((prev) => {
      for (const t of prev) {
        if (t.completed) revokeTodoAttachments(t)
      }
      return prev.filter((t) => !t.completed)
    })
  }

  return (
    <Card>
      <CardHeader className="flex flex-row items-center justify-between gap-4">
        <div className="space-y-1">
          <CardTitle className="text-2xl">To‑Do</CardTitle>
          <p className="text-muted-foreground text-sm">
            {completedCount}/{filteredTodos.length} completed
          </p>
        </div>
        <div className="flex items-center gap-2">
          <Button
            type="button"
            variant={focusMode ? "default" : "outline"}
            size="sm"
            onClick={() => {
              setFocusMode((v) => !v)
              setPage(1)
            }}
          >
            Focus Mode
          </Button>
          <ModeToggle />
        </div>
      </CardHeader>

      <CardContent className="space-y-6">
        <input
          ref={fileInputRef}
          type="file"
          multiple
          className="hidden"
          accept={[
            "image/*",
            "audio/*",
            "video/*",
            ".pdf",
            ".doc",
            ".docx",
            ".xls",
            ".xlsx",
            ".csv",
            ".txt",
            ".md",
            ".rtf",
          ].join(",")}
          onChange={handleFilesPicked}
        />

        {reminder && (
          <Alert className="border-primary/30 bg-primary/5">
            <Bell className="h-4 w-4" />
            <div className="flex flex-1 flex-col gap-1">
              <div className="flex flex-wrap items-center justify-between gap-2">
                <AlertTitle className="text-sm">
                  Next task starts in {reminder.mins} minute{reminder.mins === 1 ? "" : "s"}
                </AlertTitle>
                <Button
                  type="button"
                  variant="ghost"
                  size="sm"
                  onClick={() => setDismissedReminderTaskId(reminder.todo.id)}
                >
                  Dismiss
                </Button>
              </div>
              <AlertDescription className="text-sm">
                <span className="font-medium">{reminder.todo.title}</span> ·{" "}
                {formatDateTimeFromMs(reminder.dueMs)}
              </AlertDescription>
            </div>
          </Alert>
        )}

        <div className="rounded-xl border bg-card p-4">
          <div className="flex flex-wrap items-center justify-between gap-2">
            <p className="text-sm font-medium">
              Daily load{" "}
              <span className="text-muted-foreground font-normal">
                ({new Intl.DateTimeFormat(undefined, {
                  weekday: "short",
                  year: "numeric",
                  month: "short",
                  day: "2-digit",
                }).format(parseLocalDateOnly(loadDayKey))})
              </span>
            </p>
            <DailyLoadBadge load={dailyLoad.load} />
          </div>
          <p className="text-muted-foreground mt-2 text-sm">
            {dailyLoad.total} task(s) · busiest window {dailyLoad.busiestWindow} ({dailyLoad.peak})
          </p>
        </div>

        <div className="grid gap-3 sm:grid-cols-3">
          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Today’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">
              {summary.todayCompleted} completed
            </p>
            <p className="text-muted-foreground text-sm">{summary.todayPending} pending</p>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tomorrow’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">{summary.tomorrowTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.tomorrowBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tasks Until Next Week</p>
            <p className="mt-2 text-2xl font-semibold">{summary.upcomingTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.upcomingBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>
        </div>

        {focusMode && (
          <div className="flex flex-col gap-1 rounded-lg border bg-muted/20 px-3 py-2 sm:flex-row sm:items-center sm:justify-between">
            <p className="text-sm">
              <span className="font-medium">Focus Mode:</span>{" "}
              showing tasks due in the next 4 hours (until{" "}
              <span className="font-medium">
                {formatDateTimeFromMs(nowMs + 4 * 60 * 60 * 1000)}
              </span>
              )
            </p>
            <Button type="button" variant="ghost" size="sm" onClick={() => setFocusMode(false)}>
              Exit
            </Button>
          </div>
        )}

        <Form {...form}>
          <form
            onSubmit={form.handleSubmit(addTodo)}
            className="space-y-2"
            noValidate
          >
            <div className="flex flex-col gap-2 sm:flex-row">
              <FormField
                control={form.control}
                name="title"
                render={({ field }) => (
                  <FormItem className="flex-1">
                    <FormControl>
                      <Input
                        placeholder="Add a task…"
                        autoComplete="off"
                        {...field}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="dueAt"
                render={({ field }) => (
                  <FormItem className="sm:w-64">
                    <FormControl>
                      <Input type="datetime-local" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <Button type="submit">Add</Button>
            </div>
          </form>
        </Form>

        <Separator />

        <div className="space-y-3">
          <div className="flex flex-wrap items-center justify-between gap-2">
            <p className="text-sm font-medium">Filter by date & time</p>
            <div className="flex items-center gap-2">
              <Button
                type="button"
                size="sm"
                variant={filterMode === "between" ? "default" : "outline"}
                onClick={() => setFilterMode("between")}
              >
                Between
              </Button>
              <Button
                type="button"
                size="sm"
                variant={filterMode === "exact" ? "default" : "outline"}
                onClick={() => setFilterMode("exact")}
              >
                Exact
              </Button>
              <Button
                type="button"
                size="sm"
                variant="ghost"
                onClick={() => {
                  setFilterFromDate("")
                  setFilterFromTime("")
                  setFilterToDate("")
                  setFilterToTime("")
                  setFilterExactDate("")
                  setFilterExactTime("")
                }}
              >
                Clear
              </Button>
            </div>
          </div>

          {filterMode === "between" ? (
            <div className="grid gap-2 sm:grid-cols-2">
              <div className="grid gap-2 sm:grid-cols-2">
                <Input
                  type="date"
                  value={filterFromDate}
                  onChange={(e) => setFilterFromDate(e.target.value)}
                />
                <Input
                  type="time"
                  value={filterFromTime}
                  onChange={(e) => setFilterFromTime(e.target.value)}
                />
              </div>
              <div className="grid gap-2 sm:grid-cols-2">
                <Input
                  type="date"
                  value={filterToDate}
                  onChange={(e) => setFilterToDate(e.target.value)}
                />
                <Input
                  type="time"
                  value={filterToTime}
                  onChange={(e) => setFilterToTime(e.target.value)}
                />
              </div>
            </div>
          ) : (
            <div className="grid gap-2 sm:grid-cols-2">
              <Input
                type="date"
                value={filterExactDate}
                onChange={(e) => setFilterExactDate(e.target.value)}
              />
              <Input
                type="time"
                value={filterExactTime}
                onChange={(e) => setFilterExactTime(e.target.value)}
              />
            </div>
          )}
        </div>

        <Separator />

        <div className="space-y-2">
          {groupedTodos.length === 0 ? (
            <p className="text-muted-foreground text-sm">No tasks yet.</p>
          ) : (
            groupedTodos.map((group) => (
              <div key={group.date} className="space-y-2">
                <div className="flex items-center gap-3 pt-2">
                  <Separator className="flex-1" />
                  <span className="text-muted-foreground whitespace-nowrap text-xs font-medium">
                    {new Intl.DateTimeFormat(undefined, {
                      weekday: "short",
                      year: "numeric",
                      month: "short",
                      day: "2-digit",
                    }).format(parseLocalDateOnly(group.date))}
                  </span>
                  <Separator className="flex-1" />
                </div>

                {group.items.map((todo) => {
                  const flags = getTaskFlags(todo, nowMs, inProgressTaskId)

                  return (
                    <div
                      key={todo.id}
                      className={cn(
                        "rounded-lg border px-3 py-2",
                        flags.completed && "opacity-75",
                        flags.overdue &&
                          "border-destructive/40 bg-destructive/5 text-muted-foreground",
                        flags.inProgress && "border-sky-500/40 bg-sky-500/10",
                        conflictDueAt &&
                          todo.dueAt === conflictDueAt &&
                          "border-destructive/60 bg-destructive/5 ring-1 ring-destructive/30"
                      )}
                    >
                      <div className="flex items-start justify-between gap-3">
                        <label className="flex cursor-pointer items-start gap-3">
                        <Checkbox
                          checked={todo.completed}
                          onCheckedChange={(v) => {
                            const next = Boolean(v)
                            toggleTodo(todo.id, next)
                            if (next && !todo.completed) {
                              requestAttachmentsForTodo(todo.id)
                            }
                          }}
                          aria-label={`Mark "${todo.title}" as ${
                            todo.completed ? "not completed" : "completed"
                          }`}
                          className="mt-0.5"
                        />
                        <span
                          className={cn(
                            "leading-6",
                            todo.completed && "text-muted-foreground line-through"
                          )}
                        >
                          <span className="flex flex-wrap items-center gap-2">
                            <span className="block">{todo.title}</span>
                              <span className="flex flex-wrap items-center gap-2">
                                <TaskBadges {...flags} />
                              </span>
                          </span>
                          <span className="text-muted-foreground block text-xs">
                            Due: {formatLocalDateTime(todo.dueAt)}
                          </span>
                        </span>
                      </label>

                      <div className="flex items-center gap-1">
                        {!todo.completed && (
                          <Button
                            type="button"
                            variant={flags.inProgress ? "default" : "outline"}
                            size="sm"
                            onClick={() =>
                              setInProgressTaskId((cur) =>
                                cur === todo.id ? null : todo.id
                              )
                            }
                            className={cn(
                              flags.inProgress && "bg-sky-600 hover:bg-sky-600"
                            )}
                          >
                            {flags.inProgress ? (
                              <>
                                <CircleStop className="mr-1 h-4 w-4" />
                                Stop
                              </>
                            ) : (
                              <>
                                <CirclePlay className="mr-1 h-4 w-4" />
                                Start
                              </>
                            )}
                          </Button>
                        )}
                        {todo.completed && (
                          <Button
                            type="button"
                            variant="outline"
                            size="sm"
                            onClick={() => requestAttachmentsForTodo(todo.id)}
                          >
                            Add files
                          </Button>
                        )}
                        <Button
                          type="button"
                          variant="ghost"
                          size="icon"
                          aria-label={`Delete "${todo.title}"`}
                          onClick={() => deleteTodo(todo.id)}
                        >
                          <Trash2 className="h-4 w-4" />
                        </Button>
                      </div>
                    </div>

                    {todo.completed && todo.attachments.length > 0 && (
                      <div className="mt-3 space-y-2">
                        <p className="text-muted-foreground text-xs">Attachments</p>
                        <ul className="space-y-1">
                          {todo.attachments.map((a) => (
                            <li
                              key={a.id}
                              className="flex items-center justify-between gap-3 rounded-md bg-muted/30 px-2 py-1"
                            >
                              <div className="flex min-w-0 items-center gap-2">
                                <AttachmentIcon kind={a.kind} />
                                <span className="truncate text-sm">{a.name}</span>
                              </div>
                              <a
                                href={a.url}
                                download={a.name}
                                className="inline-flex items-center gap-1 text-sm font-medium underline underline-offset-4"
                              >
                                <Download className="h-4 w-4" />
                                Download
                              </a>
                            </li>
                          ))}
                        </ul>
                      </div>
                    )}
                  </div>
                  )
                })}
              </div>
            ))
          )}
        </div>

        {groupedTodos.length > 0 && (
          <div className="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
            <div className="flex items-center gap-2">
              <span className="text-muted-foreground text-sm">Items per page</span>
              <Select
                value={String(pageSize)}
                onValueChange={(v) => {
                  const next = Number(v)
                  setPageSize(next)
                  setPage(1)
                }}
              >
                <SelectTrigger className="w-[110px]">
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="5">5</SelectItem>
                  <SelectItem value="10">10</SelectItem>
                  <SelectItem value="15">15</SelectItem>
                  <SelectItem value="20">20</SelectItem>
                </SelectContent>
              </Select>
            </div>

            {showPagination && (
              <div className="flex items-center justify-between gap-3 sm:justify-end">
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={() => setPage((p) => Math.max(1, p - 1))}
                  disabled={page <= 1}
                >
                  Prev
                </Button>
                <span className="text-muted-foreground text-sm">
                  Page {page} of {totalPages}
                </span>
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={() => setPage((p) => Math.min(totalPages, p + 1))}
                  disabled={page >= totalPages}
                >
                  Next
                </Button>
              </div>
            )}
          </div>
        )}

        <div className="flex items-center justify-between gap-2">
          <Button
            type="button"
            variant="secondary"
            onClick={clearCompleted}
            disabled={completedCount === 0}
          >
            Clear completed
          </Button>
          <span className="text-muted-foreground text-sm">
            Mock data only (no backend)
          </span>
    </div>
      </CardContent>
    </Card>
  )
}

```

### Overdue + In Progress can now coexist
- **Overdue remains automatic/time-based** (task is overdue when `dueAt` is in the past and it’s not completed).
- **In Progress is manual** (Start/Stop), and you can now **Start an Overdue task**.
- The UI can show **both badges at once** (e.g., **In progress** + **Overdue**).
- Still enforces **only one task In Progress at a time**.
- In Progress now **only clears** when the task is **completed** or **deleted** (not when it becomes overdue).

### File updated
- `src/app/page.tsx`

---

**User**

Add an optional task description field (3-row textarea). Show an info icon in the list when a description exists, and display it in a tooltip on interaction.

---

**Cursor**

Plan: add shadcn `textarea` + `tooltip`, extend the task model + zod schema with an optional `description`, update the create form with a 3-row textarea, then show an info icon in each list row (only when description exists) that reveals the description in a tooltip. Then I’ll run a build to confirm.

```typescriptreact
"use client"

import { zodResolver } from "@hookform/resolvers/zod"
import {
  AlertTriangle,
  CirclePlay,
  CircleStop,
  CalendarClock,
  CheckCircle2,
  Download,
  File,
  FileSpreadsheet,
  FileText,
  Image as ImageIcon,
  Info,
  Music,
  Bell,
  Timer,
  Trash2,
  Video,
} from "lucide-react"
import * as React from "react"
import { useForm } from "react-hook-form"
import { toast } from "sonner"
import { z } from "zod"

import { ModeToggle } from "@/components/mode-toggle"
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert"
import { Badge } from "@/components/ui/badge"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Checkbox } from "@/components/ui/checkbox"
import { Form, FormControl, FormField, FormItem, FormMessage } from "@/components/ui/form"
import { Input } from "@/components/ui/input"
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select"
import { Separator } from "@/components/ui/separator"
import { Textarea } from "@/components/ui/textarea"
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip"
import { cn } from "@/lib/utils"

type AttachmentKind =
  | "image"
  | "audio"
  | "video"
  | "pdf"
  | "spreadsheet"
  | "document"
  | "text"
  | "file"

type Attachment = {
  id: string
  name: string
  type: string
  size: number
  url: string
  kind: AttachmentKind
}

type Todo = {
  id: string
  title: string
  description?: string
  completed: boolean
  // Stored as `datetime-local` string (YYYY-MM-DDTHH:mm) in local time.
  dueAt: string
  attachments: Attachment[]
}

type TaskState = "planned" | "in_progress" | "completed" | "overdue"
type DailyLoad = "light" | "balanced" | "heavy"

const todoSchema = z.object({
  title: z
    .string()
    .trim()
    .min(1, "Title is required.")
    .max(80, "Keep it under 80 characters."),
  description: z
    .string()
    .trim()
    .max(500, "Keep it under 500 characters.")
    .optional()
    .or(z.literal("")),
  dueAt: z
    .string()
    .min(1, "Due date & time is required.")
    .regex(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}$/, "Invalid date/time."),
})

type TodoFormValues = z.infer<typeof todoSchema>

const initialTodos: Todo[] = [
  {
    id: "1",
    title: "Create a Next.js app",
    description: "Scaffold with TypeScript + Tailwind and confirm it runs locally.",
    completed: true,
    dueAt: "2026-01-16T09:00",
    attachments: [],
  },
  {
    id: "2",
    title: "Add shadcn/ui + dark theme",
    description: "Initialize shadcn, set up theme provider, and verify dark mode.",
    completed: true,
    dueAt: "2026-01-16T10:30",
    attachments: [],
  },
  {
    id: "3",
    title: "Build a mock-data to-do list",
    completed: false,
    dueAt: "2026-01-16T15:00",
    attachments: [],
  },
  {
    id: "4",
    title: "Yesterday: review requirements",
    completed: true,
    dueAt: "2026-01-15T11:15",
    attachments: [],
  },
  {
    id: "5",
    title: "Yesterday: sketch UI layout",
    completed: true,
    dueAt: "2026-01-15T17:45",
    attachments: [],
  },
  {
    id: "6",
    title: "Today: add attachments support",
    completed: false,
    dueAt: "2026-01-16T18:20",
    attachments: [],
  },
  {
    id: "7",
    title: "Tomorrow: QA the filters",
    description: "Test date-only, time-only, exact, and between behaviors.",
    completed: false,
    dueAt: "2026-01-17T08:05",
    attachments: [],
  },
  {
    id: "8",
    title: "Tomorrow: polish summary cards",
    completed: false,
    dueAt: "2026-01-17T13:30",
    attachments: [],
  },
  {
    id: "9",
    title: "Tomorrow: write small UX notes",
    completed: false,
    dueAt: "2026-01-17T20:10",
    attachments: [],
  },
  {
    id: "10",
    title: "This weekend: add more mock tasks",
    completed: false,
    dueAt: "2026-01-18T10:00",
    attachments: [],
  },
  {
    id: "11",
    title: "This weekend: check time-only filter",
    completed: false,
    dueAt: "2026-01-18T22:15",
    attachments: [],
  },
  {
    id: "12",
    title: "Next week: sync with team",
    completed: false,
    dueAt: "2026-01-19T09:30",
    attachments: [],
  },
  {
    id: "13",
    title: "Next week: test date-only filter",
    completed: false,
    dueAt: "2026-01-20T14:05",
    attachments: [],
  },
  {
    id: "14",
    title: "Next week: test exact date+time filter",
    completed: false,
    dueAt: "2026-01-21T12:00",
    attachments: [],
  },
  {
    id: "15",
    title: "Next week: attach docs to completed tasks",
    completed: false,
    dueAt: "2026-01-22T16:40",
    attachments: [],
  },
  {
    id: "16",
    title: "Next week: final review",
    completed: false,
    dueAt: "2026-01-23T11:00",
    attachments: [],
  },
]

function parseLocalDateTime(value: string): number {
  // value: "YYYY-MM-DDTHH:mm"
  const [datePart, timePart] = value.split("T")
  const [y, m, d] = datePart.split("-").map(Number)
  const [hh, mm] = timePart.split(":").map(Number)
  return new Date(y, m - 1, d, hh, mm, 0, 0).getTime()
}

function pad2(n: number) {
  return String(n).padStart(2, "0")
}

function localDateKey(d: Date) {
  return `${d.getFullYear()}-${pad2(d.getMonth() + 1)}-${pad2(d.getDate())}`
}

function addDays(date: Date, days: number) {
  const d = new Date(date)
  d.setDate(d.getDate() + days)
  return d
}

function startOfDay(date: Date) {
  return new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0, 0)
}

function endOfDay(date: Date) {
  return new Date(
    date.getFullYear(),
    date.getMonth(),
    date.getDate(),
    23,
    59,
    59,
    999
  )
}

function getDatePart(dueAt: string) {
  return dueAt.split("T")[0] ?? ""
}

function getTimePart(dueAt: string) {
  return dueAt.split("T")[1] ?? ""
}

function parseLocalDateOnly(value: string): Date {
  // value: "YYYY-MM-DD"
  const [y, m, d] = value.split("-").map(Number)
  return new Date(y, m - 1, d, 0, 0, 0, 0)
}

function parseLocalTimeToMinutes(value: string): number {
  // value: "HH:mm"
  const [hh, mm] = value.split(":").map(Number)
  return hh * 60 + mm
}

function formatLocalDateTime(value: string): string {
  const ms = parseLocalDateTime(value)
  if (!Number.isFinite(ms)) return value
  return new Intl.DateTimeFormat(undefined, {
    year: "numeric",
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  }).format(new Date(ms))
}

function formatDateTimeFromMs(ms: number): string {
  return new Intl.DateTimeFormat(undefined, {
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  }).format(new Date(ms))
}

function minutesUntil(targetMs: number, nowMs: number) {
  return Math.ceil((targetMs - nowMs) / 60_000)
}

function getTaskFlags(todo: Todo, nowMs: number, inProgressTaskId: string | null) {
  const completed = todo.completed
  const dueMs = parseLocalDateTime(todo.dueAt)
  const overdue = !completed && dueMs < nowMs
  const inProgress = !completed && inProgressTaskId === todo.id
  const planned = !completed && !overdue && !inProgress
  return { completed, overdue, inProgress, planned }
}

function getDailyLoad(todosForDay: Todo[]) {
  // 4-hour windows across the day (local).
  const labels = [
    "00:00–04:00",
    "04:00–08:00",
    "08:00–12:00",
    "12:00–16:00",
    "16:00–20:00",
    "20:00–24:00",
  ]
  const buckets = Array.from({ length: 6 }, () => 0) as number[]
  for (const t of todosForDay) {
    const ms = parseLocalDateTime(t.dueAt)
    const hour = new Date(ms).getHours()
    const idx = Math.floor(hour / 4)
    buckets[idx] = (buckets[idx] ?? 0) + 1
  }

  const total = todosForDay.length
  const peak = Math.max(0, ...buckets)
  const spread = buckets.filter((c) => c > 0).length
  const busiestIdx = buckets.findIndex((c) => c === peak)
  const busiestWindow = busiestIdx >= 0 ? labels[busiestIdx] : labels[0]

  // Heuristic: more tasks + higher concentration in one window => heavier day.
  const score = total + peak * 1.5 + Math.max(0, spread - 1) * 0.5
  const load: DailyLoad = score <= 5 ? "light" : score <= 10 ? "balanced" : "heavy"

  return { load, total, peak, spread, busiestWindow }
}

function DailyLoadBadge({ load }: { load: DailyLoad }) {
  if (load === "heavy") return <Badge variant="destructive">Heavy</Badge>
  if (load === "balanced") return <Badge variant="secondary">Balanced</Badge>
  return <Badge variant="outline">Light</Badge>
}

function TaskBadges({
  completed,
  overdue,
  inProgress,
  planned,
}: {
  completed: boolean
  overdue: boolean
  inProgress: boolean
  planned: boolean
}) {
  if (completed) {
    return (
      <Badge className="gap-1 bg-emerald-600 text-white hover:bg-emerald-600">
        <CheckCircle2 className="h-3.5 w-3.5" />
        Completed
      </Badge>
    )
  }

  return (
    <>
      {inProgress && (
        <Badge className="gap-1 bg-sky-600 text-white hover:bg-sky-600">
          <Timer className="h-3.5 w-3.5 text-white" />
          In progress
        </Badge>
      )}
      {overdue && (
        <Badge variant="destructive" className="gap-1">
          <AlertTriangle className="h-3.5 w-3.5" />
          Overdue
        </Badge>
      )}
      {planned && (
        <Badge variant="outline" className="gap-1">
          <CalendarClock className="h-3.5 w-3.5" />
          Planned
        </Badge>
      )}
    </>
  )
}

function getAttachmentKind(file: File): AttachmentKind {
  const type = (file.type || "").toLowerCase()
  const name = file.name.toLowerCase()
  const ext = name.includes(".") ? name.split(".").pop() ?? "" : ""

  if (type.startsWith("image/")) return "image"
  if (type.startsWith("audio/")) return "audio"
  if (type.startsWith("video/")) return "video"

  if (ext === "pdf") return "pdf"
  if (["xls", "xlsx", "csv"].includes(ext)) return "spreadsheet"
  if (["doc", "docx"].includes(ext)) return "document"
  if (["txt", "md", "rtf"].includes(ext)) return "text"

  return "file"
}

function makeAttachment(file: File): Attachment {
  return {
    id: crypto.randomUUID(),
    name: file.name,
    type: file.type,
    size: file.size,
    url: URL.createObjectURL(file),
    kind: getAttachmentKind(file),
  }
}

function revokeTodoAttachments(todo: Todo) {
  for (const a of todo.attachments) URL.revokeObjectURL(a.url)
}

function AttachmentIcon({ kind }: { kind: AttachmentKind }) {
  const className = "h-4 w-4 text-muted-foreground"

  switch (kind) {
    case "image":
      return <ImageIcon className={className} />
    case "audio":
      return <Music className={className} />
    case "video":
      return <Video className={className} />
    case "spreadsheet":
      return <FileSpreadsheet className={className} />
    case "pdf":
    case "document":
    case "text":
      return <FileText className={className} />
    default:
      return <File className={className} />
  }
}

export default function Home() {
  return (
    <div className="mx-auto flex min-h-screen max-w-2xl flex-col gap-6 px-4 py-10">
      <TodoApp />
    </div>
  )
}

function TodoApp() {
  const [todos, setTodos] = React.useState<Todo[]>(initialTodos)
  const [attachTargetTodoId, setAttachTargetTodoId] = React.useState<string | null>(
    null
  )
  const [conflictDueAt, setConflictDueAt] = React.useState<string | null>(null)
  const clearConflictTimerRef = React.useRef<number | null>(null)
  const [focusMode, setFocusMode] = React.useState(false)
  const [nowMs, setNowMs] = React.useState(() => Date.now())
  const [inProgressTaskId, setInProgressTaskId] = React.useState<string | null>(null)
  const [dismissedReminderTaskId, setDismissedReminderTaskId] = React.useState<
    string | null
  >(null)
  const [filterMode, setFilterMode] = React.useState<"between" | "exact">("between")
  const [filterFromDate, setFilterFromDate] = React.useState<string>("")
  const [filterFromTime, setFilterFromTime] = React.useState<string>("")
  const [filterToDate, setFilterToDate] = React.useState<string>("")
  const [filterToTime, setFilterToTime] = React.useState<string>("")
  const [filterExactDate, setFilterExactDate] = React.useState<string>("")
  const [filterExactTime, setFilterExactTime] = React.useState<string>("")
  const fileInputRef = React.useRef<HTMLInputElement>(null)
  const [pageSize, setPageSize] = React.useState<number>(5)
  const [page, setPage] = React.useState<number>(1)

  const todosRef = React.useRef(todos)
  React.useEffect(() => {
    todosRef.current = todos
  }, [todos])
  React.useEffect(() => {
    return () => {
      for (const t of todosRef.current) revokeTodoAttachments(t)
    }
  }, [])

  // Keep "now" fresh so overdue/in-progress states stay accurate without user interaction.
  React.useEffect(() => {
    const id = window.setInterval(() => setNowMs(Date.now()), 30_000)
    return () => window.clearInterval(id)
  }, [])

  // Only one task can be "In Progress"; auto-clear if completed, deleted, or overdue.
  React.useEffect(() => {
    if (!inProgressTaskId) return
    const t = todos.find((x) => x.id === inProgressTaskId)
    if (!t || t.completed) {
      setInProgressTaskId(null)
      return
    }
  }, [inProgressTaskId, nowMs, todos])

  const nextUpcoming = React.useMemo(() => {
    const upcoming = todos
      .filter((t) => !t.completed)
      .map((t) => ({ todo: t, dueMs: parseLocalDateTime(t.dueAt) }))
      .filter((x) => x.dueMs >= nowMs)
      .sort((a, b) => a.dueMs - b.dueMs)[0]
    return upcoming ?? null
  }, [nowMs, todos])

  React.useEffect(() => {
    // If "next upcoming" changed, allow reminder again (dismiss is per-task).
    if (nextUpcoming && nextUpcoming.todo.id !== dismissedReminderTaskId) return
    if (!nextUpcoming) setDismissedReminderTaskId(null)
  }, [dismissedReminderTaskId, nextUpcoming])

  const reminder = React.useMemo(() => {
    const REMINDER_WINDOW_MIN = 15
    if (!nextUpcoming) return null
    if (dismissedReminderTaskId === nextUpcoming.todo.id) return null
    const mins = minutesUntil(nextUpcoming.dueMs, nowMs)
    if (mins < 0 || mins > REMINDER_WINDOW_MIN) return null
    return { ...nextUpcoming, mins }
  }, [dismissedReminderTaskId, nextUpcoming, nowMs])

  const form = useForm<TodoFormValues>({
    resolver: zodResolver(todoSchema),
    defaultValues: { title: "", description: "", dueAt: "" },
    mode: "onSubmit",
  })

  const summary = React.useMemo(() => {
    const now = new Date()
    const todayKey = localDateKey(now)
    const tomorrow = addDays(now, 1)
    const tomorrowKey = localDateKey(tomorrow)

    const todays = todos.filter((t) => t.dueAt.startsWith(todayKey))
    const todayCompleted = todays.filter((t) => t.completed).length
    const todayPending = todays.length - todayCompleted

    const labels = [
      "00:00–04:00",
      "04:00–08:00",
      "08:00–12:00",
      "12:00–16:00",
      "16:00–20:00",
      "20:00–24:00",
    ]

    // Tomorrow: same 4-hour windows breakdown
    const tomorrowTasks = todos.filter((t) => t.dueAt.startsWith(tomorrowKey))
    const tomorrowBuckets = Array.from({ length: 6 }, () => 0) as number[]
    for (const t of tomorrowTasks) {
      const ms = parseLocalDateTime(t.dueAt)
      const hour = new Date(ms).getHours()
      const idx = Math.floor(hour / 4)
      tomorrowBuckets[idx] = (tomorrowBuckets[idx] ?? 0) + 1
    }

    // Until next week = next 7 days starting tomorrow (local), grouped into 4-hour windows.
    const rangeStart = startOfDay(tomorrow).getTime()
    const rangeEnd = addDays(startOfDay(tomorrow), 7).getTime()
    const buckets = Array.from({ length: 6 }, () => 0) as number[]

    const upcoming = todos.filter((t) => {
      const ms = parseLocalDateTime(t.dueAt)
      return ms >= rangeStart && ms < rangeEnd
    })

    for (const t of upcoming) {
      const ms = parseLocalDateTime(t.dueAt)
      const hour = new Date(ms).getHours()
      const idx = Math.floor(hour / 4)
      buckets[idx] = (buckets[idx] ?? 0) + 1
    }

    return {
      todayCompleted,
      todayPending,
      tomorrowTotal: tomorrowTasks.length,
      tomorrowBuckets: labels.map((label, i) => ({ label, count: tomorrowBuckets[i] ?? 0 })),
      upcomingTotal: upcoming.length,
      upcomingBuckets: labels.map((label, i) => ({ label, count: buckets[i] ?? 0 })),
    }
  }, [todos])

  const loadDayKey = React.useMemo(() => {
    // Prefer an explicitly selected date from filters; otherwise use today.
    if (filterMode === "exact" && filterExactDate) return filterExactDate
    if (filterFromDate && !filterToDate) return filterFromDate
    if (filterFromDate && filterToDate && filterFromDate === filterToDate) return filterFromDate
    if (!filterFromDate && filterToDate) return filterToDate
    return localDateKey(new Date(nowMs))
  }, [filterExactDate, filterFromDate, filterMode, filterToDate, nowMs])

  const dailyLoad = React.useMemo(() => {
    const dayTodos = todos.filter((t) => getDatePart(t.dueAt) === loadDayKey)
    return getDailyLoad(dayTodos)
  }, [loadDayKey, todos])

  const filteredTodos = React.useMemo(() => {
    if (focusMode) {
      const endMs = nowMs + 4 * 60 * 60 * 1000
      const withMs = todos.map((t) => ({ ...t, _dueMs: parseLocalDateTime(t.dueAt) }))
      return withMs.filter((t) => t._dueMs >= nowMs && t._dueMs <= endMs)
    }

    const withMs = todos.map((t) => ({ ...t, _dueMs: parseLocalDateTime(t.dueAt) }))
    if (filterMode === "exact") {
      // If only date is selected -> show tasks for that date.
      // If time is selected too -> match exact date+time.
      // If only time is selected -> match time-of-day across all dates.
      if (!filterExactDate && !filterExactTime) return withMs

      if (filterExactDate && !filterExactTime) {
        return withMs.filter((t) => getDatePart(t.dueAt) === filterExactDate)
      }

      if (filterExactDate && filterExactTime) {
        const exactMs = parseLocalDateTime(`${filterExactDate}T${filterExactTime}`)
        return withMs.filter((t) => t._dueMs === exactMs)
      }

      // time only
      return withMs.filter((t) => getTimePart(t.dueAt) === filterExactTime)
    }
    // between
    const hasAnyDate = Boolean(filterFromDate || filterToDate)
    const hasAnyTime = Boolean(filterFromTime || filterToTime)

    // Date range (optional)
    const fromDateMs = filterFromDate
      ? startOfDay(parseLocalDateOnly(filterFromDate)).getTime()
      : Number.NEGATIVE_INFINITY
    const toDateMs = filterToDate
      ? endOfDay(parseLocalDateOnly(filterToDate)).getTime()
      : Number.POSITIVE_INFINITY

    // Time-of-day range (optional)
    const fromTimeMin = filterFromTime ? parseLocalTimeToMinutes(filterFromTime) : 0
    const toTimeMin = filterToTime ? parseLocalTimeToMinutes(filterToTime) : 24 * 60 - 1

    return withMs.filter((t) => {
      const ms = t._dueMs
      if (hasAnyDate && (ms < fromDateMs || ms > toDateMs)) return false

      if (hasAnyTime) {
        const time = getTimePart(t.dueAt)
        if (!time) return false
        const mins = parseLocalTimeToMinutes(time)
        // Simple (non-wrapping) range. If you want wrap-around (e.g. 22:00–02:00), tell me.
        if (mins < fromTimeMin || mins > toTimeMin) return false
      }

      // If neither date nor time selected, pass through (handled above anyway)
      return true
    })
  }, [
    todos,
    focusMode,
    nowMs,
    filterExactDate,
    filterExactTime,
    filterFromDate,
    filterFromTime,
    filterMode,
    filterToDate,
    filterToTime,
  ])

  const sortedFilteredTodos = React.useMemo(
    () =>
      filteredTodos
        .slice()
        .sort((a, b) => parseLocalDateTime(a.dueAt) - parseLocalDateTime(b.dueAt)),
    [filteredTodos]
  )

  // Clamp page when filters/pageSize change.
  React.useEffect(() => {
    const totalPages = Math.max(1, Math.ceil(sortedFilteredTodos.length / pageSize))
    setPage((p) => Math.min(Math.max(1, p), totalPages))
  }, [pageSize, sortedFilteredTodos.length])

  const totalItems = sortedFilteredTodos.length
  const totalPages = Math.max(1, Math.ceil(totalItems / pageSize))
  const showPagination = totalPages > 1

  const pageItems = React.useMemo(() => {
    const start = (page - 1) * pageSize
    return sortedFilteredTodos.slice(start, start + pageSize)
  }, [page, pageSize, sortedFilteredTodos])

  const groupedTodos = React.useMemo(() => {
    const groups: Array<{ date: string; items: typeof pageItems }> = []
    for (const t of pageItems) {
      const date = getDatePart(t.dueAt)
      const last = groups[groups.length - 1]
      if (!last || last.date !== date) groups.push({ date, items: [t] })
      else last.items.push(t)
    }
    return groups
  }, [pageItems])

  const completedCount = filteredTodos.filter((t) => t.completed).length

  function addTodo(values: TodoFormValues) {
    const conflicts = todos.filter((t) => t.dueAt === values.dueAt)
    if (conflicts.length > 0) {
      setConflictDueAt(values.dueAt)
      if (clearConflictTimerRef.current) window.clearTimeout(clearConflictTimerRef.current)
      clearConflictTimerRef.current = window.setTimeout(() => {
        setConflictDueAt(null)
      }, 8000)

      // Make sure the user can see the conflicting tasks even if they were filtered out.
      const [d, time] = values.dueAt.split("T")
      setFilterMode("exact")
      setFilterExactDate(d ?? "")
      setFilterExactTime(time ?? "")
      setPage(1)

      toast.error("Time conflict", {
        description: `You already have ${conflicts.length} task(s) scheduled at ${formatLocalDateTime(
          values.dueAt
        )}.`,
      })
    }

    setTodos((prev) => [
      {
        id: crypto.randomUUID(),
        title: values.title.trim(),
        description:
          (values.description ?? "").trim().length > 0
            ? (values.description ?? "").trim()
            : undefined,
        completed: false,
        dueAt: values.dueAt,
        attachments: [],
      },
      ...prev,
    ])
    form.reset()
  }

  function toggleTodo(id: string, completed: boolean) {
    setTodos((prev) => prev.map((t) => (t.id === id ? { ...t, completed } : t)))
    if (completed) setInProgressTaskId((cur) => (cur === id ? null : cur))
  }

  function requestAttachmentsForTodo(todoId: string) {
    setAttachTargetTodoId(todoId)
    // Let state update before opening picker (some browsers are picky).
    queueMicrotask(() => fileInputRef.current?.click())
  }

  function handleFilesPicked(e: React.ChangeEvent<HTMLInputElement>) {
    const files = Array.from(e.target.files ?? [])
    const targetId = attachTargetTodoId

    // reset input so picking the same file again triggers onChange
    e.target.value = ""
    setAttachTargetTodoId(null)

    if (!targetId || files.length === 0) return

    const attachments = files.map(makeAttachment)

    setTodos((prev) =>
      prev.map((t) =>
        t.id === targetId
          ? { ...t, attachments: [...t.attachments, ...attachments] }
          : t
      )
    )
  }

  function deleteTodo(id: string) {
    setTodos((prev) => {
      const victim = prev.find((t) => t.id === id)
      if (victim) revokeTodoAttachments(victim)
      return prev.filter((t) => t.id !== id)
    })
    setInProgressTaskId((cur) => (cur === id ? null : cur))
  }

  function clearCompleted() {
    setTodos((prev) => {
      for (const t of prev) {
        if (t.completed) revokeTodoAttachments(t)
      }
      return prev.filter((t) => !t.completed)
    })
  }

  return (
    <Card>
      <CardHeader className="flex flex-row items-center justify-between gap-4">
        <div className="space-y-1">
          <CardTitle className="text-2xl">To‑Do</CardTitle>
          <p className="text-muted-foreground text-sm">
            {completedCount}/{filteredTodos.length} completed
          </p>
        </div>
        <div className="flex items-center gap-2">
          <Button
            type="button"
            variant={focusMode ? "default" : "outline"}
            size="sm"
            onClick={() => {
              setFocusMode((v) => !v)
              setPage(1)
            }}
          >
            Focus Mode
          </Button>
          <ModeToggle />
        </div>
      </CardHeader>

      <CardContent className="space-y-6">
        <input
          ref={fileInputRef}
          type="file"
          multiple
          className="hidden"
          accept={[
            "image/*",
            "audio/*",
            "video/*",
            ".pdf",
            ".doc",
            ".docx",
            ".xls",
            ".xlsx",
            ".csv",
            ".txt",
            ".md",
            ".rtf",
          ].join(",")}
          onChange={handleFilesPicked}
        />

        {reminder && (
          <Alert className="border-primary/30 bg-primary/5">
            <Bell className="h-4 w-4" />
            <div className="flex flex-1 flex-col gap-1">
              <div className="flex flex-wrap items-center justify-between gap-2">
                <AlertTitle className="text-sm">
                  Next task starts in {reminder.mins} minute{reminder.mins === 1 ? "" : "s"}
                </AlertTitle>
                <Button
                  type="button"
                  variant="ghost"
                  size="sm"
                  onClick={() => setDismissedReminderTaskId(reminder.todo.id)}
                >
                  Dismiss
                </Button>
              </div>
              <AlertDescription className="text-sm">
                <span className="font-medium">{reminder.todo.title}</span> ·{" "}
                {formatDateTimeFromMs(reminder.dueMs)}
              </AlertDescription>
            </div>
          </Alert>
        )}

        <div className="rounded-xl border bg-card p-4">
          <div className="flex flex-wrap items-center justify-between gap-2">
            <p className="text-sm font-medium">
              Daily load{" "}
              <span className="text-muted-foreground font-normal">
                ({new Intl.DateTimeFormat(undefined, {
                  weekday: "short",
                  year: "numeric",
                  month: "short",
                  day: "2-digit",
                }).format(parseLocalDateOnly(loadDayKey))})
              </span>
            </p>
            <DailyLoadBadge load={dailyLoad.load} />
          </div>
          <p className="text-muted-foreground mt-2 text-sm">
            {dailyLoad.total} task(s) · busiest window {dailyLoad.busiestWindow} ({dailyLoad.peak})
          </p>
        </div>

        <div className="grid gap-3 sm:grid-cols-3">
          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Today’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">
              {summary.todayCompleted} completed
            </p>
            <p className="text-muted-foreground text-sm">{summary.todayPending} pending</p>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tomorrow’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">{summary.tomorrowTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.tomorrowBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tasks Until Next Week</p>
            <p className="mt-2 text-2xl font-semibold">{summary.upcomingTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.upcomingBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>
        </div>

        {focusMode && (
          <div className="flex flex-col gap-1 rounded-lg border bg-muted/20 px-3 py-2 sm:flex-row sm:items-center sm:justify-between">
            <p className="text-sm">
              <span className="font-medium">Focus Mode:</span>{" "}
              showing tasks due in the next 4 hours (until{" "}
              <span className="font-medium">
                {formatDateTimeFromMs(nowMs + 4 * 60 * 60 * 1000)}
              </span>
              )
            </p>
            <Button type="button" variant="ghost" size="sm" onClick={() => setFocusMode(false)}>
              Exit
            </Button>
          </div>
        )}

        <Form {...form}>
          <form
            onSubmit={form.handleSubmit(addTodo)}
            className="space-y-2"
            noValidate
          >
            <div className="flex flex-col gap-2 sm:flex-row">
              <FormField
                control={form.control}
                name="title"
                render={({ field }) => (
                  <FormItem className="flex-1">
                    <FormControl>
                      <Input
                        placeholder="Add a task…"
                        autoComplete="off"
                        {...field}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="dueAt"
                render={({ field }) => (
                  <FormItem className="sm:w-64">
                    <FormControl>
                      <Input type="datetime-local" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <Button type="submit">Add</Button>
            </div>
          </form>
        </Form>

        <Separator />

        <div className="space-y-3">
          <div className="flex flex-wrap items-center justify-between gap-2">
            <p className="text-sm font-medium">Filter by date & time</p>
            <div className="flex items-center gap-2">
              <Button
                type="button"
                size="sm"
                variant={filterMode === "between" ? "default" : "outline"}
                onClick={() => setFilterMode("between")}
              >
                Between
              </Button>
              <Button
                type="button"
                size="sm"
                variant={filterMode === "exact" ? "default" : "outline"}
                onClick={() => setFilterMode("exact")}
              >
                Exact
              </Button>
              <Button
                type="button"
                size="sm"
                variant="ghost"
                onClick={() => {
                  setFilterFromDate("")
                  setFilterFromTime("")
                  setFilterToDate("")
                  setFilterToTime("")
                  setFilterExactDate("")
                  setFilterExactTime("")
                }}
              >
                Clear
              </Button>
            </div>
          </div>

          {filterMode === "between" ? (
            <div className="grid gap-2 sm:grid-cols-2">
              <div className="grid gap-2 sm:grid-cols-2">
                <Input
                  type="date"
                  value={filterFromDate}
                  onChange={(e) => setFilterFromDate(e.target.value)}
                />
                <Input
                  type="time"
                  value={filterFromTime}
                  onChange={(e) => setFilterFromTime(e.target.value)}
                />
              </div>
              <div className="grid gap-2 sm:grid-cols-2">
                <Input
                  type="date"
                  value={filterToDate}
                  onChange={(e) => setFilterToDate(e.target.value)}
                />
                <Input
                  type="time"
                  value={filterToTime}
                  onChange={(e) => setFilterToTime(e.target.value)}
                />
              </div>
            </div>
          ) : (
            <div className="grid gap-2 sm:grid-cols-2">
              <Input
                type="date"
                value={filterExactDate}
                onChange={(e) => setFilterExactDate(e.target.value)}
              />
              <Input
                type="time"
                value={filterExactTime}
                onChange={(e) => setFilterExactTime(e.target.value)}
              />
            </div>
          )}
        </div>

        <Separator />

        <div className="space-y-2">
          {groupedTodos.length === 0 ? (
            <p className="text-muted-foreground text-sm">No tasks yet.</p>
          ) : (
            groupedTodos.map((group) => (
              <div key={group.date} className="space-y-2">
                <div className="flex items-center gap-3 pt-2">
                  <Separator className="flex-1" />
                  <span className="text-muted-foreground whitespace-nowrap text-xs font-medium">
                    {new Intl.DateTimeFormat(undefined, {
                      weekday: "short",
                      year: "numeric",
                      month: "short",
                      day: "2-digit",
                    }).format(parseLocalDateOnly(group.date))}
                  </span>
                  <Separator className="flex-1" />
                </div>

                {group.items.map((todo) => {
                  const flags = getTaskFlags(todo, nowMs, inProgressTaskId)

                  return (
                    <div
                      key={todo.id}
                      className={cn(
                        "rounded-lg border px-3 py-2",
                        flags.completed && "opacity-75",
                        flags.overdue &&
                          "border-destructive/40 bg-destructive/5 text-muted-foreground",
                        flags.inProgress && "border-sky-500/40 bg-sky-500/10",
                        conflictDueAt &&
                          todo.dueAt === conflictDueAt &&
                          "border-destructive/60 bg-destructive/5 ring-1 ring-destructive/30"
                      )}
                    >
                      <div className="flex items-start justify-between gap-3">
                        <label className="flex cursor-pointer items-start gap-3">
                        <Checkbox
                          checked={todo.completed}
                          onCheckedChange={(v) => {
                            const next = Boolean(v)
                            toggleTodo(todo.id, next)
                            if (next && !todo.completed) {
                              requestAttachmentsForTodo(todo.id)
                            }
                          }}
                          aria-label={`Mark "${todo.title}" as ${
                            todo.completed ? "not completed" : "completed"
                          }`}
                          className="mt-0.5"
                        />
                        <span
                          className={cn(
                            "leading-6",
                            todo.completed && "text-muted-foreground line-through"
                          )}
                        >
                          <span className="flex flex-wrap items-center gap-2">
                            <span className="block">{todo.title}</span>
                              <span className="flex flex-wrap items-center gap-2">
                                <TaskBadges {...flags} />
                              </span>
                          </span>
                          <span className="text-muted-foreground block text-xs">
                            Due: {formatLocalDateTime(todo.dueAt)}
                          </span>
                        </span>
                      </label>

                      <div className="flex items-center gap-1">
                        {!todo.completed && (
                          <Button
                            type="button"
                            variant={flags.inProgress ? "default" : "outline"}
                            size="sm"
                            onClick={() =>
                              setInProgressTaskId((cur) =>
                                cur === todo.id ? null : todo.id
                              )
                            }
                            className={cn(
                              flags.inProgress && "bg-sky-600 hover:bg-sky-600"
                            )}
                          >
                            {flags.inProgress ? (
                              <>
                                <CircleStop className="mr-1 h-4 w-4" />
                                Stop
                              </>
                            ) : (
                              <>
                                <CirclePlay className="mr-1 h-4 w-4" />
                                Start
                              </>
                            )}
                          </Button>
                        )}
                        {todo.completed && (
                          <Button
                            type="button"
                            variant="outline"
                            size="sm"
                            onClick={() => requestAttachmentsForTodo(todo.id)}
                          >
                            Add files
                          </Button>
                        )}
                        <Button
                          type="button"
                          variant="ghost"
                          size="icon"
                          aria-label={`Delete "${todo.title}"`}
                          onClick={() => deleteTodo(todo.id)}
                        >
                          <Trash2 className="h-4 w-4" />
                        </Button>
                      </div>
                    </div>

                    {todo.completed && todo.attachments.length > 0 && (
                      <div className="mt-3 space-y-2">
                        <p className="text-muted-foreground text-xs">Attachments</p>
                        <ul className="space-y-1">
                          {todo.attachments.map((a) => (
                            <li
                              key={a.id}
                              className="flex items-center justify-between gap-3 rounded-md bg-muted/30 px-2 py-1"
                            >
                              <div className="flex min-w-0 items-center gap-2">
                                <AttachmentIcon kind={a.kind} />
                                <span className="truncate text-sm">{a.name}</span>
                              </div>
                              <a
                                href={a.url}
                                download={a.name}
                                className="inline-flex items-center gap-1 text-sm font-medium underline underline-offset-4"
                              >
                                <Download className="h-4 w-4" />
                                Download
                              </a>
                            </li>
                          ))}
                        </ul>
                      </div>
                    )}
                  </div>
                  )
                })}
              </div>
            ))
          )}
        </div>

        {groupedTodos.length > 0 && (
          <div className="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
            <div className="flex items-center gap-2">
              <span className="text-muted-foreground text-sm">Items per page</span>
              <Select
                value={String(pageSize)}
                onValueChange={(v) => {
                  const next = Number(v)
                  setPageSize(next)
                  setPage(1)
                }}
              >
                <SelectTrigger className="w-[110px]">
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="5">5</SelectItem>
                  <SelectItem value="10">10</SelectItem>
                  <SelectItem value="15">15</SelectItem>
                  <SelectItem value="20">20</SelectItem>
                </SelectContent>
              </Select>
            </div>

            {showPagination && (
              <div className="flex items-center justify-between gap-3 sm:justify-end">
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={() => setPage((p) => Math.max(1, p - 1))}
                  disabled={page <= 1}
                >
                  Prev
                </Button>
                <span className="text-muted-foreground text-sm">
                  Page {page} of {totalPages}
                </span>
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={() => setPage((p) => Math.min(totalPages, p + 1))}
                  disabled={page >= totalPages}
                >
                  Next
                </Button>
              </div>
            )}
          </div>
        )}

        <div className="flex items-center justify-between gap-2">
          <Button
            type="button"
            variant="secondary"
            onClick={clearCompleted}
            disabled={completedCount === 0}
          >
            Clear completed
          </Button>
          <span className="text-muted-foreground text-sm">
            Mock data only (no backend)
          </span>
    </div>
      </CardContent>
    </Card>
  )
}

```

```typescriptreact
"use client"

import { zodResolver } from "@hookform/resolvers/zod"
import {
  AlertTriangle,
  CirclePlay,
  CircleStop,
  CalendarClock,
  CheckCircle2,
  Download,
  File,
  FileSpreadsheet,
  FileText,
  Image as ImageIcon,
  Info,
  Music,
  Bell,
  Timer,
  Trash2,
  Video,
} from "lucide-react"
import * as React from "react"
import { useForm } from "react-hook-form"
import { toast } from "sonner"
import { z } from "zod"

import { ModeToggle } from "@/components/mode-toggle"
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert"
import { Badge } from "@/components/ui/badge"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Checkbox } from "@/components/ui/checkbox"
import { Form, FormControl, FormField, FormItem, FormMessage } from "@/components/ui/form"
import { Input } from "@/components/ui/input"
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select"
import { Separator } from "@/components/ui/separator"
import { Textarea } from "@/components/ui/textarea"
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip"
import { cn } from "@/lib/utils"

type AttachmentKind =
  | "image"
  | "audio"
  | "video"
  | "pdf"
  | "spreadsheet"
  | "document"
  | "text"
  | "file"

type Attachment = {
  id: string
  name: string
  type: string
  size: number
  url: string
  kind: AttachmentKind
}

type Todo = {
  id: string
  title: string
  description?: string
  completed: boolean
  // Stored as `datetime-local` string (YYYY-MM-DDTHH:mm) in local time.
  dueAt: string
  attachments: Attachment[]
}

type TaskState = "planned" | "in_progress" | "completed" | "overdue"
type DailyLoad = "light" | "balanced" | "heavy"

const todoSchema = z.object({
  title: z
    .string()
    .trim()
    .min(1, "Title is required.")
    .max(80, "Keep it under 80 characters."),
  description: z
    .string()
    .trim()
    .max(500, "Keep it under 500 characters.")
    .optional()
    .or(z.literal("")),
  dueAt: z
    .string()
    .min(1, "Due date & time is required.")
    .regex(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}$/, "Invalid date/time."),
})

type TodoFormValues = z.infer<typeof todoSchema>

const initialTodos: Todo[] = [
  {
    id: "1",
    title: "Create a Next.js app",
    description: "Scaffold with TypeScript + Tailwind and confirm it runs locally.",
    completed: true,
    dueAt: "2026-01-16T09:00",
    attachments: [],
  },
  {
    id: "2",
    title: "Add shadcn/ui + dark theme",
    description: "Initialize shadcn, set up theme provider, and verify dark mode.",
    completed: true,
    dueAt: "2026-01-16T10:30",
    attachments: [],
  },
  {
    id: "3",
    title: "Build a mock-data to-do list",
    completed: false,
    dueAt: "2026-01-16T15:00",
    attachments: [],
  },
  {
    id: "4",
    title: "Yesterday: review requirements",
    completed: true,
    dueAt: "2026-01-15T11:15",
    attachments: [],
  },
  {
    id: "5",
    title: "Yesterday: sketch UI layout",
    completed: true,
    dueAt: "2026-01-15T17:45",
    attachments: [],
  },
  {
    id: "6",
    title: "Today: add attachments support",
    completed: false,
    dueAt: "2026-01-16T18:20",
    attachments: [],
  },
  {
    id: "7",
    title: "Tomorrow: QA the filters",
    description: "Test date-only, time-only, exact, and between behaviors.",
    completed: false,
    dueAt: "2026-01-17T08:05",
    attachments: [],
  },
  {
    id: "8",
    title: "Tomorrow: polish summary cards",
    completed: false,
    dueAt: "2026-01-17T13:30",
    attachments: [],
  },
  {
    id: "9",
    title: "Tomorrow: write small UX notes",
    completed: false,
    dueAt: "2026-01-17T20:10",
    attachments: [],
  },
  {
    id: "10",
    title: "This weekend: add more mock tasks",
    completed: false,
    dueAt: "2026-01-18T10:00",
    attachments: [],
  },
  {
    id: "11",
    title: "This weekend: check time-only filter",
    completed: false,
    dueAt: "2026-01-18T22:15",
    attachments: [],
  },
  {
    id: "12",
    title: "Next week: sync with team",
    completed: false,
    dueAt: "2026-01-19T09:30",
    attachments: [],
  },
  {
    id: "13",
    title: "Next week: test date-only filter",
    completed: false,
    dueAt: "2026-01-20T14:05",
    attachments: [],
  },
  {
    id: "14",
    title: "Next week: test exact date+time filter",
    completed: false,
    dueAt: "2026-01-21T12:00",
    attachments: [],
  },
  {
    id: "15",
    title: "Next week: attach docs to completed tasks",
    completed: false,
    dueAt: "2026-01-22T16:40",
    attachments: [],
  },
  {
    id: "16",
    title: "Next week: final review",
    completed: false,
    dueAt: "2026-01-23T11:00",
    attachments: [],
  },
]

function parseLocalDateTime(value: string): number {
  // value: "YYYY-MM-DDTHH:mm"
  const [datePart, timePart] = value.split("T")
  const [y, m, d] = datePart.split("-").map(Number)
  const [hh, mm] = timePart.split(":").map(Number)
  return new Date(y, m - 1, d, hh, mm, 0, 0).getTime()
}

function pad2(n: number) {
  return String(n).padStart(2, "0")
}

function localDateKey(d: Date) {
  return `${d.getFullYear()}-${pad2(d.getMonth() + 1)}-${pad2(d.getDate())}`
}

function addDays(date: Date, days: number) {
  const d = new Date(date)
  d.setDate(d.getDate() + days)
  return d
}

function startOfDay(date: Date) {
  return new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0, 0)
}

function endOfDay(date: Date) {
  return new Date(
    date.getFullYear(),
    date.getMonth(),
    date.getDate(),
    23,
    59,
    59,
    999
  )
}

function getDatePart(dueAt: string) {
  return dueAt.split("T")[0] ?? ""
}

function getTimePart(dueAt: string) {
  return dueAt.split("T")[1] ?? ""
}

function parseLocalDateOnly(value: string): Date {
  // value: "YYYY-MM-DD"
  const [y, m, d] = value.split("-").map(Number)
  return new Date(y, m - 1, d, 0, 0, 0, 0)
}

function parseLocalTimeToMinutes(value: string): number {
  // value: "HH:mm"
  const [hh, mm] = value.split(":").map(Number)
  return hh * 60 + mm
}

function formatLocalDateTime(value: string): string {
  const ms = parseLocalDateTime(value)
  if (!Number.isFinite(ms)) return value
  return new Intl.DateTimeFormat(undefined, {
    year: "numeric",
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  }).format(new Date(ms))
}

function formatDateTimeFromMs(ms: number): string {
  return new Intl.DateTimeFormat(undefined, {
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  }).format(new Date(ms))
}

function minutesUntil(targetMs: number, nowMs: number) {
  return Math.ceil((targetMs - nowMs) / 60_000)
}

function getTaskFlags(todo: Todo, nowMs: number, inProgressTaskId: string | null) {
  const completed = todo.completed
  const dueMs = parseLocalDateTime(todo.dueAt)
  const overdue = !completed && dueMs < nowMs
  const inProgress = !completed && inProgressTaskId === todo.id
  const planned = !completed && !overdue && !inProgress
  return { completed, overdue, inProgress, planned }
}

function getDailyLoad(todosForDay: Todo[]) {
  // 4-hour windows across the day (local).
  const labels = [
    "00:00–04:00",
    "04:00–08:00",
    "08:00–12:00",
    "12:00–16:00",
    "16:00–20:00",
    "20:00–24:00",
  ]
  const buckets = Array.from({ length: 6 }, () => 0) as number[]
  for (const t of todosForDay) {
    const ms = parseLocalDateTime(t.dueAt)
    const hour = new Date(ms).getHours()
    const idx = Math.floor(hour / 4)
    buckets[idx] = (buckets[idx] ?? 0) + 1
  }

  const total = todosForDay.length
  const peak = Math.max(0, ...buckets)
  const spread = buckets.filter((c) => c > 0).length
  const busiestIdx = buckets.findIndex((c) => c === peak)
  const busiestWindow = busiestIdx >= 0 ? labels[busiestIdx] : labels[0]

  // Heuristic: more tasks + higher concentration in one window => heavier day.
  const score = total + peak * 1.5 + Math.max(0, spread - 1) * 0.5
  const load: DailyLoad = score <= 5 ? "light" : score <= 10 ? "balanced" : "heavy"

  return { load, total, peak, spread, busiestWindow }
}

function DailyLoadBadge({ load }: { load: DailyLoad }) {
  if (load === "heavy") return <Badge variant="destructive">Heavy</Badge>
  if (load === "balanced") return <Badge variant="secondary">Balanced</Badge>
  return <Badge variant="outline">Light</Badge>
}

function TaskBadges({
  completed,
  overdue,
  inProgress,
  planned,
}: {
  completed: boolean
  overdue: boolean
  inProgress: boolean
  planned: boolean
}) {
  if (completed) {
    return (
      <Badge className="gap-1 bg-emerald-600 text-white hover:bg-emerald-600">
        <CheckCircle2 className="h-3.5 w-3.5" />
        Completed
      </Badge>
    )
  }

  return (
    <>
      {inProgress && (
        <Badge className="gap-1 bg-sky-600 text-white hover:bg-sky-600">
          <Timer className="h-3.5 w-3.5 text-white" />
          In progress
        </Badge>
      )}
      {overdue && (
        <Badge variant="destructive" className="gap-1">
          <AlertTriangle className="h-3.5 w-3.5" />
          Overdue
        </Badge>
      )}
      {planned && (
        <Badge variant="outline" className="gap-1">
          <CalendarClock className="h-3.5 w-3.5" />
          Planned
        </Badge>
      )}
    </>
  )
}

function getAttachmentKind(file: File): AttachmentKind {
  const type = (file.type || "").toLowerCase()
  const name = file.name.toLowerCase()
  const ext = name.includes(".") ? name.split(".").pop() ?? "" : ""

  if (type.startsWith("image/")) return "image"
  if (type.startsWith("audio/")) return "audio"
  if (type.startsWith("video/")) return "video"

  if (ext === "pdf") return "pdf"
  if (["xls", "xlsx", "csv"].includes(ext)) return "spreadsheet"
  if (["doc", "docx"].includes(ext)) return "document"
  if (["txt", "md", "rtf"].includes(ext)) return "text"

  return "file"
}

function makeAttachment(file: File): Attachment {
  return {
    id: crypto.randomUUID(),
    name: file.name,
    type: file.type,
    size: file.size,
    url: URL.createObjectURL(file),
    kind: getAttachmentKind(file),
  }
}

function revokeTodoAttachments(todo: Todo) {
  for (const a of todo.attachments) URL.revokeObjectURL(a.url)
}

function AttachmentIcon({ kind }: { kind: AttachmentKind }) {
  const className = "h-4 w-4 text-muted-foreground"

  switch (kind) {
    case "image":
      return <ImageIcon className={className} />
    case "audio":
      return <Music className={className} />
    case "video":
      return <Video className={className} />
    case "spreadsheet":
      return <FileSpreadsheet className={className} />
    case "pdf":
    case "document":
    case "text":
      return <FileText className={className} />
    default:
      return <File className={className} />
  }
}

export default function Home() {
  return (
    <div className="mx-auto flex min-h-screen max-w-2xl flex-col gap-6 px-4 py-10">
      <TodoApp />
    </div>
  )
}

function TodoApp() {
  const [todos, setTodos] = React.useState<Todo[]>(initialTodos)
  const [attachTargetTodoId, setAttachTargetTodoId] = React.useState<string | null>(
    null
  )
  const [conflictDueAt, setConflictDueAt] = React.useState<string | null>(null)
  const clearConflictTimerRef = React.useRef<number | null>(null)
  const [focusMode, setFocusMode] = React.useState(false)
  const [nowMs, setNowMs] = React.useState(() => Date.now())
  const [inProgressTaskId, setInProgressTaskId] = React.useState<string | null>(null)
  const [dismissedReminderTaskId, setDismissedReminderTaskId] = React.useState<
    string | null
  >(null)
  const [filterMode, setFilterMode] = React.useState<"between" | "exact">("between")
  const [filterFromDate, setFilterFromDate] = React.useState<string>("")
  const [filterFromTime, setFilterFromTime] = React.useState<string>("")
  const [filterToDate, setFilterToDate] = React.useState<string>("")
  const [filterToTime, setFilterToTime] = React.useState<string>("")
  const [filterExactDate, setFilterExactDate] = React.useState<string>("")
  const [filterExactTime, setFilterExactTime] = React.useState<string>("")
  const fileInputRef = React.useRef<HTMLInputElement>(null)
  const [pageSize, setPageSize] = React.useState<number>(5)
  const [page, setPage] = React.useState<number>(1)

  const todosRef = React.useRef(todos)
  React.useEffect(() => {
    todosRef.current = todos
  }, [todos])
  React.useEffect(() => {
    return () => {
      for (const t of todosRef.current) revokeTodoAttachments(t)
    }
  }, [])

  // Keep "now" fresh so overdue/in-progress states stay accurate without user interaction.
  React.useEffect(() => {
    const id = window.setInterval(() => setNowMs(Date.now()), 30_000)
    return () => window.clearInterval(id)
  }, [])

  // Only one task can be "In Progress"; auto-clear if completed, deleted, or overdue.
  React.useEffect(() => {
    if (!inProgressTaskId) return
    const t = todos.find((x) => x.id === inProgressTaskId)
    if (!t || t.completed) {
      setInProgressTaskId(null)
      return
    }
  }, [inProgressTaskId, nowMs, todos])

  const nextUpcoming = React.useMemo(() => {
    const upcoming = todos
      .filter((t) => !t.completed)
      .map((t) => ({ todo: t, dueMs: parseLocalDateTime(t.dueAt) }))
      .filter((x) => x.dueMs >= nowMs)
      .sort((a, b) => a.dueMs - b.dueMs)[0]
    return upcoming ?? null
  }, [nowMs, todos])

  React.useEffect(() => {
    // If "next upcoming" changed, allow reminder again (dismiss is per-task).
    if (nextUpcoming && nextUpcoming.todo.id !== dismissedReminderTaskId) return
    if (!nextUpcoming) setDismissedReminderTaskId(null)
  }, [dismissedReminderTaskId, nextUpcoming])

  const reminder = React.useMemo(() => {
    const REMINDER_WINDOW_MIN = 15
    if (!nextUpcoming) return null
    if (dismissedReminderTaskId === nextUpcoming.todo.id) return null
    const mins = minutesUntil(nextUpcoming.dueMs, nowMs)
    if (mins < 0 || mins > REMINDER_WINDOW_MIN) return null
    return { ...nextUpcoming, mins }
  }, [dismissedReminderTaskId, nextUpcoming, nowMs])

  const form = useForm<TodoFormValues>({
    resolver: zodResolver(todoSchema),
    defaultValues: { title: "", description: "", dueAt: "" },
    mode: "onSubmit",
  })

  const summary = React.useMemo(() => {
    const now = new Date()
    const todayKey = localDateKey(now)
    const tomorrow = addDays(now, 1)
    const tomorrowKey = localDateKey(tomorrow)

    const todays = todos.filter((t) => t.dueAt.startsWith(todayKey))
    const todayCompleted = todays.filter((t) => t.completed).length
    const todayPending = todays.length - todayCompleted

    const labels = [
      "00:00–04:00",
      "04:00–08:00",
      "08:00–12:00",
      "12:00–16:00",
      "16:00–20:00",
      "20:00–24:00",
    ]

    // Tomorrow: same 4-hour windows breakdown
    const tomorrowTasks = todos.filter((t) => t.dueAt.startsWith(tomorrowKey))
    const tomorrowBuckets = Array.from({ length: 6 }, () => 0) as number[]
    for (const t of tomorrowTasks) {
      const ms = parseLocalDateTime(t.dueAt)
      const hour = new Date(ms).getHours()
      const idx = Math.floor(hour / 4)
      tomorrowBuckets[idx] = (tomorrowBuckets[idx] ?? 0) + 1
    }

    // Until next week = next 7 days starting tomorrow (local), grouped into 4-hour windows.
    const rangeStart = startOfDay(tomorrow).getTime()
    const rangeEnd = addDays(startOfDay(tomorrow), 7).getTime()
    const buckets = Array.from({ length: 6 }, () => 0) as number[]

    const upcoming = todos.filter((t) => {
      const ms = parseLocalDateTime(t.dueAt)
      return ms >= rangeStart && ms < rangeEnd
    })

    for (const t of upcoming) {
      const ms = parseLocalDateTime(t.dueAt)
      const hour = new Date(ms).getHours()
      const idx = Math.floor(hour / 4)
      buckets[idx] = (buckets[idx] ?? 0) + 1
    }

    return {
      todayCompleted,
      todayPending,
      tomorrowTotal: tomorrowTasks.length,
      tomorrowBuckets: labels.map((label, i) => ({ label, count: tomorrowBuckets[i] ?? 0 })),
      upcomingTotal: upcoming.length,
      upcomingBuckets: labels.map((label, i) => ({ label, count: buckets[i] ?? 0 })),
    }
  }, [todos])

  const loadDayKey = React.useMemo(() => {
    // Prefer an explicitly selected date from filters; otherwise use today.
    if (filterMode === "exact" && filterExactDate) return filterExactDate
    if (filterFromDate && !filterToDate) return filterFromDate
    if (filterFromDate && filterToDate && filterFromDate === filterToDate) return filterFromDate
    if (!filterFromDate && filterToDate) return filterToDate
    return localDateKey(new Date(nowMs))
  }, [filterExactDate, filterFromDate, filterMode, filterToDate, nowMs])

  const dailyLoad = React.useMemo(() => {
    const dayTodos = todos.filter((t) => getDatePart(t.dueAt) === loadDayKey)
    return getDailyLoad(dayTodos)
  }, [loadDayKey, todos])

  const filteredTodos = React.useMemo(() => {
    if (focusMode) {
      const endMs = nowMs + 4 * 60 * 60 * 1000
      const withMs = todos.map((t) => ({ ...t, _dueMs: parseLocalDateTime(t.dueAt) }))
      return withMs.filter((t) => t._dueMs >= nowMs && t._dueMs <= endMs)
    }

    const withMs = todos.map((t) => ({ ...t, _dueMs: parseLocalDateTime(t.dueAt) }))
    if (filterMode === "exact") {
      // If only date is selected -> show tasks for that date.
      // If time is selected too -> match exact date+time.
      // If only time is selected -> match time-of-day across all dates.
      if (!filterExactDate && !filterExactTime) return withMs

      if (filterExactDate && !filterExactTime) {
        return withMs.filter((t) => getDatePart(t.dueAt) === filterExactDate)
      }

      if (filterExactDate && filterExactTime) {
        const exactMs = parseLocalDateTime(`${filterExactDate}T${filterExactTime}`)
        return withMs.filter((t) => t._dueMs === exactMs)
      }

      // time only
      return withMs.filter((t) => getTimePart(t.dueAt) === filterExactTime)
    }
    // between
    const hasAnyDate = Boolean(filterFromDate || filterToDate)
    const hasAnyTime = Boolean(filterFromTime || filterToTime)

    // Date range (optional)
    const fromDateMs = filterFromDate
      ? startOfDay(parseLocalDateOnly(filterFromDate)).getTime()
      : Number.NEGATIVE_INFINITY
    const toDateMs = filterToDate
      ? endOfDay(parseLocalDateOnly(filterToDate)).getTime()
      : Number.POSITIVE_INFINITY

    // Time-of-day range (optional)
    const fromTimeMin = filterFromTime ? parseLocalTimeToMinutes(filterFromTime) : 0
    const toTimeMin = filterToTime ? parseLocalTimeToMinutes(filterToTime) : 24 * 60 - 1

    return withMs.filter((t) => {
      const ms = t._dueMs
      if (hasAnyDate && (ms < fromDateMs || ms > toDateMs)) return false

      if (hasAnyTime) {
        const time = getTimePart(t.dueAt)
        if (!time) return false
        const mins = parseLocalTimeToMinutes(time)
        // Simple (non-wrapping) range. If you want wrap-around (e.g. 22:00–02:00), tell me.
        if (mins < fromTimeMin || mins > toTimeMin) return false
      }

      // If neither date nor time selected, pass through (handled above anyway)
      return true
    })
  }, [
    todos,
    focusMode,
    nowMs,
    filterExactDate,
    filterExactTime,
    filterFromDate,
    filterFromTime,
    filterMode,
    filterToDate,
    filterToTime,
  ])

  const sortedFilteredTodos = React.useMemo(
    () =>
      filteredTodos
        .slice()
        .sort((a, b) => parseLocalDateTime(a.dueAt) - parseLocalDateTime(b.dueAt)),
    [filteredTodos]
  )

  // Clamp page when filters/pageSize change.
  React.useEffect(() => {
    const totalPages = Math.max(1, Math.ceil(sortedFilteredTodos.length / pageSize))
    setPage((p) => Math.min(Math.max(1, p), totalPages))
  }, [pageSize, sortedFilteredTodos.length])

  const totalItems = sortedFilteredTodos.length
  const totalPages = Math.max(1, Math.ceil(totalItems / pageSize))
  const showPagination = totalPages > 1

  const pageItems = React.useMemo(() => {
    const start = (page - 1) * pageSize
    return sortedFilteredTodos.slice(start, start + pageSize)
  }, [page, pageSize, sortedFilteredTodos])

  const groupedTodos = React.useMemo(() => {
    const groups: Array<{ date: string; items: typeof pageItems }> = []
    for (const t of pageItems) {
      const date = getDatePart(t.dueAt)
      const last = groups[groups.length - 1]
      if (!last || last.date !== date) groups.push({ date, items: [t] })
      else last.items.push(t)
    }
    return groups
  }, [pageItems])

  const completedCount = filteredTodos.filter((t) => t.completed).length

  function addTodo(values: TodoFormValues) {
    const conflicts = todos.filter((t) => t.dueAt === values.dueAt)
    if (conflicts.length > 0) {
      setConflictDueAt(values.dueAt)
      if (clearConflictTimerRef.current) window.clearTimeout(clearConflictTimerRef.current)
      clearConflictTimerRef.current = window.setTimeout(() => {
        setConflictDueAt(null)
      }, 8000)

      // Make sure the user can see the conflicting tasks even if they were filtered out.
      const [d, time] = values.dueAt.split("T")
      setFilterMode("exact")
      setFilterExactDate(d ?? "")
      setFilterExactTime(time ?? "")
      setPage(1)

      toast.error("Time conflict", {
        description: `You already have ${conflicts.length} task(s) scheduled at ${formatLocalDateTime(
          values.dueAt
        )}.`,
      })
    }

    setTodos((prev) => [
      {
        id: crypto.randomUUID(),
        title: values.title.trim(),
        description:
          (values.description ?? "").trim().length > 0
            ? (values.description ?? "").trim()
            : undefined,
        completed: false,
        dueAt: values.dueAt,
        attachments: [],
      },
      ...prev,
    ])
    form.reset()
  }

  function toggleTodo(id: string, completed: boolean) {
    setTodos((prev) => prev.map((t) => (t.id === id ? { ...t, completed } : t)))
    if (completed) setInProgressTaskId((cur) => (cur === id ? null : cur))
  }

  function requestAttachmentsForTodo(todoId: string) {
    setAttachTargetTodoId(todoId)
    // Let state update before opening picker (some browsers are picky).
    queueMicrotask(() => fileInputRef.current?.click())
  }

  function handleFilesPicked(e: React.ChangeEvent<HTMLInputElement>) {
    const files = Array.from(e.target.files ?? [])
    const targetId = attachTargetTodoId

    // reset input so picking the same file again triggers onChange
    e.target.value = ""
    setAttachTargetTodoId(null)

    if (!targetId || files.length === 0) return

    const attachments = files.map(makeAttachment)

    setTodos((prev) =>
      prev.map((t) =>
        t.id === targetId
          ? { ...t, attachments: [...t.attachments, ...attachments] }
          : t
      )
    )
  }

  function deleteTodo(id: string) {
    setTodos((prev) => {
      const victim = prev.find((t) => t.id === id)
      if (victim) revokeTodoAttachments(victim)
      return prev.filter((t) => t.id !== id)
    })
    setInProgressTaskId((cur) => (cur === id ? null : cur))
  }

  function clearCompleted() {
    setTodos((prev) => {
      for (const t of prev) {
        if (t.completed) revokeTodoAttachments(t)
      }
      return prev.filter((t) => !t.completed)
    })
  }

  return (
    <Card>
      <CardHeader className="flex flex-row items-center justify-between gap-4">
        <div className="space-y-1">
          <CardTitle className="text-2xl">To‑Do</CardTitle>
          <p className="text-muted-foreground text-sm">
            {completedCount}/{filteredTodos.length} completed
          </p>
        </div>
        <div className="flex items-center gap-2">
          <Button
            type="button"
            variant={focusMode ? "default" : "outline"}
            size="sm"
            onClick={() => {
              setFocusMode((v) => !v)
              setPage(1)
            }}
          >
            Focus Mode
          </Button>
          <ModeToggle />
        </div>
      </CardHeader>

      <CardContent className="space-y-6">
        <input
          ref={fileInputRef}
          type="file"
          multiple
          className="hidden"
          accept={[
            "image/*",
            "audio/*",
            "video/*",
            ".pdf",
            ".doc",
            ".docx",
            ".xls",
            ".xlsx",
            ".csv",
            ".txt",
            ".md",
            ".rtf",
          ].join(",")}
          onChange={handleFilesPicked}
        />

        {reminder && (
          <Alert className="border-primary/30 bg-primary/5">
            <Bell className="h-4 w-4" />
            <div className="flex flex-1 flex-col gap-1">
              <div className="flex flex-wrap items-center justify-between gap-2">
                <AlertTitle className="text-sm">
                  Next task starts in {reminder.mins} minute{reminder.mins === 1 ? "" : "s"}
                </AlertTitle>
                <Button
                  type="button"
                  variant="ghost"
                  size="sm"
                  onClick={() => setDismissedReminderTaskId(reminder.todo.id)}
                >
                  Dismiss
                </Button>
              </div>
              <AlertDescription className="text-sm">
                <span className="font-medium">{reminder.todo.title}</span> ·{" "}
                {formatDateTimeFromMs(reminder.dueMs)}
              </AlertDescription>
            </div>
          </Alert>
        )}

        <div className="rounded-xl border bg-card p-4">
          <div className="flex flex-wrap items-center justify-between gap-2">
            <p className="text-sm font-medium">
              Daily load{" "}
              <span className="text-muted-foreground font-normal">
                ({new Intl.DateTimeFormat(undefined, {
                  weekday: "short",
                  year: "numeric",
                  month: "short",
                  day: "2-digit",
                }).format(parseLocalDateOnly(loadDayKey))})
              </span>
            </p>
            <DailyLoadBadge load={dailyLoad.load} />
          </div>
          <p className="text-muted-foreground mt-2 text-sm">
            {dailyLoad.total} task(s) · busiest window {dailyLoad.busiestWindow} ({dailyLoad.peak})
          </p>
        </div>

        <div className="grid gap-3 sm:grid-cols-3">
          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Today’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">
              {summary.todayCompleted} completed
            </p>
            <p className="text-muted-foreground text-sm">{summary.todayPending} pending</p>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tomorrow’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">{summary.tomorrowTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.tomorrowBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tasks Until Next Week</p>
            <p className="mt-2 text-2xl font-semibold">{summary.upcomingTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.upcomingBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>
        </div>

        {focusMode && (
          <div className="flex flex-col gap-1 rounded-lg border bg-muted/20 px-3 py-2 sm:flex-row sm:items-center sm:justify-between">
            <p className="text-sm">
              <span className="font-medium">Focus Mode:</span>{" "}
              showing tasks due in the next 4 hours (until{" "}
              <span className="font-medium">
                {formatDateTimeFromMs(nowMs + 4 * 60 * 60 * 1000)}
              </span>
              )
            </p>
            <Button type="button" variant="ghost" size="sm" onClick={() => setFocusMode(false)}>
              Exit
            </Button>
          </div>
        )}

        <Form {...form}>
          <form
            onSubmit={form.handleSubmit(addTodo)}
            className="space-y-2"
            noValidate
          >
            <div className="flex flex-col gap-2 sm:flex-row">
              <FormField
                control={form.control}
                name="title"
                render={({ field }) => (
                  <FormItem className="flex-1">
                    <FormControl>
                      <Input
                        placeholder="Add a task…"
                        autoComplete="off"
                        {...field}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="dueAt"
                render={({ field }) => (
                  <FormItem className="sm:w-64">
                    <FormControl>
                      <Input type="datetime-local" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <Button type="submit">Add</Button>
            </div>

            <FormField
              control={form.control}
              name="description"
              render={({ field }) => (
                <FormItem>
                  <FormControl>
                    <Textarea
                      rows={3}
                      placeholder="Description (optional)…"
                      {...field}
                    />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />
          </form>
        </Form>

        <Separator />

        <div className="space-y-3">
          <div className="flex flex-wrap items-center justify-between gap-2">
            <p className="text-sm font-medium">Filter by date & time</p>
            <div className="flex items-center gap-2">
              <Button
                type="button"
                size="sm"
                variant={filterMode === "between" ? "default" : "outline"}
                onClick={() => setFilterMode("between")}
              >
                Between
              </Button>
              <Button
                type="button"
                size="sm"
                variant={filterMode === "exact" ? "default" : "outline"}
                onClick={() => setFilterMode("exact")}
              >
                Exact
              </Button>
              <Button
                type="button"
                size="sm"
                variant="ghost"
                onClick={() => {
                  setFilterFromDate("")
                  setFilterFromTime("")
                  setFilterToDate("")
                  setFilterToTime("")
                  setFilterExactDate("")
                  setFilterExactTime("")
                }}
              >
                Clear
              </Button>
            </div>
          </div>

          {filterMode === "between" ? (
            <div className="grid gap-2 sm:grid-cols-2">
              <div className="grid gap-2 sm:grid-cols-2">
                <Input
                  type="date"
                  value={filterFromDate}
                  onChange={(e) => setFilterFromDate(e.target.value)}
                />
                <Input
                  type="time"
                  value={filterFromTime}
                  onChange={(e) => setFilterFromTime(e.target.value)}
                />
              </div>
              <div className="grid gap-2 sm:grid-cols-2">
                <Input
                  type="date"
                  value={filterToDate}
                  onChange={(e) => setFilterToDate(e.target.value)}
                />
                <Input
                  type="time"
                  value={filterToTime}
                  onChange={(e) => setFilterToTime(e.target.value)}
                />
              </div>
            </div>
          ) : (
            <div className="grid gap-2 sm:grid-cols-2">
              <Input
                type="date"
                value={filterExactDate}
                onChange={(e) => setFilterExactDate(e.target.value)}
              />
              <Input
                type="time"
                value={filterExactTime}
                onChange={(e) => setFilterExactTime(e.target.value)}
              />
            </div>
          )}
        </div>

        <Separator />

        <div className="space-y-2">
          {groupedTodos.length === 0 ? (
            <p className="text-muted-foreground text-sm">No tasks yet.</p>
          ) : (
            groupedTodos.map((group) => (
              <div key={group.date} className="space-y-2">
                <div className="flex items-center gap-3 pt-2">
                  <Separator className="flex-1" />
                  <span className="text-muted-foreground whitespace-nowrap text-xs font-medium">
                    {new Intl.DateTimeFormat(undefined, {
                      weekday: "short",
                      year: "numeric",
                      month: "short",
                      day: "2-digit",
                    }).format(parseLocalDateOnly(group.date))}
                  </span>
                  <Separator className="flex-1" />
                </div>

                {group.items.map((todo) => {
                  const flags = getTaskFlags(todo, nowMs, inProgressTaskId)

                  return (
                    <div
                      key={todo.id}
                      className={cn(
                        "rounded-lg border px-3 py-2",
                        flags.completed && "opacity-75",
                        flags.overdue &&
                          "border-destructive/40 bg-destructive/5 text-muted-foreground",
                        flags.inProgress && "border-sky-500/40 bg-sky-500/10",
                        conflictDueAt &&
                          todo.dueAt === conflictDueAt &&
                          "border-destructive/60 bg-destructive/5 ring-1 ring-destructive/30"
                      )}
                    >
                      <div className="flex items-start justify-between gap-3">
                        <label className="flex cursor-pointer items-start gap-3">
                        <Checkbox
                          checked={todo.completed}
                          onCheckedChange={(v) => {
                            const next = Boolean(v)
                            toggleTodo(todo.id, next)
                            if (next && !todo.completed) {
                              requestAttachmentsForTodo(todo.id)
                            }
                          }}
                          aria-label={`Mark "${todo.title}" as ${
                            todo.completed ? "not completed" : "completed"
                          }`}
                          className="mt-0.5"
                        />
                        <span
                          className={cn(
                            "leading-6",
                            todo.completed && "text-muted-foreground line-through"
                          )}
                        >
                          <span className="flex flex-wrap items-center gap-2">
                            <span className="block">{todo.title}</span>
                              <span className="flex flex-wrap items-center gap-2">
                                <TaskBadges {...flags} />
                              </span>
                          </span>
                          <span className="text-muted-foreground block text-xs">
                            Due: {formatLocalDateTime(todo.dueAt)}
                          </span>
                        </span>
                      </label>

                      <div className="flex items-center gap-1">
                        {!todo.completed && (
                          <Button
                            type="button"
                            variant={flags.inProgress ? "default" : "outline"}
                            size="sm"
                            onClick={() =>
                              setInProgressTaskId((cur) =>
                                cur === todo.id ? null : todo.id
                              )
                            }
                            className={cn(
                              flags.inProgress && "bg-sky-600 hover:bg-sky-600"
                            )}
                          >
                            {flags.inProgress ? (
                              <>
                                <CircleStop className="mr-1 h-4 w-4" />
                                Stop
                              </>
                            ) : (
                              <>
                                <CirclePlay className="mr-1 h-4 w-4" />
                                Start
                              </>
                            )}
                          </Button>
                        )}
                        {todo.completed && (
                          <Button
                            type="button"
                            variant="outline"
                            size="sm"
                            onClick={() => requestAttachmentsForTodo(todo.id)}
                          >
                            Add files
                          </Button>
                        )}
                        <Button
                          type="button"
                          variant="ghost"
                          size="icon"
                          aria-label={`Delete "${todo.title}"`}
                          onClick={() => deleteTodo(todo.id)}
                        >
                          <Trash2 className="h-4 w-4" />
                        </Button>
                      </div>
                    </div>

                    {todo.completed && todo.attachments.length > 0 && (
                      <div className="mt-3 space-y-2">
                        <p className="text-muted-foreground text-xs">Attachments</p>
                        <ul className="space-y-1">
                          {todo.attachments.map((a) => (
                            <li
                              key={a.id}
                              className="flex items-center justify-between gap-3 rounded-md bg-muted/30 px-2 py-1"
                            >
                              <div className="flex min-w-0 items-center gap-2">
                                <AttachmentIcon kind={a.kind} />
                                <span className="truncate text-sm">{a.name}</span>
                              </div>
                              <a
                                href={a.url}
                                download={a.name}
                                className="inline-flex items-center gap-1 text-sm font-medium underline underline-offset-4"
                              >
                                <Download className="h-4 w-4" />
                                Download
                              </a>
                            </li>
                          ))}
                        </ul>
                      </div>
                    )}
                  </div>
                  )
                })}
              </div>
            ))
          )}
        </div>

        {groupedTodos.length > 0 && (
          <div className="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
            <div className="flex items-center gap-2">
              <span className="text-muted-foreground text-sm">Items per page</span>
              <Select
                value={String(pageSize)}
                onValueChange={(v) => {
                  const next = Number(v)
                  setPageSize(next)
                  setPage(1)
                }}
              >
                <SelectTrigger className="w-[110px]">
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="5">5</SelectItem>
                  <SelectItem value="10">10</SelectItem>
                  <SelectItem value="15">15</SelectItem>
                  <SelectItem value="20">20</SelectItem>
                </SelectContent>
              </Select>
            </div>

            {showPagination && (
              <div className="flex items-center justify-between gap-3 sm:justify-end">
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={() => setPage((p) => Math.max(1, p - 1))}
                  disabled={page <= 1}
                >
                  Prev
                </Button>
                <span className="text-muted-foreground text-sm">
                  Page {page} of {totalPages}
                </span>
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={() => setPage((p) => Math.min(totalPages, p + 1))}
                  disabled={page >= totalPages}
                >
                  Next
                </Button>
              </div>
            )}
          </div>
        )}

        <div className="flex items-center justify-between gap-2">
          <Button
            type="button"
            variant="secondary"
            onClick={clearCompleted}
            disabled={completedCount === 0}
          >
            Clear completed
          </Button>
          <span className="text-muted-foreground text-sm">
            Mock data only (no backend)
          </span>
    </div>
      </CardContent>
    </Card>
  )
}

```

```typescriptreact
"use client"

import { zodResolver } from "@hookform/resolvers/zod"
import {
  AlertTriangle,
  CirclePlay,
  CircleStop,
  CalendarClock,
  CheckCircle2,
  Download,
  File,
  FileSpreadsheet,
  FileText,
  Image as ImageIcon,
  Info,
  Music,
  Bell,
  Timer,
  Trash2,
  Video,
} from "lucide-react"
import * as React from "react"
import { useForm } from "react-hook-form"
import { toast } from "sonner"
import { z } from "zod"

import { ModeToggle } from "@/components/mode-toggle"
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert"
import { Badge } from "@/components/ui/badge"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Checkbox } from "@/components/ui/checkbox"
import { Form, FormControl, FormField, FormItem, FormMessage } from "@/components/ui/form"
import { Input } from "@/components/ui/input"
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select"
import { Separator } from "@/components/ui/separator"
import { Textarea } from "@/components/ui/textarea"
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip"
import { cn } from "@/lib/utils"

type AttachmentKind =
  | "image"
  | "audio"
  | "video"
  | "pdf"
  | "spreadsheet"
  | "document"
  | "text"
  | "file"

type Attachment = {
  id: string
  name: string
  type: string
  size: number
  url: string
  kind: AttachmentKind
}

type Todo = {
  id: string
  title: string
  description?: string
  completed: boolean
  // Stored as `datetime-local` string (YYYY-MM-DDTHH:mm) in local time.
  dueAt: string
  attachments: Attachment[]
}

type TaskState = "planned" | "in_progress" | "completed" | "overdue"
type DailyLoad = "light" | "balanced" | "heavy"

const todoSchema = z.object({
  title: z
    .string()
    .trim()
    .min(1, "Title is required.")
    .max(80, "Keep it under 80 characters."),
  description: z
    .string()
    .trim()
    .max(500, "Keep it under 500 characters.")
    .optional()
    .or(z.literal("")),
  dueAt: z
    .string()
    .min(1, "Due date & time is required.")
    .regex(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}$/, "Invalid date/time."),
})

type TodoFormValues = z.infer<typeof todoSchema>

const initialTodos: Todo[] = [
  {
    id: "1",
    title: "Create a Next.js app",
    description: "Scaffold with TypeScript + Tailwind and confirm it runs locally.",
    completed: true,
    dueAt: "2026-01-16T09:00",
    attachments: [],
  },
  {
    id: "2",
    title: "Add shadcn/ui + dark theme",
    description: "Initialize shadcn, set up theme provider, and verify dark mode.",
    completed: true,
    dueAt: "2026-01-16T10:30",
    attachments: [],
  },
  {
    id: "3",
    title: "Build a mock-data to-do list",
    completed: false,
    dueAt: "2026-01-16T15:00",
    attachments: [],
  },
  {
    id: "4",
    title: "Yesterday: review requirements",
    completed: true,
    dueAt: "2026-01-15T11:15",
    attachments: [],
  },
  {
    id: "5",
    title: "Yesterday: sketch UI layout",
    completed: true,
    dueAt: "2026-01-15T17:45",
    attachments: [],
  },
  {
    id: "6",
    title: "Today: add attachments support",
    completed: false,
    dueAt: "2026-01-16T18:20",
    attachments: [],
  },
  {
    id: "7",
    title: "Tomorrow: QA the filters",
    description: "Test date-only, time-only, exact, and between behaviors.",
    completed: false,
    dueAt: "2026-01-17T08:05",
    attachments: [],
  },
  {
    id: "8",
    title: "Tomorrow: polish summary cards",
    completed: false,
    dueAt: "2026-01-17T13:30",
    attachments: [],
  },
  {
    id: "9",
    title: "Tomorrow: write small UX notes",
    completed: false,
    dueAt: "2026-01-17T20:10",
    attachments: [],
  },
  {
    id: "10",
    title: "This weekend: add more mock tasks",
    completed: false,
    dueAt: "2026-01-18T10:00",
    attachments: [],
  },
  {
    id: "11",
    title: "This weekend: check time-only filter",
    completed: false,
    dueAt: "2026-01-18T22:15",
    attachments: [],
  },
  {
    id: "12",
    title: "Next week: sync with team",
    completed: false,
    dueAt: "2026-01-19T09:30",
    attachments: [],
  },
  {
    id: "13",
    title: "Next week: test date-only filter",
    completed: false,
    dueAt: "2026-01-20T14:05",
    attachments: [],
  },
  {
    id: "14",
    title: "Next week: test exact date+time filter",
    completed: false,
    dueAt: "2026-01-21T12:00",
    attachments: [],
  },
  {
    id: "15",
    title: "Next week: attach docs to completed tasks",
    completed: false,
    dueAt: "2026-01-22T16:40",
    attachments: [],
  },
  {
    id: "16",
    title: "Next week: final review",
    completed: false,
    dueAt: "2026-01-23T11:00",
    attachments: [],
  },
]

function parseLocalDateTime(value: string): number {
  // value: "YYYY-MM-DDTHH:mm"
  const [datePart, timePart] = value.split("T")
  const [y, m, d] = datePart.split("-").map(Number)
  const [hh, mm] = timePart.split(":").map(Number)
  return new Date(y, m - 1, d, hh, mm, 0, 0).getTime()
}

function pad2(n: number) {
  return String(n).padStart(2, "0")
}

function localDateKey(d: Date) {
  return `${d.getFullYear()}-${pad2(d.getMonth() + 1)}-${pad2(d.getDate())}`
}

function addDays(date: Date, days: number) {
  const d = new Date(date)
  d.setDate(d.getDate() + days)
  return d
}

function startOfDay(date: Date) {
  return new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0, 0)
}

function endOfDay(date: Date) {
  return new Date(
    date.getFullYear(),
    date.getMonth(),
    date.getDate(),
    23,
    59,
    59,
    999
  )
}

function getDatePart(dueAt: string) {
  return dueAt.split("T")[0] ?? ""
}

function getTimePart(dueAt: string) {
  return dueAt.split("T")[1] ?? ""
}

function parseLocalDateOnly(value: string): Date {
  // value: "YYYY-MM-DD"
  const [y, m, d] = value.split("-").map(Number)
  return new Date(y, m - 1, d, 0, 0, 0, 0)
}

function parseLocalTimeToMinutes(value: string): number {
  // value: "HH:mm"
  const [hh, mm] = value.split(":").map(Number)
  return hh * 60 + mm
}

function formatLocalDateTime(value: string): string {
  const ms = parseLocalDateTime(value)
  if (!Number.isFinite(ms)) return value
  return new Intl.DateTimeFormat(undefined, {
    year: "numeric",
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  }).format(new Date(ms))
}

function formatDateTimeFromMs(ms: number): string {
  return new Intl.DateTimeFormat(undefined, {
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  }).format(new Date(ms))
}

function minutesUntil(targetMs: number, nowMs: number) {
  return Math.ceil((targetMs - nowMs) / 60_000)
}

function getTaskFlags(todo: Todo, nowMs: number, inProgressTaskId: string | null) {
  const completed = todo.completed
  const dueMs = parseLocalDateTime(todo.dueAt)
  const overdue = !completed && dueMs < nowMs
  const inProgress = !completed && inProgressTaskId === todo.id
  const planned = !completed && !overdue && !inProgress
  return { completed, overdue, inProgress, planned }
}

function getDailyLoad(todosForDay: Todo[]) {
  // 4-hour windows across the day (local).
  const labels = [
    "00:00–04:00",
    "04:00–08:00",
    "08:00–12:00",
    "12:00–16:00",
    "16:00–20:00",
    "20:00–24:00",
  ]
  const buckets = Array.from({ length: 6 }, () => 0) as number[]
  for (const t of todosForDay) {
    const ms = parseLocalDateTime(t.dueAt)
    const hour = new Date(ms).getHours()
    const idx = Math.floor(hour / 4)
    buckets[idx] = (buckets[idx] ?? 0) + 1
  }

  const total = todosForDay.length
  const peak = Math.max(0, ...buckets)
  const spread = buckets.filter((c) => c > 0).length
  const busiestIdx = buckets.findIndex((c) => c === peak)
  const busiestWindow = busiestIdx >= 0 ? labels[busiestIdx] : labels[0]

  // Heuristic: more tasks + higher concentration in one window => heavier day.
  const score = total + peak * 1.5 + Math.max(0, spread - 1) * 0.5
  const load: DailyLoad = score <= 5 ? "light" : score <= 10 ? "balanced" : "heavy"

  return { load, total, peak, spread, busiestWindow }
}

function DailyLoadBadge({ load }: { load: DailyLoad }) {
  if (load === "heavy") return <Badge variant="destructive">Heavy</Badge>
  if (load === "balanced") return <Badge variant="secondary">Balanced</Badge>
  return <Badge variant="outline">Light</Badge>
}

function TaskBadges({
  completed,
  overdue,
  inProgress,
  planned,
}: {
  completed: boolean
  overdue: boolean
  inProgress: boolean
  planned: boolean
}) {
  if (completed) {
    return (
      <Badge className="gap-1 bg-emerald-600 text-white hover:bg-emerald-600">
        <CheckCircle2 className="h-3.5 w-3.5" />
        Completed
      </Badge>
    )
  }

  return (
    <>
      {inProgress && (
        <Badge className="gap-1 bg-sky-600 text-white hover:bg-sky-600">
          <Timer className="h-3.5 w-3.5 text-white" />
          In progress
        </Badge>
      )}
      {overdue && (
        <Badge variant="destructive" className="gap-1">
          <AlertTriangle className="h-3.5 w-3.5" />
          Overdue
        </Badge>
      )}
      {planned && (
        <Badge variant="outline" className="gap-1">
          <CalendarClock className="h-3.5 w-3.5" />
          Planned
        </Badge>
      )}
    </>
  )
}

function getAttachmentKind(file: File): AttachmentKind {
  const type = (file.type || "").toLowerCase()
  const name = file.name.toLowerCase()
  const ext = name.includes(".") ? name.split(".").pop() ?? "" : ""

  if (type.startsWith("image/")) return "image"
  if (type.startsWith("audio/")) return "audio"
  if (type.startsWith("video/")) return "video"

  if (ext === "pdf") return "pdf"
  if (["xls", "xlsx", "csv"].includes(ext)) return "spreadsheet"
  if (["doc", "docx"].includes(ext)) return "document"
  if (["txt", "md", "rtf"].includes(ext)) return "text"

  return "file"
}

function makeAttachment(file: File): Attachment {
  return {
    id: crypto.randomUUID(),
    name: file.name,
    type: file.type,
    size: file.size,
    url: URL.createObjectURL(file),
    kind: getAttachmentKind(file),
  }
}

function revokeTodoAttachments(todo: Todo) {
  for (const a of todo.attachments) URL.revokeObjectURL(a.url)
}

function AttachmentIcon({ kind }: { kind: AttachmentKind }) {
  const className = "h-4 w-4 text-muted-foreground"

  switch (kind) {
    case "image":
      return <ImageIcon className={className} />
    case "audio":
      return <Music className={className} />
    case "video":
      return <Video className={className} />
    case "spreadsheet":
      return <FileSpreadsheet className={className} />
    case "pdf":
    case "document":
    case "text":
      return <FileText className={className} />
    default:
      return <File className={className} />
  }
}

export default function Home() {
  return (
    <div className="mx-auto flex min-h-screen max-w-2xl flex-col gap-6 px-4 py-10">
      <TodoApp />
    </div>
  )
}

function TodoApp() {
  const [todos, setTodos] = React.useState<Todo[]>(initialTodos)
  const [attachTargetTodoId, setAttachTargetTodoId] = React.useState<string | null>(
    null
  )
  const [conflictDueAt, setConflictDueAt] = React.useState<string | null>(null)
  const clearConflictTimerRef = React.useRef<number | null>(null)
  const [focusMode, setFocusMode] = React.useState(false)
  const [nowMs, setNowMs] = React.useState(() => Date.now())
  const [inProgressTaskId, setInProgressTaskId] = React.useState<string | null>(null)
  const [dismissedReminderTaskId, setDismissedReminderTaskId] = React.useState<
    string | null
  >(null)
  const [filterMode, setFilterMode] = React.useState<"between" | "exact">("between")
  const [filterFromDate, setFilterFromDate] = React.useState<string>("")
  const [filterFromTime, setFilterFromTime] = React.useState<string>("")
  const [filterToDate, setFilterToDate] = React.useState<string>("")
  const [filterToTime, setFilterToTime] = React.useState<string>("")
  const [filterExactDate, setFilterExactDate] = React.useState<string>("")
  const [filterExactTime, setFilterExactTime] = React.useState<string>("")
  const fileInputRef = React.useRef<HTMLInputElement>(null)
  const [pageSize, setPageSize] = React.useState<number>(5)
  const [page, setPage] = React.useState<number>(1)

  const todosRef = React.useRef(todos)
  React.useEffect(() => {
    todosRef.current = todos
  }, [todos])
  React.useEffect(() => {
    return () => {
      for (const t of todosRef.current) revokeTodoAttachments(t)
    }
  }, [])

  // Keep "now" fresh so overdue/in-progress states stay accurate without user interaction.
  React.useEffect(() => {
    const id = window.setInterval(() => setNowMs(Date.now()), 30_000)
    return () => window.clearInterval(id)
  }, [])

  // Only one task can be "In Progress"; auto-clear if completed, deleted, or overdue.
  React.useEffect(() => {
    if (!inProgressTaskId) return
    const t = todos.find((x) => x.id === inProgressTaskId)
    if (!t || t.completed) {
      setInProgressTaskId(null)
      return
    }
  }, [inProgressTaskId, nowMs, todos])

  const nextUpcoming = React.useMemo(() => {
    const upcoming = todos
      .filter((t) => !t.completed)
      .map((t) => ({ todo: t, dueMs: parseLocalDateTime(t.dueAt) }))
      .filter((x) => x.dueMs >= nowMs)
      .sort((a, b) => a.dueMs - b.dueMs)[0]
    return upcoming ?? null
  }, [nowMs, todos])

  React.useEffect(() => {
    // If "next upcoming" changed, allow reminder again (dismiss is per-task).
    if (nextUpcoming && nextUpcoming.todo.id !== dismissedReminderTaskId) return
    if (!nextUpcoming) setDismissedReminderTaskId(null)
  }, [dismissedReminderTaskId, nextUpcoming])

  const reminder = React.useMemo(() => {
    const REMINDER_WINDOW_MIN = 15
    if (!nextUpcoming) return null
    if (dismissedReminderTaskId === nextUpcoming.todo.id) return null
    const mins = minutesUntil(nextUpcoming.dueMs, nowMs)
    if (mins < 0 || mins > REMINDER_WINDOW_MIN) return null
    return { ...nextUpcoming, mins }
  }, [dismissedReminderTaskId, nextUpcoming, nowMs])

  const form = useForm<TodoFormValues>({
    resolver: zodResolver(todoSchema),
    defaultValues: { title: "", description: "", dueAt: "" },
    mode: "onSubmit",
  })

  const summary = React.useMemo(() => {
    const now = new Date()
    const todayKey = localDateKey(now)
    const tomorrow = addDays(now, 1)
    const tomorrowKey = localDateKey(tomorrow)

    const todays = todos.filter((t) => t.dueAt.startsWith(todayKey))
    const todayCompleted = todays.filter((t) => t.completed).length
    const todayPending = todays.length - todayCompleted

    const labels = [
      "00:00–04:00",
      "04:00–08:00",
      "08:00–12:00",
      "12:00–16:00",
      "16:00–20:00",
      "20:00–24:00",
    ]

    // Tomorrow: same 4-hour windows breakdown
    const tomorrowTasks = todos.filter((t) => t.dueAt.startsWith(tomorrowKey))
    const tomorrowBuckets = Array.from({ length: 6 }, () => 0) as number[]
    for (const t of tomorrowTasks) {
      const ms = parseLocalDateTime(t.dueAt)
      const hour = new Date(ms).getHours()
      const idx = Math.floor(hour / 4)
      tomorrowBuckets[idx] = (tomorrowBuckets[idx] ?? 0) + 1
    }

    // Until next week = next 7 days starting tomorrow (local), grouped into 4-hour windows.
    const rangeStart = startOfDay(tomorrow).getTime()
    const rangeEnd = addDays(startOfDay(tomorrow), 7).getTime()
    const buckets = Array.from({ length: 6 }, () => 0) as number[]

    const upcoming = todos.filter((t) => {
      const ms = parseLocalDateTime(t.dueAt)
      return ms >= rangeStart && ms < rangeEnd
    })

    for (const t of upcoming) {
      const ms = parseLocalDateTime(t.dueAt)
      const hour = new Date(ms).getHours()
      const idx = Math.floor(hour / 4)
      buckets[idx] = (buckets[idx] ?? 0) + 1
    }

    return {
      todayCompleted,
      todayPending,
      tomorrowTotal: tomorrowTasks.length,
      tomorrowBuckets: labels.map((label, i) => ({ label, count: tomorrowBuckets[i] ?? 0 })),
      upcomingTotal: upcoming.length,
      upcomingBuckets: labels.map((label, i) => ({ label, count: buckets[i] ?? 0 })),
    }
  }, [todos])

  const loadDayKey = React.useMemo(() => {
    // Prefer an explicitly selected date from filters; otherwise use today.
    if (filterMode === "exact" && filterExactDate) return filterExactDate
    if (filterFromDate && !filterToDate) return filterFromDate
    if (filterFromDate && filterToDate && filterFromDate === filterToDate) return filterFromDate
    if (!filterFromDate && filterToDate) return filterToDate
    return localDateKey(new Date(nowMs))
  }, [filterExactDate, filterFromDate, filterMode, filterToDate, nowMs])

  const dailyLoad = React.useMemo(() => {
    const dayTodos = todos.filter((t) => getDatePart(t.dueAt) === loadDayKey)
    return getDailyLoad(dayTodos)
  }, [loadDayKey, todos])

  const filteredTodos = React.useMemo(() => {
    if (focusMode) {
      const endMs = nowMs + 4 * 60 * 60 * 1000
      const withMs = todos.map((t) => ({ ...t, _dueMs: parseLocalDateTime(t.dueAt) }))
      return withMs.filter((t) => t._dueMs >= nowMs && t._dueMs <= endMs)
    }

    const withMs = todos.map((t) => ({ ...t, _dueMs: parseLocalDateTime(t.dueAt) }))
    if (filterMode === "exact") {
      // If only date is selected -> show tasks for that date.
      // If time is selected too -> match exact date+time.
      // If only time is selected -> match time-of-day across all dates.
      if (!filterExactDate && !filterExactTime) return withMs

      if (filterExactDate && !filterExactTime) {
        return withMs.filter((t) => getDatePart(t.dueAt) === filterExactDate)
      }

      if (filterExactDate && filterExactTime) {
        const exactMs = parseLocalDateTime(`${filterExactDate}T${filterExactTime}`)
        return withMs.filter((t) => t._dueMs === exactMs)
      }

      // time only
      return withMs.filter((t) => getTimePart(t.dueAt) === filterExactTime)
    }
    // between
    const hasAnyDate = Boolean(filterFromDate || filterToDate)
    const hasAnyTime = Boolean(filterFromTime || filterToTime)

    // Date range (optional)
    const fromDateMs = filterFromDate
      ? startOfDay(parseLocalDateOnly(filterFromDate)).getTime()
      : Number.NEGATIVE_INFINITY
    const toDateMs = filterToDate
      ? endOfDay(parseLocalDateOnly(filterToDate)).getTime()
      : Number.POSITIVE_INFINITY

    // Time-of-day range (optional)
    const fromTimeMin = filterFromTime ? parseLocalTimeToMinutes(filterFromTime) : 0
    const toTimeMin = filterToTime ? parseLocalTimeToMinutes(filterToTime) : 24 * 60 - 1

    return withMs.filter((t) => {
      const ms = t._dueMs
      if (hasAnyDate && (ms < fromDateMs || ms > toDateMs)) return false

      if (hasAnyTime) {
        const time = getTimePart(t.dueAt)
        if (!time) return false
        const mins = parseLocalTimeToMinutes(time)
        // Simple (non-wrapping) range. If you want wrap-around (e.g. 22:00–02:00), tell me.
        if (mins < fromTimeMin || mins > toTimeMin) return false
      }

      // If neither date nor time selected, pass through (handled above anyway)
      return true
    })
  }, [
    todos,
    focusMode,
    nowMs,
    filterExactDate,
    filterExactTime,
    filterFromDate,
    filterFromTime,
    filterMode,
    filterToDate,
    filterToTime,
  ])

  const sortedFilteredTodos = React.useMemo(
    () =>
      filteredTodos
        .slice()
        .sort((a, b) => parseLocalDateTime(a.dueAt) - parseLocalDateTime(b.dueAt)),
    [filteredTodos]
  )

  // Clamp page when filters/pageSize change.
  React.useEffect(() => {
    const totalPages = Math.max(1, Math.ceil(sortedFilteredTodos.length / pageSize))
    setPage((p) => Math.min(Math.max(1, p), totalPages))
  }, [pageSize, sortedFilteredTodos.length])

  const totalItems = sortedFilteredTodos.length
  const totalPages = Math.max(1, Math.ceil(totalItems / pageSize))
  const showPagination = totalPages > 1

  const pageItems = React.useMemo(() => {
    const start = (page - 1) * pageSize
    return sortedFilteredTodos.slice(start, start + pageSize)
  }, [page, pageSize, sortedFilteredTodos])

  const groupedTodos = React.useMemo(() => {
    const groups: Array<{ date: string; items: typeof pageItems }> = []
    for (const t of pageItems) {
      const date = getDatePart(t.dueAt)
      const last = groups[groups.length - 1]
      if (!last || last.date !== date) groups.push({ date, items: [t] })
      else last.items.push(t)
    }
    return groups
  }, [pageItems])

  const completedCount = filteredTodos.filter((t) => t.completed).length

  function addTodo(values: TodoFormValues) {
    const conflicts = todos.filter((t) => t.dueAt === values.dueAt)
    if (conflicts.length > 0) {
      setConflictDueAt(values.dueAt)
      if (clearConflictTimerRef.current) window.clearTimeout(clearConflictTimerRef.current)
      clearConflictTimerRef.current = window.setTimeout(() => {
        setConflictDueAt(null)
      }, 8000)

      // Make sure the user can see the conflicting tasks even if they were filtered out.
      const [d, time] = values.dueAt.split("T")
      setFilterMode("exact")
      setFilterExactDate(d ?? "")
      setFilterExactTime(time ?? "")
      setPage(1)

      toast.error("Time conflict", {
        description: `You already have ${conflicts.length} task(s) scheduled at ${formatLocalDateTime(
          values.dueAt
        )}.`,
      })
    }

    setTodos((prev) => [
      {
        id: crypto.randomUUID(),
        title: values.title.trim(),
        description:
          (values.description ?? "").trim().length > 0
            ? (values.description ?? "").trim()
            : undefined,
        completed: false,
        dueAt: values.dueAt,
        attachments: [],
      },
      ...prev,
    ])
    form.reset()
  }

  function toggleTodo(id: string, completed: boolean) {
    setTodos((prev) => prev.map((t) => (t.id === id ? { ...t, completed } : t)))
    if (completed) setInProgressTaskId((cur) => (cur === id ? null : cur))
  }

  function requestAttachmentsForTodo(todoId: string) {
    setAttachTargetTodoId(todoId)
    // Let state update before opening picker (some browsers are picky).
    queueMicrotask(() => fileInputRef.current?.click())
  }

  function handleFilesPicked(e: React.ChangeEvent<HTMLInputElement>) {
    const files = Array.from(e.target.files ?? [])
    const targetId = attachTargetTodoId

    // reset input so picking the same file again triggers onChange
    e.target.value = ""
    setAttachTargetTodoId(null)

    if (!targetId || files.length === 0) return

    const attachments = files.map(makeAttachment)

    setTodos((prev) =>
      prev.map((t) =>
        t.id === targetId
          ? { ...t, attachments: [...t.attachments, ...attachments] }
          : t
      )
    )
  }

  function deleteTodo(id: string) {
    setTodos((prev) => {
      const victim = prev.find((t) => t.id === id)
      if (victim) revokeTodoAttachments(victim)
      return prev.filter((t) => t.id !== id)
    })
    setInProgressTaskId((cur) => (cur === id ? null : cur))
  }

  function clearCompleted() {
    setTodos((prev) => {
      for (const t of prev) {
        if (t.completed) revokeTodoAttachments(t)
      }
      return prev.filter((t) => !t.completed)
    })
  }

  return (
    <Card>
      <CardHeader className="flex flex-row items-center justify-between gap-4">
        <div className="space-y-1">
          <CardTitle className="text-2xl">To‑Do</CardTitle>
          <p className="text-muted-foreground text-sm">
            {completedCount}/{filteredTodos.length} completed
          </p>
        </div>
        <div className="flex items-center gap-2">
          <Button
            type="button"
            variant={focusMode ? "default" : "outline"}
            size="sm"
            onClick={() => {
              setFocusMode((v) => !v)
              setPage(1)
            }}
          >
            Focus Mode
          </Button>
          <ModeToggle />
        </div>
      </CardHeader>

      <CardContent className="space-y-6">
        <input
          ref={fileInputRef}
          type="file"
          multiple
          className="hidden"
          accept={[
            "image/*",
            "audio/*",
            "video/*",
            ".pdf",
            ".doc",
            ".docx",
            ".xls",
            ".xlsx",
            ".csv",
            ".txt",
            ".md",
            ".rtf",
          ].join(",")}
          onChange={handleFilesPicked}
        />

        {reminder && (
          <Alert className="border-primary/30 bg-primary/5">
            <Bell className="h-4 w-4" />
            <div className="flex flex-1 flex-col gap-1">
              <div className="flex flex-wrap items-center justify-between gap-2">
                <AlertTitle className="text-sm">
                  Next task starts in {reminder.mins} minute{reminder.mins === 1 ? "" : "s"}
                </AlertTitle>
                <Button
                  type="button"
                  variant="ghost"
                  size="sm"
                  onClick={() => setDismissedReminderTaskId(reminder.todo.id)}
                >
                  Dismiss
                </Button>
              </div>
              <AlertDescription className="text-sm">
                <span className="font-medium">{reminder.todo.title}</span> ·{" "}
                {formatDateTimeFromMs(reminder.dueMs)}
              </AlertDescription>
            </div>
          </Alert>
        )}

        <div className="rounded-xl border bg-card p-4">
          <div className="flex flex-wrap items-center justify-between gap-2">
            <p className="text-sm font-medium">
              Daily load{" "}
              <span className="text-muted-foreground font-normal">
                ({new Intl.DateTimeFormat(undefined, {
                  weekday: "short",
                  year: "numeric",
                  month: "short",
                  day: "2-digit",
                }).format(parseLocalDateOnly(loadDayKey))})
              </span>
            </p>
            <DailyLoadBadge load={dailyLoad.load} />
          </div>
          <p className="text-muted-foreground mt-2 text-sm">
            {dailyLoad.total} task(s) · busiest window {dailyLoad.busiestWindow} ({dailyLoad.peak})
          </p>
        </div>

        <div className="grid gap-3 sm:grid-cols-3">
          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Today’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">
              {summary.todayCompleted} completed
            </p>
            <p className="text-muted-foreground text-sm">{summary.todayPending} pending</p>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tomorrow’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">{summary.tomorrowTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.tomorrowBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tasks Until Next Week</p>
            <p className="mt-2 text-2xl font-semibold">{summary.upcomingTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.upcomingBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>
        </div>

        {focusMode && (
          <div className="flex flex-col gap-1 rounded-lg border bg-muted/20 px-3 py-2 sm:flex-row sm:items-center sm:justify-between">
            <p className="text-sm">
              <span className="font-medium">Focus Mode:</span>{" "}
              showing tasks due in the next 4 hours (until{" "}
              <span className="font-medium">
                {formatDateTimeFromMs(nowMs + 4 * 60 * 60 * 1000)}
              </span>
              )
            </p>
            <Button type="button" variant="ghost" size="sm" onClick={() => setFocusMode(false)}>
              Exit
            </Button>
          </div>
        )}

        <Form {...form}>
          <form
            onSubmit={form.handleSubmit(addTodo)}
            className="space-y-2"
            noValidate
          >
            <div className="flex flex-col gap-2 sm:flex-row">
              <FormField
                control={form.control}
                name="title"
                render={({ field }) => (
                  <FormItem className="flex-1">
                    <FormControl>
                      <Input
                        placeholder="Add a task…"
                        autoComplete="off"
                        {...field}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="dueAt"
                render={({ field }) => (
                  <FormItem className="sm:w-64">
                    <FormControl>
                      <Input type="datetime-local" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <Button type="submit">Add</Button>
            </div>

            <FormField
              control={form.control}
              name="description"
              render={({ field }) => (
                <FormItem>
                  <FormControl>
                    <Textarea
                      rows={3}
                      placeholder="Description (optional)…"
                      {...field}
                    />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />
          </form>
        </Form>

        <Separator />

        <div className="space-y-3">
          <div className="flex flex-wrap items-center justify-between gap-2">
            <p className="text-sm font-medium">Filter by date & time</p>
            <div className="flex items-center gap-2">
              <Button
                type="button"
                size="sm"
                variant={filterMode === "between" ? "default" : "outline"}
                onClick={() => setFilterMode("between")}
              >
                Between
              </Button>
              <Button
                type="button"
                size="sm"
                variant={filterMode === "exact" ? "default" : "outline"}
                onClick={() => setFilterMode("exact")}
              >
                Exact
              </Button>
              <Button
                type="button"
                size="sm"
                variant="ghost"
                onClick={() => {
                  setFilterFromDate("")
                  setFilterFromTime("")
                  setFilterToDate("")
                  setFilterToTime("")
                  setFilterExactDate("")
                  setFilterExactTime("")
                }}
              >
                Clear
              </Button>
            </div>
          </div>

          {filterMode === "between" ? (
            <div className="grid gap-2 sm:grid-cols-2">
              <div className="grid gap-2 sm:grid-cols-2">
                <Input
                  type="date"
                  value={filterFromDate}
                  onChange={(e) => setFilterFromDate(e.target.value)}
                />
                <Input
                  type="time"
                  value={filterFromTime}
                  onChange={(e) => setFilterFromTime(e.target.value)}
                />
              </div>
              <div className="grid gap-2 sm:grid-cols-2">
                <Input
                  type="date"
                  value={filterToDate}
                  onChange={(e) => setFilterToDate(e.target.value)}
                />
                <Input
                  type="time"
                  value={filterToTime}
                  onChange={(e) => setFilterToTime(e.target.value)}
                />
              </div>
            </div>
          ) : (
            <div className="grid gap-2 sm:grid-cols-2">
              <Input
                type="date"
                value={filterExactDate}
                onChange={(e) => setFilterExactDate(e.target.value)}
              />
              <Input
                type="time"
                value={filterExactTime}
                onChange={(e) => setFilterExactTime(e.target.value)}
              />
            </div>
          )}
        </div>

        <Separator />

        <div className="space-y-2">
          {groupedTodos.length === 0 ? (
            <p className="text-muted-foreground text-sm">No tasks yet.</p>
          ) : (
            groupedTodos.map((group) => (
              <div key={group.date} className="space-y-2">
                <div className="flex items-center gap-3 pt-2">
                  <Separator className="flex-1" />
                  <span className="text-muted-foreground whitespace-nowrap text-xs font-medium">
                    {new Intl.DateTimeFormat(undefined, {
                      weekday: "short",
                      year: "numeric",
                      month: "short",
                      day: "2-digit",
                    }).format(parseLocalDateOnly(group.date))}
                  </span>
                  <Separator className="flex-1" />
                </div>

                {group.items.map((todo) => {
                  const flags = getTaskFlags(todo, nowMs, inProgressTaskId)

                  return (
                    <div
                      key={todo.id}
                      className={cn(
                        "rounded-lg border px-3 py-2",
                        flags.completed && "opacity-75",
                        flags.overdue &&
                          "border-destructive/40 bg-destructive/5 text-muted-foreground",
                        flags.inProgress && "border-sky-500/40 bg-sky-500/10",
                        conflictDueAt &&
                          todo.dueAt === conflictDueAt &&
                          "border-destructive/60 bg-destructive/5 ring-1 ring-destructive/30"
                      )}
                    >
                      <div className="flex items-start justify-between gap-3">
                        <label className="flex cursor-pointer items-start gap-3">
                        <Checkbox
                          checked={todo.completed}
                          onCheckedChange={(v) => {
                            const next = Boolean(v)
                            toggleTodo(todo.id, next)
                            if (next && !todo.completed) {
                              requestAttachmentsForTodo(todo.id)
                            }
                          }}
                          aria-label={`Mark "${todo.title}" as ${
                            todo.completed ? "not completed" : "completed"
                          }`}
                          className="mt-0.5"
                        />
                        <span
                          className={cn(
                            "leading-6",
                            todo.completed && "text-muted-foreground line-through"
                          )}
                        >
                          <span className="flex flex-wrap items-center gap-2">
                            <span className="block">{todo.title}</span>
                              <span className="flex flex-wrap items-center gap-2">
                                <TaskBadges {...flags} />
                              </span>
                            {todo.description && (
                              <TooltipProvider>
                                <Tooltip>
                                  <TooltipTrigger asChild>
                                    <button
                                      type="button"
                                      className="text-muted-foreground hover:text-foreground inline-flex h-7 w-7 items-center justify-center rounded-md border bg-background"
                                      aria-label="View description"
                                    >
                                      <Info className="h-4 w-4" />
                                    </button>
                                  </TooltipTrigger>
                                  <TooltipContent className="max-w-xs">
                                    <p className="whitespace-pre-wrap text-sm">
                                      {todo.description}
                                    </p>
                                  </TooltipContent>
                                </Tooltip>
                              </TooltipProvider>
                            )}
                          </span>
                          <span className="text-muted-foreground block text-xs">
                            Due: {formatLocalDateTime(todo.dueAt)}
                          </span>
                        </span>
                      </label>

                      <div className="flex items-center gap-1">
                        {!todo.completed && (
                          <Button
                            type="button"
                            variant={flags.inProgress ? "default" : "outline"}
                            size="sm"
                            onClick={() =>
                              setInProgressTaskId((cur) =>
                                cur === todo.id ? null : todo.id
                              )
                            }
                            className={cn(
                              flags.inProgress && "bg-sky-600 hover:bg-sky-600"
                            )}
                          >
                            {flags.inProgress ? (
                              <>
                                <CircleStop className="mr-1 h-4 w-4" />
                                Stop
                              </>
                            ) : (
                              <>
                                <CirclePlay className="mr-1 h-4 w-4" />
                                Start
                              </>
                            )}
                          </Button>
                        )}
                        {todo.completed && (
                          <Button
                            type="button"
                            variant="outline"
                            size="sm"
                            onClick={() => requestAttachmentsForTodo(todo.id)}
                          >
                            Add files
                          </Button>
                        )}
                        <Button
                          type="button"
                          variant="ghost"
                          size="icon"
                          aria-label={`Delete "${todo.title}"`}
                          onClick={() => deleteTodo(todo.id)}
                        >
                          <Trash2 className="h-4 w-4" />
                        </Button>
                      </div>
                    </div>

                    {todo.completed && todo.attachments.length > 0 && (
                      <div className="mt-3 space-y-2">
                        <p className="text-muted-foreground text-xs">Attachments</p>
                        <ul className="space-y-1">
                          {todo.attachments.map((a) => (
                            <li
                              key={a.id}
                              className="flex items-center justify-between gap-3 rounded-md bg-muted/30 px-2 py-1"
                            >
                              <div className="flex min-w-0 items-center gap-2">
                                <AttachmentIcon kind={a.kind} />
                                <span className="truncate text-sm">{a.name}</span>
                              </div>
                              <a
                                href={a.url}
                                download={a.name}
                                className="inline-flex items-center gap-1 text-sm font-medium underline underline-offset-4"
                              >
                                <Download className="h-4 w-4" />
                                Download
                              </a>
                            </li>
                          ))}
                        </ul>
                      </div>
                    )}
                  </div>
                  )
                })}
              </div>
            ))
          )}
        </div>

        {groupedTodos.length > 0 && (
          <div className="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
            <div className="flex items-center gap-2">
              <span className="text-muted-foreground text-sm">Items per page</span>
              <Select
                value={String(pageSize)}
                onValueChange={(v) => {
                  const next = Number(v)
                  setPageSize(next)
                  setPage(1)
                }}
              >
                <SelectTrigger className="w-[110px]">
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="5">5</SelectItem>
                  <SelectItem value="10">10</SelectItem>
                  <SelectItem value="15">15</SelectItem>
                  <SelectItem value="20">20</SelectItem>
                </SelectContent>
              </Select>
            </div>

            {showPagination && (
              <div className="flex items-center justify-between gap-3 sm:justify-end">
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={() => setPage((p) => Math.max(1, p - 1))}
                  disabled={page <= 1}
                >
                  Prev
                </Button>
                <span className="text-muted-foreground text-sm">
                  Page {page} of {totalPages}
                </span>
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={() => setPage((p) => Math.min(totalPages, p + 1))}
                  disabled={page >= totalPages}
                >
                  Next
                </Button>
              </div>
            )}
          </div>
        )}

        <div className="flex items-center justify-between gap-2">
          <Button
            type="button"
            variant="secondary"
            onClick={clearCompleted}
            disabled={completedCount === 0}
          >
            Clear completed
          </Button>
          <span className="text-muted-foreground text-sm">
            Mock data only (no backend)
          </span>
    </div>
      </CardContent>
    </Card>
  )
}

```

### Optional description + tooltip implemented
- **Create task form** now includes an **optional description** field using a **3-row textarea** (validated with zod, max 500 chars).
- In the list, tasks that have a description show an **info icon**; on hover/click it opens a **tooltip** showing the description.

### Files updated
- **Updated**: `src/app/page.tsx`
- **New**: `src/components/ui/textarea.tsx`, `src/components/ui/tooltip.tsx`

### Run
```bash
npm run dev
```

```shellscript
npm run dev
```

---

**User**

Add a tooltip to the Focus Mode button: “Show tasks for the next 4 hours.”

---

**Cursor**

Quick change: I’ll wrap the **Focus Mode** button with a shadcn **Tooltip** so hovering/focusing shows: “Show tasks for the next 4 hours.” Then I’ll run a fast lint/build check to ensure nothing breaks.

```typescriptreact
"use client"

import { zodResolver } from "@hookform/resolvers/zod"
import {
  AlertTriangle,
  CirclePlay,
  CircleStop,
  CalendarClock,
  CheckCircle2,
  Download,
  File,
  FileSpreadsheet,
  FileText,
  Image as ImageIcon,
  Info,
  Music,
  Bell,
  Timer,
  Trash2,
  Video,
} from "lucide-react"
import * as React from "react"
import { useForm } from "react-hook-form"
import { toast } from "sonner"
import { z } from "zod"

import { ModeToggle } from "@/components/mode-toggle"
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert"
import { Badge } from "@/components/ui/badge"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Checkbox } from "@/components/ui/checkbox"
import { Form, FormControl, FormField, FormItem, FormMessage } from "@/components/ui/form"
import { Input } from "@/components/ui/input"
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select"
import { Separator } from "@/components/ui/separator"
import { Textarea } from "@/components/ui/textarea"
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip"
import { cn } from "@/lib/utils"

type AttachmentKind =
  | "image"
  | "audio"
  | "video"
  | "pdf"
  | "spreadsheet"
  | "document"
  | "text"
  | "file"

type Attachment = {
  id: string
  name: string
  type: string
  size: number
  url: string
  kind: AttachmentKind
}

type Todo = {
  id: string
  title: string
  description?: string
  completed: boolean
  // Stored as `datetime-local` string (YYYY-MM-DDTHH:mm) in local time.
  dueAt: string
  attachments: Attachment[]
}

type TaskState = "planned" | "in_progress" | "completed" | "overdue"
type DailyLoad = "light" | "balanced" | "heavy"

const todoSchema = z.object({
  title: z
    .string()
    .trim()
    .min(1, "Title is required.")
    .max(80, "Keep it under 80 characters."),
  description: z
    .string()
    .trim()
    .max(500, "Keep it under 500 characters.")
    .optional()
    .or(z.literal("")),
  dueAt: z
    .string()
    .min(1, "Due date & time is required.")
    .regex(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}$/, "Invalid date/time."),
})

type TodoFormValues = z.infer<typeof todoSchema>

const initialTodos: Todo[] = [
  {
    id: "1",
    title: "Create a Next.js app",
    description: "Scaffold with TypeScript + Tailwind and confirm it runs locally.",
    completed: true,
    dueAt: "2026-01-16T09:00",
    attachments: [],
  },
  {
    id: "2",
    title: "Add shadcn/ui + dark theme",
    description: "Initialize shadcn, set up theme provider, and verify dark mode.",
    completed: true,
    dueAt: "2026-01-16T10:30",
    attachments: [],
  },
  {
    id: "3",
    title: "Build a mock-data to-do list",
    completed: false,
    dueAt: "2026-01-16T15:00",
    attachments: [],
  },
  {
    id: "4",
    title: "Yesterday: review requirements",
    completed: true,
    dueAt: "2026-01-15T11:15",
    attachments: [],
  },
  {
    id: "5",
    title: "Yesterday: sketch UI layout",
    completed: true,
    dueAt: "2026-01-15T17:45",
    attachments: [],
  },
  {
    id: "6",
    title: "Today: add attachments support",
    completed: false,
    dueAt: "2026-01-16T18:20",
    attachments: [],
  },
  {
    id: "7",
    title: "Tomorrow: QA the filters",
    description: "Test date-only, time-only, exact, and between behaviors.",
    completed: false,
    dueAt: "2026-01-17T08:05",
    attachments: [],
  },
  {
    id: "8",
    title: "Tomorrow: polish summary cards",
    completed: false,
    dueAt: "2026-01-17T13:30",
    attachments: [],
  },
  {
    id: "9",
    title: "Tomorrow: write small UX notes",
    completed: false,
    dueAt: "2026-01-17T20:10",
    attachments: [],
  },
  {
    id: "10",
    title: "This weekend: add more mock tasks",
    completed: false,
    dueAt: "2026-01-18T10:00",
    attachments: [],
  },
  {
    id: "11",
    title: "This weekend: check time-only filter",
    completed: false,
    dueAt: "2026-01-18T22:15",
    attachments: [],
  },
  {
    id: "12",
    title: "Next week: sync with team",
    completed: false,
    dueAt: "2026-01-19T09:30",
    attachments: [],
  },
  {
    id: "13",
    title: "Next week: test date-only filter",
    completed: false,
    dueAt: "2026-01-20T14:05",
    attachments: [],
  },
  {
    id: "14",
    title: "Next week: test exact date+time filter",
    completed: false,
    dueAt: "2026-01-21T12:00",
    attachments: [],
  },
  {
    id: "15",
    title: "Next week: attach docs to completed tasks",
    completed: false,
    dueAt: "2026-01-22T16:40",
    attachments: [],
  },
  {
    id: "16",
    title: "Next week: final review",
    completed: false,
    dueAt: "2026-01-23T11:00",
    attachments: [],
  },
]

function parseLocalDateTime(value: string): number {
  // value: "YYYY-MM-DDTHH:mm"
  const [datePart, timePart] = value.split("T")
  const [y, m, d] = datePart.split("-").map(Number)
  const [hh, mm] = timePart.split(":").map(Number)
  return new Date(y, m - 1, d, hh, mm, 0, 0).getTime()
}

function pad2(n: number) {
  return String(n).padStart(2, "0")
}

function localDateKey(d: Date) {
  return `${d.getFullYear()}-${pad2(d.getMonth() + 1)}-${pad2(d.getDate())}`
}

function addDays(date: Date, days: number) {
  const d = new Date(date)
  d.setDate(d.getDate() + days)
  return d
}

function startOfDay(date: Date) {
  return new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0, 0)
}

function endOfDay(date: Date) {
  return new Date(
    date.getFullYear(),
    date.getMonth(),
    date.getDate(),
    23,
    59,
    59,
    999
  )
}

function getDatePart(dueAt: string) {
  return dueAt.split("T")[0] ?? ""
}

function getTimePart(dueAt: string) {
  return dueAt.split("T")[1] ?? ""
}

function parseLocalDateOnly(value: string): Date {
  // value: "YYYY-MM-DD"
  const [y, m, d] = value.split("-").map(Number)
  return new Date(y, m - 1, d, 0, 0, 0, 0)
}

function parseLocalTimeToMinutes(value: string): number {
  // value: "HH:mm"
  const [hh, mm] = value.split(":").map(Number)
  return hh * 60 + mm
}

function formatLocalDateTime(value: string): string {
  const ms = parseLocalDateTime(value)
  if (!Number.isFinite(ms)) return value
  return new Intl.DateTimeFormat(undefined, {
    year: "numeric",
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  }).format(new Date(ms))
}

function formatDateTimeFromMs(ms: number): string {
  return new Intl.DateTimeFormat(undefined, {
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  }).format(new Date(ms))
}

function minutesUntil(targetMs: number, nowMs: number) {
  return Math.ceil((targetMs - nowMs) / 60_000)
}

function getTaskFlags(todo: Todo, nowMs: number, inProgressTaskId: string | null) {
  const completed = todo.completed
  const dueMs = parseLocalDateTime(todo.dueAt)
  const overdue = !completed && dueMs < nowMs
  const inProgress = !completed && inProgressTaskId === todo.id
  const planned = !completed && !overdue && !inProgress
  return { completed, overdue, inProgress, planned }
}

function getDailyLoad(todosForDay: Todo[]) {
  // 4-hour windows across the day (local).
  const labels = [
    "00:00–04:00",
    "04:00–08:00",
    "08:00–12:00",
    "12:00–16:00",
    "16:00–20:00",
    "20:00–24:00",
  ]
  const buckets = Array.from({ length: 6 }, () => 0) as number[]
  for (const t of todosForDay) {
    const ms = parseLocalDateTime(t.dueAt)
    const hour = new Date(ms).getHours()
    const idx = Math.floor(hour / 4)
    buckets[idx] = (buckets[idx] ?? 0) + 1
  }

  const total = todosForDay.length
  const peak = Math.max(0, ...buckets)
  const spread = buckets.filter((c) => c > 0).length
  const busiestIdx = buckets.findIndex((c) => c === peak)
  const busiestWindow = busiestIdx >= 0 ? labels[busiestIdx] : labels[0]

  // Heuristic: more tasks + higher concentration in one window => heavier day.
  const score = total + peak * 1.5 + Math.max(0, spread - 1) * 0.5
  const load: DailyLoad = score <= 5 ? "light" : score <= 10 ? "balanced" : "heavy"

  return { load, total, peak, spread, busiestWindow }
}

function DailyLoadBadge({ load }: { load: DailyLoad }) {
  if (load === "heavy") return <Badge variant="destructive">Heavy</Badge>
  if (load === "balanced") return <Badge variant="secondary">Balanced</Badge>
  return <Badge variant="outline">Light</Badge>
}

function TaskBadges({
  completed,
  overdue,
  inProgress,
  planned,
}: {
  completed: boolean
  overdue: boolean
  inProgress: boolean
  planned: boolean
}) {
  if (completed) {
    return (
      <Badge className="gap-1 bg-emerald-600 text-white hover:bg-emerald-600">
        <CheckCircle2 className="h-3.5 w-3.5" />
        Completed
      </Badge>
    )
  }

  return (
    <>
      {inProgress && (
        <Badge className="gap-1 bg-sky-600 text-white hover:bg-sky-600">
          <Timer className="h-3.5 w-3.5 text-white" />
          In progress
        </Badge>
      )}
      {overdue && (
        <Badge variant="destructive" className="gap-1">
          <AlertTriangle className="h-3.5 w-3.5" />
          Overdue
        </Badge>
      )}
      {planned && (
        <Badge variant="outline" className="gap-1">
          <CalendarClock className="h-3.5 w-3.5" />
          Planned
        </Badge>
      )}
    </>
  )
}

function getAttachmentKind(file: File): AttachmentKind {
  const type = (file.type || "").toLowerCase()
  const name = file.name.toLowerCase()
  const ext = name.includes(".") ? name.split(".").pop() ?? "" : ""

  if (type.startsWith("image/")) return "image"
  if (type.startsWith("audio/")) return "audio"
  if (type.startsWith("video/")) return "video"

  if (ext === "pdf") return "pdf"
  if (["xls", "xlsx", "csv"].includes(ext)) return "spreadsheet"
  if (["doc", "docx"].includes(ext)) return "document"
  if (["txt", "md", "rtf"].includes(ext)) return "text"

  return "file"
}

function makeAttachment(file: File): Attachment {
  return {
    id: crypto.randomUUID(),
    name: file.name,
    type: file.type,
    size: file.size,
    url: URL.createObjectURL(file),
    kind: getAttachmentKind(file),
  }
}

function revokeTodoAttachments(todo: Todo) {
  for (const a of todo.attachments) URL.revokeObjectURL(a.url)
}

function AttachmentIcon({ kind }: { kind: AttachmentKind }) {
  const className = "h-4 w-4 text-muted-foreground"

  switch (kind) {
    case "image":
      return <ImageIcon className={className} />
    case "audio":
      return <Music className={className} />
    case "video":
      return <Video className={className} />
    case "spreadsheet":
      return <FileSpreadsheet className={className} />
    case "pdf":
    case "document":
    case "text":
      return <FileText className={className} />
    default:
      return <File className={className} />
  }
}

export default function Home() {
  return (
    <div className="mx-auto flex min-h-screen max-w-2xl flex-col gap-6 px-4 py-10">
      <TodoApp />
    </div>
  )
}

function TodoApp() {
  const [todos, setTodos] = React.useState<Todo[]>(initialTodos)
  const [attachTargetTodoId, setAttachTargetTodoId] = React.useState<string | null>(
    null
  )
  const [conflictDueAt, setConflictDueAt] = React.useState<string | null>(null)
  const clearConflictTimerRef = React.useRef<number | null>(null)
  const [focusMode, setFocusMode] = React.useState(false)
  const [nowMs, setNowMs] = React.useState(() => Date.now())
  const [inProgressTaskId, setInProgressTaskId] = React.useState<string | null>(null)
  const [dismissedReminderTaskId, setDismissedReminderTaskId] = React.useState<
    string | null
  >(null)
  const [filterMode, setFilterMode] = React.useState<"between" | "exact">("between")
  const [filterFromDate, setFilterFromDate] = React.useState<string>("")
  const [filterFromTime, setFilterFromTime] = React.useState<string>("")
  const [filterToDate, setFilterToDate] = React.useState<string>("")
  const [filterToTime, setFilterToTime] = React.useState<string>("")
  const [filterExactDate, setFilterExactDate] = React.useState<string>("")
  const [filterExactTime, setFilterExactTime] = React.useState<string>("")
  const fileInputRef = React.useRef<HTMLInputElement>(null)
  const [pageSize, setPageSize] = React.useState<number>(5)
  const [page, setPage] = React.useState<number>(1)

  const todosRef = React.useRef(todos)
  React.useEffect(() => {
    todosRef.current = todos
  }, [todos])
  React.useEffect(() => {
    return () => {
      for (const t of todosRef.current) revokeTodoAttachments(t)
    }
  }, [])

  // Keep "now" fresh so overdue/in-progress states stay accurate without user interaction.
  React.useEffect(() => {
    const id = window.setInterval(() => setNowMs(Date.now()), 30_000)
    return () => window.clearInterval(id)
  }, [])

  // Only one task can be "In Progress"; auto-clear if completed, deleted, or overdue.
  React.useEffect(() => {
    if (!inProgressTaskId) return
    const t = todos.find((x) => x.id === inProgressTaskId)
    if (!t || t.completed) {
      setInProgressTaskId(null)
      return
    }
  }, [inProgressTaskId, nowMs, todos])

  const nextUpcoming = React.useMemo(() => {
    const upcoming = todos
      .filter((t) => !t.completed)
      .map((t) => ({ todo: t, dueMs: parseLocalDateTime(t.dueAt) }))
      .filter((x) => x.dueMs >= nowMs)
      .sort((a, b) => a.dueMs - b.dueMs)[0]
    return upcoming ?? null
  }, [nowMs, todos])

  React.useEffect(() => {
    // If "next upcoming" changed, allow reminder again (dismiss is per-task).
    if (nextUpcoming && nextUpcoming.todo.id !== dismissedReminderTaskId) return
    if (!nextUpcoming) setDismissedReminderTaskId(null)
  }, [dismissedReminderTaskId, nextUpcoming])

  const reminder = React.useMemo(() => {
    const REMINDER_WINDOW_MIN = 15
    if (!nextUpcoming) return null
    if (dismissedReminderTaskId === nextUpcoming.todo.id) return null
    const mins = minutesUntil(nextUpcoming.dueMs, nowMs)
    if (mins < 0 || mins > REMINDER_WINDOW_MIN) return null
    return { ...nextUpcoming, mins }
  }, [dismissedReminderTaskId, nextUpcoming, nowMs])

  const form = useForm<TodoFormValues>({
    resolver: zodResolver(todoSchema),
    defaultValues: { title: "", description: "", dueAt: "" },
    mode: "onSubmit",
  })

  const summary = React.useMemo(() => {
    const now = new Date()
    const todayKey = localDateKey(now)
    const tomorrow = addDays(now, 1)
    const tomorrowKey = localDateKey(tomorrow)

    const todays = todos.filter((t) => t.dueAt.startsWith(todayKey))
    const todayCompleted = todays.filter((t) => t.completed).length
    const todayPending = todays.length - todayCompleted

    const labels = [
      "00:00–04:00",
      "04:00–08:00",
      "08:00–12:00",
      "12:00–16:00",
      "16:00–20:00",
      "20:00–24:00",
    ]

    // Tomorrow: same 4-hour windows breakdown
    const tomorrowTasks = todos.filter((t) => t.dueAt.startsWith(tomorrowKey))
    const tomorrowBuckets = Array.from({ length: 6 }, () => 0) as number[]
    for (const t of tomorrowTasks) {
      const ms = parseLocalDateTime(t.dueAt)
      const hour = new Date(ms).getHours()
      const idx = Math.floor(hour / 4)
      tomorrowBuckets[idx] = (tomorrowBuckets[idx] ?? 0) + 1
    }

    // Until next week = next 7 days starting tomorrow (local), grouped into 4-hour windows.
    const rangeStart = startOfDay(tomorrow).getTime()
    const rangeEnd = addDays(startOfDay(tomorrow), 7).getTime()
    const buckets = Array.from({ length: 6 }, () => 0) as number[]

    const upcoming = todos.filter((t) => {
      const ms = parseLocalDateTime(t.dueAt)
      return ms >= rangeStart && ms < rangeEnd
    })

    for (const t of upcoming) {
      const ms = parseLocalDateTime(t.dueAt)
      const hour = new Date(ms).getHours()
      const idx = Math.floor(hour / 4)
      buckets[idx] = (buckets[idx] ?? 0) + 1
    }

    return {
      todayCompleted,
      todayPending,
      tomorrowTotal: tomorrowTasks.length,
      tomorrowBuckets: labels.map((label, i) => ({ label, count: tomorrowBuckets[i] ?? 0 })),
      upcomingTotal: upcoming.length,
      upcomingBuckets: labels.map((label, i) => ({ label, count: buckets[i] ?? 0 })),
    }
  }, [todos])

  const loadDayKey = React.useMemo(() => {
    // Prefer an explicitly selected date from filters; otherwise use today.
    if (filterMode === "exact" && filterExactDate) return filterExactDate
    if (filterFromDate && !filterToDate) return filterFromDate
    if (filterFromDate && filterToDate && filterFromDate === filterToDate) return filterFromDate
    if (!filterFromDate && filterToDate) return filterToDate
    return localDateKey(new Date(nowMs))
  }, [filterExactDate, filterFromDate, filterMode, filterToDate, nowMs])

  const dailyLoad = React.useMemo(() => {
    const dayTodos = todos.filter((t) => getDatePart(t.dueAt) === loadDayKey)
    return getDailyLoad(dayTodos)
  }, [loadDayKey, todos])

  const filteredTodos = React.useMemo(() => {
    if (focusMode) {
      const endMs = nowMs + 4 * 60 * 60 * 1000
      const withMs = todos.map((t) => ({ ...t, _dueMs: parseLocalDateTime(t.dueAt) }))
      return withMs.filter((t) => t._dueMs >= nowMs && t._dueMs <= endMs)
    }

    const withMs = todos.map((t) => ({ ...t, _dueMs: parseLocalDateTime(t.dueAt) }))
    if (filterMode === "exact") {
      // If only date is selected -> show tasks for that date.
      // If time is selected too -> match exact date+time.
      // If only time is selected -> match time-of-day across all dates.
      if (!filterExactDate && !filterExactTime) return withMs

      if (filterExactDate && !filterExactTime) {
        return withMs.filter((t) => getDatePart(t.dueAt) === filterExactDate)
      }

      if (filterExactDate && filterExactTime) {
        const exactMs = parseLocalDateTime(`${filterExactDate}T${filterExactTime}`)
        return withMs.filter((t) => t._dueMs === exactMs)
      }

      // time only
      return withMs.filter((t) => getTimePart(t.dueAt) === filterExactTime)
    }
    // between
    const hasAnyDate = Boolean(filterFromDate || filterToDate)
    const hasAnyTime = Boolean(filterFromTime || filterToTime)

    // Date range (optional)
    const fromDateMs = filterFromDate
      ? startOfDay(parseLocalDateOnly(filterFromDate)).getTime()
      : Number.NEGATIVE_INFINITY
    const toDateMs = filterToDate
      ? endOfDay(parseLocalDateOnly(filterToDate)).getTime()
      : Number.POSITIVE_INFINITY

    // Time-of-day range (optional)
    const fromTimeMin = filterFromTime ? parseLocalTimeToMinutes(filterFromTime) : 0
    const toTimeMin = filterToTime ? parseLocalTimeToMinutes(filterToTime) : 24 * 60 - 1

    return withMs.filter((t) => {
      const ms = t._dueMs
      if (hasAnyDate && (ms < fromDateMs || ms > toDateMs)) return false

      if (hasAnyTime) {
        const time = getTimePart(t.dueAt)
        if (!time) return false
        const mins = parseLocalTimeToMinutes(time)
        // Simple (non-wrapping) range. If you want wrap-around (e.g. 22:00–02:00), tell me.
        if (mins < fromTimeMin || mins > toTimeMin) return false
      }

      // If neither date nor time selected, pass through (handled above anyway)
      return true
    })
  }, [
    todos,
    focusMode,
    nowMs,
    filterExactDate,
    filterExactTime,
    filterFromDate,
    filterFromTime,
    filterMode,
    filterToDate,
    filterToTime,
  ])

  const sortedFilteredTodos = React.useMemo(
    () =>
      filteredTodos
        .slice()
        .sort((a, b) => parseLocalDateTime(a.dueAt) - parseLocalDateTime(b.dueAt)),
    [filteredTodos]
  )

  // Clamp page when filters/pageSize change.
  React.useEffect(() => {
    const totalPages = Math.max(1, Math.ceil(sortedFilteredTodos.length / pageSize))
    setPage((p) => Math.min(Math.max(1, p), totalPages))
  }, [pageSize, sortedFilteredTodos.length])

  const totalItems = sortedFilteredTodos.length
  const totalPages = Math.max(1, Math.ceil(totalItems / pageSize))
  const showPagination = totalPages > 1

  const pageItems = React.useMemo(() => {
    const start = (page - 1) * pageSize
    return sortedFilteredTodos.slice(start, start + pageSize)
  }, [page, pageSize, sortedFilteredTodos])

  const groupedTodos = React.useMemo(() => {
    const groups: Array<{ date: string; items: typeof pageItems }> = []
    for (const t of pageItems) {
      const date = getDatePart(t.dueAt)
      const last = groups[groups.length - 1]
      if (!last || last.date !== date) groups.push({ date, items: [t] })
      else last.items.push(t)
    }
    return groups
  }, [pageItems])

  const completedCount = filteredTodos.filter((t) => t.completed).length

  function addTodo(values: TodoFormValues) {
    const conflicts = todos.filter((t) => t.dueAt === values.dueAt)
    if (conflicts.length > 0) {
      setConflictDueAt(values.dueAt)
      if (clearConflictTimerRef.current) window.clearTimeout(clearConflictTimerRef.current)
      clearConflictTimerRef.current = window.setTimeout(() => {
        setConflictDueAt(null)
      }, 8000)

      // Make sure the user can see the conflicting tasks even if they were filtered out.
      const [d, time] = values.dueAt.split("T")
      setFilterMode("exact")
      setFilterExactDate(d ?? "")
      setFilterExactTime(time ?? "")
      setPage(1)

      toast.error("Time conflict", {
        description: `You already have ${conflicts.length} task(s) scheduled at ${formatLocalDateTime(
          values.dueAt
        )}.`,
      })
    }

    setTodos((prev) => [
      {
        id: crypto.randomUUID(),
        title: values.title.trim(),
        description:
          (values.description ?? "").trim().length > 0
            ? (values.description ?? "").trim()
            : undefined,
        completed: false,
        dueAt: values.dueAt,
        attachments: [],
      },
      ...prev,
    ])
    form.reset()
  }

  function toggleTodo(id: string, completed: boolean) {
    setTodos((prev) => prev.map((t) => (t.id === id ? { ...t, completed } : t)))
    if (completed) setInProgressTaskId((cur) => (cur === id ? null : cur))
  }

  function requestAttachmentsForTodo(todoId: string) {
    setAttachTargetTodoId(todoId)
    // Let state update before opening picker (some browsers are picky).
    queueMicrotask(() => fileInputRef.current?.click())
  }

  function handleFilesPicked(e: React.ChangeEvent<HTMLInputElement>) {
    const files = Array.from(e.target.files ?? [])
    const targetId = attachTargetTodoId

    // reset input so picking the same file again triggers onChange
    e.target.value = ""
    setAttachTargetTodoId(null)

    if (!targetId || files.length === 0) return

    const attachments = files.map(makeAttachment)

    setTodos((prev) =>
      prev.map((t) =>
        t.id === targetId
          ? { ...t, attachments: [...t.attachments, ...attachments] }
          : t
      )
    )
  }

  function deleteTodo(id: string) {
    setTodos((prev) => {
      const victim = prev.find((t) => t.id === id)
      if (victim) revokeTodoAttachments(victim)
      return prev.filter((t) => t.id !== id)
    })
    setInProgressTaskId((cur) => (cur === id ? null : cur))
  }

  function clearCompleted() {
    setTodos((prev) => {
      for (const t of prev) {
        if (t.completed) revokeTodoAttachments(t)
      }
      return prev.filter((t) => !t.completed)
    })
  }

  return (
    <Card>
      <CardHeader className="flex flex-row items-center justify-between gap-4">
        <div className="space-y-1">
          <CardTitle className="text-2xl">To‑Do</CardTitle>
          <p className="text-muted-foreground text-sm">
            {completedCount}/{filteredTodos.length} completed
          </p>
        </div>
        <div className="flex items-center gap-2">
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <Button
                  type="button"
                  variant={focusMode ? "default" : "outline"}
                  size="sm"
                  onClick={() => {
                    setFocusMode((v) => !v)
                    setPage(1)
                  }}
                >
                  Focus Mode
                </Button>
              </TooltipTrigger>
              <TooltipContent>
                <p>Show tasks for the next 4 hours.</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
          <ModeToggle />
        </div>
      </CardHeader>

      <CardContent className="space-y-6">
        <input
          ref={fileInputRef}
          type="file"
          multiple
          className="hidden"
          accept={[
            "image/*",
            "audio/*",
            "video/*",
            ".pdf",
            ".doc",
            ".docx",
            ".xls",
            ".xlsx",
            ".csv",
            ".txt",
            ".md",
            ".rtf",
          ].join(",")}
          onChange={handleFilesPicked}
        />

        {reminder && (
          <Alert className="border-primary/30 bg-primary/5">
            <Bell className="h-4 w-4" />
            <div className="flex flex-1 flex-col gap-1">
              <div className="flex flex-wrap items-center justify-between gap-2">
                <AlertTitle className="text-sm">
                  Next task starts in {reminder.mins} minute{reminder.mins === 1 ? "" : "s"}
                </AlertTitle>
                <Button
                  type="button"
                  variant="ghost"
                  size="sm"
                  onClick={() => setDismissedReminderTaskId(reminder.todo.id)}
                >
                  Dismiss
                </Button>
              </div>
              <AlertDescription className="text-sm">
                <span className="font-medium">{reminder.todo.title}</span> ·{" "}
                {formatDateTimeFromMs(reminder.dueMs)}
              </AlertDescription>
            </div>
          </Alert>
        )}

        <div className="rounded-xl border bg-card p-4">
          <div className="flex flex-wrap items-center justify-between gap-2">
            <p className="text-sm font-medium">
              Daily load{" "}
              <span className="text-muted-foreground font-normal">
                ({new Intl.DateTimeFormat(undefined, {
                  weekday: "short",
                  year: "numeric",
                  month: "short",
                  day: "2-digit",
                }).format(parseLocalDateOnly(loadDayKey))})
              </span>
            </p>
            <DailyLoadBadge load={dailyLoad.load} />
          </div>
          <p className="text-muted-foreground mt-2 text-sm">
            {dailyLoad.total} task(s) · busiest window {dailyLoad.busiestWindow} ({dailyLoad.peak})
          </p>
        </div>

        <div className="grid gap-3 sm:grid-cols-3">
          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Today’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">
              {summary.todayCompleted} completed
            </p>
            <p className="text-muted-foreground text-sm">{summary.todayPending} pending</p>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tomorrow’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">{summary.tomorrowTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.tomorrowBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tasks Until Next Week</p>
            <p className="mt-2 text-2xl font-semibold">{summary.upcomingTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.upcomingBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>
        </div>

        {focusMode && (
          <div className="flex flex-col gap-1 rounded-lg border bg-muted/20 px-3 py-2 sm:flex-row sm:items-center sm:justify-between">
            <p className="text-sm">
              <span className="font-medium">Focus Mode:</span>{" "}
              showing tasks due in the next 4 hours (until{" "}
              <span className="font-medium">
                {formatDateTimeFromMs(nowMs + 4 * 60 * 60 * 1000)}
              </span>
              )
            </p>
            <Button type="button" variant="ghost" size="sm" onClick={() => setFocusMode(false)}>
              Exit
            </Button>
          </div>
        )}

        <Form {...form}>
          <form
            onSubmit={form.handleSubmit(addTodo)}
            className="space-y-2"
            noValidate
          >
            <div className="flex flex-col gap-2 sm:flex-row">
              <FormField
                control={form.control}
                name="title"
                render={({ field }) => (
                  <FormItem className="flex-1">
                    <FormControl>
                      <Input
                        placeholder="Add a task…"
                        autoComplete="off"
                        {...field}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="dueAt"
                render={({ field }) => (
                  <FormItem className="sm:w-64">
                    <FormControl>
                      <Input type="datetime-local" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <Button type="submit">Add</Button>
            </div>

            <FormField
              control={form.control}
              name="description"
              render={({ field }) => (
                <FormItem>
                  <FormControl>
                    <Textarea
                      rows={3}
                      placeholder="Description (optional)…"
                      {...field}
                    />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />
          </form>
        </Form>

        <Separator />

        <div className="space-y-3">
          <div className="flex flex-wrap items-center justify-between gap-2">
            <p className="text-sm font-medium">Filter by date & time</p>
            <div className="flex items-center gap-2">
              <Button
                type="button"
                size="sm"
                variant={filterMode === "between" ? "default" : "outline"}
                onClick={() => setFilterMode("between")}
              >
                Between
              </Button>
              <Button
                type="button"
                size="sm"
                variant={filterMode === "exact" ? "default" : "outline"}
                onClick={() => setFilterMode("exact")}
              >
                Exact
              </Button>
              <Button
                type="button"
                size="sm"
                variant="ghost"
                onClick={() => {
                  setFilterFromDate("")
                  setFilterFromTime("")
                  setFilterToDate("")
                  setFilterToTime("")
                  setFilterExactDate("")
                  setFilterExactTime("")
                }}
              >
                Clear
              </Button>
            </div>
          </div>

          {filterMode === "between" ? (
            <div className="grid gap-2 sm:grid-cols-2">
              <div className="grid gap-2 sm:grid-cols-2">
                <Input
                  type="date"
                  value={filterFromDate}
                  onChange={(e) => setFilterFromDate(e.target.value)}
                />
                <Input
                  type="time"
                  value={filterFromTime}
                  onChange={(e) => setFilterFromTime(e.target.value)}
                />
              </div>
              <div className="grid gap-2 sm:grid-cols-2">
                <Input
                  type="date"
                  value={filterToDate}
                  onChange={(e) => setFilterToDate(e.target.value)}
                />
                <Input
                  type="time"
                  value={filterToTime}
                  onChange={(e) => setFilterToTime(e.target.value)}
                />
              </div>
            </div>
          ) : (
            <div className="grid gap-2 sm:grid-cols-2">
              <Input
                type="date"
                value={filterExactDate}
                onChange={(e) => setFilterExactDate(e.target.value)}
              />
              <Input
                type="time"
                value={filterExactTime}
                onChange={(e) => setFilterExactTime(e.target.value)}
              />
            </div>
          )}
        </div>

        <Separator />

        <div className="space-y-2">
          {groupedTodos.length === 0 ? (
            <p className="text-muted-foreground text-sm">No tasks yet.</p>
          ) : (
            groupedTodos.map((group) => (
              <div key={group.date} className="space-y-2">
                <div className="flex items-center gap-3 pt-2">
                  <Separator className="flex-1" />
                  <span className="text-muted-foreground whitespace-nowrap text-xs font-medium">
                    {new Intl.DateTimeFormat(undefined, {
                      weekday: "short",
                      year: "numeric",
                      month: "short",
                      day: "2-digit",
                    }).format(parseLocalDateOnly(group.date))}
                  </span>
                  <Separator className="flex-1" />
                </div>

                {group.items.map((todo) => {
                  const flags = getTaskFlags(todo, nowMs, inProgressTaskId)

                  return (
                    <div
                      key={todo.id}
                      className={cn(
                        "rounded-lg border px-3 py-2",
                        flags.completed && "opacity-75",
                        flags.overdue &&
                          "border-destructive/40 bg-destructive/5 text-muted-foreground",
                        flags.inProgress && "border-sky-500/40 bg-sky-500/10",
                        conflictDueAt &&
                          todo.dueAt === conflictDueAt &&
                          "border-destructive/60 bg-destructive/5 ring-1 ring-destructive/30"
                      )}
                    >
                      <div className="flex items-start justify-between gap-3">
                        <label className="flex cursor-pointer items-start gap-3">
                        <Checkbox
                          checked={todo.completed}
                          onCheckedChange={(v) => {
                            const next = Boolean(v)
                            toggleTodo(todo.id, next)
                            if (next && !todo.completed) {
                              requestAttachmentsForTodo(todo.id)
                            }
                          }}
                          aria-label={`Mark "${todo.title}" as ${
                            todo.completed ? "not completed" : "completed"
                          }`}
                          className="mt-0.5"
                        />
                        <span
                          className={cn(
                            "leading-6",
                            todo.completed && "text-muted-foreground line-through"
                          )}
                        >
                          <span className="flex flex-wrap items-center gap-2">
                            <span className="block">{todo.title}</span>
                              <span className="flex flex-wrap items-center gap-2">
                                <TaskBadges {...flags} />
                              </span>
                            {todo.description && (
                              <TooltipProvider>
                                <Tooltip>
                                  <TooltipTrigger asChild>
                                    <button
                                      type="button"
                                      className="text-muted-foreground hover:text-foreground inline-flex h-7 w-7 items-center justify-center rounded-md border bg-background"
                                      aria-label="View description"
                                    >
                                      <Info className="h-4 w-4" />
                                    </button>
                                  </TooltipTrigger>
                                  <TooltipContent className="max-w-xs">
                                    <p className="whitespace-pre-wrap text-sm">
                                      {todo.description}
                                    </p>
                                  </TooltipContent>
                                </Tooltip>
                              </TooltipProvider>
                            )}
                          </span>
                          <span className="text-muted-foreground block text-xs">
                            Due: {formatLocalDateTime(todo.dueAt)}
                          </span>
                        </span>
                      </label>

                      <div className="flex items-center gap-1">
                        {!todo.completed && (
                          <Button
                            type="button"
                            variant={flags.inProgress ? "default" : "outline"}
                            size="sm"
                            onClick={() =>
                              setInProgressTaskId((cur) =>
                                cur === todo.id ? null : todo.id
                              )
                            }
                            className={cn(
                              flags.inProgress && "bg-sky-600 hover:bg-sky-600"
                            )}
                          >
                            {flags.inProgress ? (
                              <>
                                <CircleStop className="mr-1 h-4 w-4" />
                                Stop
                              </>
                            ) : (
                              <>
                                <CirclePlay className="mr-1 h-4 w-4" />
                                Start
                              </>
                            )}
                          </Button>
                        )}
                        {todo.completed && (
                          <Button
                            type="button"
                            variant="outline"
                            size="sm"
                            onClick={() => requestAttachmentsForTodo(todo.id)}
                          >
                            Add files
                          </Button>
                        )}
                        <Button
                          type="button"
                          variant="ghost"
                          size="icon"
                          aria-label={`Delete "${todo.title}"`}
                          onClick={() => deleteTodo(todo.id)}
                        >
                          <Trash2 className="h-4 w-4" />
                        </Button>
                      </div>
                    </div>

                    {todo.completed && todo.attachments.length > 0 && (
                      <div className="mt-3 space-y-2">
                        <p className="text-muted-foreground text-xs">Attachments</p>
                        <ul className="space-y-1">
                          {todo.attachments.map((a) => (
                            <li
                              key={a.id}
                              className="flex items-center justify-between gap-3 rounded-md bg-muted/30 px-2 py-1"
                            >
                              <div className="flex min-w-0 items-center gap-2">
                                <AttachmentIcon kind={a.kind} />
                                <span className="truncate text-sm">{a.name}</span>
                              </div>
                              <a
                                href={a.url}
                                download={a.name}
                                className="inline-flex items-center gap-1 text-sm font-medium underline underline-offset-4"
                              >
                                <Download className="h-4 w-4" />
                                Download
                              </a>
                            </li>
                          ))}
                        </ul>
                      </div>
                    )}
                  </div>
                  )
                })}
              </div>
            ))
          )}
        </div>

        {groupedTodos.length > 0 && (
          <div className="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
            <div className="flex items-center gap-2">
              <span className="text-muted-foreground text-sm">Items per page</span>
              <Select
                value={String(pageSize)}
                onValueChange={(v) => {
                  const next = Number(v)
                  setPageSize(next)
                  setPage(1)
                }}
              >
                <SelectTrigger className="w-[110px]">
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="5">5</SelectItem>
                  <SelectItem value="10">10</SelectItem>
                  <SelectItem value="15">15</SelectItem>
                  <SelectItem value="20">20</SelectItem>
                </SelectContent>
              </Select>
            </div>

            {showPagination && (
              <div className="flex items-center justify-between gap-3 sm:justify-end">
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={() => setPage((p) => Math.max(1, p - 1))}
                  disabled={page <= 1}
                >
                  Prev
                </Button>
                <span className="text-muted-foreground text-sm">
                  Page {page} of {totalPages}
                </span>
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={() => setPage((p) => Math.min(totalPages, p + 1))}
                  disabled={page >= totalPages}
                >
                  Next
                </Button>
              </div>
            )}
          </div>
        )}

        <div className="flex items-center justify-between gap-2">
          <Button
            type="button"
            variant="secondary"
            onClick={clearCompleted}
            disabled={completedCount === 0}
          >
            Clear completed
          </Button>
          <span className="text-muted-foreground text-sm">
            Mock data only (no backend)
          </span>
    </div>
      </CardContent>
    </Card>
  )
}

```

### Done
- Added a tooltip to the **Focus Mode** button: **“Show tasks for the next 4 hours.”**

### File updated
- `src/app/page.tsx`

---

**User**

Integrate Supabase as a lightweight backend for authentication and persistent task storage. Implement basic authentication, a tasks table, handle all form-related events, and add a storage bucket for file uploads with simple RLS policies.

---

**Cursor**

Plan: add Supabase client + env setup, create a basic email/password auth UI, switch tasks state to load/save from a `tasks` table, and move attachments to a Supabase Storage bucket with simple RLS. I’ll also drop a ready-to-run SQL file to create tables, policies, and the bucket.

Nice—this workspace blocks editing dotfiles, so I’ll provide the env template as a normal file (`supabase.env.example`) and a short setup doc. Next I’ll add the Supabase client helper + the SQL schema/policies, then wire auth/tasks to use it.

```plaintext
NEXT_PUBLIC_SUPABASE_URL=https://YOUR_PROJECT_REF.supabase.co
NEXT_PUBLIC_SUPABASE_ANON_KEY=YOUR_SUPABASE_ANON_KEY


```

```markdown
## Supabase setup (auth + tasks + storage)

### 1) Add env vars
Create a `.env.local` file in the project root with:

```txt
NEXT_PUBLIC_SUPABASE_URL=...
NEXT_PUBLIC_SUPABASE_ANON_KEY=...
```

You can copy from `supabase.env.example`.

### 2) Create DB tables + policies
In Supabase Dashboard:
- Go to **SQL Editor**
- Paste and run the SQL from `supabase/schema.sql`

### 3) Create the storage bucket
The SQL also creates a bucket named **`task-attachments`** and policies.


```

```typescript
"use client"

import { createClient } from "@supabase/supabase-js"

export function createBrowserSupabaseClient() {
  const url = process.env.NEXT_PUBLIC_SUPABASE_URL
  const anonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY

  if (!url || !anonKey) {
    throw new Error(
      "Missing Supabase env vars. Set NEXT_PUBLIC_SUPABASE_URL and NEXT_PUBLIC_SUPABASE_ANON_KEY."
    )
  }

  return createClient(url, anonKey)
}


```

```sql
-- Supabase schema for: auth + tasks + attachments storage
-- Run this in Supabase SQL Editor.

-- Needed for gen_random_uuid()
create extension if not exists pgcrypto;

-- Tasks table (single-table approach with attachments stored as jsonb)
create table if not exists public.tasks (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references auth.users (id) on delete cascade,
  title text not null,
  description text,
  -- Store as local datetime string: YYYY-MM-DDTHH:mm (lexicographically sortable)
  due_at text not null,
  completed boolean not null default false,
  in_progress boolean not null default false,
  attachments jsonb not null default '[]'::jsonb,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

-- Keep updated_at fresh
create or replace function public.set_updated_at()
returns trigger language plpgsql as $$
begin
  new.updated_at = now();
  return new;
end;
$$;

drop trigger if exists trg_tasks_updated_at on public.tasks;
create trigger trg_tasks_updated_at
before update on public.tasks
for each row execute function public.set_updated_at();

-- Ensure only one "in progress" per user (optional but recommended)
create unique index if not exists tasks_one_in_progress_per_user
on public.tasks (user_id)
where in_progress = true;

-- Basic due_at format check (optional)
alter table public.tasks
  drop constraint if exists tasks_due_at_format;
alter table public.tasks
  add constraint tasks_due_at_format
  check (due_at ~ '^[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}$');

-- RLS
alter table public.tasks enable row level security;

drop policy if exists "tasks_select_own" on public.tasks;
create policy "tasks_select_own"
on public.tasks for select
using (auth.uid() = user_id);

drop policy if exists "tasks_insert_own" on public.tasks;
create policy "tasks_insert_own"
on public.tasks for insert
with check (auth.uid() = user_id);

drop policy if exists "tasks_update_own" on public.tasks;
create policy "tasks_update_own"
on public.tasks for update
using (auth.uid() = user_id)
with check (auth.uid() = user_id);

drop policy if exists "tasks_delete_own" on public.tasks;
create policy "tasks_delete_own"
on public.tasks for delete
using (auth.uid() = user_id);

-- Storage bucket for attachments
-- Note: requires Supabase Storage enabled.
insert into storage.buckets (id, name, public)
values ('task-attachments', 'task-attachments', false)
on conflict (id) do nothing;

-- Storage RLS policies: allow authenticated users to manage only their own objects in this bucket.
-- Supabase sets storage.objects.owner to auth.uid() automatically on upload.
create policy "attachments_select_own"
on storage.objects for select
to authenticated
using (bucket_id = 'task-attachments' and owner = auth.uid());

create policy "attachments_insert_own"
on storage.objects for insert
to authenticated
with check (bucket_id = 'task-attachments' and owner = auth.uid());

create policy "attachments_update_own"
on storage.objects for update
to authenticated
using (bucket_id = 'task-attachments' and owner = auth.uid())
with check (bucket_id = 'task-attachments' and owner = auth.uid());

create policy "attachments_delete_own"
on storage.objects for delete
to authenticated
using (bucket_id = 'task-attachments' and owner = auth.uid());


```

```typescriptreact
"use client"

import { zodResolver } from "@hookform/resolvers/zod"
import {
  AlertTriangle,
  CirclePlay,
  CircleStop,
  CalendarClock,
  CheckCircle2,
  Download,
  File,
  FileSpreadsheet,
  FileText,
  Image as ImageIcon,
  Info,
  Music,
  Bell,
  Timer,
  Trash2,
  Video,
} from "lucide-react"
import * as React from "react"
import { useForm } from "react-hook-form"
import { toast } from "sonner"
import { z } from "zod"
import type { SupabaseClient, User } from "@supabase/supabase-js"

import { ModeToggle } from "@/components/mode-toggle"
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert"
import { Badge } from "@/components/ui/badge"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Checkbox } from "@/components/ui/checkbox"
import { Form, FormControl, FormField, FormItem, FormMessage } from "@/components/ui/form"
import { Input } from "@/components/ui/input"
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select"
import { Separator } from "@/components/ui/separator"
import { Textarea } from "@/components/ui/textarea"
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip"
import { cn } from "@/lib/utils"
import { createBrowserSupabaseClient } from "@/lib/supabase/client"

type AttachmentKind =
  | "image"
  | "audio"
  | "video"
  | "pdf"
  | "spreadsheet"
  | "document"
  | "text"
  | "file"

type Attachment = {
  id: string
  name: string
  type: string
  size: number
  bucket: string
  path: string
  kind: AttachmentKind
}

type Todo = {
  id: string
  title: string
  description?: string
  completed: boolean
  // Stored as `datetime-local` string (YYYY-MM-DDTHH:mm) in local time.
  dueAt: string
  attachments: Attachment[]
}

type TaskState = "planned" | "in_progress" | "completed" | "overdue"
type DailyLoad = "light" | "balanced" | "heavy"

const todoSchema = z.object({
  title: z
    .string()
    .trim()
    .min(1, "Title is required.")
    .max(80, "Keep it under 80 characters."),
  description: z
    .string()
    .trim()
    .max(500, "Keep it under 500 characters.")
    .optional()
    .or(z.literal("")),
  dueAt: z
    .string()
    .min(1, "Due date & time is required.")
    .regex(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}$/, "Invalid date/time."),
})

type TodoFormValues = z.infer<typeof todoSchema>

const initialTodos: Todo[] = [
  {
    id: "1",
    title: "Create a Next.js app",
    description: "Scaffold with TypeScript + Tailwind and confirm it runs locally.",
    completed: true,
    dueAt: "2026-01-16T09:00",
    attachments: [],
  },
  {
    id: "2",
    title: "Add shadcn/ui + dark theme",
    description: "Initialize shadcn, set up theme provider, and verify dark mode.",
    completed: true,
    dueAt: "2026-01-16T10:30",
    attachments: [],
  },
  {
    id: "3",
    title: "Build a mock-data to-do list",
    completed: false,
    dueAt: "2026-01-16T15:00",
    attachments: [],
  },
  {
    id: "4",
    title: "Yesterday: review requirements",
    completed: true,
    dueAt: "2026-01-15T11:15",
    attachments: [],
  },
  {
    id: "5",
    title: "Yesterday: sketch UI layout",
    completed: true,
    dueAt: "2026-01-15T17:45",
    attachments: [],
  },
  {
    id: "6",
    title: "Today: add attachments support",
    completed: false,
    dueAt: "2026-01-16T18:20",
    attachments: [],
  },
  {
    id: "7",
    title: "Tomorrow: QA the filters",
    description: "Test date-only, time-only, exact, and between behaviors.",
    completed: false,
    dueAt: "2026-01-17T08:05",
    attachments: [],
  },
  {
    id: "8",
    title: "Tomorrow: polish summary cards",
    completed: false,
    dueAt: "2026-01-17T13:30",
    attachments: [],
  },
  {
    id: "9",
    title: "Tomorrow: write small UX notes",
    completed: false,
    dueAt: "2026-01-17T20:10",
    attachments: [],
  },
  {
    id: "10",
    title: "This weekend: add more mock tasks",
    completed: false,
    dueAt: "2026-01-18T10:00",
    attachments: [],
  },
  {
    id: "11",
    title: "This weekend: check time-only filter",
    completed: false,
    dueAt: "2026-01-18T22:15",
    attachments: [],
  },
  {
    id: "12",
    title: "Next week: sync with team",
    completed: false,
    dueAt: "2026-01-19T09:30",
    attachments: [],
  },
  {
    id: "13",
    title: "Next week: test date-only filter",
    completed: false,
    dueAt: "2026-01-20T14:05",
    attachments: [],
  },
  {
    id: "14",
    title: "Next week: test exact date+time filter",
    completed: false,
    dueAt: "2026-01-21T12:00",
    attachments: [],
  },
  {
    id: "15",
    title: "Next week: attach docs to completed tasks",
    completed: false,
    dueAt: "2026-01-22T16:40",
    attachments: [],
  },
  {
    id: "16",
    title: "Next week: final review",
    completed: false,
    dueAt: "2026-01-23T11:00",
    attachments: [],
  },
]

type DbTaskRow = {
  id: string
  user_id: string
  title: string
  description: string | null
  due_at: string
  completed: boolean
  in_progress: boolean
  attachments: unknown
}

function coerceAttachments(raw: unknown): Attachment[] {
  if (!raw || typeof raw !== "object") return []
  if (!Array.isArray(raw)) return []
  return raw.filter(Boolean) as Attachment[]
}

function toDbTaskInsert(values: TodoFormValues, userId: string) {
  return {
    user_id: userId,
    title: values.title.trim(),
    description: (values.description ?? "").trim() || null,
    due_at: values.dueAt,
    completed: false,
    in_progress: false,
    attachments: [],
  }
}

function fromDbTask(row: DbTaskRow): Todo {
  return {
    id: row.id,
    title: row.title,
    description: row.description ?? undefined,
    completed: row.completed,
    dueAt: row.due_at,
    attachments: coerceAttachments(row.attachments),
  }
}

function parseLocalDateTime(value: string): number {
  // value: "YYYY-MM-DDTHH:mm"
  const [datePart, timePart] = value.split("T")
  const [y, m, d] = datePart.split("-").map(Number)
  const [hh, mm] = timePart.split(":").map(Number)
  return new Date(y, m - 1, d, hh, mm, 0, 0).getTime()
}

function pad2(n: number) {
  return String(n).padStart(2, "0")
}

function localDateKey(d: Date) {
  return `${d.getFullYear()}-${pad2(d.getMonth() + 1)}-${pad2(d.getDate())}`
}

function addDays(date: Date, days: number) {
  const d = new Date(date)
  d.setDate(d.getDate() + days)
  return d
}

function startOfDay(date: Date) {
  return new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0, 0)
}

function endOfDay(date: Date) {
  return new Date(
    date.getFullYear(),
    date.getMonth(),
    date.getDate(),
    23,
    59,
    59,
    999
  )
}

function getDatePart(dueAt: string) {
  return dueAt.split("T")[0] ?? ""
}

function getTimePart(dueAt: string) {
  return dueAt.split("T")[1] ?? ""
}

function parseLocalDateOnly(value: string): Date {
  // value: "YYYY-MM-DD"
  const [y, m, d] = value.split("-").map(Number)
  return new Date(y, m - 1, d, 0, 0, 0, 0)
}

function parseLocalTimeToMinutes(value: string): number {
  // value: "HH:mm"
  const [hh, mm] = value.split(":").map(Number)
  return hh * 60 + mm
}

function formatLocalDateTime(value: string): string {
  const ms = parseLocalDateTime(value)
  if (!Number.isFinite(ms)) return value
  return new Intl.DateTimeFormat(undefined, {
    year: "numeric",
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  }).format(new Date(ms))
}

function formatDateTimeFromMs(ms: number): string {
  return new Intl.DateTimeFormat(undefined, {
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  }).format(new Date(ms))
}

function minutesUntil(targetMs: number, nowMs: number) {
  return Math.ceil((targetMs - nowMs) / 60_000)
}

function getTaskFlags(todo: Todo, nowMs: number, inProgressTaskId: string | null) {
  const completed = todo.completed
  const dueMs = parseLocalDateTime(todo.dueAt)
  const overdue = !completed && dueMs < nowMs
  const inProgress = !completed && inProgressTaskId === todo.id
  const planned = !completed && !overdue && !inProgress
  return { completed, overdue, inProgress, planned }
}

function getDailyLoad(todosForDay: Todo[]) {
  // 4-hour windows across the day (local).
  const labels = [
    "00:00–04:00",
    "04:00–08:00",
    "08:00–12:00",
    "12:00–16:00",
    "16:00–20:00",
    "20:00–24:00",
  ]
  const buckets = Array.from({ length: 6 }, () => 0) as number[]
  for (const t of todosForDay) {
    const ms = parseLocalDateTime(t.dueAt)
    const hour = new Date(ms).getHours()
    const idx = Math.floor(hour / 4)
    buckets[idx] = (buckets[idx] ?? 0) + 1
  }

  const total = todosForDay.length
  const peak = Math.max(0, ...buckets)
  const spread = buckets.filter((c) => c > 0).length
  const busiestIdx = buckets.findIndex((c) => c === peak)
  const busiestWindow = busiestIdx >= 0 ? labels[busiestIdx] : labels[0]

  // Heuristic: more tasks + higher concentration in one window => heavier day.
  const score = total + peak * 1.5 + Math.max(0, spread - 1) * 0.5
  const load: DailyLoad = score <= 5 ? "light" : score <= 10 ? "balanced" : "heavy"

  return { load, total, peak, spread, busiestWindow }
}

function DailyLoadBadge({ load }: { load: DailyLoad }) {
  if (load === "heavy") return <Badge variant="destructive">Heavy</Badge>
  if (load === "balanced") return <Badge variant="secondary">Balanced</Badge>
  return <Badge variant="outline">Light</Badge>
}

function TaskBadges({
  completed,
  overdue,
  inProgress,
  planned,
}: {
  completed: boolean
  overdue: boolean
  inProgress: boolean
  planned: boolean
}) {
  if (completed) {
    return (
      <Badge className="gap-1 bg-emerald-600 text-white hover:bg-emerald-600">
        <CheckCircle2 className="h-3.5 w-3.5" />
        Completed
      </Badge>
    )
  }

  return (
    <>
      {inProgress && (
        <Badge className="gap-1 bg-sky-600 text-white hover:bg-sky-600">
          <Timer className="h-3.5 w-3.5 text-white" />
          In progress
        </Badge>
      )}
      {overdue && (
        <Badge variant="destructive" className="gap-1">
          <AlertTriangle className="h-3.5 w-3.5" />
          Overdue
        </Badge>
      )}
      {planned && (
        <Badge variant="outline" className="gap-1">
          <CalendarClock className="h-3.5 w-3.5" />
          Planned
        </Badge>
      )}
    </>
  )
}

function getAttachmentKind(file: File): AttachmentKind {
  const type = (file.type || "").toLowerCase()
  const name = file.name.toLowerCase()
  const ext = name.includes(".") ? name.split(".").pop() ?? "" : ""

  if (type.startsWith("image/")) return "image"
  if (type.startsWith("audio/")) return "audio"
  if (type.startsWith("video/")) return "video"

  if (ext === "pdf") return "pdf"
  if (["xls", "xlsx", "csv"].includes(ext)) return "spreadsheet"
  if (["doc", "docx"].includes(ext)) return "document"
  if (["txt", "md", "rtf"].includes(ext)) return "text"

  return "file"
}

function sanitizePathSegment(s: string) {
  return s.replace(/[^\w.\-]+/g, "_")
}

function buildAttachmentRecord(file: File, bucket: string, path: string): Attachment {
  return {
    id: crypto.randomUUID(),
    name: file.name,
    type: file.type,
    size: file.size,
    bucket,
    path,
    kind: getAttachmentKind(file),
  }
}

function AttachmentIcon({ kind }: { kind: AttachmentKind }) {
  const className = "h-4 w-4 text-muted-foreground"

  switch (kind) {
    case "image":
      return <ImageIcon className={className} />
    case "audio":
      return <Music className={className} />
    case "video":
      return <Video className={className} />
    case "spreadsheet":
      return <FileSpreadsheet className={className} />
    case "pdf":
    case "document":
    case "text":
      return <FileText className={className} />
    default:
      return <File className={className} />
  }
}

const authSchema = z.object({
  email: z.string().email("Enter a valid email."),
  password: z.string().min(6, "Password must be at least 6 characters."),
})
type AuthValues = z.infer<typeof authSchema>

function AuthCard({ supabase }: { supabase: SupabaseClient }) {
  const [mode, setMode] = React.useState<"sign_in" | "sign_up">("sign_in")
  const [busy, setBusy] = React.useState(false)

  const form = useForm<AuthValues>({
    resolver: zodResolver(authSchema),
    defaultValues: { email: "", password: "" },
  })

  async function onSubmit(values: AuthValues) {
    setBusy(true)
    try {
      if (mode === "sign_in") {
        const { error } = await supabase.auth.signInWithPassword(values)
        if (error) throw error
      } else {
        const { error } = await supabase.auth.signUp(values)
        if (error) throw error
        toast.success("Account created", { description: "You can now sign in." })
        setMode("sign_in")
      }
    } catch (e) {
      toast.error("Authentication failed", {
        description: e instanceof Error ? e.message : "Please try again.",
      })
    } finally {
      setBusy(false)
    }
  }

  return (
    <div className="mx-auto flex min-h-screen max-w-md flex-col justify-center px-4 py-10">
      <Card>
        <CardHeader>
          <CardTitle className="text-2xl">Sign in</CardTitle>
          <p className="text-muted-foreground text-sm">
            {mode === "sign_in"
              ? "Use your email and password."
              : "Create an account with email and password."}
          </p>
        </CardHeader>
        <CardContent className="space-y-4">
          <Form {...form}>
            <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-3" noValidate>
              <FormField
                control={form.control}
                name="email"
                render={({ field }) => (
                  <FormItem>
                    <FormControl>
                      <Input placeholder="Email" autoComplete="email" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="password"
                render={({ field }) => (
                  <FormItem>
                    <FormControl>
                      <Input
                        type="password"
                        placeholder="Password"
                        autoComplete={
                          mode === "sign_in" ? "current-password" : "new-password"
                        }
                        {...field}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <Button type="submit" className="w-full" disabled={busy}>
                {mode === "sign_in" ? "Sign in" : "Sign up"}
              </Button>
            </form>
          </Form>

          <div className="flex items-center justify-between gap-3 text-sm">
            <span className="text-muted-foreground">
              {mode === "sign_in" ? "No account?" : "Already have an account?"}
            </span>
            <Button
              type="button"
              variant="link"
              className="px-0"
              onClick={() => setMode((m) => (m === "sign_in" ? "sign_up" : "sign_in"))}
            >
              {mode === "sign_in" ? "Sign up" : "Sign in"}
            </Button>
          </div>
        </CardContent>
      </Card>
    </div>
  )
}

export default function Home() {
  const [supabaseError, setSupabaseError] = React.useState<string | null>(null)
  const supabase = React.useMemo(() => {
    try {
      return createBrowserSupabaseClient()
    } catch (e) {
      setSupabaseError(e instanceof Error ? e.message : "Supabase is not configured.")
      return null
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [])

  const [user, setUser] = React.useState<User | null>(null)
  const [authLoading, setAuthLoading] = React.useState(true)

  React.useEffect(() => {
    if (!supabase) return
    let alive = true
    supabase.auth.getUser().then(({ data }) => {
      if (!alive) return
      setUser(data.user ?? null)
      setAuthLoading(false)
    })
    const { data } = supabase.auth.onAuthStateChange((_event, session) => {
      setUser(session?.user ?? null)
    })
    return () => {
      alive = false
      data.subscription.unsubscribe()
    }
  }, [supabase])

  if (supabaseError) {
    return (
      <div className="mx-auto flex min-h-screen max-w-2xl flex-col justify-center gap-4 px-4 py-10">
        <Card>
          <CardHeader>
            <CardTitle>Supabase not configured</CardTitle>
          </CardHeader>
          <CardContent className="space-y-2">
            <p className="text-muted-foreground text-sm">{supabaseError}</p>
            <p className="text-muted-foreground text-sm">
              See <code>SUPABASE_SETUP.md</code> and <code>supabase.env.example</code>.
            </p>
          </CardContent>
        </Card>
      </div>
    )
  }

  if (!supabase) return null
  if (authLoading) {
    return (
      <div className="mx-auto flex min-h-screen max-w-2xl flex-col justify-center px-4 py-10">
        <p className="text-muted-foreground text-sm">Loading…</p>
      </div>
    )
  }

  if (!user) return <AuthCard supabase={supabase} />

  return (
    <div className="mx-auto flex min-h-screen max-w-2xl flex-col gap-6 px-4 py-10">
      <TodoApp supabase={supabase} user={user} />
    </div>
  )
}

function TodoApp({ supabase, user }: { supabase: SupabaseClient; user: User }) {
  const userId = user.id
  const [todos, setTodos] = React.useState<Todo[]>([])
  const [tasksLoading, setTasksLoading] = React.useState(true)
  const [attachTargetTodoId, setAttachTargetTodoId] = React.useState<string | null>(
    null
  )
  const [conflictDueAt, setConflictDueAt] = React.useState<string | null>(null)
  const clearConflictTimerRef = React.useRef<number | null>(null)
  const [focusMode, setFocusMode] = React.useState(false)
  const [nowMs, setNowMs] = React.useState(() => Date.now())
  const [inProgressTaskId, setInProgressTaskId] = React.useState<string | null>(null)
  const [dismissedReminderTaskId, setDismissedReminderTaskId] = React.useState<
    string | null
  >(null)
  const [filterMode, setFilterMode] = React.useState<"between" | "exact">("between")
  const [filterFromDate, setFilterFromDate] = React.useState<string>("")
  const [filterFromTime, setFilterFromTime] = React.useState<string>("")
  const [filterToDate, setFilterToDate] = React.useState<string>("")
  const [filterToTime, setFilterToTime] = React.useState<string>("")
  const [filterExactDate, setFilterExactDate] = React.useState<string>("")
  const [filterExactTime, setFilterExactTime] = React.useState<string>("")
  const fileInputRef = React.useRef<HTMLInputElement>(null)
  const [pageSize, setPageSize] = React.useState<number>(5)
  const [page, setPage] = React.useState<number>(1)

  React.useEffect(() => {
    let alive = true
    async function load() {
      setTasksLoading(true)
      const { data, error } = await supabase
        .from("tasks")
        .select("*")
        .eq("user_id", userId)
        .order("due_at", { ascending: true })
      if (!alive) return
      if (error) {
        toast.error("Failed to load tasks", { description: error.message })
        setTodos([])
        setInProgressTaskId(null)
      } else {
        const rows = (data ?? []) as DbTaskRow[]
        setTodos(rows.map(fromDbTask))
        setInProgressTaskId(rows.find((r) => r.in_progress)?.id ?? null)
      }
      setTasksLoading(false)
    }
    load()
    return () => {
      alive = false
    }
  }, [supabase, userId])

  // Keep "now" fresh so overdue/in-progress states stay accurate without user interaction.
  React.useEffect(() => {
    const id = window.setInterval(() => setNowMs(Date.now()), 30_000)
    return () => window.clearInterval(id)
  }, [])

  // Only one task can be "In Progress"; auto-clear if completed, deleted, or overdue.
  React.useEffect(() => {
    if (!inProgressTaskId) return
    const t = todos.find((x) => x.id === inProgressTaskId)
    if (!t || t.completed) {
      setInProgressTaskId(null)
      return
    }
  }, [inProgressTaskId, nowMs, todos])

  const nextUpcoming = React.useMemo(() => {
    const upcoming = todos
      .filter((t) => !t.completed)
      .map((t) => ({ todo: t, dueMs: parseLocalDateTime(t.dueAt) }))
      .filter((x) => x.dueMs >= nowMs)
      .sort((a, b) => a.dueMs - b.dueMs)[0]
    return upcoming ?? null
  }, [nowMs, todos])

  React.useEffect(() => {
    // If "next upcoming" changed, allow reminder again (dismiss is per-task).
    if (nextUpcoming && nextUpcoming.todo.id !== dismissedReminderTaskId) return
    if (!nextUpcoming) setDismissedReminderTaskId(null)
  }, [dismissedReminderTaskId, nextUpcoming])

  const reminder = React.useMemo(() => {
    const REMINDER_WINDOW_MIN = 15
    if (!nextUpcoming) return null
    if (dismissedReminderTaskId === nextUpcoming.todo.id) return null
    const mins = minutesUntil(nextUpcoming.dueMs, nowMs)
    if (mins < 0 || mins > REMINDER_WINDOW_MIN) return null
    return { ...nextUpcoming, mins }
  }, [dismissedReminderTaskId, nextUpcoming, nowMs])

  const form = useForm<TodoFormValues>({
    resolver: zodResolver(todoSchema),
    defaultValues: { title: "", description: "", dueAt: "" },
    mode: "onSubmit",
  })

  const summary = React.useMemo(() => {
    const now = new Date()
    const todayKey = localDateKey(now)
    const tomorrow = addDays(now, 1)
    const tomorrowKey = localDateKey(tomorrow)

    const todays = todos.filter((t) => t.dueAt.startsWith(todayKey))
    const todayCompleted = todays.filter((t) => t.completed).length
    const todayPending = todays.length - todayCompleted

    const labels = [
      "00:00–04:00",
      "04:00–08:00",
      "08:00–12:00",
      "12:00–16:00",
      "16:00–20:00",
      "20:00–24:00",
    ]

    // Tomorrow: same 4-hour windows breakdown
    const tomorrowTasks = todos.filter((t) => t.dueAt.startsWith(tomorrowKey))
    const tomorrowBuckets = Array.from({ length: 6 }, () => 0) as number[]
    for (const t of tomorrowTasks) {
      const ms = parseLocalDateTime(t.dueAt)
      const hour = new Date(ms).getHours()
      const idx = Math.floor(hour / 4)
      tomorrowBuckets[idx] = (tomorrowBuckets[idx] ?? 0) + 1
    }

    // Until next week = next 7 days starting tomorrow (local), grouped into 4-hour windows.
    const rangeStart = startOfDay(tomorrow).getTime()
    const rangeEnd = addDays(startOfDay(tomorrow), 7).getTime()
    const buckets = Array.from({ length: 6 }, () => 0) as number[]

    const upcoming = todos.filter((t) => {
      const ms = parseLocalDateTime(t.dueAt)
      return ms >= rangeStart && ms < rangeEnd
    })

    for (const t of upcoming) {
      const ms = parseLocalDateTime(t.dueAt)
      const hour = new Date(ms).getHours()
      const idx = Math.floor(hour / 4)
      buckets[idx] = (buckets[idx] ?? 0) + 1
    }

    return {
      todayCompleted,
      todayPending,
      tomorrowTotal: tomorrowTasks.length,
      tomorrowBuckets: labels.map((label, i) => ({ label, count: tomorrowBuckets[i] ?? 0 })),
      upcomingTotal: upcoming.length,
      upcomingBuckets: labels.map((label, i) => ({ label, count: buckets[i] ?? 0 })),
    }
  }, [todos])

  const loadDayKey = React.useMemo(() => {
    // Prefer an explicitly selected date from filters; otherwise use today.
    if (filterMode === "exact" && filterExactDate) return filterExactDate
    if (filterFromDate && !filterToDate) return filterFromDate
    if (filterFromDate && filterToDate && filterFromDate === filterToDate) return filterFromDate
    if (!filterFromDate && filterToDate) return filterToDate
    return localDateKey(new Date(nowMs))
  }, [filterExactDate, filterFromDate, filterMode, filterToDate, nowMs])

  const dailyLoad = React.useMemo(() => {
    const dayTodos = todos.filter((t) => getDatePart(t.dueAt) === loadDayKey)
    return getDailyLoad(dayTodos)
  }, [loadDayKey, todos])

  const filteredTodos = React.useMemo(() => {
    if (focusMode) {
      const endMs = nowMs + 4 * 60 * 60 * 1000
      const withMs = todos.map((t) => ({ ...t, _dueMs: parseLocalDateTime(t.dueAt) }))
      return withMs.filter((t) => t._dueMs >= nowMs && t._dueMs <= endMs)
    }

    const withMs = todos.map((t) => ({ ...t, _dueMs: parseLocalDateTime(t.dueAt) }))
    if (filterMode === "exact") {
      // If only date is selected -> show tasks for that date.
      // If time is selected too -> match exact date+time.
      // If only time is selected -> match time-of-day across all dates.
      if (!filterExactDate && !filterExactTime) return withMs

      if (filterExactDate && !filterExactTime) {
        return withMs.filter((t) => getDatePart(t.dueAt) === filterExactDate)
      }

      if (filterExactDate && filterExactTime) {
        const exactMs = parseLocalDateTime(`${filterExactDate}T${filterExactTime}`)
        return withMs.filter((t) => t._dueMs === exactMs)
      }

      // time only
      return withMs.filter((t) => getTimePart(t.dueAt) === filterExactTime)
    }
    // between
    const hasAnyDate = Boolean(filterFromDate || filterToDate)
    const hasAnyTime = Boolean(filterFromTime || filterToTime)

    // Date range (optional)
    const fromDateMs = filterFromDate
      ? startOfDay(parseLocalDateOnly(filterFromDate)).getTime()
      : Number.NEGATIVE_INFINITY
    const toDateMs = filterToDate
      ? endOfDay(parseLocalDateOnly(filterToDate)).getTime()
      : Number.POSITIVE_INFINITY

    // Time-of-day range (optional)
    const fromTimeMin = filterFromTime ? parseLocalTimeToMinutes(filterFromTime) : 0
    const toTimeMin = filterToTime ? parseLocalTimeToMinutes(filterToTime) : 24 * 60 - 1

    return withMs.filter((t) => {
      const ms = t._dueMs
      if (hasAnyDate && (ms < fromDateMs || ms > toDateMs)) return false

      if (hasAnyTime) {
        const time = getTimePart(t.dueAt)
        if (!time) return false
        const mins = parseLocalTimeToMinutes(time)
        // Simple (non-wrapping) range. If you want wrap-around (e.g. 22:00–02:00), tell me.
        if (mins < fromTimeMin || mins > toTimeMin) return false
      }

      // If neither date nor time selected, pass through (handled above anyway)
      return true
    })
  }, [
    todos,
    focusMode,
    nowMs,
    filterExactDate,
    filterExactTime,
    filterFromDate,
    filterFromTime,
    filterMode,
    filterToDate,
    filterToTime,
  ])

  const sortedFilteredTodos = React.useMemo(
    () =>
      filteredTodos
        .slice()
        .sort((a, b) => parseLocalDateTime(a.dueAt) - parseLocalDateTime(b.dueAt)),
    [filteredTodos]
  )

  // Clamp page when filters/pageSize change.
  React.useEffect(() => {
    const totalPages = Math.max(1, Math.ceil(sortedFilteredTodos.length / pageSize))
    setPage((p) => Math.min(Math.max(1, p), totalPages))
  }, [pageSize, sortedFilteredTodos.length])

  const totalItems = sortedFilteredTodos.length
  const totalPages = Math.max(1, Math.ceil(totalItems / pageSize))
  const showPagination = totalPages > 1

  const pageItems = React.useMemo(() => {
    const start = (page - 1) * pageSize
    return sortedFilteredTodos.slice(start, start + pageSize)
  }, [page, pageSize, sortedFilteredTodos])

  const groupedTodos = React.useMemo(() => {
    const groups: Array<{ date: string; items: typeof pageItems }> = []
    for (const t of pageItems) {
      const date = getDatePart(t.dueAt)
      const last = groups[groups.length - 1]
      if (!last || last.date !== date) groups.push({ date, items: [t] })
      else last.items.push(t)
    }
    return groups
  }, [pageItems])

  const completedCount = filteredTodos.filter((t) => t.completed).length

  function addTodo(values: TodoFormValues) {
    const conflicts = todos.filter((t) => t.dueAt === values.dueAt)
    if (conflicts.length > 0) {
      setConflictDueAt(values.dueAt)
      if (clearConflictTimerRef.current) window.clearTimeout(clearConflictTimerRef.current)
      clearConflictTimerRef.current = window.setTimeout(() => {
        setConflictDueAt(null)
      }, 8000)

      // Make sure the user can see the conflicting tasks even if they were filtered out.
      const [d, time] = values.dueAt.split("T")
      setFilterMode("exact")
      setFilterExactDate(d ?? "")
      setFilterExactTime(time ?? "")
      setPage(1)

      toast.error("Time conflict", {
        description: `You already have ${conflicts.length} task(s) scheduled at ${formatLocalDateTime(
          values.dueAt
        )}.`,
      })
    }

    setTodos((prev) => [
      {
        id: crypto.randomUUID(),
        title: values.title.trim(),
        description:
          (values.description ?? "").trim().length > 0
            ? (values.description ?? "").trim()
            : undefined,
        completed: false,
        dueAt: values.dueAt,
        attachments: [],
      },
      ...prev,
    ])
    form.reset()
  }

  function toggleTodo(id: string, completed: boolean) {
    setTodos((prev) => prev.map((t) => (t.id === id ? { ...t, completed } : t)))
    if (completed) setInProgressTaskId((cur) => (cur === id ? null : cur))
  }

  function requestAttachmentsForTodo(todoId: string) {
    setAttachTargetTodoId(todoId)
    // Let state update before opening picker (some browsers are picky).
    queueMicrotask(() => fileInputRef.current?.click())
  }

  function handleFilesPicked(e: React.ChangeEvent<HTMLInputElement>) {
    const files = Array.from(e.target.files ?? [])
    const targetId = attachTargetTodoId

    // reset input so picking the same file again triggers onChange
    e.target.value = ""
    setAttachTargetTodoId(null)

    if (!targetId || files.length === 0) return

    const attachments = files.map(makeAttachment)

    setTodos((prev) =>
      prev.map((t) =>
        t.id === targetId
          ? { ...t, attachments: [...t.attachments, ...attachments] }
          : t
      )
    )
  }

  function deleteTodo(id: string) {
    setTodos((prev) => {
      const victim = prev.find((t) => t.id === id)
      if (victim) revokeTodoAttachments(victim)
      return prev.filter((t) => t.id !== id)
    })
    setInProgressTaskId((cur) => (cur === id ? null : cur))
  }

  function clearCompleted() {
    setTodos((prev) => {
      for (const t of prev) {
        if (t.completed) revokeTodoAttachments(t)
      }
      return prev.filter((t) => !t.completed)
    })
  }

  return (
    <Card>
      <CardHeader className="flex flex-row items-center justify-between gap-4">
        <div className="space-y-1">
          <CardTitle className="text-2xl">To‑Do</CardTitle>
          <p className="text-muted-foreground text-sm">
            {completedCount}/{filteredTodos.length} completed
          </p>
        </div>
        <div className="flex items-center gap-2">
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <Button
                  type="button"
                  variant={focusMode ? "default" : "outline"}
                  size="sm"
                  onClick={() => {
                    setFocusMode((v) => !v)
                    setPage(1)
                  }}
                >
                  Focus Mode
                </Button>
              </TooltipTrigger>
              <TooltipContent>
                <p>Show tasks for the next 4 hours.</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
          <ModeToggle />
        </div>
      </CardHeader>

      <CardContent className="space-y-6">
        <input
          ref={fileInputRef}
          type="file"
          multiple
          className="hidden"
          accept={[
            "image/*",
            "audio/*",
            "video/*",
            ".pdf",
            ".doc",
            ".docx",
            ".xls",
            ".xlsx",
            ".csv",
            ".txt",
            ".md",
            ".rtf",
          ].join(",")}
          onChange={handleFilesPicked}
        />

        {reminder && (
          <Alert className="border-primary/30 bg-primary/5">
            <Bell className="h-4 w-4" />
            <div className="flex flex-1 flex-col gap-1">
              <div className="flex flex-wrap items-center justify-between gap-2">
                <AlertTitle className="text-sm">
                  Next task starts in {reminder.mins} minute{reminder.mins === 1 ? "" : "s"}
                </AlertTitle>
                <Button
                  type="button"
                  variant="ghost"
                  size="sm"
                  onClick={() => setDismissedReminderTaskId(reminder.todo.id)}
                >
                  Dismiss
                </Button>
              </div>
              <AlertDescription className="text-sm">
                <span className="font-medium">{reminder.todo.title}</span> ·{" "}
                {formatDateTimeFromMs(reminder.dueMs)}
              </AlertDescription>
            </div>
          </Alert>
        )}

        <div className="rounded-xl border bg-card p-4">
          <div className="flex flex-wrap items-center justify-between gap-2">
            <p className="text-sm font-medium">
              Daily load{" "}
              <span className="text-muted-foreground font-normal">
                ({new Intl.DateTimeFormat(undefined, {
                  weekday: "short",
                  year: "numeric",
                  month: "short",
                  day: "2-digit",
                }).format(parseLocalDateOnly(loadDayKey))})
              </span>
            </p>
            <DailyLoadBadge load={dailyLoad.load} />
          </div>
          <p className="text-muted-foreground mt-2 text-sm">
            {dailyLoad.total} task(s) · busiest window {dailyLoad.busiestWindow} ({dailyLoad.peak})
          </p>
        </div>

        <div className="grid gap-3 sm:grid-cols-3">
          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Today’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">
              {summary.todayCompleted} completed
            </p>
            <p className="text-muted-foreground text-sm">{summary.todayPending} pending</p>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tomorrow’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">{summary.tomorrowTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.tomorrowBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tasks Until Next Week</p>
            <p className="mt-2 text-2xl font-semibold">{summary.upcomingTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.upcomingBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>
        </div>

        {focusMode && (
          <div className="flex flex-col gap-1 rounded-lg border bg-muted/20 px-3 py-2 sm:flex-row sm:items-center sm:justify-between">
            <p className="text-sm">
              <span className="font-medium">Focus Mode:</span>{" "}
              showing tasks due in the next 4 hours (until{" "}
              <span className="font-medium">
                {formatDateTimeFromMs(nowMs + 4 * 60 * 60 * 1000)}
              </span>
              )
            </p>
            <Button type="button" variant="ghost" size="sm" onClick={() => setFocusMode(false)}>
              Exit
            </Button>
          </div>
        )}

        <Form {...form}>
          <form
            onSubmit={form.handleSubmit(addTodo)}
            className="space-y-2"
            noValidate
          >
            <div className="flex flex-col gap-2 sm:flex-row">
              <FormField
                control={form.control}
                name="title"
                render={({ field }) => (
                  <FormItem className="flex-1">
                    <FormControl>
                      <Input
                        placeholder="Add a task…"
                        autoComplete="off"
                        {...field}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="dueAt"
                render={({ field }) => (
                  <FormItem className="sm:w-64">
                    <FormControl>
                      <Input type="datetime-local" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <Button type="submit">Add</Button>
            </div>

            <FormField
              control={form.control}
              name="description"
              render={({ field }) => (
                <FormItem>
                  <FormControl>
                    <Textarea
                      rows={3}
                      placeholder="Description (optional)…"
                      {...field}
                    />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />
          </form>
        </Form>

        <Separator />

        <div className="space-y-3">
          <div className="flex flex-wrap items-center justify-between gap-2">
            <p className="text-sm font-medium">Filter by date & time</p>
            <div className="flex items-center gap-2">
              <Button
                type="button"
                size="sm"
                variant={filterMode === "between" ? "default" : "outline"}
                onClick={() => setFilterMode("between")}
              >
                Between
              </Button>
              <Button
                type="button"
                size="sm"
                variant={filterMode === "exact" ? "default" : "outline"}
                onClick={() => setFilterMode("exact")}
              >
                Exact
              </Button>
              <Button
                type="button"
                size="sm"
                variant="ghost"
                onClick={() => {
                  setFilterFromDate("")
                  setFilterFromTime("")
                  setFilterToDate("")
                  setFilterToTime("")
                  setFilterExactDate("")
                  setFilterExactTime("")
                }}
              >
                Clear
              </Button>
            </div>
          </div>

          {filterMode === "between" ? (
            <div className="grid gap-2 sm:grid-cols-2">
              <div className="grid gap-2 sm:grid-cols-2">
                <Input
                  type="date"
                  value={filterFromDate}
                  onChange={(e) => setFilterFromDate(e.target.value)}
                />
                <Input
                  type="time"
                  value={filterFromTime}
                  onChange={(e) => setFilterFromTime(e.target.value)}
                />
              </div>
              <div className="grid gap-2 sm:grid-cols-2">
                <Input
                  type="date"
                  value={filterToDate}
                  onChange={(e) => setFilterToDate(e.target.value)}
                />
                <Input
                  type="time"
                  value={filterToTime}
                  onChange={(e) => setFilterToTime(e.target.value)}
                />
              </div>
            </div>
          ) : (
            <div className="grid gap-2 sm:grid-cols-2">
              <Input
                type="date"
                value={filterExactDate}
                onChange={(e) => setFilterExactDate(e.target.value)}
              />
              <Input
                type="time"
                value={filterExactTime}
                onChange={(e) => setFilterExactTime(e.target.value)}
              />
            </div>
          )}
        </div>

        <Separator />

        <div className="space-y-2">
          {groupedTodos.length === 0 ? (
            <p className="text-muted-foreground text-sm">No tasks yet.</p>
          ) : (
            groupedTodos.map((group) => (
              <div key={group.date} className="space-y-2">
                <div className="flex items-center gap-3 pt-2">
                  <Separator className="flex-1" />
                  <span className="text-muted-foreground whitespace-nowrap text-xs font-medium">
                    {new Intl.DateTimeFormat(undefined, {
                      weekday: "short",
                      year: "numeric",
                      month: "short",
                      day: "2-digit",
                    }).format(parseLocalDateOnly(group.date))}
                  </span>
                  <Separator className="flex-1" />
                </div>

                {group.items.map((todo) => {
                  const flags = getTaskFlags(todo, nowMs, inProgressTaskId)

                  return (
                    <div
                      key={todo.id}
                      className={cn(
                        "rounded-lg border px-3 py-2",
                        flags.completed && "opacity-75",
                        flags.overdue &&
                          "border-destructive/40 bg-destructive/5 text-muted-foreground",
                        flags.inProgress && "border-sky-500/40 bg-sky-500/10",
                        conflictDueAt &&
                          todo.dueAt === conflictDueAt &&
                          "border-destructive/60 bg-destructive/5 ring-1 ring-destructive/30"
                      )}
                    >
                      <div className="flex items-start justify-between gap-3">
                        <label className="flex cursor-pointer items-start gap-3">
                        <Checkbox
                          checked={todo.completed}
                          onCheckedChange={(v) => {
                            const next = Boolean(v)
                            toggleTodo(todo.id, next)
                            if (next && !todo.completed) {
                              requestAttachmentsForTodo(todo.id)
                            }
                          }}
                          aria-label={`Mark "${todo.title}" as ${
                            todo.completed ? "not completed" : "completed"
                          }`}
                          className="mt-0.5"
                        />
                        <span
                          className={cn(
                            "leading-6",
                            todo.completed && "text-muted-foreground line-through"
                          )}
                        >
                          <span className="flex flex-wrap items-center gap-2">
                            <span className="block">{todo.title}</span>
                              <span className="flex flex-wrap items-center gap-2">
                                <TaskBadges {...flags} />
                              </span>
                            {todo.description && (
                              <TooltipProvider>
                                <Tooltip>
                                  <TooltipTrigger asChild>
                                    <button
                                      type="button"
                                      className="text-muted-foreground hover:text-foreground inline-flex h-7 w-7 items-center justify-center rounded-md border bg-background"
                                      aria-label="View description"
                                    >
                                      <Info className="h-4 w-4" />
                                    </button>
                                  </TooltipTrigger>
                                  <TooltipContent className="max-w-xs">
                                    <p className="whitespace-pre-wrap text-sm">
                                      {todo.description}
                                    </p>
                                  </TooltipContent>
                                </Tooltip>
                              </TooltipProvider>
                            )}
                          </span>
                          <span className="text-muted-foreground block text-xs">
                            Due: {formatLocalDateTime(todo.dueAt)}
                          </span>
                        </span>
                      </label>

                      <div className="flex items-center gap-1">
                        {!todo.completed && (
                          <Button
                            type="button"
                            variant={flags.inProgress ? "default" : "outline"}
                            size="sm"
                            onClick={() =>
                              setInProgressTaskId((cur) =>
                                cur === todo.id ? null : todo.id
                              )
                            }
                            className={cn(
                              flags.inProgress && "bg-sky-600 hover:bg-sky-600"
                            )}
                          >
                            {flags.inProgress ? (
                              <>
                                <CircleStop className="mr-1 h-4 w-4" />
                                Stop
                              </>
                            ) : (
                              <>
                                <CirclePlay className="mr-1 h-4 w-4" />
                                Start
                              </>
                            )}
                          </Button>
                        )}
                        {todo.completed && (
                          <Button
                            type="button"
                            variant="outline"
                            size="sm"
                            onClick={() => requestAttachmentsForTodo(todo.id)}
                          >
                            Add files
                          </Button>
                        )}
                        <Button
                          type="button"
                          variant="ghost"
                          size="icon"
                          aria-label={`Delete "${todo.title}"`}
                          onClick={() => deleteTodo(todo.id)}
                        >
                          <Trash2 className="h-4 w-4" />
                        </Button>
                      </div>
                    </div>

                    {todo.completed && todo.attachments.length > 0 && (
                      <div className="mt-3 space-y-2">
                        <p className="text-muted-foreground text-xs">Attachments</p>
                        <ul className="space-y-1">
                          {todo.attachments.map((a) => (
                            <li
                              key={a.id}
                              className="flex items-center justify-between gap-3 rounded-md bg-muted/30 px-2 py-1"
                            >
                              <div className="flex min-w-0 items-center gap-2">
                                <AttachmentIcon kind={a.kind} />
                                <span className="truncate text-sm">{a.name}</span>
                              </div>
                              <a
                                href={a.url}
                                download={a.name}
                                className="inline-flex items-center gap-1 text-sm font-medium underline underline-offset-4"
                              >
                                <Download className="h-4 w-4" />
                                Download
                              </a>
                            </li>
                          ))}
                        </ul>
                      </div>
                    )}
                  </div>
                  )
                })}
              </div>
            ))
          )}
        </div>

        {groupedTodos.length > 0 && (
          <div className="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
            <div className="flex items-center gap-2">
              <span className="text-muted-foreground text-sm">Items per page</span>
              <Select
                value={String(pageSize)}
                onValueChange={(v) => {
                  const next = Number(v)
                  setPageSize(next)
                  setPage(1)
                }}
              >
                <SelectTrigger className="w-[110px]">
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="5">5</SelectItem>
                  <SelectItem value="10">10</SelectItem>
                  <SelectItem value="15">15</SelectItem>
                  <SelectItem value="20">20</SelectItem>
                </SelectContent>
              </Select>
            </div>

            {showPagination && (
              <div className="flex items-center justify-between gap-3 sm:justify-end">
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={() => setPage((p) => Math.max(1, p - 1))}
                  disabled={page <= 1}
                >
                  Prev
                </Button>
                <span className="text-muted-foreground text-sm">
                  Page {page} of {totalPages}
                </span>
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={() => setPage((p) => Math.min(totalPages, p + 1))}
                  disabled={page >= totalPages}
                >
                  Next
                </Button>
              </div>
            )}
          </div>
        )}

        <div className="flex items-center justify-between gap-2">
          <Button
            type="button"
            variant="secondary"
            onClick={clearCompleted}
            disabled={completedCount === 0}
          >
            Clear completed
          </Button>
          <span className="text-muted-foreground text-sm">
            Mock data only (no backend)
          </span>
    </div>
      </CardContent>
    </Card>
  )
}

```

```typescriptreact
"use client"

import { zodResolver } from "@hookform/resolvers/zod"
import {
  AlertTriangle,
  CirclePlay,
  CircleStop,
  CalendarClock,
  CheckCircle2,
  Download,
  File,
  FileSpreadsheet,
  FileText,
  Image as ImageIcon,
  Info,
  Music,
  Bell,
  Timer,
  Trash2,
  Video,
} from "lucide-react"
import * as React from "react"
import { useForm } from "react-hook-form"
import { toast } from "sonner"
import { z } from "zod"
import type { SupabaseClient, User } from "@supabase/supabase-js"

import { ModeToggle } from "@/components/mode-toggle"
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert"
import { Badge } from "@/components/ui/badge"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Checkbox } from "@/components/ui/checkbox"
import { Form, FormControl, FormField, FormItem, FormMessage } from "@/components/ui/form"
import { Input } from "@/components/ui/input"
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select"
import { Separator } from "@/components/ui/separator"
import { Textarea } from "@/components/ui/textarea"
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip"
import { cn } from "@/lib/utils"
import { createBrowserSupabaseClient } from "@/lib/supabase/client"

type AttachmentKind =
  | "image"
  | "audio"
  | "video"
  | "pdf"
  | "spreadsheet"
  | "document"
  | "text"
  | "file"

type Attachment = {
  id: string
  name: string
  type: string
  size: number
  bucket: string
  path: string
  kind: AttachmentKind
}

type Todo = {
  id: string
  title: string
  description?: string
  completed: boolean
  // Stored as `datetime-local` string (YYYY-MM-DDTHH:mm) in local time.
  dueAt: string
  attachments: Attachment[]
}

type TaskState = "planned" | "in_progress" | "completed" | "overdue"
type DailyLoad = "light" | "balanced" | "heavy"

const todoSchema = z.object({
  title: z
    .string()
    .trim()
    .min(1, "Title is required.")
    .max(80, "Keep it under 80 characters."),
  description: z
    .string()
    .trim()
    .max(500, "Keep it under 500 characters.")
    .optional()
    .or(z.literal("")),
  dueAt: z
    .string()
    .min(1, "Due date & time is required.")
    .regex(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}$/, "Invalid date/time."),
})

type TodoFormValues = z.infer<typeof todoSchema>

const initialTodos: Todo[] = [
  {
    id: "1",
    title: "Create a Next.js app",
    description: "Scaffold with TypeScript + Tailwind and confirm it runs locally.",
    completed: true,
    dueAt: "2026-01-16T09:00",
    attachments: [],
  },
  {
    id: "2",
    title: "Add shadcn/ui + dark theme",
    description: "Initialize shadcn, set up theme provider, and verify dark mode.",
    completed: true,
    dueAt: "2026-01-16T10:30",
    attachments: [],
  },
  {
    id: "3",
    title: "Build a mock-data to-do list",
    completed: false,
    dueAt: "2026-01-16T15:00",
    attachments: [],
  },
  {
    id: "4",
    title: "Yesterday: review requirements",
    completed: true,
    dueAt: "2026-01-15T11:15",
    attachments: [],
  },
  {
    id: "5",
    title: "Yesterday: sketch UI layout",
    completed: true,
    dueAt: "2026-01-15T17:45",
    attachments: [],
  },
  {
    id: "6",
    title: "Today: add attachments support",
    completed: false,
    dueAt: "2026-01-16T18:20",
    attachments: [],
  },
  {
    id: "7",
    title: "Tomorrow: QA the filters",
    description: "Test date-only, time-only, exact, and between behaviors.",
    completed: false,
    dueAt: "2026-01-17T08:05",
    attachments: [],
  },
  {
    id: "8",
    title: "Tomorrow: polish summary cards",
    completed: false,
    dueAt: "2026-01-17T13:30",
    attachments: [],
  },
  {
    id: "9",
    title: "Tomorrow: write small UX notes",
    completed: false,
    dueAt: "2026-01-17T20:10",
    attachments: [],
  },
  {
    id: "10",
    title: "This weekend: add more mock tasks",
    completed: false,
    dueAt: "2026-01-18T10:00",
    attachments: [],
  },
  {
    id: "11",
    title: "This weekend: check time-only filter",
    completed: false,
    dueAt: "2026-01-18T22:15",
    attachments: [],
  },
  {
    id: "12",
    title: "Next week: sync with team",
    completed: false,
    dueAt: "2026-01-19T09:30",
    attachments: [],
  },
  {
    id: "13",
    title: "Next week: test date-only filter",
    completed: false,
    dueAt: "2026-01-20T14:05",
    attachments: [],
  },
  {
    id: "14",
    title: "Next week: test exact date+time filter",
    completed: false,
    dueAt: "2026-01-21T12:00",
    attachments: [],
  },
  {
    id: "15",
    title: "Next week: attach docs to completed tasks",
    completed: false,
    dueAt: "2026-01-22T16:40",
    attachments: [],
  },
  {
    id: "16",
    title: "Next week: final review",
    completed: false,
    dueAt: "2026-01-23T11:00",
    attachments: [],
  },
]

type DbTaskRow = {
  id: string
  user_id: string
  title: string
  description: string | null
  due_at: string
  completed: boolean
  in_progress: boolean
  attachments: unknown
}

function coerceAttachments(raw: unknown): Attachment[] {
  if (!raw || typeof raw !== "object") return []
  if (!Array.isArray(raw)) return []
  return raw.filter(Boolean) as Attachment[]
}

function toDbTaskInsert(values: TodoFormValues, userId: string) {
  return {
    user_id: userId,
    title: values.title.trim(),
    description: (values.description ?? "").trim() || null,
    due_at: values.dueAt,
    completed: false,
    in_progress: false,
    attachments: [],
  }
}

function fromDbTask(row: DbTaskRow): Todo {
  return {
    id: row.id,
    title: row.title,
    description: row.description ?? undefined,
    completed: row.completed,
    dueAt: row.due_at,
    attachments: coerceAttachments(row.attachments),
  }
}

function parseLocalDateTime(value: string): number {
  // value: "YYYY-MM-DDTHH:mm"
  const [datePart, timePart] = value.split("T")
  const [y, m, d] = datePart.split("-").map(Number)
  const [hh, mm] = timePart.split(":").map(Number)
  return new Date(y, m - 1, d, hh, mm, 0, 0).getTime()
}

function pad2(n: number) {
  return String(n).padStart(2, "0")
}

function localDateKey(d: Date) {
  return `${d.getFullYear()}-${pad2(d.getMonth() + 1)}-${pad2(d.getDate())}`
}

function addDays(date: Date, days: number) {
  const d = new Date(date)
  d.setDate(d.getDate() + days)
  return d
}

function startOfDay(date: Date) {
  return new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0, 0)
}

function endOfDay(date: Date) {
  return new Date(
    date.getFullYear(),
    date.getMonth(),
    date.getDate(),
    23,
    59,
    59,
    999
  )
}

function getDatePart(dueAt: string) {
  return dueAt.split("T")[0] ?? ""
}

function getTimePart(dueAt: string) {
  return dueAt.split("T")[1] ?? ""
}

function parseLocalDateOnly(value: string): Date {
  // value: "YYYY-MM-DD"
  const [y, m, d] = value.split("-").map(Number)
  return new Date(y, m - 1, d, 0, 0, 0, 0)
}

function parseLocalTimeToMinutes(value: string): number {
  // value: "HH:mm"
  const [hh, mm] = value.split(":").map(Number)
  return hh * 60 + mm
}

function formatLocalDateTime(value: string): string {
  const ms = parseLocalDateTime(value)
  if (!Number.isFinite(ms)) return value
  return new Intl.DateTimeFormat(undefined, {
    year: "numeric",
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  }).format(new Date(ms))
}

function formatDateTimeFromMs(ms: number): string {
  return new Intl.DateTimeFormat(undefined, {
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  }).format(new Date(ms))
}

function minutesUntil(targetMs: number, nowMs: number) {
  return Math.ceil((targetMs - nowMs) / 60_000)
}

function getTaskFlags(todo: Todo, nowMs: number, inProgressTaskId: string | null) {
  const completed = todo.completed
  const dueMs = parseLocalDateTime(todo.dueAt)
  const overdue = !completed && dueMs < nowMs
  const inProgress = !completed && inProgressTaskId === todo.id
  const planned = !completed && !overdue && !inProgress
  return { completed, overdue, inProgress, planned }
}

function getDailyLoad(todosForDay: Todo[]) {
  // 4-hour windows across the day (local).
  const labels = [
    "00:00–04:00",
    "04:00–08:00",
    "08:00–12:00",
    "12:00–16:00",
    "16:00–20:00",
    "20:00–24:00",
  ]
  const buckets = Array.from({ length: 6 }, () => 0) as number[]
  for (const t of todosForDay) {
    const ms = parseLocalDateTime(t.dueAt)
    const hour = new Date(ms).getHours()
    const idx = Math.floor(hour / 4)
    buckets[idx] = (buckets[idx] ?? 0) + 1
  }

  const total = todosForDay.length
  const peak = Math.max(0, ...buckets)
  const spread = buckets.filter((c) => c > 0).length
  const busiestIdx = buckets.findIndex((c) => c === peak)
  const busiestWindow = busiestIdx >= 0 ? labels[busiestIdx] : labels[0]

  // Heuristic: more tasks + higher concentration in one window => heavier day.
  const score = total + peak * 1.5 + Math.max(0, spread - 1) * 0.5
  const load: DailyLoad = score <= 5 ? "light" : score <= 10 ? "balanced" : "heavy"

  return { load, total, peak, spread, busiestWindow }
}

function DailyLoadBadge({ load }: { load: DailyLoad }) {
  if (load === "heavy") return <Badge variant="destructive">Heavy</Badge>
  if (load === "balanced") return <Badge variant="secondary">Balanced</Badge>
  return <Badge variant="outline">Light</Badge>
}

function TaskBadges({
  completed,
  overdue,
  inProgress,
  planned,
}: {
  completed: boolean
  overdue: boolean
  inProgress: boolean
  planned: boolean
}) {
  if (completed) {
    return (
      <Badge className="gap-1 bg-emerald-600 text-white hover:bg-emerald-600">
        <CheckCircle2 className="h-3.5 w-3.5" />
        Completed
      </Badge>
    )
  }

  return (
    <>
      {inProgress && (
        <Badge className="gap-1 bg-sky-600 text-white hover:bg-sky-600">
          <Timer className="h-3.5 w-3.5 text-white" />
          In progress
        </Badge>
      )}
      {overdue && (
        <Badge variant="destructive" className="gap-1">
          <AlertTriangle className="h-3.5 w-3.5" />
          Overdue
        </Badge>
      )}
      {planned && (
        <Badge variant="outline" className="gap-1">
          <CalendarClock className="h-3.5 w-3.5" />
          Planned
        </Badge>
      )}
    </>
  )
}

function getAttachmentKind(file: File): AttachmentKind {
  const type = (file.type || "").toLowerCase()
  const name = file.name.toLowerCase()
  const ext = name.includes(".") ? name.split(".").pop() ?? "" : ""

  if (type.startsWith("image/")) return "image"
  if (type.startsWith("audio/")) return "audio"
  if (type.startsWith("video/")) return "video"

  if (ext === "pdf") return "pdf"
  if (["xls", "xlsx", "csv"].includes(ext)) return "spreadsheet"
  if (["doc", "docx"].includes(ext)) return "document"
  if (["txt", "md", "rtf"].includes(ext)) return "text"

  return "file"
}

function sanitizePathSegment(s: string) {
  return s.replace(/[^\w.\-]+/g, "_")
}

function buildAttachmentRecord(file: File, bucket: string, path: string): Attachment {
  return {
    id: crypto.randomUUID(),
    name: file.name,
    type: file.type,
    size: file.size,
    bucket,
    path,
    kind: getAttachmentKind(file),
  }
}

function AttachmentIcon({ kind }: { kind: AttachmentKind }) {
  const className = "h-4 w-4 text-muted-foreground"

  switch (kind) {
    case "image":
      return <ImageIcon className={className} />
    case "audio":
      return <Music className={className} />
    case "video":
      return <Video className={className} />
    case "spreadsheet":
      return <FileSpreadsheet className={className} />
    case "pdf":
    case "document":
    case "text":
      return <FileText className={className} />
    default:
      return <File className={className} />
  }
}

const authSchema = z.object({
  email: z.string().email("Enter a valid email."),
  password: z.string().min(6, "Password must be at least 6 characters."),
})
type AuthValues = z.infer<typeof authSchema>

function AuthCard({ supabase }: { supabase: SupabaseClient }) {
  const [mode, setMode] = React.useState<"sign_in" | "sign_up">("sign_in")
  const [busy, setBusy] = React.useState(false)

  const form = useForm<AuthValues>({
    resolver: zodResolver(authSchema),
    defaultValues: { email: "", password: "" },
  })

  async function onSubmit(values: AuthValues) {
    setBusy(true)
    try {
      if (mode === "sign_in") {
        const { error } = await supabase.auth.signInWithPassword(values)
        if (error) throw error
      } else {
        const { error } = await supabase.auth.signUp(values)
        if (error) throw error
        toast.success("Account created", { description: "You can now sign in." })
        setMode("sign_in")
      }
    } catch (e) {
      toast.error("Authentication failed", {
        description: e instanceof Error ? e.message : "Please try again.",
      })
    } finally {
      setBusy(false)
    }
  }

  return (
    <div className="mx-auto flex min-h-screen max-w-md flex-col justify-center px-4 py-10">
      <Card>
        <CardHeader>
          <CardTitle className="text-2xl">Sign in</CardTitle>
          <p className="text-muted-foreground text-sm">
            {mode === "sign_in"
              ? "Use your email and password."
              : "Create an account with email and password."}
          </p>
        </CardHeader>
        <CardContent className="space-y-4">
          <Form {...form}>
            <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-3" noValidate>
              <FormField
                control={form.control}
                name="email"
                render={({ field }) => (
                  <FormItem>
                    <FormControl>
                      <Input placeholder="Email" autoComplete="email" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="password"
                render={({ field }) => (
                  <FormItem>
                    <FormControl>
                      <Input
                        type="password"
                        placeholder="Password"
                        autoComplete={
                          mode === "sign_in" ? "current-password" : "new-password"
                        }
                        {...field}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <Button type="submit" className="w-full" disabled={busy}>
                {mode === "sign_in" ? "Sign in" : "Sign up"}
              </Button>
            </form>
          </Form>

          <div className="flex items-center justify-between gap-3 text-sm">
            <span className="text-muted-foreground">
              {mode === "sign_in" ? "No account?" : "Already have an account?"}
            </span>
            <Button
              type="button"
              variant="link"
              className="px-0"
              onClick={() => setMode((m) => (m === "sign_in" ? "sign_up" : "sign_in"))}
            >
              {mode === "sign_in" ? "Sign up" : "Sign in"}
            </Button>
          </div>
        </CardContent>
      </Card>
    </div>
  )
}

export default function Home() {
  const [supabaseError, setSupabaseError] = React.useState<string | null>(null)
  const supabase = React.useMemo(() => {
    try {
      return createBrowserSupabaseClient()
    } catch (e) {
      setSupabaseError(e instanceof Error ? e.message : "Supabase is not configured.")
      return null
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [])

  const [user, setUser] = React.useState<User | null>(null)
  const [authLoading, setAuthLoading] = React.useState(true)

  React.useEffect(() => {
    if (!supabase) return
    let alive = true
    supabase.auth.getUser().then(({ data }) => {
      if (!alive) return
      setUser(data.user ?? null)
      setAuthLoading(false)
    })
    const { data } = supabase.auth.onAuthStateChange((_event, session) => {
      setUser(session?.user ?? null)
    })
    return () => {
      alive = false
      data.subscription.unsubscribe()
    }
  }, [supabase])

  if (supabaseError) {
    return (
      <div className="mx-auto flex min-h-screen max-w-2xl flex-col justify-center gap-4 px-4 py-10">
        <Card>
          <CardHeader>
            <CardTitle>Supabase not configured</CardTitle>
          </CardHeader>
          <CardContent className="space-y-2">
            <p className="text-muted-foreground text-sm">{supabaseError}</p>
            <p className="text-muted-foreground text-sm">
              See <code>SUPABASE_SETUP.md</code> and <code>supabase.env.example</code>.
            </p>
          </CardContent>
        </Card>
      </div>
    )
  }

  if (!supabase) return null
  if (authLoading) {
    return (
      <div className="mx-auto flex min-h-screen max-w-2xl flex-col justify-center px-4 py-10">
        <p className="text-muted-foreground text-sm">Loading…</p>
      </div>
    )
  }

  if (!user) return <AuthCard supabase={supabase} />

  return (
    <div className="mx-auto flex min-h-screen max-w-2xl flex-col gap-6 px-4 py-10">
      <TodoApp supabase={supabase} user={user} />
    </div>
  )
}

function TodoApp({ supabase, user }: { supabase: SupabaseClient; user: User }) {
  const userId = user.id
  const [todos, setTodos] = React.useState<Todo[]>([])
  const [tasksLoading, setTasksLoading] = React.useState(true)
  const [attachTargetTodoId, setAttachTargetTodoId] = React.useState<string | null>(
    null
  )
  const [conflictDueAt, setConflictDueAt] = React.useState<string | null>(null)
  const clearConflictTimerRef = React.useRef<number | null>(null)
  const [focusMode, setFocusMode] = React.useState(false)
  const [nowMs, setNowMs] = React.useState(() => Date.now())
  const [inProgressTaskId, setInProgressTaskId] = React.useState<string | null>(null)
  const [dismissedReminderTaskId, setDismissedReminderTaskId] = React.useState<
    string | null
  >(null)
  const [filterMode, setFilterMode] = React.useState<"between" | "exact">("between")
  const [filterFromDate, setFilterFromDate] = React.useState<string>("")
  const [filterFromTime, setFilterFromTime] = React.useState<string>("")
  const [filterToDate, setFilterToDate] = React.useState<string>("")
  const [filterToTime, setFilterToTime] = React.useState<string>("")
  const [filterExactDate, setFilterExactDate] = React.useState<string>("")
  const [filterExactTime, setFilterExactTime] = React.useState<string>("")
  const fileInputRef = React.useRef<HTMLInputElement>(null)
  const [pageSize, setPageSize] = React.useState<number>(5)
  const [page, setPage] = React.useState<number>(1)

  React.useEffect(() => {
    let alive = true
    async function load() {
      setTasksLoading(true)
      const { data, error } = await supabase
        .from("tasks")
        .select("*")
        .eq("user_id", userId)
        .order("due_at", { ascending: true })
      if (!alive) return
      if (error) {
        toast.error("Failed to load tasks", { description: error.message })
        setTodos([])
        setInProgressTaskId(null)
      } else {
        const rows = (data ?? []) as DbTaskRow[]
        setTodos(rows.map(fromDbTask))
        setInProgressTaskId(rows.find((r) => r.in_progress)?.id ?? null)
      }
      setTasksLoading(false)
    }
    load()
    return () => {
      alive = false
    }
  }, [supabase, userId])

  // Keep "now" fresh so overdue/in-progress states stay accurate without user interaction.
  React.useEffect(() => {
    const id = window.setInterval(() => setNowMs(Date.now()), 30_000)
    return () => window.clearInterval(id)
  }, [])

  // Only one task can be "In Progress"; auto-clear if completed, deleted, or overdue.
  React.useEffect(() => {
    if (!inProgressTaskId) return
    const t = todos.find((x) => x.id === inProgressTaskId)
    if (!t || t.completed) {
      setInProgressTaskId(null)
      return
    }
  }, [inProgressTaskId, nowMs, todos])

  const nextUpcoming = React.useMemo(() => {
    const upcoming = todos
      .filter((t) => !t.completed)
      .map((t) => ({ todo: t, dueMs: parseLocalDateTime(t.dueAt) }))
      .filter((x) => x.dueMs >= nowMs)
      .sort((a, b) => a.dueMs - b.dueMs)[0]
    return upcoming ?? null
  }, [nowMs, todos])

  React.useEffect(() => {
    // If "next upcoming" changed, allow reminder again (dismiss is per-task).
    if (nextUpcoming && nextUpcoming.todo.id !== dismissedReminderTaskId) return
    if (!nextUpcoming) setDismissedReminderTaskId(null)
  }, [dismissedReminderTaskId, nextUpcoming])

  const reminder = React.useMemo(() => {
    const REMINDER_WINDOW_MIN = 15
    if (!nextUpcoming) return null
    if (dismissedReminderTaskId === nextUpcoming.todo.id) return null
    const mins = minutesUntil(nextUpcoming.dueMs, nowMs)
    if (mins < 0 || mins > REMINDER_WINDOW_MIN) return null
    return { ...nextUpcoming, mins }
  }, [dismissedReminderTaskId, nextUpcoming, nowMs])

  const form = useForm<TodoFormValues>({
    resolver: zodResolver(todoSchema),
    defaultValues: { title: "", description: "", dueAt: "" },
    mode: "onSubmit",
  })

  const summary = React.useMemo(() => {
    const now = new Date()
    const todayKey = localDateKey(now)
    const tomorrow = addDays(now, 1)
    const tomorrowKey = localDateKey(tomorrow)

    const todays = todos.filter((t) => t.dueAt.startsWith(todayKey))
    const todayCompleted = todays.filter((t) => t.completed).length
    const todayPending = todays.length - todayCompleted

    const labels = [
      "00:00–04:00",
      "04:00–08:00",
      "08:00–12:00",
      "12:00–16:00",
      "16:00–20:00",
      "20:00–24:00",
    ]

    // Tomorrow: same 4-hour windows breakdown
    const tomorrowTasks = todos.filter((t) => t.dueAt.startsWith(tomorrowKey))
    const tomorrowBuckets = Array.from({ length: 6 }, () => 0) as number[]
    for (const t of tomorrowTasks) {
      const ms = parseLocalDateTime(t.dueAt)
      const hour = new Date(ms).getHours()
      const idx = Math.floor(hour / 4)
      tomorrowBuckets[idx] = (tomorrowBuckets[idx] ?? 0) + 1
    }

    // Until next week = next 7 days starting tomorrow (local), grouped into 4-hour windows.
    const rangeStart = startOfDay(tomorrow).getTime()
    const rangeEnd = addDays(startOfDay(tomorrow), 7).getTime()
    const buckets = Array.from({ length: 6 }, () => 0) as number[]

    const upcoming = todos.filter((t) => {
      const ms = parseLocalDateTime(t.dueAt)
      return ms >= rangeStart && ms < rangeEnd
    })

    for (const t of upcoming) {
      const ms = parseLocalDateTime(t.dueAt)
      const hour = new Date(ms).getHours()
      const idx = Math.floor(hour / 4)
      buckets[idx] = (buckets[idx] ?? 0) + 1
    }

    return {
      todayCompleted,
      todayPending,
      tomorrowTotal: tomorrowTasks.length,
      tomorrowBuckets: labels.map((label, i) => ({ label, count: tomorrowBuckets[i] ?? 0 })),
      upcomingTotal: upcoming.length,
      upcomingBuckets: labels.map((label, i) => ({ label, count: buckets[i] ?? 0 })),
    }
  }, [todos])

  const loadDayKey = React.useMemo(() => {
    // Prefer an explicitly selected date from filters; otherwise use today.
    if (filterMode === "exact" && filterExactDate) return filterExactDate
    if (filterFromDate && !filterToDate) return filterFromDate
    if (filterFromDate && filterToDate && filterFromDate === filterToDate) return filterFromDate
    if (!filterFromDate && filterToDate) return filterToDate
    return localDateKey(new Date(nowMs))
  }, [filterExactDate, filterFromDate, filterMode, filterToDate, nowMs])

  const dailyLoad = React.useMemo(() => {
    const dayTodos = todos.filter((t) => getDatePart(t.dueAt) === loadDayKey)
    return getDailyLoad(dayTodos)
  }, [loadDayKey, todos])

  const filteredTodos = React.useMemo(() => {
    if (focusMode) {
      const endMs = nowMs + 4 * 60 * 60 * 1000
      const withMs = todos.map((t) => ({ ...t, _dueMs: parseLocalDateTime(t.dueAt) }))
      return withMs.filter((t) => t._dueMs >= nowMs && t._dueMs <= endMs)
    }

    const withMs = todos.map((t) => ({ ...t, _dueMs: parseLocalDateTime(t.dueAt) }))
    if (filterMode === "exact") {
      // If only date is selected -> show tasks for that date.
      // If time is selected too -> match exact date+time.
      // If only time is selected -> match time-of-day across all dates.
      if (!filterExactDate && !filterExactTime) return withMs

      if (filterExactDate && !filterExactTime) {
        return withMs.filter((t) => getDatePart(t.dueAt) === filterExactDate)
      }

      if (filterExactDate && filterExactTime) {
        const exactMs = parseLocalDateTime(`${filterExactDate}T${filterExactTime}`)
        return withMs.filter((t) => t._dueMs === exactMs)
      }

      // time only
      return withMs.filter((t) => getTimePart(t.dueAt) === filterExactTime)
    }
    // between
    const hasAnyDate = Boolean(filterFromDate || filterToDate)
    const hasAnyTime = Boolean(filterFromTime || filterToTime)

    // Date range (optional)
    const fromDateMs = filterFromDate
      ? startOfDay(parseLocalDateOnly(filterFromDate)).getTime()
      : Number.NEGATIVE_INFINITY
    const toDateMs = filterToDate
      ? endOfDay(parseLocalDateOnly(filterToDate)).getTime()
      : Number.POSITIVE_INFINITY

    // Time-of-day range (optional)
    const fromTimeMin = filterFromTime ? parseLocalTimeToMinutes(filterFromTime) : 0
    const toTimeMin = filterToTime ? parseLocalTimeToMinutes(filterToTime) : 24 * 60 - 1

    return withMs.filter((t) => {
      const ms = t._dueMs
      if (hasAnyDate && (ms < fromDateMs || ms > toDateMs)) return false

      if (hasAnyTime) {
        const time = getTimePart(t.dueAt)
        if (!time) return false
        const mins = parseLocalTimeToMinutes(time)
        // Simple (non-wrapping) range. If you want wrap-around (e.g. 22:00–02:00), tell me.
        if (mins < fromTimeMin || mins > toTimeMin) return false
      }

      // If neither date nor time selected, pass through (handled above anyway)
      return true
    })
  }, [
    todos,
    focusMode,
    nowMs,
    filterExactDate,
    filterExactTime,
    filterFromDate,
    filterFromTime,
    filterMode,
    filterToDate,
    filterToTime,
  ])

  const sortedFilteredTodos = React.useMemo(
    () =>
      filteredTodos
        .slice()
        .sort((a, b) => parseLocalDateTime(a.dueAt) - parseLocalDateTime(b.dueAt)),
    [filteredTodos]
  )

  // Clamp page when filters/pageSize change.
  React.useEffect(() => {
    const totalPages = Math.max(1, Math.ceil(sortedFilteredTodos.length / pageSize))
    setPage((p) => Math.min(Math.max(1, p), totalPages))
  }, [pageSize, sortedFilteredTodos.length])

  const totalItems = sortedFilteredTodos.length
  const totalPages = Math.max(1, Math.ceil(totalItems / pageSize))
  const showPagination = totalPages > 1

  const pageItems = React.useMemo(() => {
    const start = (page - 1) * pageSize
    return sortedFilteredTodos.slice(start, start + pageSize)
  }, [page, pageSize, sortedFilteredTodos])

  const groupedTodos = React.useMemo(() => {
    const groups: Array<{ date: string; items: typeof pageItems }> = []
    for (const t of pageItems) {
      const date = getDatePart(t.dueAt)
      const last = groups[groups.length - 1]
      if (!last || last.date !== date) groups.push({ date, items: [t] })
      else last.items.push(t)
    }
    return groups
  }, [pageItems])

  const completedCount = filteredTodos.filter((t) => t.completed).length

  async function addTodo(values: TodoFormValues) {
    const conflicts = todos.filter((t) => t.dueAt === values.dueAt)
    if (conflicts.length > 0) {
      setConflictDueAt(values.dueAt)
      if (clearConflictTimerRef.current) window.clearTimeout(clearConflictTimerRef.current)
      clearConflictTimerRef.current = window.setTimeout(() => {
        setConflictDueAt(null)
      }, 8000)

      // Make sure the user can see the conflicting tasks even if they were filtered out.
      const [d, time] = values.dueAt.split("T")
      setFilterMode("exact")
      setFilterExactDate(d ?? "")
      setFilterExactTime(time ?? "")
      setPage(1)

      toast.error("Time conflict", {
        description: `You already have ${conflicts.length} task(s) scheduled at ${formatLocalDateTime(
          values.dueAt
        )}.`,
      })
    }

    const { data, error } = await supabase
      .from("tasks")
      .insert(toDbTaskInsert(values, userId))
      .select("*")
      .single()
    if (error) {
      toast.error("Failed to add task", { description: error.message })
      return
    }

    setTodos((prev) => [fromDbTask(data as DbTaskRow), ...prev])
    form.reset()
  }

  async function toggleTodo(id: string, completed: boolean) {
    // optimistic
    setTodos((prev) =>
      prev.map((t) =>
        t.id === id ? { ...t, completed, attachments: t.attachments } : t
      )
    )
    if (completed) setInProgressTaskId((cur) => (cur === id ? null : cur))

    const { error } = await supabase
      .from("tasks")
      .update({ completed, in_progress: completed ? false : undefined })
      .eq("id", id)
      .eq("user_id", userId)
    if (error) {
      toast.error("Failed to update task", { description: error.message })
    }
  }

  function requestAttachmentsForTodo(todoId: string) {
    setAttachTargetTodoId(todoId)
    // Let state update before opening picker (some browsers are picky).
    queueMicrotask(() => fileInputRef.current?.click())
  }

  async function handleFilesPicked(e: React.ChangeEvent<HTMLInputElement>) {
    const files = Array.from(e.target.files ?? [])
    const targetId = attachTargetTodoId

    // reset input so picking the same file again triggers onChange
    e.target.value = ""
    setAttachTargetTodoId(null)

    if (!targetId || files.length === 0) return
    const targetTodo = todos.find((t) => t.id === targetId)
    if (!targetTodo) return

    const bucket = "task-attachments"
    const uploaded: Attachment[] = []

    for (const file of files) {
      const safeName = sanitizePathSegment(file.name)
      const path = `${userId}/${targetId}/${crypto.randomUUID()}-${safeName}`
      const { error } = await supabase.storage
        .from(bucket)
        .upload(path, file, { contentType: file.type, upsert: false })
      if (error) {
        toast.error("Upload failed", { description: error.message })
        continue
      }
      uploaded.push(buildAttachmentRecord(file, bucket, path))
    }

    if (uploaded.length === 0) return
    const nextAttachments = [...targetTodo.attachments, ...uploaded]

    // optimistic
    setTodos((prev) =>
      prev.map((t) => (t.id === targetId ? { ...t, attachments: nextAttachments } : t))
    )

    const { error } = await supabase
      .from("tasks")
      .update({ attachments: nextAttachments })
      .eq("id", targetId)
      .eq("user_id", userId)
    if (error) {
      toast.error("Failed to save attachments", { description: error.message })
    }
  }

  async function deleteTodo(id: string) {
    // optimistic
    setTodos((prev) => prev.filter((t) => t.id !== id))
    setInProgressTaskId((cur) => (cur === id ? null : cur))

    const { error } = await supabase.from("tasks").delete().eq("id", id).eq("user_id", userId)
    if (error) toast.error("Failed to delete task", { description: error.message })
  }

  async function clearCompleted() {
    const completedIds = new Set(todos.filter((t) => t.completed).map((t) => t.id))
    if (completedIds.size === 0) return

    // optimistic
    setTodos((prev) => prev.filter((t) => !completedIds.has(t.id)))

    const { error } = await supabase
      .from("tasks")
      .delete()
      .eq("user_id", userId)
      .eq("completed", true)
    if (error) toast.error("Failed to clear completed", { description: error.message })
  }

  return (
    <Card>
      <CardHeader className="flex flex-row items-center justify-between gap-4">
        <div className="space-y-1">
          <CardTitle className="text-2xl">To‑Do</CardTitle>
          <p className="text-muted-foreground text-sm">
            {completedCount}/{filteredTodos.length} completed
          </p>
        </div>
        <div className="flex items-center gap-2">
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <Button
                  type="button"
                  variant={focusMode ? "default" : "outline"}
                  size="sm"
                  onClick={() => {
                    setFocusMode((v) => !v)
                    setPage(1)
                  }}
                >
                  Focus Mode
                </Button>
              </TooltipTrigger>
              <TooltipContent>
                <p>Show tasks for the next 4 hours.</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
          <ModeToggle />
        </div>
      </CardHeader>

      <CardContent className="space-y-6">
        <input
          ref={fileInputRef}
          type="file"
          multiple
          className="hidden"
          accept={[
            "image/*",
            "audio/*",
            "video/*",
            ".pdf",
            ".doc",
            ".docx",
            ".xls",
            ".xlsx",
            ".csv",
            ".txt",
            ".md",
            ".rtf",
          ].join(",")}
          onChange={handleFilesPicked}
        />

        {reminder && (
          <Alert className="border-primary/30 bg-primary/5">
            <Bell className="h-4 w-4" />
            <div className="flex flex-1 flex-col gap-1">
              <div className="flex flex-wrap items-center justify-between gap-2">
                <AlertTitle className="text-sm">
                  Next task starts in {reminder.mins} minute{reminder.mins === 1 ? "" : "s"}
                </AlertTitle>
                <Button
                  type="button"
                  variant="ghost"
                  size="sm"
                  onClick={() => setDismissedReminderTaskId(reminder.todo.id)}
                >
                  Dismiss
                </Button>
              </div>
              <AlertDescription className="text-sm">
                <span className="font-medium">{reminder.todo.title}</span> ·{" "}
                {formatDateTimeFromMs(reminder.dueMs)}
              </AlertDescription>
            </div>
          </Alert>
        )}

        <div className="rounded-xl border bg-card p-4">
          <div className="flex flex-wrap items-center justify-between gap-2">
            <p className="text-sm font-medium">
              Daily load{" "}
              <span className="text-muted-foreground font-normal">
                ({new Intl.DateTimeFormat(undefined, {
                  weekday: "short",
                  year: "numeric",
                  month: "short",
                  day: "2-digit",
                }).format(parseLocalDateOnly(loadDayKey))})
              </span>
            </p>
            <DailyLoadBadge load={dailyLoad.load} />
          </div>
          <p className="text-muted-foreground mt-2 text-sm">
            {dailyLoad.total} task(s) · busiest window {dailyLoad.busiestWindow} ({dailyLoad.peak})
          </p>
        </div>

        <div className="grid gap-3 sm:grid-cols-3">
          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Today’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">
              {summary.todayCompleted} completed
            </p>
            <p className="text-muted-foreground text-sm">{summary.todayPending} pending</p>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tomorrow’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">{summary.tomorrowTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.tomorrowBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tasks Until Next Week</p>
            <p className="mt-2 text-2xl font-semibold">{summary.upcomingTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.upcomingBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>
        </div>

        {focusMode && (
          <div className="flex flex-col gap-1 rounded-lg border bg-muted/20 px-3 py-2 sm:flex-row sm:items-center sm:justify-between">
            <p className="text-sm">
              <span className="font-medium">Focus Mode:</span>{" "}
              showing tasks due in the next 4 hours (until{" "}
              <span className="font-medium">
                {formatDateTimeFromMs(nowMs + 4 * 60 * 60 * 1000)}
              </span>
              )
            </p>
            <Button type="button" variant="ghost" size="sm" onClick={() => setFocusMode(false)}>
              Exit
            </Button>
          </div>
        )}

        <Form {...form}>
          <form
            onSubmit={form.handleSubmit(addTodo)}
            className="space-y-2"
            noValidate
          >
            <div className="flex flex-col gap-2 sm:flex-row">
              <FormField
                control={form.control}
                name="title"
                render={({ field }) => (
                  <FormItem className="flex-1">
                    <FormControl>
                      <Input
                        placeholder="Add a task…"
                        autoComplete="off"
                        {...field}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="dueAt"
                render={({ field }) => (
                  <FormItem className="sm:w-64">
                    <FormControl>
                      <Input type="datetime-local" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <Button type="submit">Add</Button>
            </div>

            <FormField
              control={form.control}
              name="description"
              render={({ field }) => (
                <FormItem>
                  <FormControl>
                    <Textarea
                      rows={3}
                      placeholder="Description (optional)…"
                      {...field}
                    />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />
          </form>
        </Form>

        <Separator />

        <div className="space-y-3">
          <div className="flex flex-wrap items-center justify-between gap-2">
            <p className="text-sm font-medium">Filter by date & time</p>
            <div className="flex items-center gap-2">
              <Button
                type="button"
                size="sm"
                variant={filterMode === "between" ? "default" : "outline"}
                onClick={() => setFilterMode("between")}
              >
                Between
              </Button>
              <Button
                type="button"
                size="sm"
                variant={filterMode === "exact" ? "default" : "outline"}
                onClick={() => setFilterMode("exact")}
              >
                Exact
              </Button>
              <Button
                type="button"
                size="sm"
                variant="ghost"
                onClick={() => {
                  setFilterFromDate("")
                  setFilterFromTime("")
                  setFilterToDate("")
                  setFilterToTime("")
                  setFilterExactDate("")
                  setFilterExactTime("")
                }}
              >
                Clear
              </Button>
            </div>
          </div>

          {filterMode === "between" ? (
            <div className="grid gap-2 sm:grid-cols-2">
              <div className="grid gap-2 sm:grid-cols-2">
                <Input
                  type="date"
                  value={filterFromDate}
                  onChange={(e) => setFilterFromDate(e.target.value)}
                />
                <Input
                  type="time"
                  value={filterFromTime}
                  onChange={(e) => setFilterFromTime(e.target.value)}
                />
              </div>
              <div className="grid gap-2 sm:grid-cols-2">
                <Input
                  type="date"
                  value={filterToDate}
                  onChange={(e) => setFilterToDate(e.target.value)}
                />
                <Input
                  type="time"
                  value={filterToTime}
                  onChange={(e) => setFilterToTime(e.target.value)}
                />
              </div>
            </div>
          ) : (
            <div className="grid gap-2 sm:grid-cols-2">
              <Input
                type="date"
                value={filterExactDate}
                onChange={(e) => setFilterExactDate(e.target.value)}
              />
              <Input
                type="time"
                value={filterExactTime}
                onChange={(e) => setFilterExactTime(e.target.value)}
              />
            </div>
          )}
        </div>

        <Separator />

        <div className="space-y-2">
          {groupedTodos.length === 0 ? (
            <p className="text-muted-foreground text-sm">No tasks yet.</p>
          ) : (
            groupedTodos.map((group) => (
              <div key={group.date} className="space-y-2">
                <div className="flex items-center gap-3 pt-2">
                  <Separator className="flex-1" />
                  <span className="text-muted-foreground whitespace-nowrap text-xs font-medium">
                    {new Intl.DateTimeFormat(undefined, {
                      weekday: "short",
                      year: "numeric",
                      month: "short",
                      day: "2-digit",
                    }).format(parseLocalDateOnly(group.date))}
                  </span>
                  <Separator className="flex-1" />
                </div>

                {group.items.map((todo) => {
                  const flags = getTaskFlags(todo, nowMs, inProgressTaskId)

                  return (
                    <div
                      key={todo.id}
                      className={cn(
                        "rounded-lg border px-3 py-2",
                        flags.completed && "opacity-75",
                        flags.overdue &&
                          "border-destructive/40 bg-destructive/5 text-muted-foreground",
                        flags.inProgress && "border-sky-500/40 bg-sky-500/10",
                        conflictDueAt &&
                          todo.dueAt === conflictDueAt &&
                          "border-destructive/60 bg-destructive/5 ring-1 ring-destructive/30"
                      )}
                    >
                      <div className="flex items-start justify-between gap-3">
                        <label className="flex cursor-pointer items-start gap-3">
                        <Checkbox
                          checked={todo.completed}
                          onCheckedChange={(v) => {
                            const next = Boolean(v)
                            toggleTodo(todo.id, next)
                            if (next && !todo.completed) {
                              requestAttachmentsForTodo(todo.id)
                            }
                          }}
                          aria-label={`Mark "${todo.title}" as ${
                            todo.completed ? "not completed" : "completed"
                          }`}
                          className="mt-0.5"
                        />
                        <span
                          className={cn(
                            "leading-6",
                            todo.completed && "text-muted-foreground line-through"
                          )}
                        >
                          <span className="flex flex-wrap items-center gap-2">
                            <span className="block">{todo.title}</span>
                              <span className="flex flex-wrap items-center gap-2">
                                <TaskBadges {...flags} />
                              </span>
                            {todo.description && (
                              <TooltipProvider>
                                <Tooltip>
                                  <TooltipTrigger asChild>
                                    <button
                                      type="button"
                                      className="text-muted-foreground hover:text-foreground inline-flex h-7 w-7 items-center justify-center rounded-md border bg-background"
                                      aria-label="View description"
                                    >
                                      <Info className="h-4 w-4" />
                                    </button>
                                  </TooltipTrigger>
                                  <TooltipContent className="max-w-xs">
                                    <p className="whitespace-pre-wrap text-sm">
                                      {todo.description}
                                    </p>
                                  </TooltipContent>
                                </Tooltip>
                              </TooltipProvider>
                            )}
                          </span>
                          <span className="text-muted-foreground block text-xs">
                            Due: {formatLocalDateTime(todo.dueAt)}
                          </span>
                        </span>
                      </label>

                      <div className="flex items-center gap-1">
                        {!todo.completed && (
                          <Button
                            type="button"
                            variant={flags.inProgress ? "default" : "outline"}
                            size="sm"
                            onClick={() =>
                              setInProgressTaskId((cur) =>
                                cur === todo.id ? null : todo.id
                              )
                            }
                            className={cn(
                              flags.inProgress && "bg-sky-600 hover:bg-sky-600"
                            )}
                          >
                            {flags.inProgress ? (
                              <>
                                <CircleStop className="mr-1 h-4 w-4" />
                                Stop
                              </>
                            ) : (
                              <>
                                <CirclePlay className="mr-1 h-4 w-4" />
                                Start
                              </>
                            )}
                          </Button>
                        )}
                        {todo.completed && (
                          <Button
                            type="button"
                            variant="outline"
                            size="sm"
                            onClick={() => requestAttachmentsForTodo(todo.id)}
                          >
                            Add files
                          </Button>
                        )}
                        <Button
                          type="button"
                          variant="ghost"
                          size="icon"
                          aria-label={`Delete "${todo.title}"`}
                          onClick={() => deleteTodo(todo.id)}
                        >
                          <Trash2 className="h-4 w-4" />
                        </Button>
                      </div>
                    </div>

                    {todo.completed && todo.attachments.length > 0 && (
                      <div className="mt-3 space-y-2">
                        <p className="text-muted-foreground text-xs">Attachments</p>
                        <ul className="space-y-1">
                          {todo.attachments.map((a) => (
                            <li
                              key={a.id}
                              className="flex items-center justify-between gap-3 rounded-md bg-muted/30 px-2 py-1"
                            >
                              <div className="flex min-w-0 items-center gap-2">
                                <AttachmentIcon kind={a.kind} />
                                <span className="truncate text-sm">{a.name}</span>
                              </div>
                              <a
                                href={a.url}
                                download={a.name}
                                className="inline-flex items-center gap-1 text-sm font-medium underline underline-offset-4"
                              >
                                <Download className="h-4 w-4" />
                                Download
                              </a>
                            </li>
                          ))}
                        </ul>
                      </div>
                    )}
                  </div>
                  )
                })}
              </div>
            ))
          )}
        </div>

        {groupedTodos.length > 0 && (
          <div className="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
            <div className="flex items-center gap-2">
              <span className="text-muted-foreground text-sm">Items per page</span>
              <Select
                value={String(pageSize)}
                onValueChange={(v) => {
                  const next = Number(v)
                  setPageSize(next)
                  setPage(1)
                }}
              >
                <SelectTrigger className="w-[110px]">
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="5">5</SelectItem>
                  <SelectItem value="10">10</SelectItem>
                  <SelectItem value="15">15</SelectItem>
                  <SelectItem value="20">20</SelectItem>
                </SelectContent>
              </Select>
            </div>

            {showPagination && (
              <div className="flex items-center justify-between gap-3 sm:justify-end">
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={() => setPage((p) => Math.max(1, p - 1))}
                  disabled={page <= 1}
                >
                  Prev
                </Button>
                <span className="text-muted-foreground text-sm">
                  Page {page} of {totalPages}
                </span>
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={() => setPage((p) => Math.min(totalPages, p + 1))}
                  disabled={page >= totalPages}
                >
                  Next
                </Button>
              </div>
            )}
          </div>
        )}

        <div className="flex items-center justify-between gap-2">
          <Button
            type="button"
            variant="secondary"
            onClick={clearCompleted}
            disabled={completedCount === 0}
          >
            Clear completed
          </Button>
          <span className="text-muted-foreground text-sm">
            Mock data only (no backend)
          </span>
    </div>
      </CardContent>
    </Card>
  )
}

```

```typescriptreact
"use client"

import { zodResolver } from "@hookform/resolvers/zod"
import {
  AlertTriangle,
  CirclePlay,
  CircleStop,
  CalendarClock,
  CheckCircle2,
  Download,
  File,
  FileSpreadsheet,
  FileText,
  Image as ImageIcon,
  Info,
  Music,
  Bell,
  Timer,
  Trash2,
  Video,
} from "lucide-react"
import * as React from "react"
import { useForm } from "react-hook-form"
import { toast } from "sonner"
import { z } from "zod"
import type { SupabaseClient, User } from "@supabase/supabase-js"

import { ModeToggle } from "@/components/mode-toggle"
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert"
import { Badge } from "@/components/ui/badge"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Checkbox } from "@/components/ui/checkbox"
import { Form, FormControl, FormField, FormItem, FormMessage } from "@/components/ui/form"
import { Input } from "@/components/ui/input"
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select"
import { Separator } from "@/components/ui/separator"
import { Textarea } from "@/components/ui/textarea"
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip"
import { cn } from "@/lib/utils"
import { createBrowserSupabaseClient } from "@/lib/supabase/client"

type AttachmentKind =
  | "image"
  | "audio"
  | "video"
  | "pdf"
  | "spreadsheet"
  | "document"
  | "text"
  | "file"

type Attachment = {
  id: string
  name: string
  type: string
  size: number
  bucket: string
  path: string
  kind: AttachmentKind
}

type Todo = {
  id: string
  title: string
  description?: string
  completed: boolean
  // Stored as `datetime-local` string (YYYY-MM-DDTHH:mm) in local time.
  dueAt: string
  attachments: Attachment[]
}

type TaskState = "planned" | "in_progress" | "completed" | "overdue"
type DailyLoad = "light" | "balanced" | "heavy"

const todoSchema = z.object({
  title: z
    .string()
    .trim()
    .min(1, "Title is required.")
    .max(80, "Keep it under 80 characters."),
  description: z
    .string()
    .trim()
    .max(500, "Keep it under 500 characters.")
    .optional()
    .or(z.literal("")),
  dueAt: z
    .string()
    .min(1, "Due date & time is required.")
    .regex(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}$/, "Invalid date/time."),
})

type TodoFormValues = z.infer<typeof todoSchema>

const initialTodos: Todo[] = [
  {
    id: "1",
    title: "Create a Next.js app",
    description: "Scaffold with TypeScript + Tailwind and confirm it runs locally.",
    completed: true,
    dueAt: "2026-01-16T09:00",
    attachments: [],
  },
  {
    id: "2",
    title: "Add shadcn/ui + dark theme",
    description: "Initialize shadcn, set up theme provider, and verify dark mode.",
    completed: true,
    dueAt: "2026-01-16T10:30",
    attachments: [],
  },
  {
    id: "3",
    title: "Build a mock-data to-do list",
    completed: false,
    dueAt: "2026-01-16T15:00",
    attachments: [],
  },
  {
    id: "4",
    title: "Yesterday: review requirements",
    completed: true,
    dueAt: "2026-01-15T11:15",
    attachments: [],
  },
  {
    id: "5",
    title: "Yesterday: sketch UI layout",
    completed: true,
    dueAt: "2026-01-15T17:45",
    attachments: [],
  },
  {
    id: "6",
    title: "Today: add attachments support",
    completed: false,
    dueAt: "2026-01-16T18:20",
    attachments: [],
  },
  {
    id: "7",
    title: "Tomorrow: QA the filters",
    description: "Test date-only, time-only, exact, and between behaviors.",
    completed: false,
    dueAt: "2026-01-17T08:05",
    attachments: [],
  },
  {
    id: "8",
    title: "Tomorrow: polish summary cards",
    completed: false,
    dueAt: "2026-01-17T13:30",
    attachments: [],
  },
  {
    id: "9",
    title: "Tomorrow: write small UX notes",
    completed: false,
    dueAt: "2026-01-17T20:10",
    attachments: [],
  },
  {
    id: "10",
    title: "This weekend: add more mock tasks",
    completed: false,
    dueAt: "2026-01-18T10:00",
    attachments: [],
  },
  {
    id: "11",
    title: "This weekend: check time-only filter",
    completed: false,
    dueAt: "2026-01-18T22:15",
    attachments: [],
  },
  {
    id: "12",
    title: "Next week: sync with team",
    completed: false,
    dueAt: "2026-01-19T09:30",
    attachments: [],
  },
  {
    id: "13",
    title: "Next week: test date-only filter",
    completed: false,
    dueAt: "2026-01-20T14:05",
    attachments: [],
  },
  {
    id: "14",
    title: "Next week: test exact date+time filter",
    completed: false,
    dueAt: "2026-01-21T12:00",
    attachments: [],
  },
  {
    id: "15",
    title: "Next week: attach docs to completed tasks",
    completed: false,
    dueAt: "2026-01-22T16:40",
    attachments: [],
  },
  {
    id: "16",
    title: "Next week: final review",
    completed: false,
    dueAt: "2026-01-23T11:00",
    attachments: [],
  },
]

type DbTaskRow = {
  id: string
  user_id: string
  title: string
  description: string | null
  due_at: string
  completed: boolean
  in_progress: boolean
  attachments: unknown
}

function coerceAttachments(raw: unknown): Attachment[] {
  if (!raw || typeof raw !== "object") return []
  if (!Array.isArray(raw)) return []
  return raw.filter(Boolean) as Attachment[]
}

function toDbTaskInsert(values: TodoFormValues, userId: string) {
  return {
    user_id: userId,
    title: values.title.trim(),
    description: (values.description ?? "").trim() || null,
    due_at: values.dueAt,
    completed: false,
    in_progress: false,
    attachments: [],
  }
}

function fromDbTask(row: DbTaskRow): Todo {
  return {
    id: row.id,
    title: row.title,
    description: row.description ?? undefined,
    completed: row.completed,
    dueAt: row.due_at,
    attachments: coerceAttachments(row.attachments),
  }
}

function parseLocalDateTime(value: string): number {
  // value: "YYYY-MM-DDTHH:mm"
  const [datePart, timePart] = value.split("T")
  const [y, m, d] = datePart.split("-").map(Number)
  const [hh, mm] = timePart.split(":").map(Number)
  return new Date(y, m - 1, d, hh, mm, 0, 0).getTime()
}

function pad2(n: number) {
  return String(n).padStart(2, "0")
}

function localDateKey(d: Date) {
  return `${d.getFullYear()}-${pad2(d.getMonth() + 1)}-${pad2(d.getDate())}`
}

function addDays(date: Date, days: number) {
  const d = new Date(date)
  d.setDate(d.getDate() + days)
  return d
}

function startOfDay(date: Date) {
  return new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0, 0)
}

function endOfDay(date: Date) {
  return new Date(
    date.getFullYear(),
    date.getMonth(),
    date.getDate(),
    23,
    59,
    59,
    999
  )
}

function getDatePart(dueAt: string) {
  return dueAt.split("T")[0] ?? ""
}

function getTimePart(dueAt: string) {
  return dueAt.split("T")[1] ?? ""
}

function parseLocalDateOnly(value: string): Date {
  // value: "YYYY-MM-DD"
  const [y, m, d] = value.split("-").map(Number)
  return new Date(y, m - 1, d, 0, 0, 0, 0)
}

function parseLocalTimeToMinutes(value: string): number {
  // value: "HH:mm"
  const [hh, mm] = value.split(":").map(Number)
  return hh * 60 + mm
}

function formatLocalDateTime(value: string): string {
  const ms = parseLocalDateTime(value)
  if (!Number.isFinite(ms)) return value
  return new Intl.DateTimeFormat(undefined, {
    year: "numeric",
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  }).format(new Date(ms))
}

function formatDateTimeFromMs(ms: number): string {
  return new Intl.DateTimeFormat(undefined, {
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  }).format(new Date(ms))
}

function minutesUntil(targetMs: number, nowMs: number) {
  return Math.ceil((targetMs - nowMs) / 60_000)
}

function getTaskFlags(todo: Todo, nowMs: number, inProgressTaskId: string | null) {
  const completed = todo.completed
  const dueMs = parseLocalDateTime(todo.dueAt)
  const overdue = !completed && dueMs < nowMs
  const inProgress = !completed && inProgressTaskId === todo.id
  const planned = !completed && !overdue && !inProgress
  return { completed, overdue, inProgress, planned }
}

function getDailyLoad(todosForDay: Todo[]) {
  // 4-hour windows across the day (local).
  const labels = [
    "00:00–04:00",
    "04:00–08:00",
    "08:00–12:00",
    "12:00–16:00",
    "16:00–20:00",
    "20:00–24:00",
  ]
  const buckets = Array.from({ length: 6 }, () => 0) as number[]
  for (const t of todosForDay) {
    const ms = parseLocalDateTime(t.dueAt)
    const hour = new Date(ms).getHours()
    const idx = Math.floor(hour / 4)
    buckets[idx] = (buckets[idx] ?? 0) + 1
  }

  const total = todosForDay.length
  const peak = Math.max(0, ...buckets)
  const spread = buckets.filter((c) => c > 0).length
  const busiestIdx = buckets.findIndex((c) => c === peak)
  const busiestWindow = busiestIdx >= 0 ? labels[busiestIdx] : labels[0]

  // Heuristic: more tasks + higher concentration in one window => heavier day.
  const score = total + peak * 1.5 + Math.max(0, spread - 1) * 0.5
  const load: DailyLoad = score <= 5 ? "light" : score <= 10 ? "balanced" : "heavy"

  return { load, total, peak, spread, busiestWindow }
}

function DailyLoadBadge({ load }: { load: DailyLoad }) {
  if (load === "heavy") return <Badge variant="destructive">Heavy</Badge>
  if (load === "balanced") return <Badge variant="secondary">Balanced</Badge>
  return <Badge variant="outline">Light</Badge>
}

function TaskBadges({
  completed,
  overdue,
  inProgress,
  planned,
}: {
  completed: boolean
  overdue: boolean
  inProgress: boolean
  planned: boolean
}) {
  if (completed) {
    return (
      <Badge className="gap-1 bg-emerald-600 text-white hover:bg-emerald-600">
        <CheckCircle2 className="h-3.5 w-3.5" />
        Completed
      </Badge>
    )
  }

  return (
    <>
      {inProgress && (
        <Badge className="gap-1 bg-sky-600 text-white hover:bg-sky-600">
          <Timer className="h-3.5 w-3.5 text-white" />
          In progress
        </Badge>
      )}
      {overdue && (
        <Badge variant="destructive" className="gap-1">
          <AlertTriangle className="h-3.5 w-3.5" />
          Overdue
        </Badge>
      )}
      {planned && (
        <Badge variant="outline" className="gap-1">
          <CalendarClock className="h-3.5 w-3.5" />
          Planned
        </Badge>
      )}
    </>
  )
}

function getAttachmentKind(file: File): AttachmentKind {
  const type = (file.type || "").toLowerCase()
  const name = file.name.toLowerCase()
  const ext = name.includes(".") ? name.split(".").pop() ?? "" : ""

  if (type.startsWith("image/")) return "image"
  if (type.startsWith("audio/")) return "audio"
  if (type.startsWith("video/")) return "video"

  if (ext === "pdf") return "pdf"
  if (["xls", "xlsx", "csv"].includes(ext)) return "spreadsheet"
  if (["doc", "docx"].includes(ext)) return "document"
  if (["txt", "md", "rtf"].includes(ext)) return "text"

  return "file"
}

function sanitizePathSegment(s: string) {
  return s.replace(/[^\w.\-]+/g, "_")
}

function buildAttachmentRecord(file: File, bucket: string, path: string): Attachment {
  return {
    id: crypto.randomUUID(),
    name: file.name,
    type: file.type,
    size: file.size,
    bucket,
    path,
    kind: getAttachmentKind(file),
  }
}

function AttachmentIcon({ kind }: { kind: AttachmentKind }) {
  const className = "h-4 w-4 text-muted-foreground"

  switch (kind) {
    case "image":
      return <ImageIcon className={className} />
    case "audio":
      return <Music className={className} />
    case "video":
      return <Video className={className} />
    case "spreadsheet":
      return <FileSpreadsheet className={className} />
    case "pdf":
    case "document":
    case "text":
      return <FileText className={className} />
    default:
      return <File className={className} />
  }
}

const authSchema = z.object({
  email: z.string().email("Enter a valid email."),
  password: z.string().min(6, "Password must be at least 6 characters."),
})
type AuthValues = z.infer<typeof authSchema>

function AuthCard({ supabase }: { supabase: SupabaseClient }) {
  const [mode, setMode] = React.useState<"sign_in" | "sign_up">("sign_in")
  const [busy, setBusy] = React.useState(false)

  const form = useForm<AuthValues>({
    resolver: zodResolver(authSchema),
    defaultValues: { email: "", password: "" },
  })

  async function onSubmit(values: AuthValues) {
    setBusy(true)
    try {
      if (mode === "sign_in") {
        const { error } = await supabase.auth.signInWithPassword(values)
        if (error) throw error
      } else {
        const { error } = await supabase.auth.signUp(values)
        if (error) throw error
        toast.success("Account created", { description: "You can now sign in." })
        setMode("sign_in")
      }
    } catch (e) {
      toast.error("Authentication failed", {
        description: e instanceof Error ? e.message : "Please try again.",
      })
    } finally {
      setBusy(false)
    }
  }

  return (
    <div className="mx-auto flex min-h-screen max-w-md flex-col justify-center px-4 py-10">
      <Card>
        <CardHeader>
          <CardTitle className="text-2xl">Sign in</CardTitle>
          <p className="text-muted-foreground text-sm">
            {mode === "sign_in"
              ? "Use your email and password."
              : "Create an account with email and password."}
          </p>
        </CardHeader>
        <CardContent className="space-y-4">
          <Form {...form}>
            <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-3" noValidate>
              <FormField
                control={form.control}
                name="email"
                render={({ field }) => (
                  <FormItem>
                    <FormControl>
                      <Input placeholder="Email" autoComplete="email" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="password"
                render={({ field }) => (
                  <FormItem>
                    <FormControl>
                      <Input
                        type="password"
                        placeholder="Password"
                        autoComplete={
                          mode === "sign_in" ? "current-password" : "new-password"
                        }
                        {...field}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <Button type="submit" className="w-full" disabled={busy}>
                {mode === "sign_in" ? "Sign in" : "Sign up"}
              </Button>
            </form>
          </Form>

          <div className="flex items-center justify-between gap-3 text-sm">
            <span className="text-muted-foreground">
              {mode === "sign_in" ? "No account?" : "Already have an account?"}
            </span>
            <Button
              type="button"
              variant="link"
              className="px-0"
              onClick={() => setMode((m) => (m === "sign_in" ? "sign_up" : "sign_in"))}
            >
              {mode === "sign_in" ? "Sign up" : "Sign in"}
            </Button>
          </div>
        </CardContent>
      </Card>
    </div>
  )
}

export default function Home() {
  const [supabaseError, setSupabaseError] = React.useState<string | null>(null)
  const supabase = React.useMemo(() => {
    try {
      return createBrowserSupabaseClient()
    } catch (e) {
      setSupabaseError(e instanceof Error ? e.message : "Supabase is not configured.")
      return null
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [])

  const [user, setUser] = React.useState<User | null>(null)
  const [authLoading, setAuthLoading] = React.useState(true)

  React.useEffect(() => {
    if (!supabase) return
    let alive = true
    supabase.auth.getUser().then(({ data }) => {
      if (!alive) return
      setUser(data.user ?? null)
      setAuthLoading(false)
    })
    const { data } = supabase.auth.onAuthStateChange((_event, session) => {
      setUser(session?.user ?? null)
    })
    return () => {
      alive = false
      data.subscription.unsubscribe()
    }
  }, [supabase])

  if (supabaseError) {
    return (
      <div className="mx-auto flex min-h-screen max-w-2xl flex-col justify-center gap-4 px-4 py-10">
        <Card>
          <CardHeader>
            <CardTitle>Supabase not configured</CardTitle>
          </CardHeader>
          <CardContent className="space-y-2">
            <p className="text-muted-foreground text-sm">{supabaseError}</p>
            <p className="text-muted-foreground text-sm">
              See <code>SUPABASE_SETUP.md</code> and <code>supabase.env.example</code>.
            </p>
          </CardContent>
        </Card>
      </div>
    )
  }

  if (!supabase) return null
  if (authLoading) {
    return (
      <div className="mx-auto flex min-h-screen max-w-2xl flex-col justify-center px-4 py-10">
        <p className="text-muted-foreground text-sm">Loading…</p>
      </div>
    )
  }

  if (!user) return <AuthCard supabase={supabase} />

  return (
    <div className="mx-auto flex min-h-screen max-w-2xl flex-col gap-6 px-4 py-10">
      <TodoApp supabase={supabase} user={user} />
    </div>
  )
}

function TodoApp({ supabase, user }: { supabase: SupabaseClient; user: User }) {
  const userId = user.id
  const [todos, setTodos] = React.useState<Todo[]>([])
  const [tasksLoading, setTasksLoading] = React.useState(true)
  const [attachTargetTodoId, setAttachTargetTodoId] = React.useState<string | null>(
    null
  )
  const [conflictDueAt, setConflictDueAt] = React.useState<string | null>(null)
  const clearConflictTimerRef = React.useRef<number | null>(null)
  const [focusMode, setFocusMode] = React.useState(false)
  const [nowMs, setNowMs] = React.useState(() => Date.now())
  const [inProgressTaskId, setInProgressTaskId] = React.useState<string | null>(null)
  const [dismissedReminderTaskId, setDismissedReminderTaskId] = React.useState<
    string | null
  >(null)
  const [filterMode, setFilterMode] = React.useState<"between" | "exact">("between")
  const [filterFromDate, setFilterFromDate] = React.useState<string>("")
  const [filterFromTime, setFilterFromTime] = React.useState<string>("")
  const [filterToDate, setFilterToDate] = React.useState<string>("")
  const [filterToTime, setFilterToTime] = React.useState<string>("")
  const [filterExactDate, setFilterExactDate] = React.useState<string>("")
  const [filterExactTime, setFilterExactTime] = React.useState<string>("")
  const fileInputRef = React.useRef<HTMLInputElement>(null)
  const [pageSize, setPageSize] = React.useState<number>(5)
  const [page, setPage] = React.useState<number>(1)

  React.useEffect(() => {
    let alive = true
    async function load() {
      setTasksLoading(true)
      const { data, error } = await supabase
        .from("tasks")
        .select("*")
        .eq("user_id", userId)
        .order("due_at", { ascending: true })
      if (!alive) return
      if (error) {
        toast.error("Failed to load tasks", { description: error.message })
        setTodos([])
        setInProgressTaskId(null)
      } else {
        const rows = (data ?? []) as DbTaskRow[]
        setTodos(rows.map(fromDbTask))
        setInProgressTaskId(rows.find((r) => r.in_progress)?.id ?? null)
      }
      setTasksLoading(false)
    }
    load()
    return () => {
      alive = false
    }
  }, [supabase, userId])

  // Keep "now" fresh so overdue/in-progress states stay accurate without user interaction.
  React.useEffect(() => {
    const id = window.setInterval(() => setNowMs(Date.now()), 30_000)
    return () => window.clearInterval(id)
  }, [])

  // Only one task can be "In Progress"; auto-clear if completed, deleted, or overdue.
  React.useEffect(() => {
    if (!inProgressTaskId) return
    const t = todos.find((x) => x.id === inProgressTaskId)
    if (!t || t.completed) {
      setInProgressTaskId(null)
      return
    }
  }, [inProgressTaskId, nowMs, todos])

  const nextUpcoming = React.useMemo(() => {
    const upcoming = todos
      .filter((t) => !t.completed)
      .map((t) => ({ todo: t, dueMs: parseLocalDateTime(t.dueAt) }))
      .filter((x) => x.dueMs >= nowMs)
      .sort((a, b) => a.dueMs - b.dueMs)[0]
    return upcoming ?? null
  }, [nowMs, todos])

  React.useEffect(() => {
    // If "next upcoming" changed, allow reminder again (dismiss is per-task).
    if (nextUpcoming && nextUpcoming.todo.id !== dismissedReminderTaskId) return
    if (!nextUpcoming) setDismissedReminderTaskId(null)
  }, [dismissedReminderTaskId, nextUpcoming])

  const reminder = React.useMemo(() => {
    const REMINDER_WINDOW_MIN = 15
    if (!nextUpcoming) return null
    if (dismissedReminderTaskId === nextUpcoming.todo.id) return null
    const mins = minutesUntil(nextUpcoming.dueMs, nowMs)
    if (mins < 0 || mins > REMINDER_WINDOW_MIN) return null
    return { ...nextUpcoming, mins }
  }, [dismissedReminderTaskId, nextUpcoming, nowMs])

  const form = useForm<TodoFormValues>({
    resolver: zodResolver(todoSchema),
    defaultValues: { title: "", description: "", dueAt: "" },
    mode: "onSubmit",
  })

  const summary = React.useMemo(() => {
    const now = new Date()
    const todayKey = localDateKey(now)
    const tomorrow = addDays(now, 1)
    const tomorrowKey = localDateKey(tomorrow)

    const todays = todos.filter((t) => t.dueAt.startsWith(todayKey))
    const todayCompleted = todays.filter((t) => t.completed).length
    const todayPending = todays.length - todayCompleted

    const labels = [
      "00:00–04:00",
      "04:00–08:00",
      "08:00–12:00",
      "12:00–16:00",
      "16:00–20:00",
      "20:00–24:00",
    ]

    // Tomorrow: same 4-hour windows breakdown
    const tomorrowTasks = todos.filter((t) => t.dueAt.startsWith(tomorrowKey))
    const tomorrowBuckets = Array.from({ length: 6 }, () => 0) as number[]
    for (const t of tomorrowTasks) {
      const ms = parseLocalDateTime(t.dueAt)
      const hour = new Date(ms).getHours()
      const idx = Math.floor(hour / 4)
      tomorrowBuckets[idx] = (tomorrowBuckets[idx] ?? 0) + 1
    }

    // Until next week = next 7 days starting tomorrow (local), grouped into 4-hour windows.
    const rangeStart = startOfDay(tomorrow).getTime()
    const rangeEnd = addDays(startOfDay(tomorrow), 7).getTime()
    const buckets = Array.from({ length: 6 }, () => 0) as number[]

    const upcoming = todos.filter((t) => {
      const ms = parseLocalDateTime(t.dueAt)
      return ms >= rangeStart && ms < rangeEnd
    })

    for (const t of upcoming) {
      const ms = parseLocalDateTime(t.dueAt)
      const hour = new Date(ms).getHours()
      const idx = Math.floor(hour / 4)
      buckets[idx] = (buckets[idx] ?? 0) + 1
    }

    return {
      todayCompleted,
      todayPending,
      tomorrowTotal: tomorrowTasks.length,
      tomorrowBuckets: labels.map((label, i) => ({ label, count: tomorrowBuckets[i] ?? 0 })),
      upcomingTotal: upcoming.length,
      upcomingBuckets: labels.map((label, i) => ({ label, count: buckets[i] ?? 0 })),
    }
  }, [todos])

  const loadDayKey = React.useMemo(() => {
    // Prefer an explicitly selected date from filters; otherwise use today.
    if (filterMode === "exact" && filterExactDate) return filterExactDate
    if (filterFromDate && !filterToDate) return filterFromDate
    if (filterFromDate && filterToDate && filterFromDate === filterToDate) return filterFromDate
    if (!filterFromDate && filterToDate) return filterToDate
    return localDateKey(new Date(nowMs))
  }, [filterExactDate, filterFromDate, filterMode, filterToDate, nowMs])

  const dailyLoad = React.useMemo(() => {
    const dayTodos = todos.filter((t) => getDatePart(t.dueAt) === loadDayKey)
    return getDailyLoad(dayTodos)
  }, [loadDayKey, todos])

  const filteredTodos = React.useMemo(() => {
    if (focusMode) {
      const endMs = nowMs + 4 * 60 * 60 * 1000
      const withMs = todos.map((t) => ({ ...t, _dueMs: parseLocalDateTime(t.dueAt) }))
      return withMs.filter((t) => t._dueMs >= nowMs && t._dueMs <= endMs)
    }

    const withMs = todos.map((t) => ({ ...t, _dueMs: parseLocalDateTime(t.dueAt) }))
    if (filterMode === "exact") {
      // If only date is selected -> show tasks for that date.
      // If time is selected too -> match exact date+time.
      // If only time is selected -> match time-of-day across all dates.
      if (!filterExactDate && !filterExactTime) return withMs

      if (filterExactDate && !filterExactTime) {
        return withMs.filter((t) => getDatePart(t.dueAt) === filterExactDate)
      }

      if (filterExactDate && filterExactTime) {
        const exactMs = parseLocalDateTime(`${filterExactDate}T${filterExactTime}`)
        return withMs.filter((t) => t._dueMs === exactMs)
      }

      // time only
      return withMs.filter((t) => getTimePart(t.dueAt) === filterExactTime)
    }
    // between
    const hasAnyDate = Boolean(filterFromDate || filterToDate)
    const hasAnyTime = Boolean(filterFromTime || filterToTime)

    // Date range (optional)
    const fromDateMs = filterFromDate
      ? startOfDay(parseLocalDateOnly(filterFromDate)).getTime()
      : Number.NEGATIVE_INFINITY
    const toDateMs = filterToDate
      ? endOfDay(parseLocalDateOnly(filterToDate)).getTime()
      : Number.POSITIVE_INFINITY

    // Time-of-day range (optional)
    const fromTimeMin = filterFromTime ? parseLocalTimeToMinutes(filterFromTime) : 0
    const toTimeMin = filterToTime ? parseLocalTimeToMinutes(filterToTime) : 24 * 60 - 1

    return withMs.filter((t) => {
      const ms = t._dueMs
      if (hasAnyDate && (ms < fromDateMs || ms > toDateMs)) return false

      if (hasAnyTime) {
        const time = getTimePart(t.dueAt)
        if (!time) return false
        const mins = parseLocalTimeToMinutes(time)
        // Simple (non-wrapping) range. If you want wrap-around (e.g. 22:00–02:00), tell me.
        if (mins < fromTimeMin || mins > toTimeMin) return false
      }

      // If neither date nor time selected, pass through (handled above anyway)
      return true
    })
  }, [
    todos,
    focusMode,
    nowMs,
    filterExactDate,
    filterExactTime,
    filterFromDate,
    filterFromTime,
    filterMode,
    filterToDate,
    filterToTime,
  ])

  const sortedFilteredTodos = React.useMemo(
    () =>
      filteredTodos
        .slice()
        .sort((a, b) => parseLocalDateTime(a.dueAt) - parseLocalDateTime(b.dueAt)),
    [filteredTodos]
  )

  // Clamp page when filters/pageSize change.
  React.useEffect(() => {
    const totalPages = Math.max(1, Math.ceil(sortedFilteredTodos.length / pageSize))
    setPage((p) => Math.min(Math.max(1, p), totalPages))
  }, [pageSize, sortedFilteredTodos.length])

  const totalItems = sortedFilteredTodos.length
  const totalPages = Math.max(1, Math.ceil(totalItems / pageSize))
  const showPagination = totalPages > 1

  const pageItems = React.useMemo(() => {
    const start = (page - 1) * pageSize
    return sortedFilteredTodos.slice(start, start + pageSize)
  }, [page, pageSize, sortedFilteredTodos])

  const groupedTodos = React.useMemo(() => {
    const groups: Array<{ date: string; items: typeof pageItems }> = []
    for (const t of pageItems) {
      const date = getDatePart(t.dueAt)
      const last = groups[groups.length - 1]
      if (!last || last.date !== date) groups.push({ date, items: [t] })
      else last.items.push(t)
    }
    return groups
  }, [pageItems])

  const completedCount = filteredTodos.filter((t) => t.completed).length

  async function addTodo(values: TodoFormValues) {
    const conflicts = todos.filter((t) => t.dueAt === values.dueAt)
    if (conflicts.length > 0) {
      setConflictDueAt(values.dueAt)
      if (clearConflictTimerRef.current) window.clearTimeout(clearConflictTimerRef.current)
      clearConflictTimerRef.current = window.setTimeout(() => {
        setConflictDueAt(null)
      }, 8000)

      // Make sure the user can see the conflicting tasks even if they were filtered out.
      const [d, time] = values.dueAt.split("T")
      setFilterMode("exact")
      setFilterExactDate(d ?? "")
      setFilterExactTime(time ?? "")
      setPage(1)

      toast.error("Time conflict", {
        description: `You already have ${conflicts.length} task(s) scheduled at ${formatLocalDateTime(
          values.dueAt
        )}.`,
      })
    }

    const { data, error } = await supabase
      .from("tasks")
      .insert(toDbTaskInsert(values, userId))
      .select("*")
      .single()
    if (error) {
      toast.error("Failed to add task", { description: error.message })
      return
    }

    setTodos((prev) => [fromDbTask(data as DbTaskRow), ...prev])
    form.reset()
  }

  async function toggleTodo(id: string, completed: boolean) {
    // optimistic
    setTodos((prev) =>
      prev.map((t) =>
        t.id === id ? { ...t, completed, attachments: t.attachments } : t
      )
    )
    if (completed) setInProgressTaskId((cur) => (cur === id ? null : cur))

    const update: { completed: boolean; in_progress?: boolean } = { completed }
    if (completed) update.in_progress = false

    const { error } = await supabase
      .from("tasks")
      .update(update)
      .eq("id", id)
      .eq("user_id", userId)
    if (error) {
      toast.error("Failed to update task", { description: error.message })
    }
  }

  function requestAttachmentsForTodo(todoId: string) {
    setAttachTargetTodoId(todoId)
    // Let state update before opening picker (some browsers are picky).
    queueMicrotask(() => fileInputRef.current?.click())
  }

  async function handleFilesPicked(e: React.ChangeEvent<HTMLInputElement>) {
    const files = Array.from(e.target.files ?? [])
    const targetId = attachTargetTodoId

    // reset input so picking the same file again triggers onChange
    e.target.value = ""
    setAttachTargetTodoId(null)

    if (!targetId || files.length === 0) return
    const targetTodo = todos.find((t) => t.id === targetId)
    if (!targetTodo) return

    const bucket = "task-attachments"
    const uploaded: Attachment[] = []

    for (const file of files) {
      const safeName = sanitizePathSegment(file.name)
      const path = `${userId}/${targetId}/${crypto.randomUUID()}-${safeName}`
      const { error } = await supabase.storage
        .from(bucket)
        .upload(path, file, { contentType: file.type, upsert: false })
      if (error) {
        toast.error("Upload failed", { description: error.message })
        continue
      }
      uploaded.push(buildAttachmentRecord(file, bucket, path))
    }

    if (uploaded.length === 0) return
    const nextAttachments = [...targetTodo.attachments, ...uploaded]

    // optimistic
    setTodos((prev) =>
      prev.map((t) => (t.id === targetId ? { ...t, attachments: nextAttachments } : t))
    )

    const { error } = await supabase
      .from("tasks")
      .update({ attachments: nextAttachments })
      .eq("id", targetId)
      .eq("user_id", userId)
    if (error) {
      toast.error("Failed to save attachments", { description: error.message })
    }
  }

  async function deleteTodo(id: string) {
    // optimistic
    setTodos((prev) => prev.filter((t) => t.id !== id))
    setInProgressTaskId((cur) => (cur === id ? null : cur))

    const { error } = await supabase.from("tasks").delete().eq("id", id).eq("user_id", userId)
    if (error) toast.error("Failed to delete task", { description: error.message })
  }

  async function clearCompleted() {
    const completedIds = new Set(todos.filter((t) => t.completed).map((t) => t.id))
    if (completedIds.size === 0) return

    // optimistic
    setTodos((prev) => prev.filter((t) => !completedIds.has(t.id)))

    const { error } = await supabase
      .from("tasks")
      .delete()
      .eq("user_id", userId)
      .eq("completed", true)
    if (error) toast.error("Failed to clear completed", { description: error.message })
  }

  return (
    <Card>
      <CardHeader className="flex flex-row items-center justify-between gap-4">
        <div className="space-y-1">
          <CardTitle className="text-2xl">To‑Do</CardTitle>
          <p className="text-muted-foreground text-sm">
            {completedCount}/{filteredTodos.length} completed
          </p>
        </div>
        <div className="flex items-center gap-2">
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <Button
                  type="button"
                  variant={focusMode ? "default" : "outline"}
                  size="sm"
                  onClick={() => {
                    setFocusMode((v) => !v)
                    setPage(1)
                  }}
                >
                  Focus Mode
                </Button>
              </TooltipTrigger>
              <TooltipContent>
                <p>Show tasks for the next 4 hours.</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
          <ModeToggle />
        </div>
      </CardHeader>

      <CardContent className="space-y-6">
        <input
          ref={fileInputRef}
          type="file"
          multiple
          className="hidden"
          accept={[
            "image/*",
            "audio/*",
            "video/*",
            ".pdf",
            ".doc",
            ".docx",
            ".xls",
            ".xlsx",
            ".csv",
            ".txt",
            ".md",
            ".rtf",
          ].join(",")}
          onChange={handleFilesPicked}
        />

        {reminder && (
          <Alert className="border-primary/30 bg-primary/5">
            <Bell className="h-4 w-4" />
            <div className="flex flex-1 flex-col gap-1">
              <div className="flex flex-wrap items-center justify-between gap-2">
                <AlertTitle className="text-sm">
                  Next task starts in {reminder.mins} minute{reminder.mins === 1 ? "" : "s"}
                </AlertTitle>
                <Button
                  type="button"
                  variant="ghost"
                  size="sm"
                  onClick={() => setDismissedReminderTaskId(reminder.todo.id)}
                >
                  Dismiss
                </Button>
              </div>
              <AlertDescription className="text-sm">
                <span className="font-medium">{reminder.todo.title}</span> ·{" "}
                {formatDateTimeFromMs(reminder.dueMs)}
              </AlertDescription>
            </div>
          </Alert>
        )}

        <div className="rounded-xl border bg-card p-4">
          <div className="flex flex-wrap items-center justify-between gap-2">
            <p className="text-sm font-medium">
              Daily load{" "}
              <span className="text-muted-foreground font-normal">
                ({new Intl.DateTimeFormat(undefined, {
                  weekday: "short",
                  year: "numeric",
                  month: "short",
                  day: "2-digit",
                }).format(parseLocalDateOnly(loadDayKey))})
              </span>
            </p>
            <DailyLoadBadge load={dailyLoad.load} />
          </div>
          <p className="text-muted-foreground mt-2 text-sm">
            {dailyLoad.total} task(s) · busiest window {dailyLoad.busiestWindow} ({dailyLoad.peak})
          </p>
        </div>

        <div className="grid gap-3 sm:grid-cols-3">
          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Today’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">
              {summary.todayCompleted} completed
            </p>
            <p className="text-muted-foreground text-sm">{summary.todayPending} pending</p>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tomorrow’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">{summary.tomorrowTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.tomorrowBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tasks Until Next Week</p>
            <p className="mt-2 text-2xl font-semibold">{summary.upcomingTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.upcomingBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>
        </div>

        {focusMode && (
          <div className="flex flex-col gap-1 rounded-lg border bg-muted/20 px-3 py-2 sm:flex-row sm:items-center sm:justify-between">
            <p className="text-sm">
              <span className="font-medium">Focus Mode:</span>{" "}
              showing tasks due in the next 4 hours (until{" "}
              <span className="font-medium">
                {formatDateTimeFromMs(nowMs + 4 * 60 * 60 * 1000)}
              </span>
              )
            </p>
            <Button type="button" variant="ghost" size="sm" onClick={() => setFocusMode(false)}>
              Exit
            </Button>
          </div>
        )}

        <Form {...form}>
          <form
            onSubmit={form.handleSubmit(addTodo)}
            className="space-y-2"
            noValidate
          >
            <div className="flex flex-col gap-2 sm:flex-row">
              <FormField
                control={form.control}
                name="title"
                render={({ field }) => (
                  <FormItem className="flex-1">
                    <FormControl>
                      <Input
                        placeholder="Add a task…"
                        autoComplete="off"
                        {...field}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="dueAt"
                render={({ field }) => (
                  <FormItem className="sm:w-64">
                    <FormControl>
                      <Input type="datetime-local" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <Button type="submit">Add</Button>
            </div>

            <FormField
              control={form.control}
              name="description"
              render={({ field }) => (
                <FormItem>
                  <FormControl>
                    <Textarea
                      rows={3}
                      placeholder="Description (optional)…"
                      {...field}
                    />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />
          </form>
        </Form>

        <Separator />

        <div className="space-y-3">
          <div className="flex flex-wrap items-center justify-between gap-2">
            <p className="text-sm font-medium">Filter by date & time</p>
            <div className="flex items-center gap-2">
              <Button
                type="button"
                size="sm"
                variant={filterMode === "between" ? "default" : "outline"}
                onClick={() => setFilterMode("between")}
              >
                Between
              </Button>
              <Button
                type="button"
                size="sm"
                variant={filterMode === "exact" ? "default" : "outline"}
                onClick={() => setFilterMode("exact")}
              >
                Exact
              </Button>
              <Button
                type="button"
                size="sm"
                variant="ghost"
                onClick={() => {
                  setFilterFromDate("")
                  setFilterFromTime("")
                  setFilterToDate("")
                  setFilterToTime("")
                  setFilterExactDate("")
                  setFilterExactTime("")
                }}
              >
                Clear
              </Button>
            </div>
          </div>

          {filterMode === "between" ? (
            <div className="grid gap-2 sm:grid-cols-2">
              <div className="grid gap-2 sm:grid-cols-2">
                <Input
                  type="date"
                  value={filterFromDate}
                  onChange={(e) => setFilterFromDate(e.target.value)}
                />
                <Input
                  type="time"
                  value={filterFromTime}
                  onChange={(e) => setFilterFromTime(e.target.value)}
                />
              </div>
              <div className="grid gap-2 sm:grid-cols-2">
                <Input
                  type="date"
                  value={filterToDate}
                  onChange={(e) => setFilterToDate(e.target.value)}
                />
                <Input
                  type="time"
                  value={filterToTime}
                  onChange={(e) => setFilterToTime(e.target.value)}
                />
              </div>
            </div>
          ) : (
            <div className="grid gap-2 sm:grid-cols-2">
              <Input
                type="date"
                value={filterExactDate}
                onChange={(e) => setFilterExactDate(e.target.value)}
              />
              <Input
                type="time"
                value={filterExactTime}
                onChange={(e) => setFilterExactTime(e.target.value)}
              />
            </div>
          )}
        </div>

        <Separator />

        <div className="space-y-2">
          {groupedTodos.length === 0 ? (
            <p className="text-muted-foreground text-sm">No tasks yet.</p>
          ) : (
            groupedTodos.map((group) => (
              <div key={group.date} className="space-y-2">
                <div className="flex items-center gap-3 pt-2">
                  <Separator className="flex-1" />
                  <span className="text-muted-foreground whitespace-nowrap text-xs font-medium">
                    {new Intl.DateTimeFormat(undefined, {
                      weekday: "short",
                      year: "numeric",
                      month: "short",
                      day: "2-digit",
                    }).format(parseLocalDateOnly(group.date))}
                  </span>
                  <Separator className="flex-1" />
                </div>

                {group.items.map((todo) => {
                  const flags = getTaskFlags(todo, nowMs, inProgressTaskId)

                  return (
                    <div
                      key={todo.id}
                      className={cn(
                        "rounded-lg border px-3 py-2",
                        flags.completed && "opacity-75",
                        flags.overdue &&
                          "border-destructive/40 bg-destructive/5 text-muted-foreground",
                        flags.inProgress && "border-sky-500/40 bg-sky-500/10",
                        conflictDueAt &&
                          todo.dueAt === conflictDueAt &&
                          "border-destructive/60 bg-destructive/5 ring-1 ring-destructive/30"
                      )}
                    >
                      <div className="flex items-start justify-between gap-3">
                        <label className="flex cursor-pointer items-start gap-3">
                        <Checkbox
                          checked={todo.completed}
                          onCheckedChange={(v) => {
                            const next = Boolean(v)
                            toggleTodo(todo.id, next)
                            if (next && !todo.completed) {
                              requestAttachmentsForTodo(todo.id)
                            }
                          }}
                          aria-label={`Mark "${todo.title}" as ${
                            todo.completed ? "not completed" : "completed"
                          }`}
                          className="mt-0.5"
                        />
                        <span
                          className={cn(
                            "leading-6",
                            todo.completed && "text-muted-foreground line-through"
                          )}
                        >
                          <span className="flex flex-wrap items-center gap-2">
                            <span className="block">{todo.title}</span>
                              <span className="flex flex-wrap items-center gap-2">
                                <TaskBadges {...flags} />
                              </span>
                            {todo.description && (
                              <TooltipProvider>
                                <Tooltip>
                                  <TooltipTrigger asChild>
                                    <button
                                      type="button"
                                      className="text-muted-foreground hover:text-foreground inline-flex h-7 w-7 items-center justify-center rounded-md border bg-background"
                                      aria-label="View description"
                                    >
                                      <Info className="h-4 w-4" />
                                    </button>
                                  </TooltipTrigger>
                                  <TooltipContent className="max-w-xs">
                                    <p className="whitespace-pre-wrap text-sm">
                                      {todo.description}
                                    </p>
                                  </TooltipContent>
                                </Tooltip>
                              </TooltipProvider>
                            )}
                          </span>
                          <span className="text-muted-foreground block text-xs">
                            Due: {formatLocalDateTime(todo.dueAt)}
                          </span>
                        </span>
                      </label>

                      <div className="flex items-center gap-1">
                        {!todo.completed && (
                          <Button
                            type="button"
                            variant={flags.inProgress ? "default" : "outline"}
                            size="sm"
                            onClick={() =>
                              setInProgressTaskId((cur) =>
                                cur === todo.id ? null : todo.id
                              )
                            }
                            className={cn(
                              flags.inProgress && "bg-sky-600 hover:bg-sky-600"
                            )}
                          >
                            {flags.inProgress ? (
                              <>
                                <CircleStop className="mr-1 h-4 w-4" />
                                Stop
                              </>
                            ) : (
                              <>
                                <CirclePlay className="mr-1 h-4 w-4" />
                                Start
                              </>
                            )}
                          </Button>
                        )}
                        {todo.completed && (
                          <Button
                            type="button"
                            variant="outline"
                            size="sm"
                            onClick={() => requestAttachmentsForTodo(todo.id)}
                          >
                            Add files
                          </Button>
                        )}
                        <Button
                          type="button"
                          variant="ghost"
                          size="icon"
                          aria-label={`Delete "${todo.title}"`}
                          onClick={() => deleteTodo(todo.id)}
                        >
                          <Trash2 className="h-4 w-4" />
                        </Button>
                      </div>
                    </div>

                    {todo.completed && todo.attachments.length > 0 && (
                      <div className="mt-3 space-y-2">
                        <p className="text-muted-foreground text-xs">Attachments</p>
                        <ul className="space-y-1">
                          {todo.attachments.map((a) => (
                            <li
                              key={a.id}
                              className="flex items-center justify-between gap-3 rounded-md bg-muted/30 px-2 py-1"
                            >
                              <div className="flex min-w-0 items-center gap-2">
                                <AttachmentIcon kind={a.kind} />
                                <span className="truncate text-sm">{a.name}</span>
                              </div>
                              <a
                                href={a.url}
                                download={a.name}
                                className="inline-flex items-center gap-1 text-sm font-medium underline underline-offset-4"
                              >
                                <Download className="h-4 w-4" />
                                Download
                              </a>
                            </li>
                          ))}
                        </ul>
                      </div>
                    )}
                  </div>
                  )
                })}
              </div>
            ))
          )}
        </div>

        {groupedTodos.length > 0 && (
          <div className="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
            <div className="flex items-center gap-2">
              <span className="text-muted-foreground text-sm">Items per page</span>
              <Select
                value={String(pageSize)}
                onValueChange={(v) => {
                  const next = Number(v)
                  setPageSize(next)
                  setPage(1)
                }}
              >
                <SelectTrigger className="w-[110px]">
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="5">5</SelectItem>
                  <SelectItem value="10">10</SelectItem>
                  <SelectItem value="15">15</SelectItem>
                  <SelectItem value="20">20</SelectItem>
                </SelectContent>
              </Select>
            </div>

            {showPagination && (
              <div className="flex items-center justify-between gap-3 sm:justify-end">
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={() => setPage((p) => Math.max(1, p - 1))}
                  disabled={page <= 1}
                >
                  Prev
                </Button>
                <span className="text-muted-foreground text-sm">
                  Page {page} of {totalPages}
                </span>
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={() => setPage((p) => Math.min(totalPages, p + 1))}
                  disabled={page >= totalPages}
                >
                  Next
                </Button>
              </div>
            )}
          </div>
        )}

        <div className="flex items-center justify-between gap-2">
          <Button
            type="button"
            variant="secondary"
            onClick={clearCompleted}
            disabled={completedCount === 0}
          >
            Clear completed
          </Button>
          <span className="text-muted-foreground text-sm">
            Mock data only (no backend)
          </span>
    </div>
      </CardContent>
    </Card>
  )
}

```

```typescriptreact
"use client"

import { zodResolver } from "@hookform/resolvers/zod"
import {
  AlertTriangle,
  CirclePlay,
  CircleStop,
  CalendarClock,
  CheckCircle2,
  Download,
  File,
  FileSpreadsheet,
  FileText,
  Image as ImageIcon,
  Info,
  Music,
  Bell,
  Timer,
  Trash2,
  Video,
} from "lucide-react"
import * as React from "react"
import { useForm } from "react-hook-form"
import { toast } from "sonner"
import { z } from "zod"
import type { SupabaseClient, User } from "@supabase/supabase-js"

import { ModeToggle } from "@/components/mode-toggle"
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert"
import { Badge } from "@/components/ui/badge"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Checkbox } from "@/components/ui/checkbox"
import { Form, FormControl, FormField, FormItem, FormMessage } from "@/components/ui/form"
import { Input } from "@/components/ui/input"
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select"
import { Separator } from "@/components/ui/separator"
import { Textarea } from "@/components/ui/textarea"
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip"
import { cn } from "@/lib/utils"
import { createBrowserSupabaseClient } from "@/lib/supabase/client"

type AttachmentKind =
  | "image"
  | "audio"
  | "video"
  | "pdf"
  | "spreadsheet"
  | "document"
  | "text"
  | "file"

type Attachment = {
  id: string
  name: string
  type: string
  size: number
  bucket: string
  path: string
  kind: AttachmentKind
}

type Todo = {
  id: string
  title: string
  description?: string
  completed: boolean
  // Stored as `datetime-local` string (YYYY-MM-DDTHH:mm) in local time.
  dueAt: string
  attachments: Attachment[]
}

type TaskState = "planned" | "in_progress" | "completed" | "overdue"
type DailyLoad = "light" | "balanced" | "heavy"

const todoSchema = z.object({
  title: z
    .string()
    .trim()
    .min(1, "Title is required.")
    .max(80, "Keep it under 80 characters."),
  description: z
    .string()
    .trim()
    .max(500, "Keep it under 500 characters.")
    .optional()
    .or(z.literal("")),
  dueAt: z
    .string()
    .min(1, "Due date & time is required.")
    .regex(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}$/, "Invalid date/time."),
})

type TodoFormValues = z.infer<typeof todoSchema>

const initialTodos: Todo[] = [
  {
    id: "1",
    title: "Create a Next.js app",
    description: "Scaffold with TypeScript + Tailwind and confirm it runs locally.",
    completed: true,
    dueAt: "2026-01-16T09:00",
    attachments: [],
  },
  {
    id: "2",
    title: "Add shadcn/ui + dark theme",
    description: "Initialize shadcn, set up theme provider, and verify dark mode.",
    completed: true,
    dueAt: "2026-01-16T10:30",
    attachments: [],
  },
  {
    id: "3",
    title: "Build a mock-data to-do list",
    completed: false,
    dueAt: "2026-01-16T15:00",
    attachments: [],
  },
  {
    id: "4",
    title: "Yesterday: review requirements",
    completed: true,
    dueAt: "2026-01-15T11:15",
    attachments: [],
  },
  {
    id: "5",
    title: "Yesterday: sketch UI layout",
    completed: true,
    dueAt: "2026-01-15T17:45",
    attachments: [],
  },
  {
    id: "6",
    title: "Today: add attachments support",
    completed: false,
    dueAt: "2026-01-16T18:20",
    attachments: [],
  },
  {
    id: "7",
    title: "Tomorrow: QA the filters",
    description: "Test date-only, time-only, exact, and between behaviors.",
    completed: false,
    dueAt: "2026-01-17T08:05",
    attachments: [],
  },
  {
    id: "8",
    title: "Tomorrow: polish summary cards",
    completed: false,
    dueAt: "2026-01-17T13:30",
    attachments: [],
  },
  {
    id: "9",
    title: "Tomorrow: write small UX notes",
    completed: false,
    dueAt: "2026-01-17T20:10",
    attachments: [],
  },
  {
    id: "10",
    title: "This weekend: add more mock tasks",
    completed: false,
    dueAt: "2026-01-18T10:00",
    attachments: [],
  },
  {
    id: "11",
    title: "This weekend: check time-only filter",
    completed: false,
    dueAt: "2026-01-18T22:15",
    attachments: [],
  },
  {
    id: "12",
    title: "Next week: sync with team",
    completed: false,
    dueAt: "2026-01-19T09:30",
    attachments: [],
  },
  {
    id: "13",
    title: "Next week: test date-only filter",
    completed: false,
    dueAt: "2026-01-20T14:05",
    attachments: [],
  },
  {
    id: "14",
    title: "Next week: test exact date+time filter",
    completed: false,
    dueAt: "2026-01-21T12:00",
    attachments: [],
  },
  {
    id: "15",
    title: "Next week: attach docs to completed tasks",
    completed: false,
    dueAt: "2026-01-22T16:40",
    attachments: [],
  },
  {
    id: "16",
    title: "Next week: final review",
    completed: false,
    dueAt: "2026-01-23T11:00",
    attachments: [],
  },
]

type DbTaskRow = {
  id: string
  user_id: string
  title: string
  description: string | null
  due_at: string
  completed: boolean
  in_progress: boolean
  attachments: unknown
}

function coerceAttachments(raw: unknown): Attachment[] {
  if (!raw || typeof raw !== "object") return []
  if (!Array.isArray(raw)) return []
  return raw.filter(Boolean) as Attachment[]
}

function toDbTaskInsert(values: TodoFormValues, userId: string) {
  return {
    user_id: userId,
    title: values.title.trim(),
    description: (values.description ?? "").trim() || null,
    due_at: values.dueAt,
    completed: false,
    in_progress: false,
    attachments: [],
  }
}

function fromDbTask(row: DbTaskRow): Todo {
  return {
    id: row.id,
    title: row.title,
    description: row.description ?? undefined,
    completed: row.completed,
    dueAt: row.due_at,
    attachments: coerceAttachments(row.attachments),
  }
}

function parseLocalDateTime(value: string): number {
  // value: "YYYY-MM-DDTHH:mm"
  const [datePart, timePart] = value.split("T")
  const [y, m, d] = datePart.split("-").map(Number)
  const [hh, mm] = timePart.split(":").map(Number)
  return new Date(y, m - 1, d, hh, mm, 0, 0).getTime()
}

function pad2(n: number) {
  return String(n).padStart(2, "0")
}

function localDateKey(d: Date) {
  return `${d.getFullYear()}-${pad2(d.getMonth() + 1)}-${pad2(d.getDate())}`
}

function addDays(date: Date, days: number) {
  const d = new Date(date)
  d.setDate(d.getDate() + days)
  return d
}

function startOfDay(date: Date) {
  return new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0, 0)
}

function endOfDay(date: Date) {
  return new Date(
    date.getFullYear(),
    date.getMonth(),
    date.getDate(),
    23,
    59,
    59,
    999
  )
}

function getDatePart(dueAt: string) {
  return dueAt.split("T")[0] ?? ""
}

function getTimePart(dueAt: string) {
  return dueAt.split("T")[1] ?? ""
}

function parseLocalDateOnly(value: string): Date {
  // value: "YYYY-MM-DD"
  const [y, m, d] = value.split("-").map(Number)
  return new Date(y, m - 1, d, 0, 0, 0, 0)
}

function parseLocalTimeToMinutes(value: string): number {
  // value: "HH:mm"
  const [hh, mm] = value.split(":").map(Number)
  return hh * 60 + mm
}

function formatLocalDateTime(value: string): string {
  const ms = parseLocalDateTime(value)
  if (!Number.isFinite(ms)) return value
  return new Intl.DateTimeFormat(undefined, {
    year: "numeric",
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  }).format(new Date(ms))
}

function formatDateTimeFromMs(ms: number): string {
  return new Intl.DateTimeFormat(undefined, {
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  }).format(new Date(ms))
}

function minutesUntil(targetMs: number, nowMs: number) {
  return Math.ceil((targetMs - nowMs) / 60_000)
}

function getTaskFlags(todo: Todo, nowMs: number, inProgressTaskId: string | null) {
  const completed = todo.completed
  const dueMs = parseLocalDateTime(todo.dueAt)
  const overdue = !completed && dueMs < nowMs
  const inProgress = !completed && inProgressTaskId === todo.id
  const planned = !completed && !overdue && !inProgress
  return { completed, overdue, inProgress, planned }
}

function getDailyLoad(todosForDay: Todo[]) {
  // 4-hour windows across the day (local).
  const labels = [
    "00:00–04:00",
    "04:00–08:00",
    "08:00–12:00",
    "12:00–16:00",
    "16:00–20:00",
    "20:00–24:00",
  ]
  const buckets = Array.from({ length: 6 }, () => 0) as number[]
  for (const t of todosForDay) {
    const ms = parseLocalDateTime(t.dueAt)
    const hour = new Date(ms).getHours()
    const idx = Math.floor(hour / 4)
    buckets[idx] = (buckets[idx] ?? 0) + 1
  }

  const total = todosForDay.length
  const peak = Math.max(0, ...buckets)
  const spread = buckets.filter((c) => c > 0).length
  const busiestIdx = buckets.findIndex((c) => c === peak)
  const busiestWindow = busiestIdx >= 0 ? labels[busiestIdx] : labels[0]

  // Heuristic: more tasks + higher concentration in one window => heavier day.
  const score = total + peak * 1.5 + Math.max(0, spread - 1) * 0.5
  const load: DailyLoad = score <= 5 ? "light" : score <= 10 ? "balanced" : "heavy"

  return { load, total, peak, spread, busiestWindow }
}

function DailyLoadBadge({ load }: { load: DailyLoad }) {
  if (load === "heavy") return <Badge variant="destructive">Heavy</Badge>
  if (load === "balanced") return <Badge variant="secondary">Balanced</Badge>
  return <Badge variant="outline">Light</Badge>
}

function TaskBadges({
  completed,
  overdue,
  inProgress,
  planned,
}: {
  completed: boolean
  overdue: boolean
  inProgress: boolean
  planned: boolean
}) {
  if (completed) {
    return (
      <Badge className="gap-1 bg-emerald-600 text-white hover:bg-emerald-600">
        <CheckCircle2 className="h-3.5 w-3.5" />
        Completed
      </Badge>
    )
  }

  return (
    <>
      {inProgress && (
        <Badge className="gap-1 bg-sky-600 text-white hover:bg-sky-600">
          <Timer className="h-3.5 w-3.5 text-white" />
          In progress
        </Badge>
      )}
      {overdue && (
        <Badge variant="destructive" className="gap-1">
          <AlertTriangle className="h-3.5 w-3.5" />
          Overdue
        </Badge>
      )}
      {planned && (
        <Badge variant="outline" className="gap-1">
          <CalendarClock className="h-3.5 w-3.5" />
          Planned
        </Badge>
      )}
    </>
  )
}

function getAttachmentKind(file: File): AttachmentKind {
  const type = (file.type || "").toLowerCase()
  const name = file.name.toLowerCase()
  const ext = name.includes(".") ? name.split(".").pop() ?? "" : ""

  if (type.startsWith("image/")) return "image"
  if (type.startsWith("audio/")) return "audio"
  if (type.startsWith("video/")) return "video"

  if (ext === "pdf") return "pdf"
  if (["xls", "xlsx", "csv"].includes(ext)) return "spreadsheet"
  if (["doc", "docx"].includes(ext)) return "document"
  if (["txt", "md", "rtf"].includes(ext)) return "text"

  return "file"
}

function sanitizePathSegment(s: string) {
  return s.replace(/[^\w.\-]+/g, "_")
}

function buildAttachmentRecord(file: File, bucket: string, path: string): Attachment {
  return {
    id: crypto.randomUUID(),
    name: file.name,
    type: file.type,
    size: file.size,
    bucket,
    path,
    kind: getAttachmentKind(file),
  }
}

function AttachmentIcon({ kind }: { kind: AttachmentKind }) {
  const className = "h-4 w-4 text-muted-foreground"

  switch (kind) {
    case "image":
      return <ImageIcon className={className} />
    case "audio":
      return <Music className={className} />
    case "video":
      return <Video className={className} />
    case "spreadsheet":
      return <FileSpreadsheet className={className} />
    case "pdf":
    case "document":
    case "text":
      return <FileText className={className} />
    default:
      return <File className={className} />
  }
}

const authSchema = z.object({
  email: z.string().email("Enter a valid email."),
  password: z.string().min(6, "Password must be at least 6 characters."),
})
type AuthValues = z.infer<typeof authSchema>

function AuthCard({ supabase }: { supabase: SupabaseClient }) {
  const [mode, setMode] = React.useState<"sign_in" | "sign_up">("sign_in")
  const [busy, setBusy] = React.useState(false)

  const form = useForm<AuthValues>({
    resolver: zodResolver(authSchema),
    defaultValues: { email: "", password: "" },
  })

  async function onSubmit(values: AuthValues) {
    setBusy(true)
    try {
      if (mode === "sign_in") {
        const { error } = await supabase.auth.signInWithPassword(values)
        if (error) throw error
      } else {
        const { error } = await supabase.auth.signUp(values)
        if (error) throw error
        toast.success("Account created", { description: "You can now sign in." })
        setMode("sign_in")
      }
    } catch (e) {
      toast.error("Authentication failed", {
        description: e instanceof Error ? e.message : "Please try again.",
      })
    } finally {
      setBusy(false)
    }
  }

  return (
    <div className="mx-auto flex min-h-screen max-w-md flex-col justify-center px-4 py-10">
      <Card>
        <CardHeader>
          <CardTitle className="text-2xl">Sign in</CardTitle>
          <p className="text-muted-foreground text-sm">
            {mode === "sign_in"
              ? "Use your email and password."
              : "Create an account with email and password."}
          </p>
        </CardHeader>
        <CardContent className="space-y-4">
          <Form {...form}>
            <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-3" noValidate>
              <FormField
                control={form.control}
                name="email"
                render={({ field }) => (
                  <FormItem>
                    <FormControl>
                      <Input placeholder="Email" autoComplete="email" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="password"
                render={({ field }) => (
                  <FormItem>
                    <FormControl>
                      <Input
                        type="password"
                        placeholder="Password"
                        autoComplete={
                          mode === "sign_in" ? "current-password" : "new-password"
                        }
                        {...field}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <Button type="submit" className="w-full" disabled={busy}>
                {mode === "sign_in" ? "Sign in" : "Sign up"}
              </Button>
            </form>
          </Form>

          <div className="flex items-center justify-between gap-3 text-sm">
            <span className="text-muted-foreground">
              {mode === "sign_in" ? "No account?" : "Already have an account?"}
            </span>
            <Button
              type="button"
              variant="link"
              className="px-0"
              onClick={() => setMode((m) => (m === "sign_in" ? "sign_up" : "sign_in"))}
            >
              {mode === "sign_in" ? "Sign up" : "Sign in"}
            </Button>
          </div>
        </CardContent>
      </Card>
    </div>
  )
}

export default function Home() {
  const [supabaseError, setSupabaseError] = React.useState<string | null>(null)
  const supabase = React.useMemo(() => {
    try {
      return createBrowserSupabaseClient()
    } catch (e) {
      setSupabaseError(e instanceof Error ? e.message : "Supabase is not configured.")
      return null
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [])

  const [user, setUser] = React.useState<User | null>(null)
  const [authLoading, setAuthLoading] = React.useState(true)

  React.useEffect(() => {
    if (!supabase) return
    let alive = true
    supabase.auth.getUser().then(({ data }) => {
      if (!alive) return
      setUser(data.user ?? null)
      setAuthLoading(false)
    })
    const { data } = supabase.auth.onAuthStateChange((_event, session) => {
      setUser(session?.user ?? null)
    })
    return () => {
      alive = false
      data.subscription.unsubscribe()
    }
  }, [supabase])

  if (supabaseError) {
    return (
      <div className="mx-auto flex min-h-screen max-w-2xl flex-col justify-center gap-4 px-4 py-10">
        <Card>
          <CardHeader>
            <CardTitle>Supabase not configured</CardTitle>
          </CardHeader>
          <CardContent className="space-y-2">
            <p className="text-muted-foreground text-sm">{supabaseError}</p>
            <p className="text-muted-foreground text-sm">
              See <code>SUPABASE_SETUP.md</code> and <code>supabase.env.example</code>.
            </p>
          </CardContent>
        </Card>
      </div>
    )
  }

  if (!supabase) return null
  if (authLoading) {
    return (
      <div className="mx-auto flex min-h-screen max-w-2xl flex-col justify-center px-4 py-10">
        <p className="text-muted-foreground text-sm">Loading…</p>
      </div>
    )
  }

  if (!user) return <AuthCard supabase={supabase} />

  return (
    <div className="mx-auto flex min-h-screen max-w-2xl flex-col gap-6 px-4 py-10">
      <TodoApp supabase={supabase} user={user} />
    </div>
  )
}

function TodoApp({ supabase, user }: { supabase: SupabaseClient; user: User }) {
  const userId = user.id
  const [todos, setTodos] = React.useState<Todo[]>([])
  const [tasksLoading, setTasksLoading] = React.useState(true)
  const [attachTargetTodoId, setAttachTargetTodoId] = React.useState<string | null>(
    null
  )
  const [conflictDueAt, setConflictDueAt] = React.useState<string | null>(null)
  const clearConflictTimerRef = React.useRef<number | null>(null)
  const [focusMode, setFocusMode] = React.useState(false)
  const [nowMs, setNowMs] = React.useState(() => Date.now())
  const [inProgressTaskId, setInProgressTaskId] = React.useState<string | null>(null)
  const [dismissedReminderTaskId, setDismissedReminderTaskId] = React.useState<
    string | null
  >(null)
  const [filterMode, setFilterMode] = React.useState<"between" | "exact">("between")
  const [filterFromDate, setFilterFromDate] = React.useState<string>("")
  const [filterFromTime, setFilterFromTime] = React.useState<string>("")
  const [filterToDate, setFilterToDate] = React.useState<string>("")
  const [filterToTime, setFilterToTime] = React.useState<string>("")
  const [filterExactDate, setFilterExactDate] = React.useState<string>("")
  const [filterExactTime, setFilterExactTime] = React.useState<string>("")
  const fileInputRef = React.useRef<HTMLInputElement>(null)
  const [pageSize, setPageSize] = React.useState<number>(5)
  const [page, setPage] = React.useState<number>(1)

  React.useEffect(() => {
    let alive = true
    async function load() {
      setTasksLoading(true)
      const { data, error } = await supabase
        .from("tasks")
        .select("*")
        .eq("user_id", userId)
        .order("due_at", { ascending: true })
      if (!alive) return
      if (error) {
        toast.error("Failed to load tasks", { description: error.message })
        setTodos([])
        setInProgressTaskId(null)
      } else {
        const rows = (data ?? []) as DbTaskRow[]
        setTodos(rows.map(fromDbTask))
        setInProgressTaskId(rows.find((r) => r.in_progress)?.id ?? null)
      }
      setTasksLoading(false)
    }
    load()
    return () => {
      alive = false
    }
  }, [supabase, userId])

  // Keep "now" fresh so overdue/in-progress states stay accurate without user interaction.
  React.useEffect(() => {
    const id = window.setInterval(() => setNowMs(Date.now()), 30_000)
    return () => window.clearInterval(id)
  }, [])

  // Only one task can be "In Progress"; auto-clear if completed, deleted, or overdue.
  React.useEffect(() => {
    if (!inProgressTaskId) return
    const t = todos.find((x) => x.id === inProgressTaskId)
    if (!t || t.completed) {
      setInProgressTaskId(null)
      return
    }
  }, [inProgressTaskId, nowMs, todos])

  const nextUpcoming = React.useMemo(() => {
    const upcoming = todos
      .filter((t) => !t.completed)
      .map((t) => ({ todo: t, dueMs: parseLocalDateTime(t.dueAt) }))
      .filter((x) => x.dueMs >= nowMs)
      .sort((a, b) => a.dueMs - b.dueMs)[0]
    return upcoming ?? null
  }, [nowMs, todos])

  React.useEffect(() => {
    // If "next upcoming" changed, allow reminder again (dismiss is per-task).
    if (nextUpcoming && nextUpcoming.todo.id !== dismissedReminderTaskId) return
    if (!nextUpcoming) setDismissedReminderTaskId(null)
  }, [dismissedReminderTaskId, nextUpcoming])

  const reminder = React.useMemo(() => {
    const REMINDER_WINDOW_MIN = 15
    if (!nextUpcoming) return null
    if (dismissedReminderTaskId === nextUpcoming.todo.id) return null
    const mins = minutesUntil(nextUpcoming.dueMs, nowMs)
    if (mins < 0 || mins > REMINDER_WINDOW_MIN) return null
    return { ...nextUpcoming, mins }
  }, [dismissedReminderTaskId, nextUpcoming, nowMs])

  const form = useForm<TodoFormValues>({
    resolver: zodResolver(todoSchema),
    defaultValues: { title: "", description: "", dueAt: "" },
    mode: "onSubmit",
  })

  const summary = React.useMemo(() => {
    const now = new Date()
    const todayKey = localDateKey(now)
    const tomorrow = addDays(now, 1)
    const tomorrowKey = localDateKey(tomorrow)

    const todays = todos.filter((t) => t.dueAt.startsWith(todayKey))
    const todayCompleted = todays.filter((t) => t.completed).length
    const todayPending = todays.length - todayCompleted

    const labels = [
      "00:00–04:00",
      "04:00–08:00",
      "08:00–12:00",
      "12:00–16:00",
      "16:00–20:00",
      "20:00–24:00",
    ]

    // Tomorrow: same 4-hour windows breakdown
    const tomorrowTasks = todos.filter((t) => t.dueAt.startsWith(tomorrowKey))
    const tomorrowBuckets = Array.from({ length: 6 }, () => 0) as number[]
    for (const t of tomorrowTasks) {
      const ms = parseLocalDateTime(t.dueAt)
      const hour = new Date(ms).getHours()
      const idx = Math.floor(hour / 4)
      tomorrowBuckets[idx] = (tomorrowBuckets[idx] ?? 0) + 1
    }

    // Until next week = next 7 days starting tomorrow (local), grouped into 4-hour windows.
    const rangeStart = startOfDay(tomorrow).getTime()
    const rangeEnd = addDays(startOfDay(tomorrow), 7).getTime()
    const buckets = Array.from({ length: 6 }, () => 0) as number[]

    const upcoming = todos.filter((t) => {
      const ms = parseLocalDateTime(t.dueAt)
      return ms >= rangeStart && ms < rangeEnd
    })

    for (const t of upcoming) {
      const ms = parseLocalDateTime(t.dueAt)
      const hour = new Date(ms).getHours()
      const idx = Math.floor(hour / 4)
      buckets[idx] = (buckets[idx] ?? 0) + 1
    }

    return {
      todayCompleted,
      todayPending,
      tomorrowTotal: tomorrowTasks.length,
      tomorrowBuckets: labels.map((label, i) => ({ label, count: tomorrowBuckets[i] ?? 0 })),
      upcomingTotal: upcoming.length,
      upcomingBuckets: labels.map((label, i) => ({ label, count: buckets[i] ?? 0 })),
    }
  }, [todos])

  const loadDayKey = React.useMemo(() => {
    // Prefer an explicitly selected date from filters; otherwise use today.
    if (filterMode === "exact" && filterExactDate) return filterExactDate
    if (filterFromDate && !filterToDate) return filterFromDate
    if (filterFromDate && filterToDate && filterFromDate === filterToDate) return filterFromDate
    if (!filterFromDate && filterToDate) return filterToDate
    return localDateKey(new Date(nowMs))
  }, [filterExactDate, filterFromDate, filterMode, filterToDate, nowMs])

  const dailyLoad = React.useMemo(() => {
    const dayTodos = todos.filter((t) => getDatePart(t.dueAt) === loadDayKey)
    return getDailyLoad(dayTodos)
  }, [loadDayKey, todos])

  const filteredTodos = React.useMemo(() => {
    if (focusMode) {
      const endMs = nowMs + 4 * 60 * 60 * 1000
      const withMs = todos.map((t) => ({ ...t, _dueMs: parseLocalDateTime(t.dueAt) }))
      return withMs.filter((t) => t._dueMs >= nowMs && t._dueMs <= endMs)
    }

    const withMs = todos.map((t) => ({ ...t, _dueMs: parseLocalDateTime(t.dueAt) }))
    if (filterMode === "exact") {
      // If only date is selected -> show tasks for that date.
      // If time is selected too -> match exact date+time.
      // If only time is selected -> match time-of-day across all dates.
      if (!filterExactDate && !filterExactTime) return withMs

      if (filterExactDate && !filterExactTime) {
        return withMs.filter((t) => getDatePart(t.dueAt) === filterExactDate)
      }

      if (filterExactDate && filterExactTime) {
        const exactMs = parseLocalDateTime(`${filterExactDate}T${filterExactTime}`)
        return withMs.filter((t) => t._dueMs === exactMs)
      }

      // time only
      return withMs.filter((t) => getTimePart(t.dueAt) === filterExactTime)
    }
    // between
    const hasAnyDate = Boolean(filterFromDate || filterToDate)
    const hasAnyTime = Boolean(filterFromTime || filterToTime)

    // Date range (optional)
    const fromDateMs = filterFromDate
      ? startOfDay(parseLocalDateOnly(filterFromDate)).getTime()
      : Number.NEGATIVE_INFINITY
    const toDateMs = filterToDate
      ? endOfDay(parseLocalDateOnly(filterToDate)).getTime()
      : Number.POSITIVE_INFINITY

    // Time-of-day range (optional)
    const fromTimeMin = filterFromTime ? parseLocalTimeToMinutes(filterFromTime) : 0
    const toTimeMin = filterToTime ? parseLocalTimeToMinutes(filterToTime) : 24 * 60 - 1

    return withMs.filter((t) => {
      const ms = t._dueMs
      if (hasAnyDate && (ms < fromDateMs || ms > toDateMs)) return false

      if (hasAnyTime) {
        const time = getTimePart(t.dueAt)
        if (!time) return false
        const mins = parseLocalTimeToMinutes(time)
        // Simple (non-wrapping) range. If you want wrap-around (e.g. 22:00–02:00), tell me.
        if (mins < fromTimeMin || mins > toTimeMin) return false
      }

      // If neither date nor time selected, pass through (handled above anyway)
      return true
    })
  }, [
    todos,
    focusMode,
    nowMs,
    filterExactDate,
    filterExactTime,
    filterFromDate,
    filterFromTime,
    filterMode,
    filterToDate,
    filterToTime,
  ])

  const sortedFilteredTodos = React.useMemo(
    () =>
      filteredTodos
        .slice()
        .sort((a, b) => parseLocalDateTime(a.dueAt) - parseLocalDateTime(b.dueAt)),
    [filteredTodos]
  )

  // Clamp page when filters/pageSize change.
  React.useEffect(() => {
    const totalPages = Math.max(1, Math.ceil(sortedFilteredTodos.length / pageSize))
    setPage((p) => Math.min(Math.max(1, p), totalPages))
  }, [pageSize, sortedFilteredTodos.length])

  const totalItems = sortedFilteredTodos.length
  const totalPages = Math.max(1, Math.ceil(totalItems / pageSize))
  const showPagination = totalPages > 1

  const pageItems = React.useMemo(() => {
    const start = (page - 1) * pageSize
    return sortedFilteredTodos.slice(start, start + pageSize)
  }, [page, pageSize, sortedFilteredTodos])

  const groupedTodos = React.useMemo(() => {
    const groups: Array<{ date: string; items: typeof pageItems }> = []
    for (const t of pageItems) {
      const date = getDatePart(t.dueAt)
      const last = groups[groups.length - 1]
      if (!last || last.date !== date) groups.push({ date, items: [t] })
      else last.items.push(t)
    }
    return groups
  }, [pageItems])

  const completedCount = filteredTodos.filter((t) => t.completed).length

  async function addTodo(values: TodoFormValues) {
    const conflicts = todos.filter((t) => t.dueAt === values.dueAt)
    if (conflicts.length > 0) {
      setConflictDueAt(values.dueAt)
      if (clearConflictTimerRef.current) window.clearTimeout(clearConflictTimerRef.current)
      clearConflictTimerRef.current = window.setTimeout(() => {
        setConflictDueAt(null)
      }, 8000)

      // Make sure the user can see the conflicting tasks even if they were filtered out.
      const [d, time] = values.dueAt.split("T")
      setFilterMode("exact")
      setFilterExactDate(d ?? "")
      setFilterExactTime(time ?? "")
      setPage(1)

      toast.error("Time conflict", {
        description: `You already have ${conflicts.length} task(s) scheduled at ${formatLocalDateTime(
          values.dueAt
        )}.`,
      })
    }

    const { data, error } = await supabase
      .from("tasks")
      .insert(toDbTaskInsert(values, userId))
      .select("*")
      .single()
    if (error) {
      toast.error("Failed to add task", { description: error.message })
      return
    }

    setTodos((prev) => [fromDbTask(data as DbTaskRow), ...prev])
    form.reset()
  }

  async function toggleTodo(id: string, completed: boolean) {
    // optimistic
    setTodos((prev) =>
      prev.map((t) =>
        t.id === id ? { ...t, completed, attachments: t.attachments } : t
      )
    )
    if (completed) setInProgressTaskId((cur) => (cur === id ? null : cur))

    const update: { completed: boolean; in_progress?: boolean } = { completed }
    if (completed) update.in_progress = false

    const { error } = await supabase
      .from("tasks")
      .update(update)
      .eq("id", id)
      .eq("user_id", userId)
    if (error) {
      toast.error("Failed to update task", { description: error.message })
    }
  }

  function requestAttachmentsForTodo(todoId: string) {
    setAttachTargetTodoId(todoId)
    // Let state update before opening picker (some browsers are picky).
    queueMicrotask(() => fileInputRef.current?.click())
  }

  async function handleFilesPicked(e: React.ChangeEvent<HTMLInputElement>) {
    const files = Array.from(e.target.files ?? [])
    const targetId = attachTargetTodoId

    // reset input so picking the same file again triggers onChange
    e.target.value = ""
    setAttachTargetTodoId(null)

    if (!targetId || files.length === 0) return
    const targetTodo = todos.find((t) => t.id === targetId)
    if (!targetTodo) return

    const bucket = "task-attachments"
    const uploaded: Attachment[] = []

    for (const file of files) {
      const safeName = sanitizePathSegment(file.name)
      const path = `${userId}/${targetId}/${crypto.randomUUID()}-${safeName}`
      const { error } = await supabase.storage
        .from(bucket)
        .upload(path, file, { contentType: file.type, upsert: false })
      if (error) {
        toast.error("Upload failed", { description: error.message })
        continue
      }
      uploaded.push(buildAttachmentRecord(file, bucket, path))
    }

    if (uploaded.length === 0) return
    const nextAttachments = [...targetTodo.attachments, ...uploaded]

    // optimistic
    setTodos((prev) =>
      prev.map((t) => (t.id === targetId ? { ...t, attachments: nextAttachments } : t))
    )

    const { error } = await supabase
      .from("tasks")
      .update({ attachments: nextAttachments })
      .eq("id", targetId)
      .eq("user_id", userId)
    if (error) {
      toast.error("Failed to save attachments", { description: error.message })
    }
  }

  async function deleteTodo(id: string) {
    // optimistic
    setTodos((prev) => prev.filter((t) => t.id !== id))
    setInProgressTaskId((cur) => (cur === id ? null : cur))

    const { error } = await supabase.from("tasks").delete().eq("id", id).eq("user_id", userId)
    if (error) toast.error("Failed to delete task", { description: error.message })
  }

  async function setInProgress(taskId: string | null) {
    // optimistic
    setInProgressTaskId(taskId)

    // Clear any previous in-progress tasks first (enforces the single-task rule).
    const clearRes = await supabase
      .from("tasks")
      .update({ in_progress: false })
      .eq("user_id", userId)
      .eq("in_progress", true)
    if (clearRes.error) {
      toast.error("Failed to update in-progress", { description: clearRes.error.message })
      return
    }

    if (!taskId) return

    const setRes = await supabase
      .from("tasks")
      .update({ in_progress: true })
      .eq("id", taskId)
      .eq("user_id", userId)
    if (setRes.error) {
      toast.error("Failed to update in-progress", { description: setRes.error.message })
    }
  }

  async function downloadAttachment(a: Attachment) {
    const { data, error } = await supabase.storage.from(a.bucket).createSignedUrl(a.path, 60)
    if (error || !data?.signedUrl) {
      toast.error("Download failed", { description: error?.message ?? "Please try again." })
      return
    }
    window.open(data.signedUrl, "_blank", "noopener,noreferrer")
  }

  async function seedDemoTasks() {
    if (todos.length > 0) return
    const payload = initialTodos.map((t) => ({
      user_id: userId,
      title: t.title,
      description: t.description ?? null,
      due_at: t.dueAt,
      completed: t.completed,
      in_progress: false,
      attachments: [],
    }))
    const { data, error } = await supabase.from("tasks").insert(payload).select("*")
    if (error) {
      toast.error("Failed to seed demo tasks", { description: error.message })
      return
    }
    const rows = (data ?? []) as DbTaskRow[]
    setTodos(rows.map(fromDbTask))
  }

  async function clearCompleted() {
    const completedIds = new Set(todos.filter((t) => t.completed).map((t) => t.id))
    if (completedIds.size === 0) return

    // optimistic
    setTodos((prev) => prev.filter((t) => !completedIds.has(t.id)))

    const { error } = await supabase
      .from("tasks")
      .delete()
      .eq("user_id", userId)
      .eq("completed", true)
    if (error) toast.error("Failed to clear completed", { description: error.message })
  }

  return (
    <Card>
      <CardHeader className="flex flex-row items-center justify-between gap-4">
        <div className="space-y-1">
          <CardTitle className="text-2xl">To‑Do</CardTitle>
          <p className="text-muted-foreground text-sm">
            {completedCount}/{filteredTodos.length} completed
          </p>
        </div>
        <div className="flex items-center gap-2">
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <Button
                  type="button"
                  variant={focusMode ? "default" : "outline"}
                  size="sm"
                  onClick={() => {
                    setFocusMode((v) => !v)
                    setPage(1)
                  }}
                >
                  Focus Mode
                </Button>
              </TooltipTrigger>
              <TooltipContent>
                <p>Show tasks for the next 4 hours.</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
          <ModeToggle />
        </div>
      </CardHeader>

      <CardContent className="space-y-6">
        <input
          ref={fileInputRef}
          type="file"
          multiple
          className="hidden"
          accept={[
            "image/*",
            "audio/*",
            "video/*",
            ".pdf",
            ".doc",
            ".docx",
            ".xls",
            ".xlsx",
            ".csv",
            ".txt",
            ".md",
            ".rtf",
          ].join(",")}
          onChange={handleFilesPicked}
        />

        {reminder && (
          <Alert className="border-primary/30 bg-primary/5">
            <Bell className="h-4 w-4" />
            <div className="flex flex-1 flex-col gap-1">
              <div className="flex flex-wrap items-center justify-between gap-2">
                <AlertTitle className="text-sm">
                  Next task starts in {reminder.mins} minute{reminder.mins === 1 ? "" : "s"}
                </AlertTitle>
                <Button
                  type="button"
                  variant="ghost"
                  size="sm"
                  onClick={() => setDismissedReminderTaskId(reminder.todo.id)}
                >
                  Dismiss
                </Button>
              </div>
              <AlertDescription className="text-sm">
                <span className="font-medium">{reminder.todo.title}</span> ·{" "}
                {formatDateTimeFromMs(reminder.dueMs)}
              </AlertDescription>
            </div>
          </Alert>
        )}

        <div className="rounded-xl border bg-card p-4">
          <div className="flex flex-wrap items-center justify-between gap-2">
            <p className="text-sm font-medium">
              Daily load{" "}
              <span className="text-muted-foreground font-normal">
                ({new Intl.DateTimeFormat(undefined, {
                  weekday: "short",
                  year: "numeric",
                  month: "short",
                  day: "2-digit",
                }).format(parseLocalDateOnly(loadDayKey))})
              </span>
            </p>
            <DailyLoadBadge load={dailyLoad.load} />
          </div>
          <p className="text-muted-foreground mt-2 text-sm">
            {dailyLoad.total} task(s) · busiest window {dailyLoad.busiestWindow} ({dailyLoad.peak})
          </p>
        </div>

        <div className="grid gap-3 sm:grid-cols-3">
          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Today’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">
              {summary.todayCompleted} completed
            </p>
            <p className="text-muted-foreground text-sm">{summary.todayPending} pending</p>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tomorrow’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">{summary.tomorrowTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.tomorrowBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tasks Until Next Week</p>
            <p className="mt-2 text-2xl font-semibold">{summary.upcomingTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.upcomingBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>
        </div>

        {focusMode && (
          <div className="flex flex-col gap-1 rounded-lg border bg-muted/20 px-3 py-2 sm:flex-row sm:items-center sm:justify-between">
            <p className="text-sm">
              <span className="font-medium">Focus Mode:</span>{" "}
              showing tasks due in the next 4 hours (until{" "}
              <span className="font-medium">
                {formatDateTimeFromMs(nowMs + 4 * 60 * 60 * 1000)}
              </span>
              )
            </p>
            <Button type="button" variant="ghost" size="sm" onClick={() => setFocusMode(false)}>
              Exit
            </Button>
          </div>
        )}

        <Form {...form}>
          <form
            onSubmit={form.handleSubmit(addTodo)}
            className="space-y-2"
            noValidate
          >
            <div className="flex flex-col gap-2 sm:flex-row">
              <FormField
                control={form.control}
                name="title"
                render={({ field }) => (
                  <FormItem className="flex-1">
                    <FormControl>
                      <Input
                        placeholder="Add a task…"
                        autoComplete="off"
                        {...field}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="dueAt"
                render={({ field }) => (
                  <FormItem className="sm:w-64">
                    <FormControl>
                      <Input type="datetime-local" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <Button type="submit">Add</Button>
            </div>

            <FormField
              control={form.control}
              name="description"
              render={({ field }) => (
                <FormItem>
                  <FormControl>
                    <Textarea
                      rows={3}
                      placeholder="Description (optional)…"
                      {...field}
                    />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />
          </form>
        </Form>

        <Separator />

        <div className="space-y-3">
          <div className="flex flex-wrap items-center justify-between gap-2">
            <p className="text-sm font-medium">Filter by date & time</p>
            <div className="flex items-center gap-2">
              <Button
                type="button"
                size="sm"
                variant={filterMode === "between" ? "default" : "outline"}
                onClick={() => setFilterMode("between")}
              >
                Between
              </Button>
              <Button
                type="button"
                size="sm"
                variant={filterMode === "exact" ? "default" : "outline"}
                onClick={() => setFilterMode("exact")}
              >
                Exact
              </Button>
              <Button
                type="button"
                size="sm"
                variant="ghost"
                onClick={() => {
                  setFilterFromDate("")
                  setFilterFromTime("")
                  setFilterToDate("")
                  setFilterToTime("")
                  setFilterExactDate("")
                  setFilterExactTime("")
                }}
              >
                Clear
              </Button>
            </div>
          </div>

          {filterMode === "between" ? (
            <div className="grid gap-2 sm:grid-cols-2">
              <div className="grid gap-2 sm:grid-cols-2">
                <Input
                  type="date"
                  value={filterFromDate}
                  onChange={(e) => setFilterFromDate(e.target.value)}
                />
                <Input
                  type="time"
                  value={filterFromTime}
                  onChange={(e) => setFilterFromTime(e.target.value)}
                />
              </div>
              <div className="grid gap-2 sm:grid-cols-2">
                <Input
                  type="date"
                  value={filterToDate}
                  onChange={(e) => setFilterToDate(e.target.value)}
                />
                <Input
                  type="time"
                  value={filterToTime}
                  onChange={(e) => setFilterToTime(e.target.value)}
                />
              </div>
            </div>
          ) : (
            <div className="grid gap-2 sm:grid-cols-2">
              <Input
                type="date"
                value={filterExactDate}
                onChange={(e) => setFilterExactDate(e.target.value)}
              />
              <Input
                type="time"
                value={filterExactTime}
                onChange={(e) => setFilterExactTime(e.target.value)}
              />
            </div>
          )}
        </div>

        <Separator />

        <div className="space-y-2">
          {groupedTodos.length === 0 ? (
            <p className="text-muted-foreground text-sm">No tasks yet.</p>
          ) : (
            groupedTodos.map((group) => (
              <div key={group.date} className="space-y-2">
                <div className="flex items-center gap-3 pt-2">
                  <Separator className="flex-1" />
                  <span className="text-muted-foreground whitespace-nowrap text-xs font-medium">
                    {new Intl.DateTimeFormat(undefined, {
                      weekday: "short",
                      year: "numeric",
                      month: "short",
                      day: "2-digit",
                    }).format(parseLocalDateOnly(group.date))}
                  </span>
                  <Separator className="flex-1" />
                </div>

                {group.items.map((todo) => {
                  const flags = getTaskFlags(todo, nowMs, inProgressTaskId)

                  return (
                    <div
                      key={todo.id}
                      className={cn(
                        "rounded-lg border px-3 py-2",
                        flags.completed && "opacity-75",
                        flags.overdue &&
                          "border-destructive/40 bg-destructive/5 text-muted-foreground",
                        flags.inProgress && "border-sky-500/40 bg-sky-500/10",
                        conflictDueAt &&
                          todo.dueAt === conflictDueAt &&
                          "border-destructive/60 bg-destructive/5 ring-1 ring-destructive/30"
                      )}
                    >
                      <div className="flex items-start justify-between gap-3">
                        <label className="flex cursor-pointer items-start gap-3">
                        <Checkbox
                          checked={todo.completed}
                          onCheckedChange={(v) => {
                            const next = Boolean(v)
                            toggleTodo(todo.id, next)
                            if (next && !todo.completed) {
                              requestAttachmentsForTodo(todo.id)
                            }
                          }}
                          aria-label={`Mark "${todo.title}" as ${
                            todo.completed ? "not completed" : "completed"
                          }`}
                          className="mt-0.5"
                        />
                        <span
                          className={cn(
                            "leading-6",
                            todo.completed && "text-muted-foreground line-through"
                          )}
                        >
                          <span className="flex flex-wrap items-center gap-2">
                            <span className="block">{todo.title}</span>
                              <span className="flex flex-wrap items-center gap-2">
                                <TaskBadges {...flags} />
                              </span>
                            {todo.description && (
                              <TooltipProvider>
                                <Tooltip>
                                  <TooltipTrigger asChild>
                                    <button
                                      type="button"
                                      className="text-muted-foreground hover:text-foreground inline-flex h-7 w-7 items-center justify-center rounded-md border bg-background"
                                      aria-label="View description"
                                    >
                                      <Info className="h-4 w-4" />
                                    </button>
                                  </TooltipTrigger>
                                  <TooltipContent className="max-w-xs">
                                    <p className="whitespace-pre-wrap text-sm">
                                      {todo.description}
                                    </p>
                                  </TooltipContent>
                                </Tooltip>
                              </TooltipProvider>
                            )}
                          </span>
                          <span className="text-muted-foreground block text-xs">
                            Due: {formatLocalDateTime(todo.dueAt)}
                          </span>
                        </span>
                      </label>

                      <div className="flex items-center gap-1">
                        {!todo.completed && (
                          <Button
                            type="button"
                            variant={flags.inProgress ? "default" : "outline"}
                            size="sm"
                            onClick={() =>
                              setInProgressTaskId((cur) =>
                                cur === todo.id ? null : todo.id
                              )
                            }
                            className={cn(
                              flags.inProgress && "bg-sky-600 hover:bg-sky-600"
                            )}
                          >
                            {flags.inProgress ? (
                              <>
                                <CircleStop className="mr-1 h-4 w-4" />
                                Stop
                              </>
                            ) : (
                              <>
                                <CirclePlay className="mr-1 h-4 w-4" />
                                Start
                              </>
                            )}
                          </Button>
                        )}
                        {todo.completed && (
                          <Button
                            type="button"
                            variant="outline"
                            size="sm"
                            onClick={() => requestAttachmentsForTodo(todo.id)}
                          >
                            Add files
                          </Button>
                        )}
                        <Button
                          type="button"
                          variant="ghost"
                          size="icon"
                          aria-label={`Delete "${todo.title}"`}
                          onClick={() => deleteTodo(todo.id)}
                        >
                          <Trash2 className="h-4 w-4" />
                        </Button>
                      </div>
                    </div>

                    {todo.completed && todo.attachments.length > 0 && (
                      <div className="mt-3 space-y-2">
                        <p className="text-muted-foreground text-xs">Attachments</p>
                        <ul className="space-y-1">
                          {todo.attachments.map((a) => (
                            <li
                              key={a.id}
                              className="flex items-center justify-between gap-3 rounded-md bg-muted/30 px-2 py-1"
                            >
                              <div className="flex min-w-0 items-center gap-2">
                                <AttachmentIcon kind={a.kind} />
                                <span className="truncate text-sm">{a.name}</span>
                              </div>
                              <a
                                href={a.url}
                                download={a.name}
                                className="inline-flex items-center gap-1 text-sm font-medium underline underline-offset-4"
                              >
                                <Download className="h-4 w-4" />
                                Download
                              </a>
                            </li>
                          ))}
                        </ul>
                      </div>
                    )}
                  </div>
                  )
                })}
              </div>
            ))
          )}
        </div>

        {groupedTodos.length > 0 && (
          <div className="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
            <div className="flex items-center gap-2">
              <span className="text-muted-foreground text-sm">Items per page</span>
              <Select
                value={String(pageSize)}
                onValueChange={(v) => {
                  const next = Number(v)
                  setPageSize(next)
                  setPage(1)
                }}
              >
                <SelectTrigger className="w-[110px]">
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="5">5</SelectItem>
                  <SelectItem value="10">10</SelectItem>
                  <SelectItem value="15">15</SelectItem>
                  <SelectItem value="20">20</SelectItem>
                </SelectContent>
              </Select>
            </div>

            {showPagination && (
              <div className="flex items-center justify-between gap-3 sm:justify-end">
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={() => setPage((p) => Math.max(1, p - 1))}
                  disabled={page <= 1}
                >
                  Prev
                </Button>
                <span className="text-muted-foreground text-sm">
                  Page {page} of {totalPages}
                </span>
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={() => setPage((p) => Math.min(totalPages, p + 1))}
                  disabled={page >= totalPages}
                >
                  Next
                </Button>
              </div>
            )}
          </div>
        )}

        <div className="flex items-center justify-between gap-2">
          <Button
            type="button"
            variant="secondary"
            onClick={clearCompleted}
            disabled={completedCount === 0}
          >
            Clear completed
          </Button>
          <span className="text-muted-foreground text-sm">
            Mock data only (no backend)
          </span>
    </div>
      </CardContent>
    </Card>
  )
}

```

```typescriptreact
"use client"

import { zodResolver } from "@hookform/resolvers/zod"
import {
  AlertTriangle,
  CirclePlay,
  CircleStop,
  CalendarClock,
  CheckCircle2,
  Download,
  File,
  FileSpreadsheet,
  FileText,
  Image as ImageIcon,
  Info,
  Music,
  Bell,
  Timer,
  Trash2,
  Video,
} from "lucide-react"
import * as React from "react"
import { useForm } from "react-hook-form"
import { toast } from "sonner"
import { z } from "zod"
import type { SupabaseClient, User } from "@supabase/supabase-js"

import { ModeToggle } from "@/components/mode-toggle"
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert"
import { Badge } from "@/components/ui/badge"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Checkbox } from "@/components/ui/checkbox"
import { Form, FormControl, FormField, FormItem, FormMessage } from "@/components/ui/form"
import { Input } from "@/components/ui/input"
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select"
import { Separator } from "@/components/ui/separator"
import { Textarea } from "@/components/ui/textarea"
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip"
import { cn } from "@/lib/utils"
import { createBrowserSupabaseClient } from "@/lib/supabase/client"

type AttachmentKind =
  | "image"
  | "audio"
  | "video"
  | "pdf"
  | "spreadsheet"
  | "document"
  | "text"
  | "file"

type Attachment = {
  id: string
  name: string
  type: string
  size: number
  bucket: string
  path: string
  kind: AttachmentKind
}

type Todo = {
  id: string
  title: string
  description?: string
  completed: boolean
  // Stored as `datetime-local` string (YYYY-MM-DDTHH:mm) in local time.
  dueAt: string
  attachments: Attachment[]
}

type TaskState = "planned" | "in_progress" | "completed" | "overdue"
type DailyLoad = "light" | "balanced" | "heavy"

const todoSchema = z.object({
  title: z
    .string()
    .trim()
    .min(1, "Title is required.")
    .max(80, "Keep it under 80 characters."),
  description: z
    .string()
    .trim()
    .max(500, "Keep it under 500 characters.")
    .optional()
    .or(z.literal("")),
  dueAt: z
    .string()
    .min(1, "Due date & time is required.")
    .regex(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}$/, "Invalid date/time."),
})

type TodoFormValues = z.infer<typeof todoSchema>

const initialTodos: Todo[] = [
  {
    id: "1",
    title: "Create a Next.js app",
    description: "Scaffold with TypeScript + Tailwind and confirm it runs locally.",
    completed: true,
    dueAt: "2026-01-16T09:00",
    attachments: [],
  },
  {
    id: "2",
    title: "Add shadcn/ui + dark theme",
    description: "Initialize shadcn, set up theme provider, and verify dark mode.",
    completed: true,
    dueAt: "2026-01-16T10:30",
    attachments: [],
  },
  {
    id: "3",
    title: "Build a mock-data to-do list",
    completed: false,
    dueAt: "2026-01-16T15:00",
    attachments: [],
  },
  {
    id: "4",
    title: "Yesterday: review requirements",
    completed: true,
    dueAt: "2026-01-15T11:15",
    attachments: [],
  },
  {
    id: "5",
    title: "Yesterday: sketch UI layout",
    completed: true,
    dueAt: "2026-01-15T17:45",
    attachments: [],
  },
  {
    id: "6",
    title: "Today: add attachments support",
    completed: false,
    dueAt: "2026-01-16T18:20",
    attachments: [],
  },
  {
    id: "7",
    title: "Tomorrow: QA the filters",
    description: "Test date-only, time-only, exact, and between behaviors.",
    completed: false,
    dueAt: "2026-01-17T08:05",
    attachments: [],
  },
  {
    id: "8",
    title: "Tomorrow: polish summary cards",
    completed: false,
    dueAt: "2026-01-17T13:30",
    attachments: [],
  },
  {
    id: "9",
    title: "Tomorrow: write small UX notes",
    completed: false,
    dueAt: "2026-01-17T20:10",
    attachments: [],
  },
  {
    id: "10",
    title: "This weekend: add more mock tasks",
    completed: false,
    dueAt: "2026-01-18T10:00",
    attachments: [],
  },
  {
    id: "11",
    title: "This weekend: check time-only filter",
    completed: false,
    dueAt: "2026-01-18T22:15",
    attachments: [],
  },
  {
    id: "12",
    title: "Next week: sync with team",
    completed: false,
    dueAt: "2026-01-19T09:30",
    attachments: [],
  },
  {
    id: "13",
    title: "Next week: test date-only filter",
    completed: false,
    dueAt: "2026-01-20T14:05",
    attachments: [],
  },
  {
    id: "14",
    title: "Next week: test exact date+time filter",
    completed: false,
    dueAt: "2026-01-21T12:00",
    attachments: [],
  },
  {
    id: "15",
    title: "Next week: attach docs to completed tasks",
    completed: false,
    dueAt: "2026-01-22T16:40",
    attachments: [],
  },
  {
    id: "16",
    title: "Next week: final review",
    completed: false,
    dueAt: "2026-01-23T11:00",
    attachments: [],
  },
]

type DbTaskRow = {
  id: string
  user_id: string
  title: string
  description: string | null
  due_at: string
  completed: boolean
  in_progress: boolean
  attachments: unknown
}

function coerceAttachments(raw: unknown): Attachment[] {
  if (!raw || typeof raw !== "object") return []
  if (!Array.isArray(raw)) return []
  return raw.filter(Boolean) as Attachment[]
}

function toDbTaskInsert(values: TodoFormValues, userId: string) {
  return {
    user_id: userId,
    title: values.title.trim(),
    description: (values.description ?? "").trim() || null,
    due_at: values.dueAt,
    completed: false,
    in_progress: false,
    attachments: [],
  }
}

function fromDbTask(row: DbTaskRow): Todo {
  return {
    id: row.id,
    title: row.title,
    description: row.description ?? undefined,
    completed: row.completed,
    dueAt: row.due_at,
    attachments: coerceAttachments(row.attachments),
  }
}

function parseLocalDateTime(value: string): number {
  // value: "YYYY-MM-DDTHH:mm"
  const [datePart, timePart] = value.split("T")
  const [y, m, d] = datePart.split("-").map(Number)
  const [hh, mm] = timePart.split(":").map(Number)
  return new Date(y, m - 1, d, hh, mm, 0, 0).getTime()
}

function pad2(n: number) {
  return String(n).padStart(2, "0")
}

function localDateKey(d: Date) {
  return `${d.getFullYear()}-${pad2(d.getMonth() + 1)}-${pad2(d.getDate())}`
}

function addDays(date: Date, days: number) {
  const d = new Date(date)
  d.setDate(d.getDate() + days)
  return d
}

function startOfDay(date: Date) {
  return new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0, 0)
}

function endOfDay(date: Date) {
  return new Date(
    date.getFullYear(),
    date.getMonth(),
    date.getDate(),
    23,
    59,
    59,
    999
  )
}

function getDatePart(dueAt: string) {
  return dueAt.split("T")[0] ?? ""
}

function getTimePart(dueAt: string) {
  return dueAt.split("T")[1] ?? ""
}

function parseLocalDateOnly(value: string): Date {
  // value: "YYYY-MM-DD"
  const [y, m, d] = value.split("-").map(Number)
  return new Date(y, m - 1, d, 0, 0, 0, 0)
}

function parseLocalTimeToMinutes(value: string): number {
  // value: "HH:mm"
  const [hh, mm] = value.split(":").map(Number)
  return hh * 60 + mm
}

function formatLocalDateTime(value: string): string {
  const ms = parseLocalDateTime(value)
  if (!Number.isFinite(ms)) return value
  return new Intl.DateTimeFormat(undefined, {
    year: "numeric",
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  }).format(new Date(ms))
}

function formatDateTimeFromMs(ms: number): string {
  return new Intl.DateTimeFormat(undefined, {
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  }).format(new Date(ms))
}

function minutesUntil(targetMs: number, nowMs: number) {
  return Math.ceil((targetMs - nowMs) / 60_000)
}

function getTaskFlags(todo: Todo, nowMs: number, inProgressTaskId: string | null) {
  const completed = todo.completed
  const dueMs = parseLocalDateTime(todo.dueAt)
  const overdue = !completed && dueMs < nowMs
  const inProgress = !completed && inProgressTaskId === todo.id
  const planned = !completed && !overdue && !inProgress
  return { completed, overdue, inProgress, planned }
}

function getDailyLoad(todosForDay: Todo[]) {
  // 4-hour windows across the day (local).
  const labels = [
    "00:00–04:00",
    "04:00–08:00",
    "08:00–12:00",
    "12:00–16:00",
    "16:00–20:00",
    "20:00–24:00",
  ]
  const buckets = Array.from({ length: 6 }, () => 0) as number[]
  for (const t of todosForDay) {
    const ms = parseLocalDateTime(t.dueAt)
    const hour = new Date(ms).getHours()
    const idx = Math.floor(hour / 4)
    buckets[idx] = (buckets[idx] ?? 0) + 1
  }

  const total = todosForDay.length
  const peak = Math.max(0, ...buckets)
  const spread = buckets.filter((c) => c > 0).length
  const busiestIdx = buckets.findIndex((c) => c === peak)
  const busiestWindow = busiestIdx >= 0 ? labels[busiestIdx] : labels[0]

  // Heuristic: more tasks + higher concentration in one window => heavier day.
  const score = total + peak * 1.5 + Math.max(0, spread - 1) * 0.5
  const load: DailyLoad = score <= 5 ? "light" : score <= 10 ? "balanced" : "heavy"

  return { load, total, peak, spread, busiestWindow }
}

function DailyLoadBadge({ load }: { load: DailyLoad }) {
  if (load === "heavy") return <Badge variant="destructive">Heavy</Badge>
  if (load === "balanced") return <Badge variant="secondary">Balanced</Badge>
  return <Badge variant="outline">Light</Badge>
}

function TaskBadges({
  completed,
  overdue,
  inProgress,
  planned,
}: {
  completed: boolean
  overdue: boolean
  inProgress: boolean
  planned: boolean
}) {
  if (completed) {
    return (
      <Badge className="gap-1 bg-emerald-600 text-white hover:bg-emerald-600">
        <CheckCircle2 className="h-3.5 w-3.5" />
        Completed
      </Badge>
    )
  }

  return (
    <>
      {inProgress && (
        <Badge className="gap-1 bg-sky-600 text-white hover:bg-sky-600">
          <Timer className="h-3.5 w-3.5 text-white" />
          In progress
        </Badge>
      )}
      {overdue && (
        <Badge variant="destructive" className="gap-1">
          <AlertTriangle className="h-3.5 w-3.5" />
          Overdue
        </Badge>
      )}
      {planned && (
        <Badge variant="outline" className="gap-1">
          <CalendarClock className="h-3.5 w-3.5" />
          Planned
        </Badge>
      )}
    </>
  )
}

function getAttachmentKind(file: File): AttachmentKind {
  const type = (file.type || "").toLowerCase()
  const name = file.name.toLowerCase()
  const ext = name.includes(".") ? name.split(".").pop() ?? "" : ""

  if (type.startsWith("image/")) return "image"
  if (type.startsWith("audio/")) return "audio"
  if (type.startsWith("video/")) return "video"

  if (ext === "pdf") return "pdf"
  if (["xls", "xlsx", "csv"].includes(ext)) return "spreadsheet"
  if (["doc", "docx"].includes(ext)) return "document"
  if (["txt", "md", "rtf"].includes(ext)) return "text"

  return "file"
}

function sanitizePathSegment(s: string) {
  return s.replace(/[^\w.\-]+/g, "_")
}

function buildAttachmentRecord(file: File, bucket: string, path: string): Attachment {
  return {
    id: crypto.randomUUID(),
    name: file.name,
    type: file.type,
    size: file.size,
    bucket,
    path,
    kind: getAttachmentKind(file),
  }
}

function AttachmentIcon({ kind }: { kind: AttachmentKind }) {
  const className = "h-4 w-4 text-muted-foreground"

  switch (kind) {
    case "image":
      return <ImageIcon className={className} />
    case "audio":
      return <Music className={className} />
    case "video":
      return <Video className={className} />
    case "spreadsheet":
      return <FileSpreadsheet className={className} />
    case "pdf":
    case "document":
    case "text":
      return <FileText className={className} />
    default:
      return <File className={className} />
  }
}

const authSchema = z.object({
  email: z.string().email("Enter a valid email."),
  password: z.string().min(6, "Password must be at least 6 characters."),
})
type AuthValues = z.infer<typeof authSchema>

function AuthCard({ supabase }: { supabase: SupabaseClient }) {
  const [mode, setMode] = React.useState<"sign_in" | "sign_up">("sign_in")
  const [busy, setBusy] = React.useState(false)

  const form = useForm<AuthValues>({
    resolver: zodResolver(authSchema),
    defaultValues: { email: "", password: "" },
  })

  async function onSubmit(values: AuthValues) {
    setBusy(true)
    try {
      if (mode === "sign_in") {
        const { error } = await supabase.auth.signInWithPassword(values)
        if (error) throw error
      } else {
        const { error } = await supabase.auth.signUp(values)
        if (error) throw error
        toast.success("Account created", { description: "You can now sign in." })
        setMode("sign_in")
      }
    } catch (e) {
      toast.error("Authentication failed", {
        description: e instanceof Error ? e.message : "Please try again.",
      })
    } finally {
      setBusy(false)
    }
  }

  return (
    <div className="mx-auto flex min-h-screen max-w-md flex-col justify-center px-4 py-10">
      <Card>
        <CardHeader>
          <CardTitle className="text-2xl">Sign in</CardTitle>
          <p className="text-muted-foreground text-sm">
            {mode === "sign_in"
              ? "Use your email and password."
              : "Create an account with email and password."}
          </p>
        </CardHeader>
        <CardContent className="space-y-4">
          <Form {...form}>
            <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-3" noValidate>
              <FormField
                control={form.control}
                name="email"
                render={({ field }) => (
                  <FormItem>
                    <FormControl>
                      <Input placeholder="Email" autoComplete="email" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="password"
                render={({ field }) => (
                  <FormItem>
                    <FormControl>
                      <Input
                        type="password"
                        placeholder="Password"
                        autoComplete={
                          mode === "sign_in" ? "current-password" : "new-password"
                        }
                        {...field}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <Button type="submit" className="w-full" disabled={busy}>
                {mode === "sign_in" ? "Sign in" : "Sign up"}
              </Button>
            </form>
          </Form>

          <div className="flex items-center justify-between gap-3 text-sm">
            <span className="text-muted-foreground">
              {mode === "sign_in" ? "No account?" : "Already have an account?"}
            </span>
            <Button
              type="button"
              variant="link"
              className="px-0"
              onClick={() => setMode((m) => (m === "sign_in" ? "sign_up" : "sign_in"))}
            >
              {mode === "sign_in" ? "Sign up" : "Sign in"}
            </Button>
          </div>
        </CardContent>
      </Card>
    </div>
  )
}

export default function Home() {
  const [supabaseError, setSupabaseError] = React.useState<string | null>(null)
  const supabase = React.useMemo(() => {
    try {
      return createBrowserSupabaseClient()
    } catch (e) {
      setSupabaseError(e instanceof Error ? e.message : "Supabase is not configured.")
      return null
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [])

  const [user, setUser] = React.useState<User | null>(null)
  const [authLoading, setAuthLoading] = React.useState(true)

  React.useEffect(() => {
    if (!supabase) return
    let alive = true
    supabase.auth.getUser().then(({ data }) => {
      if (!alive) return
      setUser(data.user ?? null)
      setAuthLoading(false)
    })
    const { data } = supabase.auth.onAuthStateChange((_event, session) => {
      setUser(session?.user ?? null)
    })
    return () => {
      alive = false
      data.subscription.unsubscribe()
    }
  }, [supabase])

  if (supabaseError) {
    return (
      <div className="mx-auto flex min-h-screen max-w-2xl flex-col justify-center gap-4 px-4 py-10">
        <Card>
          <CardHeader>
            <CardTitle>Supabase not configured</CardTitle>
          </CardHeader>
          <CardContent className="space-y-2">
            <p className="text-muted-foreground text-sm">{supabaseError}</p>
            <p className="text-muted-foreground text-sm">
              See <code>SUPABASE_SETUP.md</code> and <code>supabase.env.example</code>.
            </p>
          </CardContent>
        </Card>
      </div>
    )
  }

  if (!supabase) return null
  if (authLoading) {
    return (
      <div className="mx-auto flex min-h-screen max-w-2xl flex-col justify-center px-4 py-10">
        <p className="text-muted-foreground text-sm">Loading…</p>
      </div>
    )
  }

  if (!user) return <AuthCard supabase={supabase} />

  return (
    <div className="mx-auto flex min-h-screen max-w-2xl flex-col gap-6 px-4 py-10">
      <TodoApp supabase={supabase} user={user} />
    </div>
  )
}

function TodoApp({ supabase, user }: { supabase: SupabaseClient; user: User }) {
  const userId = user.id
  const [todos, setTodos] = React.useState<Todo[]>([])
  const [tasksLoading, setTasksLoading] = React.useState(true)
  const [attachTargetTodoId, setAttachTargetTodoId] = React.useState<string | null>(
    null
  )
  const [conflictDueAt, setConflictDueAt] = React.useState<string | null>(null)
  const clearConflictTimerRef = React.useRef<number | null>(null)
  const [focusMode, setFocusMode] = React.useState(false)
  const [nowMs, setNowMs] = React.useState(() => Date.now())
  const [inProgressTaskId, setInProgressTaskId] = React.useState<string | null>(null)
  const [dismissedReminderTaskId, setDismissedReminderTaskId] = React.useState<
    string | null
  >(null)
  const [filterMode, setFilterMode] = React.useState<"between" | "exact">("between")
  const [filterFromDate, setFilterFromDate] = React.useState<string>("")
  const [filterFromTime, setFilterFromTime] = React.useState<string>("")
  const [filterToDate, setFilterToDate] = React.useState<string>("")
  const [filterToTime, setFilterToTime] = React.useState<string>("")
  const [filterExactDate, setFilterExactDate] = React.useState<string>("")
  const [filterExactTime, setFilterExactTime] = React.useState<string>("")
  const fileInputRef = React.useRef<HTMLInputElement>(null)
  const [pageSize, setPageSize] = React.useState<number>(5)
  const [page, setPage] = React.useState<number>(1)

  React.useEffect(() => {
    let alive = true
    async function load() {
      setTasksLoading(true)
      const { data, error } = await supabase
        .from("tasks")
        .select("*")
        .eq("user_id", userId)
        .order("due_at", { ascending: true })
      if (!alive) return
      if (error) {
        toast.error("Failed to load tasks", { description: error.message })
        setTodos([])
        setInProgressTaskId(null)
      } else {
        const rows = (data ?? []) as DbTaskRow[]
        setTodos(rows.map(fromDbTask))
        setInProgressTaskId(rows.find((r) => r.in_progress)?.id ?? null)
      }
      setTasksLoading(false)
    }
    load()
    return () => {
      alive = false
    }
  }, [supabase, userId])

  // Keep "now" fresh so overdue/in-progress states stay accurate without user interaction.
  React.useEffect(() => {
    const id = window.setInterval(() => setNowMs(Date.now()), 30_000)
    return () => window.clearInterval(id)
  }, [])

  // Only one task can be "In Progress"; auto-clear if completed, deleted, or overdue.
  React.useEffect(() => {
    if (!inProgressTaskId) return
    const t = todos.find((x) => x.id === inProgressTaskId)
    if (!t || t.completed) {
      setInProgressTaskId(null)
      return
    }
  }, [inProgressTaskId, nowMs, todos])

  const nextUpcoming = React.useMemo(() => {
    const upcoming = todos
      .filter((t) => !t.completed)
      .map((t) => ({ todo: t, dueMs: parseLocalDateTime(t.dueAt) }))
      .filter((x) => x.dueMs >= nowMs)
      .sort((a, b) => a.dueMs - b.dueMs)[0]
    return upcoming ?? null
  }, [nowMs, todos])

  React.useEffect(() => {
    // If "next upcoming" changed, allow reminder again (dismiss is per-task).
    if (nextUpcoming && nextUpcoming.todo.id !== dismissedReminderTaskId) return
    if (!nextUpcoming) setDismissedReminderTaskId(null)
  }, [dismissedReminderTaskId, nextUpcoming])

  const reminder = React.useMemo(() => {
    const REMINDER_WINDOW_MIN = 15
    if (!nextUpcoming) return null
    if (dismissedReminderTaskId === nextUpcoming.todo.id) return null
    const mins = minutesUntil(nextUpcoming.dueMs, nowMs)
    if (mins < 0 || mins > REMINDER_WINDOW_MIN) return null
    return { ...nextUpcoming, mins }
  }, [dismissedReminderTaskId, nextUpcoming, nowMs])

  const form = useForm<TodoFormValues>({
    resolver: zodResolver(todoSchema),
    defaultValues: { title: "", description: "", dueAt: "" },
    mode: "onSubmit",
  })

  const summary = React.useMemo(() => {
    const now = new Date()
    const todayKey = localDateKey(now)
    const tomorrow = addDays(now, 1)
    const tomorrowKey = localDateKey(tomorrow)

    const todays = todos.filter((t) => t.dueAt.startsWith(todayKey))
    const todayCompleted = todays.filter((t) => t.completed).length
    const todayPending = todays.length - todayCompleted

    const labels = [
      "00:00–04:00",
      "04:00–08:00",
      "08:00–12:00",
      "12:00–16:00",
      "16:00–20:00",
      "20:00–24:00",
    ]

    // Tomorrow: same 4-hour windows breakdown
    const tomorrowTasks = todos.filter((t) => t.dueAt.startsWith(tomorrowKey))
    const tomorrowBuckets = Array.from({ length: 6 }, () => 0) as number[]
    for (const t of tomorrowTasks) {
      const ms = parseLocalDateTime(t.dueAt)
      const hour = new Date(ms).getHours()
      const idx = Math.floor(hour / 4)
      tomorrowBuckets[idx] = (tomorrowBuckets[idx] ?? 0) + 1
    }

    // Until next week = next 7 days starting tomorrow (local), grouped into 4-hour windows.
    const rangeStart = startOfDay(tomorrow).getTime()
    const rangeEnd = addDays(startOfDay(tomorrow), 7).getTime()
    const buckets = Array.from({ length: 6 }, () => 0) as number[]

    const upcoming = todos.filter((t) => {
      const ms = parseLocalDateTime(t.dueAt)
      return ms >= rangeStart && ms < rangeEnd
    })

    for (const t of upcoming) {
      const ms = parseLocalDateTime(t.dueAt)
      const hour = new Date(ms).getHours()
      const idx = Math.floor(hour / 4)
      buckets[idx] = (buckets[idx] ?? 0) + 1
    }

    return {
      todayCompleted,
      todayPending,
      tomorrowTotal: tomorrowTasks.length,
      tomorrowBuckets: labels.map((label, i) => ({ label, count: tomorrowBuckets[i] ?? 0 })),
      upcomingTotal: upcoming.length,
      upcomingBuckets: labels.map((label, i) => ({ label, count: buckets[i] ?? 0 })),
    }
  }, [todos])

  const loadDayKey = React.useMemo(() => {
    // Prefer an explicitly selected date from filters; otherwise use today.
    if (filterMode === "exact" && filterExactDate) return filterExactDate
    if (filterFromDate && !filterToDate) return filterFromDate
    if (filterFromDate && filterToDate && filterFromDate === filterToDate) return filterFromDate
    if (!filterFromDate && filterToDate) return filterToDate
    return localDateKey(new Date(nowMs))
  }, [filterExactDate, filterFromDate, filterMode, filterToDate, nowMs])

  const dailyLoad = React.useMemo(() => {
    const dayTodos = todos.filter((t) => getDatePart(t.dueAt) === loadDayKey)
    return getDailyLoad(dayTodos)
  }, [loadDayKey, todos])

  const filteredTodos = React.useMemo(() => {
    if (focusMode) {
      const endMs = nowMs + 4 * 60 * 60 * 1000
      const withMs = todos.map((t) => ({ ...t, _dueMs: parseLocalDateTime(t.dueAt) }))
      return withMs.filter((t) => t._dueMs >= nowMs && t._dueMs <= endMs)
    }

    const withMs = todos.map((t) => ({ ...t, _dueMs: parseLocalDateTime(t.dueAt) }))
    if (filterMode === "exact") {
      // If only date is selected -> show tasks for that date.
      // If time is selected too -> match exact date+time.
      // If only time is selected -> match time-of-day across all dates.
      if (!filterExactDate && !filterExactTime) return withMs

      if (filterExactDate && !filterExactTime) {
        return withMs.filter((t) => getDatePart(t.dueAt) === filterExactDate)
      }

      if (filterExactDate && filterExactTime) {
        const exactMs = parseLocalDateTime(`${filterExactDate}T${filterExactTime}`)
        return withMs.filter((t) => t._dueMs === exactMs)
      }

      // time only
      return withMs.filter((t) => getTimePart(t.dueAt) === filterExactTime)
    }
    // between
    const hasAnyDate = Boolean(filterFromDate || filterToDate)
    const hasAnyTime = Boolean(filterFromTime || filterToTime)

    // Date range (optional)
    const fromDateMs = filterFromDate
      ? startOfDay(parseLocalDateOnly(filterFromDate)).getTime()
      : Number.NEGATIVE_INFINITY
    const toDateMs = filterToDate
      ? endOfDay(parseLocalDateOnly(filterToDate)).getTime()
      : Number.POSITIVE_INFINITY

    // Time-of-day range (optional)
    const fromTimeMin = filterFromTime ? parseLocalTimeToMinutes(filterFromTime) : 0
    const toTimeMin = filterToTime ? parseLocalTimeToMinutes(filterToTime) : 24 * 60 - 1

    return withMs.filter((t) => {
      const ms = t._dueMs
      if (hasAnyDate && (ms < fromDateMs || ms > toDateMs)) return false

      if (hasAnyTime) {
        const time = getTimePart(t.dueAt)
        if (!time) return false
        const mins = parseLocalTimeToMinutes(time)
        // Simple (non-wrapping) range. If you want wrap-around (e.g. 22:00–02:00), tell me.
        if (mins < fromTimeMin || mins > toTimeMin) return false
      }

      // If neither date nor time selected, pass through (handled above anyway)
      return true
    })
  }, [
    todos,
    focusMode,
    nowMs,
    filterExactDate,
    filterExactTime,
    filterFromDate,
    filterFromTime,
    filterMode,
    filterToDate,
    filterToTime,
  ])

  const sortedFilteredTodos = React.useMemo(
    () =>
      filteredTodos
        .slice()
        .sort((a, b) => parseLocalDateTime(a.dueAt) - parseLocalDateTime(b.dueAt)),
    [filteredTodos]
  )

  // Clamp page when filters/pageSize change.
  React.useEffect(() => {
    const totalPages = Math.max(1, Math.ceil(sortedFilteredTodos.length / pageSize))
    setPage((p) => Math.min(Math.max(1, p), totalPages))
  }, [pageSize, sortedFilteredTodos.length])

  const totalItems = sortedFilteredTodos.length
  const totalPages = Math.max(1, Math.ceil(totalItems / pageSize))
  const showPagination = totalPages > 1

  const pageItems = React.useMemo(() => {
    const start = (page - 1) * pageSize
    return sortedFilteredTodos.slice(start, start + pageSize)
  }, [page, pageSize, sortedFilteredTodos])

  const groupedTodos = React.useMemo(() => {
    const groups: Array<{ date: string; items: typeof pageItems }> = []
    for (const t of pageItems) {
      const date = getDatePart(t.dueAt)
      const last = groups[groups.length - 1]
      if (!last || last.date !== date) groups.push({ date, items: [t] })
      else last.items.push(t)
    }
    return groups
  }, [pageItems])

  const completedCount = filteredTodos.filter((t) => t.completed).length

  async function addTodo(values: TodoFormValues) {
    const conflicts = todos.filter((t) => t.dueAt === values.dueAt)
    if (conflicts.length > 0) {
      setConflictDueAt(values.dueAt)
      if (clearConflictTimerRef.current) window.clearTimeout(clearConflictTimerRef.current)
      clearConflictTimerRef.current = window.setTimeout(() => {
        setConflictDueAt(null)
      }, 8000)

      // Make sure the user can see the conflicting tasks even if they were filtered out.
      const [d, time] = values.dueAt.split("T")
      setFilterMode("exact")
      setFilterExactDate(d ?? "")
      setFilterExactTime(time ?? "")
      setPage(1)

      toast.error("Time conflict", {
        description: `You already have ${conflicts.length} task(s) scheduled at ${formatLocalDateTime(
          values.dueAt
        )}.`,
      })
    }

    const { data, error } = await supabase
      .from("tasks")
      .insert(toDbTaskInsert(values, userId))
      .select("*")
      .single()
    if (error) {
      toast.error("Failed to add task", { description: error.message })
      return
    }

    setTodos((prev) => [fromDbTask(data as DbTaskRow), ...prev])
    form.reset()
  }

  async function toggleTodo(id: string, completed: boolean) {
    // optimistic
    setTodos((prev) =>
      prev.map((t) =>
        t.id === id ? { ...t, completed, attachments: t.attachments } : t
      )
    )
    if (completed) setInProgressTaskId((cur) => (cur === id ? null : cur))

    const update: { completed: boolean; in_progress?: boolean } = { completed }
    if (completed) update.in_progress = false

    const { error } = await supabase
      .from("tasks")
      .update(update)
      .eq("id", id)
      .eq("user_id", userId)
    if (error) {
      toast.error("Failed to update task", { description: error.message })
    }
  }

  function requestAttachmentsForTodo(todoId: string) {
    setAttachTargetTodoId(todoId)
    // Let state update before opening picker (some browsers are picky).
    queueMicrotask(() => fileInputRef.current?.click())
  }

  async function handleFilesPicked(e: React.ChangeEvent<HTMLInputElement>) {
    const files = Array.from(e.target.files ?? [])
    const targetId = attachTargetTodoId

    // reset input so picking the same file again triggers onChange
    e.target.value = ""
    setAttachTargetTodoId(null)

    if (!targetId || files.length === 0) return
    const targetTodo = todos.find((t) => t.id === targetId)
    if (!targetTodo) return

    const bucket = "task-attachments"
    const uploaded: Attachment[] = []

    for (const file of files) {
      const safeName = sanitizePathSegment(file.name)
      const path = `${userId}/${targetId}/${crypto.randomUUID()}-${safeName}`
      const { error } = await supabase.storage
        .from(bucket)
        .upload(path, file, { contentType: file.type, upsert: false })
      if (error) {
        toast.error("Upload failed", { description: error.message })
        continue
      }
      uploaded.push(buildAttachmentRecord(file, bucket, path))
    }

    if (uploaded.length === 0) return
    const nextAttachments = [...targetTodo.attachments, ...uploaded]

    // optimistic
    setTodos((prev) =>
      prev.map((t) => (t.id === targetId ? { ...t, attachments: nextAttachments } : t))
    )

    const { error } = await supabase
      .from("tasks")
      .update({ attachments: nextAttachments })
      .eq("id", targetId)
      .eq("user_id", userId)
    if (error) {
      toast.error("Failed to save attachments", { description: error.message })
    }
  }

  async function deleteTodo(id: string) {
    // optimistic
    setTodos((prev) => prev.filter((t) => t.id !== id))
    setInProgressTaskId((cur) => (cur === id ? null : cur))

    const { error } = await supabase.from("tasks").delete().eq("id", id).eq("user_id", userId)
    if (error) toast.error("Failed to delete task", { description: error.message })
  }

  async function setInProgress(taskId: string | null) {
    // optimistic
    setInProgressTaskId(taskId)

    // Clear any previous in-progress tasks first (enforces the single-task rule).
    const clearRes = await supabase
      .from("tasks")
      .update({ in_progress: false })
      .eq("user_id", userId)
      .eq("in_progress", true)
    if (clearRes.error) {
      toast.error("Failed to update in-progress", { description: clearRes.error.message })
      return
    }

    if (!taskId) return

    const setRes = await supabase
      .from("tasks")
      .update({ in_progress: true })
      .eq("id", taskId)
      .eq("user_id", userId)
    if (setRes.error) {
      toast.error("Failed to update in-progress", { description: setRes.error.message })
    }
  }

  async function downloadAttachment(a: Attachment) {
    const { data, error } = await supabase.storage.from(a.bucket).createSignedUrl(a.path, 60)
    if (error || !data?.signedUrl) {
      toast.error("Download failed", { description: error?.message ?? "Please try again." })
      return
    }
    window.open(data.signedUrl, "_blank", "noopener,noreferrer")
  }

  async function seedDemoTasks() {
    if (todos.length > 0) return
    const payload = initialTodos.map((t) => ({
      user_id: userId,
      title: t.title,
      description: t.description ?? null,
      due_at: t.dueAt,
      completed: t.completed,
      in_progress: false,
      attachments: [],
    }))
    const { data, error } = await supabase.from("tasks").insert(payload).select("*")
    if (error) {
      toast.error("Failed to seed demo tasks", { description: error.message })
      return
    }
    const rows = (data ?? []) as DbTaskRow[]
    setTodos(rows.map(fromDbTask))
  }

  async function clearCompleted() {
    const completedIds = new Set(todos.filter((t) => t.completed).map((t) => t.id))
    if (completedIds.size === 0) return

    // optimistic
    setTodos((prev) => prev.filter((t) => !completedIds.has(t.id)))

    const { error } = await supabase
      .from("tasks")
      .delete()
      .eq("user_id", userId)
      .eq("completed", true)
    if (error) toast.error("Failed to clear completed", { description: error.message })
  }

  return (
    <Card>
      <CardHeader className="flex flex-row items-center justify-between gap-4">
        <div className="space-y-1">
          <CardTitle className="text-2xl">To‑Do</CardTitle>
          <p className="text-muted-foreground text-sm">
            {completedCount}/{filteredTodos.length} completed
          </p>
        </div>
        <div className="flex items-center gap-2">
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <Button
                  type="button"
                  variant={focusMode ? "default" : "outline"}
                  size="sm"
                  onClick={() => {
                    setFocusMode((v) => !v)
                    setPage(1)
                  }}
                >
                  Focus Mode
                </Button>
              </TooltipTrigger>
              <TooltipContent>
                <p>Show tasks for the next 4 hours.</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
          <Button
            type="button"
            variant="outline"
            size="sm"
            onClick={async () => {
              await supabase.auth.signOut()
            }}
          >
            Sign out
          </Button>
          <ModeToggle />
        </div>
      </CardHeader>

      <CardContent className="space-y-6">
        <input
          ref={fileInputRef}
          type="file"
          multiple
          className="hidden"
          accept={[
            "image/*",
            "audio/*",
            "video/*",
            ".pdf",
            ".doc",
            ".docx",
            ".xls",
            ".xlsx",
            ".csv",
            ".txt",
            ".md",
            ".rtf",
          ].join(",")}
          onChange={handleFilesPicked}
        />

        {reminder && (
          <Alert className="border-primary/30 bg-primary/5">
            <Bell className="h-4 w-4" />
            <div className="flex flex-1 flex-col gap-1">
              <div className="flex flex-wrap items-center justify-between gap-2">
                <AlertTitle className="text-sm">
                  Next task starts in {reminder.mins} minute{reminder.mins === 1 ? "" : "s"}
                </AlertTitle>
                <Button
                  type="button"
                  variant="ghost"
                  size="sm"
                  onClick={() => setDismissedReminderTaskId(reminder.todo.id)}
                >
                  Dismiss
                </Button>
              </div>
              <AlertDescription className="text-sm">
                <span className="font-medium">{reminder.todo.title}</span> ·{" "}
                {formatDateTimeFromMs(reminder.dueMs)}
              </AlertDescription>
            </div>
          </Alert>
        )}

        <div className="rounded-xl border bg-card p-4">
          <div className="flex flex-wrap items-center justify-between gap-2">
            <p className="text-sm font-medium">
              Daily load{" "}
              <span className="text-muted-foreground font-normal">
                ({new Intl.DateTimeFormat(undefined, {
                  weekday: "short",
                  year: "numeric",
                  month: "short",
                  day: "2-digit",
                }).format(parseLocalDateOnly(loadDayKey))})
              </span>
            </p>
            <DailyLoadBadge load={dailyLoad.load} />
          </div>
          <p className="text-muted-foreground mt-2 text-sm">
            {dailyLoad.total} task(s) · busiest window {dailyLoad.busiestWindow} ({dailyLoad.peak})
          </p>
        </div>

        <div className="grid gap-3 sm:grid-cols-3">
          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Today’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">
              {summary.todayCompleted} completed
            </p>
            <p className="text-muted-foreground text-sm">{summary.todayPending} pending</p>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tomorrow’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">{summary.tomorrowTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.tomorrowBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tasks Until Next Week</p>
            <p className="mt-2 text-2xl font-semibold">{summary.upcomingTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.upcomingBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>
        </div>

        {focusMode && (
          <div className="flex flex-col gap-1 rounded-lg border bg-muted/20 px-3 py-2 sm:flex-row sm:items-center sm:justify-between">
            <p className="text-sm">
              <span className="font-medium">Focus Mode:</span>{" "}
              showing tasks due in the next 4 hours (until{" "}
              <span className="font-medium">
                {formatDateTimeFromMs(nowMs + 4 * 60 * 60 * 1000)}
              </span>
              )
            </p>
            <Button type="button" variant="ghost" size="sm" onClick={() => setFocusMode(false)}>
              Exit
            </Button>
          </div>
        )}

        <Form {...form}>
          <form
            onSubmit={form.handleSubmit(addTodo)}
            className="space-y-2"
            noValidate
          >
            <div className="flex flex-col gap-2 sm:flex-row">
              <FormField
                control={form.control}
                name="title"
                render={({ field }) => (
                  <FormItem className="flex-1">
                    <FormControl>
                      <Input
                        placeholder="Add a task…"
                        autoComplete="off"
                        {...field}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="dueAt"
                render={({ field }) => (
                  <FormItem className="sm:w-64">
                    <FormControl>
                      <Input type="datetime-local" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <Button type="submit">Add</Button>
            </div>

            <FormField
              control={form.control}
              name="description"
              render={({ field }) => (
                <FormItem>
                  <FormControl>
                    <Textarea
                      rows={3}
                      placeholder="Description (optional)…"
                      {...field}
                    />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />
          </form>
        </Form>

        <Separator />

        <div className="space-y-3">
          <div className="flex flex-wrap items-center justify-between gap-2">
            <p className="text-sm font-medium">Filter by date & time</p>
            <div className="flex items-center gap-2">
              <Button
                type="button"
                size="sm"
                variant={filterMode === "between" ? "default" : "outline"}
                onClick={() => setFilterMode("between")}
              >
                Between
              </Button>
              <Button
                type="button"
                size="sm"
                variant={filterMode === "exact" ? "default" : "outline"}
                onClick={() => setFilterMode("exact")}
              >
                Exact
              </Button>
              <Button
                type="button"
                size="sm"
                variant="ghost"
                onClick={() => {
                  setFilterFromDate("")
                  setFilterFromTime("")
                  setFilterToDate("")
                  setFilterToTime("")
                  setFilterExactDate("")
                  setFilterExactTime("")
                }}
              >
                Clear
              </Button>
            </div>
          </div>

          {filterMode === "between" ? (
            <div className="grid gap-2 sm:grid-cols-2">
              <div className="grid gap-2 sm:grid-cols-2">
                <Input
                  type="date"
                  value={filterFromDate}
                  onChange={(e) => setFilterFromDate(e.target.value)}
                />
                <Input
                  type="time"
                  value={filterFromTime}
                  onChange={(e) => setFilterFromTime(e.target.value)}
                />
              </div>
              <div className="grid gap-2 sm:grid-cols-2">
                <Input
                  type="date"
                  value={filterToDate}
                  onChange={(e) => setFilterToDate(e.target.value)}
                />
                <Input
                  type="time"
                  value={filterToTime}
                  onChange={(e) => setFilterToTime(e.target.value)}
                />
              </div>
            </div>
          ) : (
            <div className="grid gap-2 sm:grid-cols-2">
              <Input
                type="date"
                value={filterExactDate}
                onChange={(e) => setFilterExactDate(e.target.value)}
              />
              <Input
                type="time"
                value={filterExactTime}
                onChange={(e) => setFilterExactTime(e.target.value)}
              />
            </div>
          )}
        </div>

        <Separator />

        <div className="space-y-2">
          {groupedTodos.length === 0 ? (
            <p className="text-muted-foreground text-sm">No tasks yet.</p>
          ) : (
            groupedTodos.map((group) => (
              <div key={group.date} className="space-y-2">
                <div className="flex items-center gap-3 pt-2">
                  <Separator className="flex-1" />
                  <span className="text-muted-foreground whitespace-nowrap text-xs font-medium">
                    {new Intl.DateTimeFormat(undefined, {
                      weekday: "short",
                      year: "numeric",
                      month: "short",
                      day: "2-digit",
                    }).format(parseLocalDateOnly(group.date))}
                  </span>
                  <Separator className="flex-1" />
                </div>

                {group.items.map((todo) => {
                  const flags = getTaskFlags(todo, nowMs, inProgressTaskId)

                  return (
                    <div
                      key={todo.id}
                      className={cn(
                        "rounded-lg border px-3 py-2",
                        flags.completed && "opacity-75",
                        flags.overdue &&
                          "border-destructive/40 bg-destructive/5 text-muted-foreground",
                        flags.inProgress && "border-sky-500/40 bg-sky-500/10",
                        conflictDueAt &&
                          todo.dueAt === conflictDueAt &&
                          "border-destructive/60 bg-destructive/5 ring-1 ring-destructive/30"
                      )}
                    >
                      <div className="flex items-start justify-between gap-3">
                        <label className="flex cursor-pointer items-start gap-3">
                        <Checkbox
                          checked={todo.completed}
                          onCheckedChange={(v) => {
                            const next = Boolean(v)
                            toggleTodo(todo.id, next)
                            if (next && !todo.completed) {
                              requestAttachmentsForTodo(todo.id)
                            }
                          }}
                          aria-label={`Mark "${todo.title}" as ${
                            todo.completed ? "not completed" : "completed"
                          }`}
                          className="mt-0.5"
                        />
                        <span
                          className={cn(
                            "leading-6",
                            todo.completed && "text-muted-foreground line-through"
                          )}
                        >
                          <span className="flex flex-wrap items-center gap-2">
                            <span className="block">{todo.title}</span>
                              <span className="flex flex-wrap items-center gap-2">
                                <TaskBadges {...flags} />
                              </span>
                            {todo.description && (
                              <TooltipProvider>
                                <Tooltip>
                                  <TooltipTrigger asChild>
                                    <button
                                      type="button"
                                      className="text-muted-foreground hover:text-foreground inline-flex h-7 w-7 items-center justify-center rounded-md border bg-background"
                                      aria-label="View description"
                                    >
                                      <Info className="h-4 w-4" />
                                    </button>
                                  </TooltipTrigger>
                                  <TooltipContent className="max-w-xs">
                                    <p className="whitespace-pre-wrap text-sm">
                                      {todo.description}
                                    </p>
                                  </TooltipContent>
                                </Tooltip>
                              </TooltipProvider>
                            )}
                          </span>
                          <span className="text-muted-foreground block text-xs">
                            Due: {formatLocalDateTime(todo.dueAt)}
                          </span>
                        </span>
                      </label>

                      <div className="flex items-center gap-1">
                        {!todo.completed && (
                          <Button
                            type="button"
                            variant={flags.inProgress ? "default" : "outline"}
                            size="sm"
                            onClick={() =>
                              setInProgressTaskId((cur) =>
                                cur === todo.id ? null : todo.id
                              )
                            }
                            className={cn(
                              flags.inProgress && "bg-sky-600 hover:bg-sky-600"
                            )}
                          >
                            {flags.inProgress ? (
                              <>
                                <CircleStop className="mr-1 h-4 w-4" />
                                Stop
                              </>
                            ) : (
                              <>
                                <CirclePlay className="mr-1 h-4 w-4" />
                                Start
                              </>
                            )}
                          </Button>
                        )}
                        {todo.completed && (
                          <Button
                            type="button"
                            variant="outline"
                            size="sm"
                            onClick={() => requestAttachmentsForTodo(todo.id)}
                          >
                            Add files
                          </Button>
                        )}
                        <Button
                          type="button"
                          variant="ghost"
                          size="icon"
                          aria-label={`Delete "${todo.title}"`}
                          onClick={() => deleteTodo(todo.id)}
                        >
                          <Trash2 className="h-4 w-4" />
                        </Button>
                      </div>
                    </div>

                    {todo.completed && todo.attachments.length > 0 && (
                      <div className="mt-3 space-y-2">
                        <p className="text-muted-foreground text-xs">Attachments</p>
                        <ul className="space-y-1">
                          {todo.attachments.map((a) => (
                            <li
                              key={a.id}
                              className="flex items-center justify-between gap-3 rounded-md bg-muted/30 px-2 py-1"
                            >
                              <div className="flex min-w-0 items-center gap-2">
                                <AttachmentIcon kind={a.kind} />
                                <span className="truncate text-sm">{a.name}</span>
                              </div>
                              <a
                                href={a.url}
                                download={a.name}
                                className="inline-flex items-center gap-1 text-sm font-medium underline underline-offset-4"
                              >
                                <Download className="h-4 w-4" />
                                Download
                              </a>
                            </li>
                          ))}
                        </ul>
                      </div>
                    )}
                  </div>
                  )
                })}
              </div>
            ))
          )}
        </div>

        {groupedTodos.length > 0 && (
          <div className="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
            <div className="flex items-center gap-2">
              <span className="text-muted-foreground text-sm">Items per page</span>
              <Select
                value={String(pageSize)}
                onValueChange={(v) => {
                  const next = Number(v)
                  setPageSize(next)
                  setPage(1)
                }}
              >
                <SelectTrigger className="w-[110px]">
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="5">5</SelectItem>
                  <SelectItem value="10">10</SelectItem>
                  <SelectItem value="15">15</SelectItem>
                  <SelectItem value="20">20</SelectItem>
                </SelectContent>
              </Select>
            </div>

            {showPagination && (
              <div className="flex items-center justify-between gap-3 sm:justify-end">
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={() => setPage((p) => Math.max(1, p - 1))}
                  disabled={page <= 1}
                >
                  Prev
                </Button>
                <span className="text-muted-foreground text-sm">
                  Page {page} of {totalPages}
                </span>
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={() => setPage((p) => Math.min(totalPages, p + 1))}
                  disabled={page >= totalPages}
                >
                  Next
                </Button>
              </div>
            )}
          </div>
        )}

        <div className="flex items-center justify-between gap-2">
          <Button
            type="button"
            variant="secondary"
            onClick={clearCompleted}
            disabled={completedCount === 0}
          >
            Clear completed
          </Button>
          <span className="text-muted-foreground text-sm">
            Mock data only (no backend)
          </span>
    </div>
      </CardContent>
    </Card>
  )
}

```

```typescriptreact
"use client"

import { zodResolver } from "@hookform/resolvers/zod"
import {
  AlertTriangle,
  CirclePlay,
  CircleStop,
  CalendarClock,
  CheckCircle2,
  Download,
  File,
  FileSpreadsheet,
  FileText,
  Image as ImageIcon,
  Info,
  Music,
  Bell,
  Timer,
  Trash2,
  Video,
} from "lucide-react"
import * as React from "react"
import { useForm } from "react-hook-form"
import { toast } from "sonner"
import { z } from "zod"
import type { SupabaseClient, User } from "@supabase/supabase-js"

import { ModeToggle } from "@/components/mode-toggle"
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert"
import { Badge } from "@/components/ui/badge"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Checkbox } from "@/components/ui/checkbox"
import { Form, FormControl, FormField, FormItem, FormMessage } from "@/components/ui/form"
import { Input } from "@/components/ui/input"
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select"
import { Separator } from "@/components/ui/separator"
import { Textarea } from "@/components/ui/textarea"
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip"
import { cn } from "@/lib/utils"
import { createBrowserSupabaseClient } from "@/lib/supabase/client"

type AttachmentKind =
  | "image"
  | "audio"
  | "video"
  | "pdf"
  | "spreadsheet"
  | "document"
  | "text"
  | "file"

type Attachment = {
  id: string
  name: string
  type: string
  size: number
  bucket: string
  path: string
  kind: AttachmentKind
}

type Todo = {
  id: string
  title: string
  description?: string
  completed: boolean
  // Stored as `datetime-local` string (YYYY-MM-DDTHH:mm) in local time.
  dueAt: string
  attachments: Attachment[]
}

type TaskState = "planned" | "in_progress" | "completed" | "overdue"
type DailyLoad = "light" | "balanced" | "heavy"

const todoSchema = z.object({
  title: z
    .string()
    .trim()
    .min(1, "Title is required.")
    .max(80, "Keep it under 80 characters."),
  description: z
    .string()
    .trim()
    .max(500, "Keep it under 500 characters.")
    .optional()
    .or(z.literal("")),
  dueAt: z
    .string()
    .min(1, "Due date & time is required.")
    .regex(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}$/, "Invalid date/time."),
})

type TodoFormValues = z.infer<typeof todoSchema>

const initialTodos: Todo[] = [
  {
    id: "1",
    title: "Create a Next.js app",
    description: "Scaffold with TypeScript + Tailwind and confirm it runs locally.",
    completed: true,
    dueAt: "2026-01-16T09:00",
    attachments: [],
  },
  {
    id: "2",
    title: "Add shadcn/ui + dark theme",
    description: "Initialize shadcn, set up theme provider, and verify dark mode.",
    completed: true,
    dueAt: "2026-01-16T10:30",
    attachments: [],
  },
  {
    id: "3",
    title: "Build a mock-data to-do list",
    completed: false,
    dueAt: "2026-01-16T15:00",
    attachments: [],
  },
  {
    id: "4",
    title: "Yesterday: review requirements",
    completed: true,
    dueAt: "2026-01-15T11:15",
    attachments: [],
  },
  {
    id: "5",
    title: "Yesterday: sketch UI layout",
    completed: true,
    dueAt: "2026-01-15T17:45",
    attachments: [],
  },
  {
    id: "6",
    title: "Today: add attachments support",
    completed: false,
    dueAt: "2026-01-16T18:20",
    attachments: [],
  },
  {
    id: "7",
    title: "Tomorrow: QA the filters",
    description: "Test date-only, time-only, exact, and between behaviors.",
    completed: false,
    dueAt: "2026-01-17T08:05",
    attachments: [],
  },
  {
    id: "8",
    title: "Tomorrow: polish summary cards",
    completed: false,
    dueAt: "2026-01-17T13:30",
    attachments: [],
  },
  {
    id: "9",
    title: "Tomorrow: write small UX notes",
    completed: false,
    dueAt: "2026-01-17T20:10",
    attachments: [],
  },
  {
    id: "10",
    title: "This weekend: add more mock tasks",
    completed: false,
    dueAt: "2026-01-18T10:00",
    attachments: [],
  },
  {
    id: "11",
    title: "This weekend: check time-only filter",
    completed: false,
    dueAt: "2026-01-18T22:15",
    attachments: [],
  },
  {
    id: "12",
    title: "Next week: sync with team",
    completed: false,
    dueAt: "2026-01-19T09:30",
    attachments: [],
  },
  {
    id: "13",
    title: "Next week: test date-only filter",
    completed: false,
    dueAt: "2026-01-20T14:05",
    attachments: [],
  },
  {
    id: "14",
    title: "Next week: test exact date+time filter",
    completed: false,
    dueAt: "2026-01-21T12:00",
    attachments: [],
  },
  {
    id: "15",
    title: "Next week: attach docs to completed tasks",
    completed: false,
    dueAt: "2026-01-22T16:40",
    attachments: [],
  },
  {
    id: "16",
    title: "Next week: final review",
    completed: false,
    dueAt: "2026-01-23T11:00",
    attachments: [],
  },
]

type DbTaskRow = {
  id: string
  user_id: string
  title: string
  description: string | null
  due_at: string
  completed: boolean
  in_progress: boolean
  attachments: unknown
}

function coerceAttachments(raw: unknown): Attachment[] {
  if (!raw || typeof raw !== "object") return []
  if (!Array.isArray(raw)) return []
  return raw.filter(Boolean) as Attachment[]
}

function toDbTaskInsert(values: TodoFormValues, userId: string) {
  return {
    user_id: userId,
    title: values.title.trim(),
    description: (values.description ?? "").trim() || null,
    due_at: values.dueAt,
    completed: false,
    in_progress: false,
    attachments: [],
  }
}

function fromDbTask(row: DbTaskRow): Todo {
  return {
    id: row.id,
    title: row.title,
    description: row.description ?? undefined,
    completed: row.completed,
    dueAt: row.due_at,
    attachments: coerceAttachments(row.attachments),
  }
}

function parseLocalDateTime(value: string): number {
  // value: "YYYY-MM-DDTHH:mm"
  const [datePart, timePart] = value.split("T")
  const [y, m, d] = datePart.split("-").map(Number)
  const [hh, mm] = timePart.split(":").map(Number)
  return new Date(y, m - 1, d, hh, mm, 0, 0).getTime()
}

function pad2(n: number) {
  return String(n).padStart(2, "0")
}

function localDateKey(d: Date) {
  return `${d.getFullYear()}-${pad2(d.getMonth() + 1)}-${pad2(d.getDate())}`
}

function addDays(date: Date, days: number) {
  const d = new Date(date)
  d.setDate(d.getDate() + days)
  return d
}

function startOfDay(date: Date) {
  return new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0, 0)
}

function endOfDay(date: Date) {
  return new Date(
    date.getFullYear(),
    date.getMonth(),
    date.getDate(),
    23,
    59,
    59,
    999
  )
}

function getDatePart(dueAt: string) {
  return dueAt.split("T")[0] ?? ""
}

function getTimePart(dueAt: string) {
  return dueAt.split("T")[1] ?? ""
}

function parseLocalDateOnly(value: string): Date {
  // value: "YYYY-MM-DD"
  const [y, m, d] = value.split("-").map(Number)
  return new Date(y, m - 1, d, 0, 0, 0, 0)
}

function parseLocalTimeToMinutes(value: string): number {
  // value: "HH:mm"
  const [hh, mm] = value.split(":").map(Number)
  return hh * 60 + mm
}

function formatLocalDateTime(value: string): string {
  const ms = parseLocalDateTime(value)
  if (!Number.isFinite(ms)) return value
  return new Intl.DateTimeFormat(undefined, {
    year: "numeric",
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  }).format(new Date(ms))
}

function formatDateTimeFromMs(ms: number): string {
  return new Intl.DateTimeFormat(undefined, {
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  }).format(new Date(ms))
}

function minutesUntil(targetMs: number, nowMs: number) {
  return Math.ceil((targetMs - nowMs) / 60_000)
}

function getTaskFlags(todo: Todo, nowMs: number, inProgressTaskId: string | null) {
  const completed = todo.completed
  const dueMs = parseLocalDateTime(todo.dueAt)
  const overdue = !completed && dueMs < nowMs
  const inProgress = !completed && inProgressTaskId === todo.id
  const planned = !completed && !overdue && !inProgress
  return { completed, overdue, inProgress, planned }
}

function getDailyLoad(todosForDay: Todo[]) {
  // 4-hour windows across the day (local).
  const labels = [
    "00:00–04:00",
    "04:00–08:00",
    "08:00–12:00",
    "12:00–16:00",
    "16:00–20:00",
    "20:00–24:00",
  ]
  const buckets = Array.from({ length: 6 }, () => 0) as number[]
  for (const t of todosForDay) {
    const ms = parseLocalDateTime(t.dueAt)
    const hour = new Date(ms).getHours()
    const idx = Math.floor(hour / 4)
    buckets[idx] = (buckets[idx] ?? 0) + 1
  }

  const total = todosForDay.length
  const peak = Math.max(0, ...buckets)
  const spread = buckets.filter((c) => c > 0).length
  const busiestIdx = buckets.findIndex((c) => c === peak)
  const busiestWindow = busiestIdx >= 0 ? labels[busiestIdx] : labels[0]

  // Heuristic: more tasks + higher concentration in one window => heavier day.
  const score = total + peak * 1.5 + Math.max(0, spread - 1) * 0.5
  const load: DailyLoad = score <= 5 ? "light" : score <= 10 ? "balanced" : "heavy"

  return { load, total, peak, spread, busiestWindow }
}

function DailyLoadBadge({ load }: { load: DailyLoad }) {
  if (load === "heavy") return <Badge variant="destructive">Heavy</Badge>
  if (load === "balanced") return <Badge variant="secondary">Balanced</Badge>
  return <Badge variant="outline">Light</Badge>
}

function TaskBadges({
  completed,
  overdue,
  inProgress,
  planned,
}: {
  completed: boolean
  overdue: boolean
  inProgress: boolean
  planned: boolean
}) {
  if (completed) {
    return (
      <Badge className="gap-1 bg-emerald-600 text-white hover:bg-emerald-600">
        <CheckCircle2 className="h-3.5 w-3.5" />
        Completed
      </Badge>
    )
  }

  return (
    <>
      {inProgress && (
        <Badge className="gap-1 bg-sky-600 text-white hover:bg-sky-600">
          <Timer className="h-3.5 w-3.5 text-white" />
          In progress
        </Badge>
      )}
      {overdue && (
        <Badge variant="destructive" className="gap-1">
          <AlertTriangle className="h-3.5 w-3.5" />
          Overdue
        </Badge>
      )}
      {planned && (
        <Badge variant="outline" className="gap-1">
          <CalendarClock className="h-3.5 w-3.5" />
          Planned
        </Badge>
      )}
    </>
  )
}

function getAttachmentKind(file: File): AttachmentKind {
  const type = (file.type || "").toLowerCase()
  const name = file.name.toLowerCase()
  const ext = name.includes(".") ? name.split(".").pop() ?? "" : ""

  if (type.startsWith("image/")) return "image"
  if (type.startsWith("audio/")) return "audio"
  if (type.startsWith("video/")) return "video"

  if (ext === "pdf") return "pdf"
  if (["xls", "xlsx", "csv"].includes(ext)) return "spreadsheet"
  if (["doc", "docx"].includes(ext)) return "document"
  if (["txt", "md", "rtf"].includes(ext)) return "text"

  return "file"
}

function sanitizePathSegment(s: string) {
  return s.replace(/[^\w.\-]+/g, "_")
}

function buildAttachmentRecord(file: File, bucket: string, path: string): Attachment {
  return {
    id: crypto.randomUUID(),
    name: file.name,
    type: file.type,
    size: file.size,
    bucket,
    path,
    kind: getAttachmentKind(file),
  }
}

function AttachmentIcon({ kind }: { kind: AttachmentKind }) {
  const className = "h-4 w-4 text-muted-foreground"

  switch (kind) {
    case "image":
      return <ImageIcon className={className} />
    case "audio":
      return <Music className={className} />
    case "video":
      return <Video className={className} />
    case "spreadsheet":
      return <FileSpreadsheet className={className} />
    case "pdf":
    case "document":
    case "text":
      return <FileText className={className} />
    default:
      return <File className={className} />
  }
}

const authSchema = z.object({
  email: z.string().email("Enter a valid email."),
  password: z.string().min(6, "Password must be at least 6 characters."),
})
type AuthValues = z.infer<typeof authSchema>

function AuthCard({ supabase }: { supabase: SupabaseClient }) {
  const [mode, setMode] = React.useState<"sign_in" | "sign_up">("sign_in")
  const [busy, setBusy] = React.useState(false)

  const form = useForm<AuthValues>({
    resolver: zodResolver(authSchema),
    defaultValues: { email: "", password: "" },
  })

  async function onSubmit(values: AuthValues) {
    setBusy(true)
    try {
      if (mode === "sign_in") {
        const { error } = await supabase.auth.signInWithPassword(values)
        if (error) throw error
      } else {
        const { error } = await supabase.auth.signUp(values)
        if (error) throw error
        toast.success("Account created", { description: "You can now sign in." })
        setMode("sign_in")
      }
    } catch (e) {
      toast.error("Authentication failed", {
        description: e instanceof Error ? e.message : "Please try again.",
      })
    } finally {
      setBusy(false)
    }
  }

  return (
    <div className="mx-auto flex min-h-screen max-w-md flex-col justify-center px-4 py-10">
      <Card>
        <CardHeader>
          <CardTitle className="text-2xl">Sign in</CardTitle>
          <p className="text-muted-foreground text-sm">
            {mode === "sign_in"
              ? "Use your email and password."
              : "Create an account with email and password."}
          </p>
        </CardHeader>
        <CardContent className="space-y-4">
          <Form {...form}>
            <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-3" noValidate>
              <FormField
                control={form.control}
                name="email"
                render={({ field }) => (
                  <FormItem>
                    <FormControl>
                      <Input placeholder="Email" autoComplete="email" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="password"
                render={({ field }) => (
                  <FormItem>
                    <FormControl>
                      <Input
                        type="password"
                        placeholder="Password"
                        autoComplete={
                          mode === "sign_in" ? "current-password" : "new-password"
                        }
                        {...field}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <Button type="submit" className="w-full" disabled={busy}>
                {mode === "sign_in" ? "Sign in" : "Sign up"}
              </Button>
            </form>
          </Form>

          <div className="flex items-center justify-between gap-3 text-sm">
            <span className="text-muted-foreground">
              {mode === "sign_in" ? "No account?" : "Already have an account?"}
            </span>
            <Button
              type="button"
              variant="link"
              className="px-0"
              onClick={() => setMode((m) => (m === "sign_in" ? "sign_up" : "sign_in"))}
            >
              {mode === "sign_in" ? "Sign up" : "Sign in"}
            </Button>
          </div>
        </CardContent>
      </Card>
    </div>
  )
}

export default function Home() {
  const [supabaseError, setSupabaseError] = React.useState<string | null>(null)
  const supabase = React.useMemo(() => {
    try {
      return createBrowserSupabaseClient()
    } catch (e) {
      setSupabaseError(e instanceof Error ? e.message : "Supabase is not configured.")
      return null
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [])

  const [user, setUser] = React.useState<User | null>(null)
  const [authLoading, setAuthLoading] = React.useState(true)

  React.useEffect(() => {
    if (!supabase) return
    let alive = true
    supabase.auth.getUser().then(({ data }) => {
      if (!alive) return
      setUser(data.user ?? null)
      setAuthLoading(false)
    })
    const { data } = supabase.auth.onAuthStateChange((_event, session) => {
      setUser(session?.user ?? null)
    })
    return () => {
      alive = false
      data.subscription.unsubscribe()
    }
  }, [supabase])

  if (supabaseError) {
    return (
      <div className="mx-auto flex min-h-screen max-w-2xl flex-col justify-center gap-4 px-4 py-10">
        <Card>
          <CardHeader>
            <CardTitle>Supabase not configured</CardTitle>
          </CardHeader>
          <CardContent className="space-y-2">
            <p className="text-muted-foreground text-sm">{supabaseError}</p>
            <p className="text-muted-foreground text-sm">
              See <code>SUPABASE_SETUP.md</code> and <code>supabase.env.example</code>.
            </p>
          </CardContent>
        </Card>
      </div>
    )
  }

  if (!supabase) return null
  if (authLoading) {
    return (
      <div className="mx-auto flex min-h-screen max-w-2xl flex-col justify-center px-4 py-10">
        <p className="text-muted-foreground text-sm">Loading…</p>
      </div>
    )
  }

  if (!user) return <AuthCard supabase={supabase} />

  return (
    <div className="mx-auto flex min-h-screen max-w-2xl flex-col gap-6 px-4 py-10">
      <TodoApp supabase={supabase} user={user} />
    </div>
  )
}

function TodoApp({ supabase, user }: { supabase: SupabaseClient; user: User }) {
  const userId = user.id
  const [todos, setTodos] = React.useState<Todo[]>([])
  const [tasksLoading, setTasksLoading] = React.useState(true)
  const [attachTargetTodoId, setAttachTargetTodoId] = React.useState<string | null>(
    null
  )
  const [conflictDueAt, setConflictDueAt] = React.useState<string | null>(null)
  const clearConflictTimerRef = React.useRef<number | null>(null)
  const [focusMode, setFocusMode] = React.useState(false)
  const [nowMs, setNowMs] = React.useState(() => Date.now())
  const [inProgressTaskId, setInProgressTaskId] = React.useState<string | null>(null)
  const [dismissedReminderTaskId, setDismissedReminderTaskId] = React.useState<
    string | null
  >(null)
  const [filterMode, setFilterMode] = React.useState<"between" | "exact">("between")
  const [filterFromDate, setFilterFromDate] = React.useState<string>("")
  const [filterFromTime, setFilterFromTime] = React.useState<string>("")
  const [filterToDate, setFilterToDate] = React.useState<string>("")
  const [filterToTime, setFilterToTime] = React.useState<string>("")
  const [filterExactDate, setFilterExactDate] = React.useState<string>("")
  const [filterExactTime, setFilterExactTime] = React.useState<string>("")
  const fileInputRef = React.useRef<HTMLInputElement>(null)
  const [pageSize, setPageSize] = React.useState<number>(5)
  const [page, setPage] = React.useState<number>(1)

  React.useEffect(() => {
    let alive = true
    async function load() {
      setTasksLoading(true)
      const { data, error } = await supabase
        .from("tasks")
        .select("*")
        .eq("user_id", userId)
        .order("due_at", { ascending: true })
      if (!alive) return
      if (error) {
        toast.error("Failed to load tasks", { description: error.message })
        setTodos([])
        setInProgressTaskId(null)
      } else {
        const rows = (data ?? []) as DbTaskRow[]
        setTodos(rows.map(fromDbTask))
        setInProgressTaskId(rows.find((r) => r.in_progress)?.id ?? null)
      }
      setTasksLoading(false)
    }
    load()
    return () => {
      alive = false
    }
  }, [supabase, userId])

  // Keep "now" fresh so overdue/in-progress states stay accurate without user interaction.
  React.useEffect(() => {
    const id = window.setInterval(() => setNowMs(Date.now()), 30_000)
    return () => window.clearInterval(id)
  }, [])

  // Only one task can be "In Progress"; auto-clear if completed, deleted, or overdue.
  React.useEffect(() => {
    if (!inProgressTaskId) return
    const t = todos.find((x) => x.id === inProgressTaskId)
    if (!t || t.completed) {
      setInProgressTaskId(null)
      return
    }
  }, [inProgressTaskId, nowMs, todos])

  const nextUpcoming = React.useMemo(() => {
    const upcoming = todos
      .filter((t) => !t.completed)
      .map((t) => ({ todo: t, dueMs: parseLocalDateTime(t.dueAt) }))
      .filter((x) => x.dueMs >= nowMs)
      .sort((a, b) => a.dueMs - b.dueMs)[0]
    return upcoming ?? null
  }, [nowMs, todos])

  React.useEffect(() => {
    // If "next upcoming" changed, allow reminder again (dismiss is per-task).
    if (nextUpcoming && nextUpcoming.todo.id !== dismissedReminderTaskId) return
    if (!nextUpcoming) setDismissedReminderTaskId(null)
  }, [dismissedReminderTaskId, nextUpcoming])

  const reminder = React.useMemo(() => {
    const REMINDER_WINDOW_MIN = 15
    if (!nextUpcoming) return null
    if (dismissedReminderTaskId === nextUpcoming.todo.id) return null
    const mins = minutesUntil(nextUpcoming.dueMs, nowMs)
    if (mins < 0 || mins > REMINDER_WINDOW_MIN) return null
    return { ...nextUpcoming, mins }
  }, [dismissedReminderTaskId, nextUpcoming, nowMs])

  const form = useForm<TodoFormValues>({
    resolver: zodResolver(todoSchema),
    defaultValues: { title: "", description: "", dueAt: "" },
    mode: "onSubmit",
  })

  const summary = React.useMemo(() => {
    const now = new Date()
    const todayKey = localDateKey(now)
    const tomorrow = addDays(now, 1)
    const tomorrowKey = localDateKey(tomorrow)

    const todays = todos.filter((t) => t.dueAt.startsWith(todayKey))
    const todayCompleted = todays.filter((t) => t.completed).length
    const todayPending = todays.length - todayCompleted

    const labels = [
      "00:00–04:00",
      "04:00–08:00",
      "08:00–12:00",
      "12:00–16:00",
      "16:00–20:00",
      "20:00–24:00",
    ]

    // Tomorrow: same 4-hour windows breakdown
    const tomorrowTasks = todos.filter((t) => t.dueAt.startsWith(tomorrowKey))
    const tomorrowBuckets = Array.from({ length: 6 }, () => 0) as number[]
    for (const t of tomorrowTasks) {
      const ms = parseLocalDateTime(t.dueAt)
      const hour = new Date(ms).getHours()
      const idx = Math.floor(hour / 4)
      tomorrowBuckets[idx] = (tomorrowBuckets[idx] ?? 0) + 1
    }

    // Until next week = next 7 days starting tomorrow (local), grouped into 4-hour windows.
    const rangeStart = startOfDay(tomorrow).getTime()
    const rangeEnd = addDays(startOfDay(tomorrow), 7).getTime()
    const buckets = Array.from({ length: 6 }, () => 0) as number[]

    const upcoming = todos.filter((t) => {
      const ms = parseLocalDateTime(t.dueAt)
      return ms >= rangeStart && ms < rangeEnd
    })

    for (const t of upcoming) {
      const ms = parseLocalDateTime(t.dueAt)
      const hour = new Date(ms).getHours()
      const idx = Math.floor(hour / 4)
      buckets[idx] = (buckets[idx] ?? 0) + 1
    }

    return {
      todayCompleted,
      todayPending,
      tomorrowTotal: tomorrowTasks.length,
      tomorrowBuckets: labels.map((label, i) => ({ label, count: tomorrowBuckets[i] ?? 0 })),
      upcomingTotal: upcoming.length,
      upcomingBuckets: labels.map((label, i) => ({ label, count: buckets[i] ?? 0 })),
    }
  }, [todos])

  const loadDayKey = React.useMemo(() => {
    // Prefer an explicitly selected date from filters; otherwise use today.
    if (filterMode === "exact" && filterExactDate) return filterExactDate
    if (filterFromDate && !filterToDate) return filterFromDate
    if (filterFromDate && filterToDate && filterFromDate === filterToDate) return filterFromDate
    if (!filterFromDate && filterToDate) return filterToDate
    return localDateKey(new Date(nowMs))
  }, [filterExactDate, filterFromDate, filterMode, filterToDate, nowMs])

  const dailyLoad = React.useMemo(() => {
    const dayTodos = todos.filter((t) => getDatePart(t.dueAt) === loadDayKey)
    return getDailyLoad(dayTodos)
  }, [loadDayKey, todos])

  const filteredTodos = React.useMemo(() => {
    if (focusMode) {
      const endMs = nowMs + 4 * 60 * 60 * 1000
      const withMs = todos.map((t) => ({ ...t, _dueMs: parseLocalDateTime(t.dueAt) }))
      return withMs.filter((t) => t._dueMs >= nowMs && t._dueMs <= endMs)
    }

    const withMs = todos.map((t) => ({ ...t, _dueMs: parseLocalDateTime(t.dueAt) }))
    if (filterMode === "exact") {
      // If only date is selected -> show tasks for that date.
      // If time is selected too -> match exact date+time.
      // If only time is selected -> match time-of-day across all dates.
      if (!filterExactDate && !filterExactTime) return withMs

      if (filterExactDate && !filterExactTime) {
        return withMs.filter((t) => getDatePart(t.dueAt) === filterExactDate)
      }

      if (filterExactDate && filterExactTime) {
        const exactMs = parseLocalDateTime(`${filterExactDate}T${filterExactTime}`)
        return withMs.filter((t) => t._dueMs === exactMs)
      }

      // time only
      return withMs.filter((t) => getTimePart(t.dueAt) === filterExactTime)
    }
    // between
    const hasAnyDate = Boolean(filterFromDate || filterToDate)
    const hasAnyTime = Boolean(filterFromTime || filterToTime)

    // Date range (optional)
    const fromDateMs = filterFromDate
      ? startOfDay(parseLocalDateOnly(filterFromDate)).getTime()
      : Number.NEGATIVE_INFINITY
    const toDateMs = filterToDate
      ? endOfDay(parseLocalDateOnly(filterToDate)).getTime()
      : Number.POSITIVE_INFINITY

    // Time-of-day range (optional)
    const fromTimeMin = filterFromTime ? parseLocalTimeToMinutes(filterFromTime) : 0
    const toTimeMin = filterToTime ? parseLocalTimeToMinutes(filterToTime) : 24 * 60 - 1

    return withMs.filter((t) => {
      const ms = t._dueMs
      if (hasAnyDate && (ms < fromDateMs || ms > toDateMs)) return false

      if (hasAnyTime) {
        const time = getTimePart(t.dueAt)
        if (!time) return false
        const mins = parseLocalTimeToMinutes(time)
        // Simple (non-wrapping) range. If you want wrap-around (e.g. 22:00–02:00), tell me.
        if (mins < fromTimeMin || mins > toTimeMin) return false
      }

      // If neither date nor time selected, pass through (handled above anyway)
      return true
    })
  }, [
    todos,
    focusMode,
    nowMs,
    filterExactDate,
    filterExactTime,
    filterFromDate,
    filterFromTime,
    filterMode,
    filterToDate,
    filterToTime,
  ])

  const sortedFilteredTodos = React.useMemo(
    () =>
      filteredTodos
        .slice()
        .sort((a, b) => parseLocalDateTime(a.dueAt) - parseLocalDateTime(b.dueAt)),
    [filteredTodos]
  )

  // Clamp page when filters/pageSize change.
  React.useEffect(() => {
    const totalPages = Math.max(1, Math.ceil(sortedFilteredTodos.length / pageSize))
    setPage((p) => Math.min(Math.max(1, p), totalPages))
  }, [pageSize, sortedFilteredTodos.length])

  const totalItems = sortedFilteredTodos.length
  const totalPages = Math.max(1, Math.ceil(totalItems / pageSize))
  const showPagination = totalPages > 1

  const pageItems = React.useMemo(() => {
    const start = (page - 1) * pageSize
    return sortedFilteredTodos.slice(start, start + pageSize)
  }, [page, pageSize, sortedFilteredTodos])

  const groupedTodos = React.useMemo(() => {
    const groups: Array<{ date: string; items: typeof pageItems }> = []
    for (const t of pageItems) {
      const date = getDatePart(t.dueAt)
      const last = groups[groups.length - 1]
      if (!last || last.date !== date) groups.push({ date, items: [t] })
      else last.items.push(t)
    }
    return groups
  }, [pageItems])

  const completedCount = filteredTodos.filter((t) => t.completed).length

  async function addTodo(values: TodoFormValues) {
    const conflicts = todos.filter((t) => t.dueAt === values.dueAt)
    if (conflicts.length > 0) {
      setConflictDueAt(values.dueAt)
      if (clearConflictTimerRef.current) window.clearTimeout(clearConflictTimerRef.current)
      clearConflictTimerRef.current = window.setTimeout(() => {
        setConflictDueAt(null)
      }, 8000)

      // Make sure the user can see the conflicting tasks even if they were filtered out.
      const [d, time] = values.dueAt.split("T")
      setFilterMode("exact")
      setFilterExactDate(d ?? "")
      setFilterExactTime(time ?? "")
      setPage(1)

      toast.error("Time conflict", {
        description: `You already have ${conflicts.length} task(s) scheduled at ${formatLocalDateTime(
          values.dueAt
        )}.`,
      })
    }

    const { data, error } = await supabase
      .from("tasks")
      .insert(toDbTaskInsert(values, userId))
      .select("*")
      .single()
    if (error) {
      toast.error("Failed to add task", { description: error.message })
      return
    }

    setTodos((prev) => [fromDbTask(data as DbTaskRow), ...prev])
    form.reset()
  }

  async function toggleTodo(id: string, completed: boolean) {
    // optimistic
    setTodos((prev) =>
      prev.map((t) =>
        t.id === id ? { ...t, completed, attachments: t.attachments } : t
      )
    )
    if (completed) setInProgressTaskId((cur) => (cur === id ? null : cur))

    const update: { completed: boolean; in_progress?: boolean } = { completed }
    if (completed) update.in_progress = false

    const { error } = await supabase
      .from("tasks")
      .update(update)
      .eq("id", id)
      .eq("user_id", userId)
    if (error) {
      toast.error("Failed to update task", { description: error.message })
    }
  }

  function requestAttachmentsForTodo(todoId: string) {
    setAttachTargetTodoId(todoId)
    // Let state update before opening picker (some browsers are picky).
    queueMicrotask(() => fileInputRef.current?.click())
  }

  async function handleFilesPicked(e: React.ChangeEvent<HTMLInputElement>) {
    const files = Array.from(e.target.files ?? [])
    const targetId = attachTargetTodoId

    // reset input so picking the same file again triggers onChange
    e.target.value = ""
    setAttachTargetTodoId(null)

    if (!targetId || files.length === 0) return
    const targetTodo = todos.find((t) => t.id === targetId)
    if (!targetTodo) return

    const bucket = "task-attachments"
    const uploaded: Attachment[] = []

    for (const file of files) {
      const safeName = sanitizePathSegment(file.name)
      const path = `${userId}/${targetId}/${crypto.randomUUID()}-${safeName}`
      const { error } = await supabase.storage
        .from(bucket)
        .upload(path, file, { contentType: file.type, upsert: false })
      if (error) {
        toast.error("Upload failed", { description: error.message })
        continue
      }
      uploaded.push(buildAttachmentRecord(file, bucket, path))
    }

    if (uploaded.length === 0) return
    const nextAttachments = [...targetTodo.attachments, ...uploaded]

    // optimistic
    setTodos((prev) =>
      prev.map((t) => (t.id === targetId ? { ...t, attachments: nextAttachments } : t))
    )

    const { error } = await supabase
      .from("tasks")
      .update({ attachments: nextAttachments })
      .eq("id", targetId)
      .eq("user_id", userId)
    if (error) {
      toast.error("Failed to save attachments", { description: error.message })
    }
  }

  async function deleteTodo(id: string) {
    // optimistic
    setTodos((prev) => prev.filter((t) => t.id !== id))
    setInProgressTaskId((cur) => (cur === id ? null : cur))

    const { error } = await supabase.from("tasks").delete().eq("id", id).eq("user_id", userId)
    if (error) toast.error("Failed to delete task", { description: error.message })
  }

  async function setInProgress(taskId: string | null) {
    // optimistic
    setInProgressTaskId(taskId)

    // Clear any previous in-progress tasks first (enforces the single-task rule).
    const clearRes = await supabase
      .from("tasks")
      .update({ in_progress: false })
      .eq("user_id", userId)
      .eq("in_progress", true)
    if (clearRes.error) {
      toast.error("Failed to update in-progress", { description: clearRes.error.message })
      return
    }

    if (!taskId) return

    const setRes = await supabase
      .from("tasks")
      .update({ in_progress: true })
      .eq("id", taskId)
      .eq("user_id", userId)
    if (setRes.error) {
      toast.error("Failed to update in-progress", { description: setRes.error.message })
    }
  }

  async function downloadAttachment(a: Attachment) {
    const { data, error } = await supabase.storage.from(a.bucket).createSignedUrl(a.path, 60)
    if (error || !data?.signedUrl) {
      toast.error("Download failed", { description: error?.message ?? "Please try again." })
      return
    }
    window.open(data.signedUrl, "_blank", "noopener,noreferrer")
  }

  async function seedDemoTasks() {
    if (todos.length > 0) return
    const payload = initialTodos.map((t) => ({
      user_id: userId,
      title: t.title,
      description: t.description ?? null,
      due_at: t.dueAt,
      completed: t.completed,
      in_progress: false,
      attachments: [],
    }))
    const { data, error } = await supabase.from("tasks").insert(payload).select("*")
    if (error) {
      toast.error("Failed to seed demo tasks", { description: error.message })
      return
    }
    const rows = (data ?? []) as DbTaskRow[]
    setTodos(rows.map(fromDbTask))
  }

  async function clearCompleted() {
    const completedIds = new Set(todos.filter((t) => t.completed).map((t) => t.id))
    if (completedIds.size === 0) return

    // optimistic
    setTodos((prev) => prev.filter((t) => !completedIds.has(t.id)))

    const { error } = await supabase
      .from("tasks")
      .delete()
      .eq("user_id", userId)
      .eq("completed", true)
    if (error) toast.error("Failed to clear completed", { description: error.message })
  }

  return (
    <Card>
      <CardHeader className="flex flex-row items-center justify-between gap-4">
        <div className="space-y-1">
          <CardTitle className="text-2xl">To‑Do</CardTitle>
          <p className="text-muted-foreground text-sm">
            {completedCount}/{filteredTodos.length} completed
          </p>
        </div>
        <div className="flex items-center gap-2">
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <Button
                  type="button"
                  variant={focusMode ? "default" : "outline"}
                  size="sm"
                  onClick={() => {
                    setFocusMode((v) => !v)
                    setPage(1)
                  }}
                >
                  Focus Mode
                </Button>
              </TooltipTrigger>
              <TooltipContent>
                <p>Show tasks for the next 4 hours.</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
          <Button
            type="button"
            variant="outline"
            size="sm"
            onClick={async () => {
              await supabase.auth.signOut()
            }}
          >
            Sign out
          </Button>
          <ModeToggle />
        </div>
      </CardHeader>

      <CardContent className="space-y-6">
        <input
          ref={fileInputRef}
          type="file"
          multiple
          className="hidden"
          accept={[
            "image/*",
            "audio/*",
            "video/*",
            ".pdf",
            ".doc",
            ".docx",
            ".xls",
            ".xlsx",
            ".csv",
            ".txt",
            ".md",
            ".rtf",
          ].join(",")}
          onChange={handleFilesPicked}
        />

        {reminder && (
          <Alert className="border-primary/30 bg-primary/5">
            <Bell className="h-4 w-4" />
            <div className="flex flex-1 flex-col gap-1">
              <div className="flex flex-wrap items-center justify-between gap-2">
                <AlertTitle className="text-sm">
                  Next task starts in {reminder.mins} minute{reminder.mins === 1 ? "" : "s"}
                </AlertTitle>
                <Button
                  type="button"
                  variant="ghost"
                  size="sm"
                  onClick={() => setDismissedReminderTaskId(reminder.todo.id)}
                >
                  Dismiss
                </Button>
              </div>
              <AlertDescription className="text-sm">
                <span className="font-medium">{reminder.todo.title}</span> ·{" "}
                {formatDateTimeFromMs(reminder.dueMs)}
              </AlertDescription>
            </div>
          </Alert>
        )}

        <div className="rounded-xl border bg-card p-4">
          <div className="flex flex-wrap items-center justify-between gap-2">
            <p className="text-sm font-medium">
              Daily load{" "}
              <span className="text-muted-foreground font-normal">
                ({new Intl.DateTimeFormat(undefined, {
                  weekday: "short",
                  year: "numeric",
                  month: "short",
                  day: "2-digit",
                }).format(parseLocalDateOnly(loadDayKey))})
              </span>
            </p>
            <DailyLoadBadge load={dailyLoad.load} />
          </div>
          <p className="text-muted-foreground mt-2 text-sm">
            {dailyLoad.total} task(s) · busiest window {dailyLoad.busiestWindow} ({dailyLoad.peak})
          </p>
        </div>

        <div className="grid gap-3 sm:grid-cols-3">
          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Today’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">
              {summary.todayCompleted} completed
            </p>
            <p className="text-muted-foreground text-sm">{summary.todayPending} pending</p>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tomorrow’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">{summary.tomorrowTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.tomorrowBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tasks Until Next Week</p>
            <p className="mt-2 text-2xl font-semibold">{summary.upcomingTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.upcomingBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>
        </div>

        {focusMode && (
          <div className="flex flex-col gap-1 rounded-lg border bg-muted/20 px-3 py-2 sm:flex-row sm:items-center sm:justify-between">
            <p className="text-sm">
              <span className="font-medium">Focus Mode:</span>{" "}
              showing tasks due in the next 4 hours (until{" "}
              <span className="font-medium">
                {formatDateTimeFromMs(nowMs + 4 * 60 * 60 * 1000)}
              </span>
              )
            </p>
            <Button type="button" variant="ghost" size="sm" onClick={() => setFocusMode(false)}>
              Exit
            </Button>
          </div>
        )}

        <Form {...form}>
          <form
            onSubmit={form.handleSubmit(addTodo)}
            className="space-y-2"
            noValidate
          >
            <div className="flex flex-col gap-2 sm:flex-row">
              <FormField
                control={form.control}
                name="title"
                render={({ field }) => (
                  <FormItem className="flex-1">
                    <FormControl>
                      <Input
                        placeholder="Add a task…"
                        autoComplete="off"
                        {...field}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="dueAt"
                render={({ field }) => (
                  <FormItem className="sm:w-64">
                    <FormControl>
                      <Input type="datetime-local" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <Button type="submit">Add</Button>
            </div>

            <FormField
              control={form.control}
              name="description"
              render={({ field }) => (
                <FormItem>
                  <FormControl>
                    <Textarea
                      rows={3}
                      placeholder="Description (optional)…"
                      {...field}
                    />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />
          </form>
        </Form>

        <Separator />

        <div className="space-y-3">
          <div className="flex flex-wrap items-center justify-between gap-2">
            <p className="text-sm font-medium">Filter by date & time</p>
            <div className="flex items-center gap-2">
              <Button
                type="button"
                size="sm"
                variant={filterMode === "between" ? "default" : "outline"}
                onClick={() => setFilterMode("between")}
              >
                Between
              </Button>
              <Button
                type="button"
                size="sm"
                variant={filterMode === "exact" ? "default" : "outline"}
                onClick={() => setFilterMode("exact")}
              >
                Exact
              </Button>
              <Button
                type="button"
                size="sm"
                variant="ghost"
                onClick={() => {
                  setFilterFromDate("")
                  setFilterFromTime("")
                  setFilterToDate("")
                  setFilterToTime("")
                  setFilterExactDate("")
                  setFilterExactTime("")
                }}
              >
                Clear
              </Button>
            </div>
          </div>

          {filterMode === "between" ? (
            <div className="grid gap-2 sm:grid-cols-2">
              <div className="grid gap-2 sm:grid-cols-2">
                <Input
                  type="date"
                  value={filterFromDate}
                  onChange={(e) => setFilterFromDate(e.target.value)}
                />
                <Input
                  type="time"
                  value={filterFromTime}
                  onChange={(e) => setFilterFromTime(e.target.value)}
                />
              </div>
              <div className="grid gap-2 sm:grid-cols-2">
                <Input
                  type="date"
                  value={filterToDate}
                  onChange={(e) => setFilterToDate(e.target.value)}
                />
                <Input
                  type="time"
                  value={filterToTime}
                  onChange={(e) => setFilterToTime(e.target.value)}
                />
              </div>
            </div>
          ) : (
            <div className="grid gap-2 sm:grid-cols-2">
              <Input
                type="date"
                value={filterExactDate}
                onChange={(e) => setFilterExactDate(e.target.value)}
              />
              <Input
                type="time"
                value={filterExactTime}
                onChange={(e) => setFilterExactTime(e.target.value)}
              />
            </div>
          )}
        </div>

        <Separator />

        <div className="space-y-2">
          {groupedTodos.length === 0 ? (
            <p className="text-muted-foreground text-sm">No tasks yet.</p>
          ) : (
            groupedTodos.map((group) => (
              <div key={group.date} className="space-y-2">
                <div className="flex items-center gap-3 pt-2">
                  <Separator className="flex-1" />
                  <span className="text-muted-foreground whitespace-nowrap text-xs font-medium">
                    {new Intl.DateTimeFormat(undefined, {
                      weekday: "short",
                      year: "numeric",
                      month: "short",
                      day: "2-digit",
                    }).format(parseLocalDateOnly(group.date))}
                  </span>
                  <Separator className="flex-1" />
                </div>

                {group.items.map((todo) => {
                  const flags = getTaskFlags(todo, nowMs, inProgressTaskId)

                  return (
                    <div
                      key={todo.id}
                      className={cn(
                        "rounded-lg border px-3 py-2",
                        flags.completed && "opacity-75",
                        flags.overdue &&
                          "border-destructive/40 bg-destructive/5 text-muted-foreground",
                        flags.inProgress && "border-sky-500/40 bg-sky-500/10",
                        conflictDueAt &&
                          todo.dueAt === conflictDueAt &&
                          "border-destructive/60 bg-destructive/5 ring-1 ring-destructive/30"
                      )}
                    >
                      <div className="flex items-start justify-between gap-3">
                        <label className="flex cursor-pointer items-start gap-3">
                        <Checkbox
                          checked={todo.completed}
                          onCheckedChange={(v) => {
                            const next = Boolean(v)
                            toggleTodo(todo.id, next)
                            if (next && !todo.completed) {
                              requestAttachmentsForTodo(todo.id)
                            }
                          }}
                          aria-label={`Mark "${todo.title}" as ${
                            todo.completed ? "not completed" : "completed"
                          }`}
                          className="mt-0.5"
                        />
                        <span
                          className={cn(
                            "leading-6",
                            todo.completed && "text-muted-foreground line-through"
                          )}
                        >
                          <span className="flex flex-wrap items-center gap-2">
                            <span className="block">{todo.title}</span>
                              <span className="flex flex-wrap items-center gap-2">
                                <TaskBadges {...flags} />
                              </span>
                            {todo.description && (
                              <TooltipProvider>
                                <Tooltip>
                                  <TooltipTrigger asChild>
                                    <button
                                      type="button"
                                      className="text-muted-foreground hover:text-foreground inline-flex h-7 w-7 items-center justify-center rounded-md border bg-background"
                                      aria-label="View description"
                                    >
                                      <Info className="h-4 w-4" />
                                    </button>
                                  </TooltipTrigger>
                                  <TooltipContent className="max-w-xs">
                                    <p className="whitespace-pre-wrap text-sm">
                                      {todo.description}
                                    </p>
                                  </TooltipContent>
                                </Tooltip>
                              </TooltipProvider>
                            )}
                          </span>
                          <span className="text-muted-foreground block text-xs">
                            Due: {formatLocalDateTime(todo.dueAt)}
                          </span>
                        </span>
                      </label>

                      <div className="flex items-center gap-1">
                        {!todo.completed && (
                          <Button
                            type="button"
                            variant={flags.inProgress ? "default" : "outline"}
                            size="sm"
                            onClick={() => void setInProgress(flags.inProgress ? null : todo.id)}
                            className={cn(
                              flags.inProgress && "bg-sky-600 hover:bg-sky-600"
                            )}
                          >
                            {flags.inProgress ? (
                              <>
                                <CircleStop className="mr-1 h-4 w-4" />
                                Stop
                              </>
                            ) : (
                              <>
                                <CirclePlay className="mr-1 h-4 w-4" />
                                Start
                              </>
                            )}
                          </Button>
                        )}
                        {todo.completed && (
                          <Button
                            type="button"
                            variant="outline"
                            size="sm"
                            onClick={() => requestAttachmentsForTodo(todo.id)}
                          >
                            Add files
                          </Button>
                        )}
                        <Button
                          type="button"
                          variant="ghost"
                          size="icon"
                          aria-label={`Delete "${todo.title}"`}
                          onClick={() => deleteTodo(todo.id)}
                        >
                          <Trash2 className="h-4 w-4" />
                        </Button>
                      </div>
                    </div>

                    {todo.completed && todo.attachments.length > 0 && (
                      <div className="mt-3 space-y-2">
                        <p className="text-muted-foreground text-xs">Attachments</p>
                        <ul className="space-y-1">
                          {todo.attachments.map((a) => (
                            <li
                              key={a.id}
                              className="flex items-center justify-between gap-3 rounded-md bg-muted/30 px-2 py-1"
                            >
                              <div className="flex min-w-0 items-center gap-2">
                                <AttachmentIcon kind={a.kind} />
                                <span className="truncate text-sm">{a.name}</span>
                              </div>
                              <button
                                type="button"
                                onClick={() => void downloadAttachment(a)}
                                className="inline-flex items-center gap-1 text-sm font-medium underline underline-offset-4"
                              >
                                <Download className="h-4 w-4" />
                                Download
                              </button>
                            </li>
                          ))}
                        </ul>
                      </div>
                    )}
                  </div>
                  )
                })}
              </div>
            ))
          )}
        </div>

        {groupedTodos.length > 0 && (
          <div className="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
            <div className="flex items-center gap-2">
              <span className="text-muted-foreground text-sm">Items per page</span>
              <Select
                value={String(pageSize)}
                onValueChange={(v) => {
                  const next = Number(v)
                  setPageSize(next)
                  setPage(1)
                }}
              >
                <SelectTrigger className="w-[110px]">
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="5">5</SelectItem>
                  <SelectItem value="10">10</SelectItem>
                  <SelectItem value="15">15</SelectItem>
                  <SelectItem value="20">20</SelectItem>
                </SelectContent>
              </Select>
            </div>

            {showPagination && (
              <div className="flex items-center justify-between gap-3 sm:justify-end">
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={() => setPage((p) => Math.max(1, p - 1))}
                  disabled={page <= 1}
                >
                  Prev
                </Button>
                <span className="text-muted-foreground text-sm">
                  Page {page} of {totalPages}
                </span>
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={() => setPage((p) => Math.min(totalPages, p + 1))}
                  disabled={page >= totalPages}
                >
                  Next
                </Button>
              </div>
            )}
          </div>
        )}

        <div className="flex items-center justify-between gap-2">
          <Button
            type="button"
            variant="secondary"
            onClick={clearCompleted}
            disabled={completedCount === 0}
          >
            Clear completed
          </Button>
          <span className="text-muted-foreground text-sm">
            Mock data only (no backend)
          </span>
    </div>
      </CardContent>
    </Card>
  )
}

```

```typescriptreact
"use client"

import { zodResolver } from "@hookform/resolvers/zod"
import {
  AlertTriangle,
  CirclePlay,
  CircleStop,
  CalendarClock,
  CheckCircle2,
  Download,
  File,
  FileSpreadsheet,
  FileText,
  Image as ImageIcon,
  Info,
  Music,
  Bell,
  Timer,
  Trash2,
  Video,
} from "lucide-react"
import * as React from "react"
import { useForm } from "react-hook-form"
import { toast } from "sonner"
import { z } from "zod"
import type { SupabaseClient, User } from "@supabase/supabase-js"

import { ModeToggle } from "@/components/mode-toggle"
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert"
import { Badge } from "@/components/ui/badge"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Checkbox } from "@/components/ui/checkbox"
import { Form, FormControl, FormField, FormItem, FormMessage } from "@/components/ui/form"
import { Input } from "@/components/ui/input"
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select"
import { Separator } from "@/components/ui/separator"
import { Textarea } from "@/components/ui/textarea"
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip"
import { cn } from "@/lib/utils"
import { createBrowserSupabaseClient } from "@/lib/supabase/client"

type AttachmentKind =
  | "image"
  | "audio"
  | "video"
  | "pdf"
  | "spreadsheet"
  | "document"
  | "text"
  | "file"

type Attachment = {
  id: string
  name: string
  type: string
  size: number
  bucket: string
  path: string
  kind: AttachmentKind
}

type Todo = {
  id: string
  title: string
  description?: string
  completed: boolean
  // Stored as `datetime-local` string (YYYY-MM-DDTHH:mm) in local time.
  dueAt: string
  attachments: Attachment[]
}

type TaskState = "planned" | "in_progress" | "completed" | "overdue"
type DailyLoad = "light" | "balanced" | "heavy"

const todoSchema = z.object({
  title: z
    .string()
    .trim()
    .min(1, "Title is required.")
    .max(80, "Keep it under 80 characters."),
  description: z
    .string()
    .trim()
    .max(500, "Keep it under 500 characters.")
    .optional()
    .or(z.literal("")),
  dueAt: z
    .string()
    .min(1, "Due date & time is required.")
    .regex(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}$/, "Invalid date/time."),
})

type TodoFormValues = z.infer<typeof todoSchema>

const initialTodos: Todo[] = [
  {
    id: "1",
    title: "Create a Next.js app",
    description: "Scaffold with TypeScript + Tailwind and confirm it runs locally.",
    completed: true,
    dueAt: "2026-01-16T09:00",
    attachments: [],
  },
  {
    id: "2",
    title: "Add shadcn/ui + dark theme",
    description: "Initialize shadcn, set up theme provider, and verify dark mode.",
    completed: true,
    dueAt: "2026-01-16T10:30",
    attachments: [],
  },
  {
    id: "3",
    title: "Build a mock-data to-do list",
    completed: false,
    dueAt: "2026-01-16T15:00",
    attachments: [],
  },
  {
    id: "4",
    title: "Yesterday: review requirements",
    completed: true,
    dueAt: "2026-01-15T11:15",
    attachments: [],
  },
  {
    id: "5",
    title: "Yesterday: sketch UI layout",
    completed: true,
    dueAt: "2026-01-15T17:45",
    attachments: [],
  },
  {
    id: "6",
    title: "Today: add attachments support",
    completed: false,
    dueAt: "2026-01-16T18:20",
    attachments: [],
  },
  {
    id: "7",
    title: "Tomorrow: QA the filters",
    description: "Test date-only, time-only, exact, and between behaviors.",
    completed: false,
    dueAt: "2026-01-17T08:05",
    attachments: [],
  },
  {
    id: "8",
    title: "Tomorrow: polish summary cards",
    completed: false,
    dueAt: "2026-01-17T13:30",
    attachments: [],
  },
  {
    id: "9",
    title: "Tomorrow: write small UX notes",
    completed: false,
    dueAt: "2026-01-17T20:10",
    attachments: [],
  },
  {
    id: "10",
    title: "This weekend: add more mock tasks",
    completed: false,
    dueAt: "2026-01-18T10:00",
    attachments: [],
  },
  {
    id: "11",
    title: "This weekend: check time-only filter",
    completed: false,
    dueAt: "2026-01-18T22:15",
    attachments: [],
  },
  {
    id: "12",
    title: "Next week: sync with team",
    completed: false,
    dueAt: "2026-01-19T09:30",
    attachments: [],
  },
  {
    id: "13",
    title: "Next week: test date-only filter",
    completed: false,
    dueAt: "2026-01-20T14:05",
    attachments: [],
  },
  {
    id: "14",
    title: "Next week: test exact date+time filter",
    completed: false,
    dueAt: "2026-01-21T12:00",
    attachments: [],
  },
  {
    id: "15",
    title: "Next week: attach docs to completed tasks",
    completed: false,
    dueAt: "2026-01-22T16:40",
    attachments: [],
  },
  {
    id: "16",
    title: "Next week: final review",
    completed: false,
    dueAt: "2026-01-23T11:00",
    attachments: [],
  },
]

type DbTaskRow = {
  id: string
  user_id: string
  title: string
  description: string | null
  due_at: string
  completed: boolean
  in_progress: boolean
  attachments: unknown
}

function coerceAttachments(raw: unknown): Attachment[] {
  if (!raw || typeof raw !== "object") return []
  if (!Array.isArray(raw)) return []
  return raw.filter(Boolean) as Attachment[]
}

function toDbTaskInsert(values: TodoFormValues, userId: string) {
  return {
    user_id: userId,
    title: values.title.trim(),
    description: (values.description ?? "").trim() || null,
    due_at: values.dueAt,
    completed: false,
    in_progress: false,
    attachments: [],
  }
}

function fromDbTask(row: DbTaskRow): Todo {
  return {
    id: row.id,
    title: row.title,
    description: row.description ?? undefined,
    completed: row.completed,
    dueAt: row.due_at,
    attachments: coerceAttachments(row.attachments),
  }
}

function parseLocalDateTime(value: string): number {
  // value: "YYYY-MM-DDTHH:mm"
  const [datePart, timePart] = value.split("T")
  const [y, m, d] = datePart.split("-").map(Number)
  const [hh, mm] = timePart.split(":").map(Number)
  return new Date(y, m - 1, d, hh, mm, 0, 0).getTime()
}

function pad2(n: number) {
  return String(n).padStart(2, "0")
}

function localDateKey(d: Date) {
  return `${d.getFullYear()}-${pad2(d.getMonth() + 1)}-${pad2(d.getDate())}`
}

function addDays(date: Date, days: number) {
  const d = new Date(date)
  d.setDate(d.getDate() + days)
  return d
}

function startOfDay(date: Date) {
  return new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0, 0)
}

function endOfDay(date: Date) {
  return new Date(
    date.getFullYear(),
    date.getMonth(),
    date.getDate(),
    23,
    59,
    59,
    999
  )
}

function getDatePart(dueAt: string) {
  return dueAt.split("T")[0] ?? ""
}

function getTimePart(dueAt: string) {
  return dueAt.split("T")[1] ?? ""
}

function parseLocalDateOnly(value: string): Date {
  // value: "YYYY-MM-DD"
  const [y, m, d] = value.split("-").map(Number)
  return new Date(y, m - 1, d, 0, 0, 0, 0)
}

function parseLocalTimeToMinutes(value: string): number {
  // value: "HH:mm"
  const [hh, mm] = value.split(":").map(Number)
  return hh * 60 + mm
}

function formatLocalDateTime(value: string): string {
  const ms = parseLocalDateTime(value)
  if (!Number.isFinite(ms)) return value
  return new Intl.DateTimeFormat(undefined, {
    year: "numeric",
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  }).format(new Date(ms))
}

function formatDateTimeFromMs(ms: number): string {
  return new Intl.DateTimeFormat(undefined, {
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  }).format(new Date(ms))
}

function minutesUntil(targetMs: number, nowMs: number) {
  return Math.ceil((targetMs - nowMs) / 60_000)
}

function getTaskFlags(todo: Todo, nowMs: number, inProgressTaskId: string | null) {
  const completed = todo.completed
  const dueMs = parseLocalDateTime(todo.dueAt)
  const overdue = !completed && dueMs < nowMs
  const inProgress = !completed && inProgressTaskId === todo.id
  const planned = !completed && !overdue && !inProgress
  return { completed, overdue, inProgress, planned }
}

function getDailyLoad(todosForDay: Todo[]) {
  // 4-hour windows across the day (local).
  const labels = [
    "00:00–04:00",
    "04:00–08:00",
    "08:00–12:00",
    "12:00–16:00",
    "16:00–20:00",
    "20:00–24:00",
  ]
  const buckets = Array.from({ length: 6 }, () => 0) as number[]
  for (const t of todosForDay) {
    const ms = parseLocalDateTime(t.dueAt)
    const hour = new Date(ms).getHours()
    const idx = Math.floor(hour / 4)
    buckets[idx] = (buckets[idx] ?? 0) + 1
  }

  const total = todosForDay.length
  const peak = Math.max(0, ...buckets)
  const spread = buckets.filter((c) => c > 0).length
  const busiestIdx = buckets.findIndex((c) => c === peak)
  const busiestWindow = busiestIdx >= 0 ? labels[busiestIdx] : labels[0]

  // Heuristic: more tasks + higher concentration in one window => heavier day.
  const score = total + peak * 1.5 + Math.max(0, spread - 1) * 0.5
  const load: DailyLoad = score <= 5 ? "light" : score <= 10 ? "balanced" : "heavy"

  return { load, total, peak, spread, busiestWindow }
}

function DailyLoadBadge({ load }: { load: DailyLoad }) {
  if (load === "heavy") return <Badge variant="destructive">Heavy</Badge>
  if (load === "balanced") return <Badge variant="secondary">Balanced</Badge>
  return <Badge variant="outline">Light</Badge>
}

function TaskBadges({
  completed,
  overdue,
  inProgress,
  planned,
}: {
  completed: boolean
  overdue: boolean
  inProgress: boolean
  planned: boolean
}) {
  if (completed) {
    return (
      <Badge className="gap-1 bg-emerald-600 text-white hover:bg-emerald-600">
        <CheckCircle2 className="h-3.5 w-3.5" />
        Completed
      </Badge>
    )
  }

  return (
    <>
      {inProgress && (
        <Badge className="gap-1 bg-sky-600 text-white hover:bg-sky-600">
          <Timer className="h-3.5 w-3.5 text-white" />
          In progress
        </Badge>
      )}
      {overdue && (
        <Badge variant="destructive" className="gap-1">
          <AlertTriangle className="h-3.5 w-3.5" />
          Overdue
        </Badge>
      )}
      {planned && (
        <Badge variant="outline" className="gap-1">
          <CalendarClock className="h-3.5 w-3.5" />
          Planned
        </Badge>
      )}
    </>
  )
}

function getAttachmentKind(file: File): AttachmentKind {
  const type = (file.type || "").toLowerCase()
  const name = file.name.toLowerCase()
  const ext = name.includes(".") ? name.split(".").pop() ?? "" : ""

  if (type.startsWith("image/")) return "image"
  if (type.startsWith("audio/")) return "audio"
  if (type.startsWith("video/")) return "video"

  if (ext === "pdf") return "pdf"
  if (["xls", "xlsx", "csv"].includes(ext)) return "spreadsheet"
  if (["doc", "docx"].includes(ext)) return "document"
  if (["txt", "md", "rtf"].includes(ext)) return "text"

  return "file"
}

function sanitizePathSegment(s: string) {
  return s.replace(/[^\w.\-]+/g, "_")
}

function buildAttachmentRecord(file: File, bucket: string, path: string): Attachment {
  return {
    id: crypto.randomUUID(),
    name: file.name,
    type: file.type,
    size: file.size,
    bucket,
    path,
    kind: getAttachmentKind(file),
  }
}

function AttachmentIcon({ kind }: { kind: AttachmentKind }) {
  const className = "h-4 w-4 text-muted-foreground"

  switch (kind) {
    case "image":
      return <ImageIcon className={className} />
    case "audio":
      return <Music className={className} />
    case "video":
      return <Video className={className} />
    case "spreadsheet":
      return <FileSpreadsheet className={className} />
    case "pdf":
    case "document":
    case "text":
      return <FileText className={className} />
    default:
      return <File className={className} />
  }
}

const authSchema = z.object({
  email: z.string().email("Enter a valid email."),
  password: z.string().min(6, "Password must be at least 6 characters."),
})
type AuthValues = z.infer<typeof authSchema>

function AuthCard({ supabase }: { supabase: SupabaseClient }) {
  const [mode, setMode] = React.useState<"sign_in" | "sign_up">("sign_in")
  const [busy, setBusy] = React.useState(false)

  const form = useForm<AuthValues>({
    resolver: zodResolver(authSchema),
    defaultValues: { email: "", password: "" },
  })

  async function onSubmit(values: AuthValues) {
    setBusy(true)
    try {
      if (mode === "sign_in") {
        const { error } = await supabase.auth.signInWithPassword(values)
        if (error) throw error
      } else {
        const { error } = await supabase.auth.signUp(values)
        if (error) throw error
        toast.success("Account created", { description: "You can now sign in." })
        setMode("sign_in")
      }
    } catch (e) {
      toast.error("Authentication failed", {
        description: e instanceof Error ? e.message : "Please try again.",
      })
    } finally {
      setBusy(false)
    }
  }

  return (
    <div className="mx-auto flex min-h-screen max-w-md flex-col justify-center px-4 py-10">
      <Card>
        <CardHeader>
          <CardTitle className="text-2xl">Sign in</CardTitle>
          <p className="text-muted-foreground text-sm">
            {mode === "sign_in"
              ? "Use your email and password."
              : "Create an account with email and password."}
          </p>
        </CardHeader>
        <CardContent className="space-y-4">
          <Form {...form}>
            <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-3" noValidate>
              <FormField
                control={form.control}
                name="email"
                render={({ field }) => (
                  <FormItem>
                    <FormControl>
                      <Input placeholder="Email" autoComplete="email" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="password"
                render={({ field }) => (
                  <FormItem>
                    <FormControl>
                      <Input
                        type="password"
                        placeholder="Password"
                        autoComplete={
                          mode === "sign_in" ? "current-password" : "new-password"
                        }
                        {...field}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <Button type="submit" className="w-full" disabled={busy}>
                {mode === "sign_in" ? "Sign in" : "Sign up"}
              </Button>
            </form>
          </Form>

          <div className="flex items-center justify-between gap-3 text-sm">
            <span className="text-muted-foreground">
              {mode === "sign_in" ? "No account?" : "Already have an account?"}
            </span>
            <Button
              type="button"
              variant="link"
              className="px-0"
              onClick={() => setMode((m) => (m === "sign_in" ? "sign_up" : "sign_in"))}
            >
              {mode === "sign_in" ? "Sign up" : "Sign in"}
            </Button>
          </div>
        </CardContent>
      </Card>
    </div>
  )
}

export default function Home() {
  const [supabaseError, setSupabaseError] = React.useState<string | null>(null)
  const supabase = React.useMemo(() => {
    try {
      return createBrowserSupabaseClient()
    } catch (e) {
      setSupabaseError(e instanceof Error ? e.message : "Supabase is not configured.")
      return null
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [])

  const [user, setUser] = React.useState<User | null>(null)
  const [authLoading, setAuthLoading] = React.useState(true)

  React.useEffect(() => {
    if (!supabase) return
    let alive = true
    supabase.auth.getUser().then(({ data }) => {
      if (!alive) return
      setUser(data.user ?? null)
      setAuthLoading(false)
    })
    const { data } = supabase.auth.onAuthStateChange((_event, session) => {
      setUser(session?.user ?? null)
    })
    return () => {
      alive = false
      data.subscription.unsubscribe()
    }
  }, [supabase])

  if (supabaseError) {
    return (
      <div className="mx-auto flex min-h-screen max-w-2xl flex-col justify-center gap-4 px-4 py-10">
        <Card>
          <CardHeader>
            <CardTitle>Supabase not configured</CardTitle>
          </CardHeader>
          <CardContent className="space-y-2">
            <p className="text-muted-foreground text-sm">{supabaseError}</p>
            <p className="text-muted-foreground text-sm">
              See <code>SUPABASE_SETUP.md</code> and <code>supabase.env.example</code>.
            </p>
          </CardContent>
        </Card>
      </div>
    )
  }

  if (!supabase) return null
  if (authLoading) {
    return (
      <div className="mx-auto flex min-h-screen max-w-2xl flex-col justify-center px-4 py-10">
        <p className="text-muted-foreground text-sm">Loading…</p>
      </div>
    )
  }

  if (!user) return <AuthCard supabase={supabase} />

  return (
    <div className="mx-auto flex min-h-screen max-w-2xl flex-col gap-6 px-4 py-10">
      <TodoApp supabase={supabase} user={user} />
    </div>
  )
}

function TodoApp({ supabase, user }: { supabase: SupabaseClient; user: User }) {
  const userId = user.id
  const [todos, setTodos] = React.useState<Todo[]>([])
  const [tasksLoading, setTasksLoading] = React.useState(true)
  const [attachTargetTodoId, setAttachTargetTodoId] = React.useState<string | null>(
    null
  )
  const [conflictDueAt, setConflictDueAt] = React.useState<string | null>(null)
  const clearConflictTimerRef = React.useRef<number | null>(null)
  const [focusMode, setFocusMode] = React.useState(false)
  const [nowMs, setNowMs] = React.useState(() => Date.now())
  const [inProgressTaskId, setInProgressTaskId] = React.useState<string | null>(null)
  const [dismissedReminderTaskId, setDismissedReminderTaskId] = React.useState<
    string | null
  >(null)
  const [filterMode, setFilterMode] = React.useState<"between" | "exact">("between")
  const [filterFromDate, setFilterFromDate] = React.useState<string>("")
  const [filterFromTime, setFilterFromTime] = React.useState<string>("")
  const [filterToDate, setFilterToDate] = React.useState<string>("")
  const [filterToTime, setFilterToTime] = React.useState<string>("")
  const [filterExactDate, setFilterExactDate] = React.useState<string>("")
  const [filterExactTime, setFilterExactTime] = React.useState<string>("")
  const fileInputRef = React.useRef<HTMLInputElement>(null)
  const [pageSize, setPageSize] = React.useState<number>(5)
  const [page, setPage] = React.useState<number>(1)

  React.useEffect(() => {
    let alive = true
    async function load() {
      setTasksLoading(true)
      const { data, error } = await supabase
        .from("tasks")
        .select("*")
        .eq("user_id", userId)
        .order("due_at", { ascending: true })
      if (!alive) return
      if (error) {
        toast.error("Failed to load tasks", { description: error.message })
        setTodos([])
        setInProgressTaskId(null)
      } else {
        const rows = (data ?? []) as DbTaskRow[]
        setTodos(rows.map(fromDbTask))
        setInProgressTaskId(rows.find((r) => r.in_progress)?.id ?? null)
      }
      setTasksLoading(false)
    }
    load()
    return () => {
      alive = false
    }
  }, [supabase, userId])

  // Keep "now" fresh so overdue/in-progress states stay accurate without user interaction.
  React.useEffect(() => {
    const id = window.setInterval(() => setNowMs(Date.now()), 30_000)
    return () => window.clearInterval(id)
  }, [])

  // Only one task can be "In Progress"; auto-clear if completed, deleted, or overdue.
  React.useEffect(() => {
    if (!inProgressTaskId) return
    const t = todos.find((x) => x.id === inProgressTaskId)
    if (!t || t.completed) {
      setInProgressTaskId(null)
      return
    }
  }, [inProgressTaskId, nowMs, todos])

  const nextUpcoming = React.useMemo(() => {
    const upcoming = todos
      .filter((t) => !t.completed)
      .map((t) => ({ todo: t, dueMs: parseLocalDateTime(t.dueAt) }))
      .filter((x) => x.dueMs >= nowMs)
      .sort((a, b) => a.dueMs - b.dueMs)[0]
    return upcoming ?? null
  }, [nowMs, todos])

  React.useEffect(() => {
    // If "next upcoming" changed, allow reminder again (dismiss is per-task).
    if (nextUpcoming && nextUpcoming.todo.id !== dismissedReminderTaskId) return
    if (!nextUpcoming) setDismissedReminderTaskId(null)
  }, [dismissedReminderTaskId, nextUpcoming])

  const reminder = React.useMemo(() => {
    const REMINDER_WINDOW_MIN = 15
    if (!nextUpcoming) return null
    if (dismissedReminderTaskId === nextUpcoming.todo.id) return null
    const mins = minutesUntil(nextUpcoming.dueMs, nowMs)
    if (mins < 0 || mins > REMINDER_WINDOW_MIN) return null
    return { ...nextUpcoming, mins }
  }, [dismissedReminderTaskId, nextUpcoming, nowMs])

  const form = useForm<TodoFormValues>({
    resolver: zodResolver(todoSchema),
    defaultValues: { title: "", description: "", dueAt: "" },
    mode: "onSubmit",
  })

  const summary = React.useMemo(() => {
    const now = new Date()
    const todayKey = localDateKey(now)
    const tomorrow = addDays(now, 1)
    const tomorrowKey = localDateKey(tomorrow)

    const todays = todos.filter((t) => t.dueAt.startsWith(todayKey))
    const todayCompleted = todays.filter((t) => t.completed).length
    const todayPending = todays.length - todayCompleted

    const labels = [
      "00:00–04:00",
      "04:00–08:00",
      "08:00–12:00",
      "12:00–16:00",
      "16:00–20:00",
      "20:00–24:00",
    ]

    // Tomorrow: same 4-hour windows breakdown
    const tomorrowTasks = todos.filter((t) => t.dueAt.startsWith(tomorrowKey))
    const tomorrowBuckets = Array.from({ length: 6 }, () => 0) as number[]
    for (const t of tomorrowTasks) {
      const ms = parseLocalDateTime(t.dueAt)
      const hour = new Date(ms).getHours()
      const idx = Math.floor(hour / 4)
      tomorrowBuckets[idx] = (tomorrowBuckets[idx] ?? 0) + 1
    }

    // Until next week = next 7 days starting tomorrow (local), grouped into 4-hour windows.
    const rangeStart = startOfDay(tomorrow).getTime()
    const rangeEnd = addDays(startOfDay(tomorrow), 7).getTime()
    const buckets = Array.from({ length: 6 }, () => 0) as number[]

    const upcoming = todos.filter((t) => {
      const ms = parseLocalDateTime(t.dueAt)
      return ms >= rangeStart && ms < rangeEnd
    })

    for (const t of upcoming) {
      const ms = parseLocalDateTime(t.dueAt)
      const hour = new Date(ms).getHours()
      const idx = Math.floor(hour / 4)
      buckets[idx] = (buckets[idx] ?? 0) + 1
    }

    return {
      todayCompleted,
      todayPending,
      tomorrowTotal: tomorrowTasks.length,
      tomorrowBuckets: labels.map((label, i) => ({ label, count: tomorrowBuckets[i] ?? 0 })),
      upcomingTotal: upcoming.length,
      upcomingBuckets: labels.map((label, i) => ({ label, count: buckets[i] ?? 0 })),
    }
  }, [todos])

  const loadDayKey = React.useMemo(() => {
    // Prefer an explicitly selected date from filters; otherwise use today.
    if (filterMode === "exact" && filterExactDate) return filterExactDate
    if (filterFromDate && !filterToDate) return filterFromDate
    if (filterFromDate && filterToDate && filterFromDate === filterToDate) return filterFromDate
    if (!filterFromDate && filterToDate) return filterToDate
    return localDateKey(new Date(nowMs))
  }, [filterExactDate, filterFromDate, filterMode, filterToDate, nowMs])

  const dailyLoad = React.useMemo(() => {
    const dayTodos = todos.filter((t) => getDatePart(t.dueAt) === loadDayKey)
    return getDailyLoad(dayTodos)
  }, [loadDayKey, todos])

  const filteredTodos = React.useMemo(() => {
    if (focusMode) {
      const endMs = nowMs + 4 * 60 * 60 * 1000
      const withMs = todos.map((t) => ({ ...t, _dueMs: parseLocalDateTime(t.dueAt) }))
      return withMs.filter((t) => t._dueMs >= nowMs && t._dueMs <= endMs)
    }

    const withMs = todos.map((t) => ({ ...t, _dueMs: parseLocalDateTime(t.dueAt) }))
    if (filterMode === "exact") {
      // If only date is selected -> show tasks for that date.
      // If time is selected too -> match exact date+time.
      // If only time is selected -> match time-of-day across all dates.
      if (!filterExactDate && !filterExactTime) return withMs

      if (filterExactDate && !filterExactTime) {
        return withMs.filter((t) => getDatePart(t.dueAt) === filterExactDate)
      }

      if (filterExactDate && filterExactTime) {
        const exactMs = parseLocalDateTime(`${filterExactDate}T${filterExactTime}`)
        return withMs.filter((t) => t._dueMs === exactMs)
      }

      // time only
      return withMs.filter((t) => getTimePart(t.dueAt) === filterExactTime)
    }
    // between
    const hasAnyDate = Boolean(filterFromDate || filterToDate)
    const hasAnyTime = Boolean(filterFromTime || filterToTime)

    // Date range (optional)
    const fromDateMs = filterFromDate
      ? startOfDay(parseLocalDateOnly(filterFromDate)).getTime()
      : Number.NEGATIVE_INFINITY
    const toDateMs = filterToDate
      ? endOfDay(parseLocalDateOnly(filterToDate)).getTime()
      : Number.POSITIVE_INFINITY

    // Time-of-day range (optional)
    const fromTimeMin = filterFromTime ? parseLocalTimeToMinutes(filterFromTime) : 0
    const toTimeMin = filterToTime ? parseLocalTimeToMinutes(filterToTime) : 24 * 60 - 1

    return withMs.filter((t) => {
      const ms = t._dueMs
      if (hasAnyDate && (ms < fromDateMs || ms > toDateMs)) return false

      if (hasAnyTime) {
        const time = getTimePart(t.dueAt)
        if (!time) return false
        const mins = parseLocalTimeToMinutes(time)
        // Simple (non-wrapping) range. If you want wrap-around (e.g. 22:00–02:00), tell me.
        if (mins < fromTimeMin || mins > toTimeMin) return false
      }

      // If neither date nor time selected, pass through (handled above anyway)
      return true
    })
  }, [
    todos,
    focusMode,
    nowMs,
    filterExactDate,
    filterExactTime,
    filterFromDate,
    filterFromTime,
    filterMode,
    filterToDate,
    filterToTime,
  ])

  const sortedFilteredTodos = React.useMemo(
    () =>
      filteredTodos
        .slice()
        .sort((a, b) => parseLocalDateTime(a.dueAt) - parseLocalDateTime(b.dueAt)),
    [filteredTodos]
  )

  // Clamp page when filters/pageSize change.
  React.useEffect(() => {
    const totalPages = Math.max(1, Math.ceil(sortedFilteredTodos.length / pageSize))
    setPage((p) => Math.min(Math.max(1, p), totalPages))
  }, [pageSize, sortedFilteredTodos.length])

  const totalItems = sortedFilteredTodos.length
  const totalPages = Math.max(1, Math.ceil(totalItems / pageSize))
  const showPagination = totalPages > 1

  const pageItems = React.useMemo(() => {
    const start = (page - 1) * pageSize
    return sortedFilteredTodos.slice(start, start + pageSize)
  }, [page, pageSize, sortedFilteredTodos])

  const groupedTodos = React.useMemo(() => {
    const groups: Array<{ date: string; items: typeof pageItems }> = []
    for (const t of pageItems) {
      const date = getDatePart(t.dueAt)
      const last = groups[groups.length - 1]
      if (!last || last.date !== date) groups.push({ date, items: [t] })
      else last.items.push(t)
    }
    return groups
  }, [pageItems])

  const completedCount = filteredTodos.filter((t) => t.completed).length

  async function addTodo(values: TodoFormValues) {
    const conflicts = todos.filter((t) => t.dueAt === values.dueAt)
    if (conflicts.length > 0) {
      setConflictDueAt(values.dueAt)
      if (clearConflictTimerRef.current) window.clearTimeout(clearConflictTimerRef.current)
      clearConflictTimerRef.current = window.setTimeout(() => {
        setConflictDueAt(null)
      }, 8000)

      // Make sure the user can see the conflicting tasks even if they were filtered out.
      const [d, time] = values.dueAt.split("T")
      setFilterMode("exact")
      setFilterExactDate(d ?? "")
      setFilterExactTime(time ?? "")
      setPage(1)

      toast.error("Time conflict", {
        description: `You already have ${conflicts.length} task(s) scheduled at ${formatLocalDateTime(
          values.dueAt
        )}.`,
      })
    }

    const { data, error } = await supabase
      .from("tasks")
      .insert(toDbTaskInsert(values, userId))
      .select("*")
      .single()
    if (error) {
      toast.error("Failed to add task", { description: error.message })
      return
    }

    setTodos((prev) => [fromDbTask(data as DbTaskRow), ...prev])
    form.reset()
  }

  async function toggleTodo(id: string, completed: boolean) {
    // optimistic
    setTodos((prev) =>
      prev.map((t) =>
        t.id === id ? { ...t, completed, attachments: t.attachments } : t
      )
    )
    if (completed) setInProgressTaskId((cur) => (cur === id ? null : cur))

    const update: { completed: boolean; in_progress?: boolean } = { completed }
    if (completed) update.in_progress = false

    const { error } = await supabase
      .from("tasks")
      .update(update)
      .eq("id", id)
      .eq("user_id", userId)
    if (error) {
      toast.error("Failed to update task", { description: error.message })
    }
  }

  function requestAttachmentsForTodo(todoId: string) {
    setAttachTargetTodoId(todoId)
    // Let state update before opening picker (some browsers are picky).
    queueMicrotask(() => fileInputRef.current?.click())
  }

  async function handleFilesPicked(e: React.ChangeEvent<HTMLInputElement>) {
    const files = Array.from(e.target.files ?? [])
    const targetId = attachTargetTodoId

    // reset input so picking the same file again triggers onChange
    e.target.value = ""
    setAttachTargetTodoId(null)

    if (!targetId || files.length === 0) return
    const targetTodo = todos.find((t) => t.id === targetId)
    if (!targetTodo) return

    const bucket = "task-attachments"
    const uploaded: Attachment[] = []

    for (const file of files) {
      const safeName = sanitizePathSegment(file.name)
      const path = `${userId}/${targetId}/${crypto.randomUUID()}-${safeName}`
      const { error } = await supabase.storage
        .from(bucket)
        .upload(path, file, { contentType: file.type, upsert: false })
      if (error) {
        toast.error("Upload failed", { description: error.message })
        continue
      }
      uploaded.push(buildAttachmentRecord(file, bucket, path))
    }

    if (uploaded.length === 0) return
    const nextAttachments = [...targetTodo.attachments, ...uploaded]

    // optimistic
    setTodos((prev) =>
      prev.map((t) => (t.id === targetId ? { ...t, attachments: nextAttachments } : t))
    )

    const { error } = await supabase
      .from("tasks")
      .update({ attachments: nextAttachments })
      .eq("id", targetId)
      .eq("user_id", userId)
    if (error) {
      toast.error("Failed to save attachments", { description: error.message })
    }
  }

  async function deleteTodo(id: string) {
    // optimistic
    setTodos((prev) => prev.filter((t) => t.id !== id))
    setInProgressTaskId((cur) => (cur === id ? null : cur))

    const { error } = await supabase.from("tasks").delete().eq("id", id).eq("user_id", userId)
    if (error) toast.error("Failed to delete task", { description: error.message })
  }

  async function setInProgress(taskId: string | null) {
    // optimistic
    setInProgressTaskId(taskId)

    // Clear any previous in-progress tasks first (enforces the single-task rule).
    const clearRes = await supabase
      .from("tasks")
      .update({ in_progress: false })
      .eq("user_id", userId)
      .eq("in_progress", true)
    if (clearRes.error) {
      toast.error("Failed to update in-progress", { description: clearRes.error.message })
      return
    }

    if (!taskId) return

    const setRes = await supabase
      .from("tasks")
      .update({ in_progress: true })
      .eq("id", taskId)
      .eq("user_id", userId)
    if (setRes.error) {
      toast.error("Failed to update in-progress", { description: setRes.error.message })
    }
  }

  async function downloadAttachment(a: Attachment) {
    const { data, error } = await supabase.storage.from(a.bucket).createSignedUrl(a.path, 60)
    if (error || !data?.signedUrl) {
      toast.error("Download failed", { description: error?.message ?? "Please try again." })
      return
    }
    window.open(data.signedUrl, "_blank", "noopener,noreferrer")
  }

  async function seedDemoTasks() {
    if (todos.length > 0) return
    const payload = initialTodos.map((t) => ({
      user_id: userId,
      title: t.title,
      description: t.description ?? null,
      due_at: t.dueAt,
      completed: t.completed,
      in_progress: false,
      attachments: [],
    }))
    const { data, error } = await supabase.from("tasks").insert(payload).select("*")
    if (error) {
      toast.error("Failed to seed demo tasks", { description: error.message })
      return
    }
    const rows = (data ?? []) as DbTaskRow[]
    setTodos(rows.map(fromDbTask))
  }

  async function clearCompleted() {
    const completedIds = new Set(todos.filter((t) => t.completed).map((t) => t.id))
    if (completedIds.size === 0) return

    // optimistic
    setTodos((prev) => prev.filter((t) => !completedIds.has(t.id)))

    const { error } = await supabase
      .from("tasks")
      .delete()
      .eq("user_id", userId)
      .eq("completed", true)
    if (error) toast.error("Failed to clear completed", { description: error.message })
  }

  return (
    <Card>
      <CardHeader className="flex flex-row items-center justify-between gap-4">
        <div className="space-y-1">
          <CardTitle className="text-2xl">To‑Do</CardTitle>
          <p className="text-muted-foreground text-sm">
            {completedCount}/{filteredTodos.length} completed
          </p>
        </div>
        <div className="flex items-center gap-2">
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <Button
                  type="button"
                  variant={focusMode ? "default" : "outline"}
                  size="sm"
                  onClick={() => {
                    setFocusMode((v) => !v)
                    setPage(1)
                  }}
                >
                  Focus Mode
                </Button>
              </TooltipTrigger>
              <TooltipContent>
                <p>Show tasks for the next 4 hours.</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
          <Button
            type="button"
            variant="outline"
            size="sm"
            onClick={async () => {
              await supabase.auth.signOut()
            }}
          >
            Sign out
          </Button>
          <ModeToggle />
        </div>
      </CardHeader>

      <CardContent className="space-y-6">
        {tasksLoading && (
          <p className="text-muted-foreground text-sm">Loading tasks…</p>
        )}

        {!tasksLoading && todos.length === 0 && (
          <div className="flex items-center justify-between gap-3 rounded-lg border bg-muted/20 px-3 py-2">
            <p className="text-muted-foreground text-sm">No tasks yet.</p>
            <Button type="button" variant="outline" size="sm" onClick={() => void seedDemoTasks()}>
              Seed demo tasks
            </Button>
          </div>
        )}

        <input
          ref={fileInputRef}
          type="file"
          multiple
          className="hidden"
          accept={[
            "image/*",
            "audio/*",
            "video/*",
            ".pdf",
            ".doc",
            ".docx",
            ".xls",
            ".xlsx",
            ".csv",
            ".txt",
            ".md",
            ".rtf",
          ].join(",")}
          onChange={handleFilesPicked}
        />

        {reminder && (
          <Alert className="border-primary/30 bg-primary/5">
            <Bell className="h-4 w-4" />
            <div className="flex flex-1 flex-col gap-1">
              <div className="flex flex-wrap items-center justify-between gap-2">
                <AlertTitle className="text-sm">
                  Next task starts in {reminder.mins} minute{reminder.mins === 1 ? "" : "s"}
                </AlertTitle>
                <Button
                  type="button"
                  variant="ghost"
                  size="sm"
                  onClick={() => setDismissedReminderTaskId(reminder.todo.id)}
                >
                  Dismiss
                </Button>
              </div>
              <AlertDescription className="text-sm">
                <span className="font-medium">{reminder.todo.title}</span> ·{" "}
                {formatDateTimeFromMs(reminder.dueMs)}
              </AlertDescription>
            </div>
          </Alert>
        )}

        <div className="rounded-xl border bg-card p-4">
          <div className="flex flex-wrap items-center justify-between gap-2">
            <p className="text-sm font-medium">
              Daily load{" "}
              <span className="text-muted-foreground font-normal">
                ({new Intl.DateTimeFormat(undefined, {
                  weekday: "short",
                  year: "numeric",
                  month: "short",
                  day: "2-digit",
                }).format(parseLocalDateOnly(loadDayKey))})
              </span>
            </p>
            <DailyLoadBadge load={dailyLoad.load} />
          </div>
          <p className="text-muted-foreground mt-2 text-sm">
            {dailyLoad.total} task(s) · busiest window {dailyLoad.busiestWindow} ({dailyLoad.peak})
          </p>
        </div>

        <div className="grid gap-3 sm:grid-cols-3">
          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Today’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">
              {summary.todayCompleted} completed
            </p>
            <p className="text-muted-foreground text-sm">{summary.todayPending} pending</p>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tomorrow’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">{summary.tomorrowTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.tomorrowBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tasks Until Next Week</p>
            <p className="mt-2 text-2xl font-semibold">{summary.upcomingTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.upcomingBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>
        </div>

        {focusMode && (
          <div className="flex flex-col gap-1 rounded-lg border bg-muted/20 px-3 py-2 sm:flex-row sm:items-center sm:justify-between">
            <p className="text-sm">
              <span className="font-medium">Focus Mode:</span>{" "}
              showing tasks due in the next 4 hours (until{" "}
              <span className="font-medium">
                {formatDateTimeFromMs(nowMs + 4 * 60 * 60 * 1000)}
              </span>
              )
            </p>
            <Button type="button" variant="ghost" size="sm" onClick={() => setFocusMode(false)}>
              Exit
            </Button>
          </div>
        )}

        <Form {...form}>
          <form
            onSubmit={form.handleSubmit(addTodo)}
            className="space-y-2"
            noValidate
          >
            <div className="flex flex-col gap-2 sm:flex-row">
              <FormField
                control={form.control}
                name="title"
                render={({ field }) => (
                  <FormItem className="flex-1">
                    <FormControl>
                      <Input
                        placeholder="Add a task…"
                        autoComplete="off"
                        {...field}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="dueAt"
                render={({ field }) => (
                  <FormItem className="sm:w-64">
                    <FormControl>
                      <Input type="datetime-local" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <Button type="submit">Add</Button>
            </div>

            <FormField
              control={form.control}
              name="description"
              render={({ field }) => (
                <FormItem>
                  <FormControl>
                    <Textarea
                      rows={3}
                      placeholder="Description (optional)…"
                      {...field}
                    />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />
          </form>
        </Form>

        <Separator />

        <div className="space-y-3">
          <div className="flex flex-wrap items-center justify-between gap-2">
            <p className="text-sm font-medium">Filter by date & time</p>
            <div className="flex items-center gap-2">
              <Button
                type="button"
                size="sm"
                variant={filterMode === "between" ? "default" : "outline"}
                onClick={() => setFilterMode("between")}
              >
                Between
              </Button>
              <Button
                type="button"
                size="sm"
                variant={filterMode === "exact" ? "default" : "outline"}
                onClick={() => setFilterMode("exact")}
              >
                Exact
              </Button>
              <Button
                type="button"
                size="sm"
                variant="ghost"
                onClick={() => {
                  setFilterFromDate("")
                  setFilterFromTime("")
                  setFilterToDate("")
                  setFilterToTime("")
                  setFilterExactDate("")
                  setFilterExactTime("")
                }}
              >
                Clear
              </Button>
            </div>
          </div>

          {filterMode === "between" ? (
            <div className="grid gap-2 sm:grid-cols-2">
              <div className="grid gap-2 sm:grid-cols-2">
                <Input
                  type="date"
                  value={filterFromDate}
                  onChange={(e) => setFilterFromDate(e.target.value)}
                />
                <Input
                  type="time"
                  value={filterFromTime}
                  onChange={(e) => setFilterFromTime(e.target.value)}
                />
              </div>
              <div className="grid gap-2 sm:grid-cols-2">
                <Input
                  type="date"
                  value={filterToDate}
                  onChange={(e) => setFilterToDate(e.target.value)}
                />
                <Input
                  type="time"
                  value={filterToTime}
                  onChange={(e) => setFilterToTime(e.target.value)}
                />
              </div>
            </div>
          ) : (
            <div className="grid gap-2 sm:grid-cols-2">
              <Input
                type="date"
                value={filterExactDate}
                onChange={(e) => setFilterExactDate(e.target.value)}
              />
              <Input
                type="time"
                value={filterExactTime}
                onChange={(e) => setFilterExactTime(e.target.value)}
              />
            </div>
          )}
        </div>

        <Separator />

        <div className="space-y-2">
          {groupedTodos.length === 0 ? (
            <p className="text-muted-foreground text-sm">No tasks yet.</p>
          ) : (
            groupedTodos.map((group) => (
              <div key={group.date} className="space-y-2">
                <div className="flex items-center gap-3 pt-2">
                  <Separator className="flex-1" />
                  <span className="text-muted-foreground whitespace-nowrap text-xs font-medium">
                    {new Intl.DateTimeFormat(undefined, {
                      weekday: "short",
                      year: "numeric",
                      month: "short",
                      day: "2-digit",
                    }).format(parseLocalDateOnly(group.date))}
                  </span>
                  <Separator className="flex-1" />
                </div>

                {group.items.map((todo) => {
                  const flags = getTaskFlags(todo, nowMs, inProgressTaskId)

                  return (
                    <div
                      key={todo.id}
                      className={cn(
                        "rounded-lg border px-3 py-2",
                        flags.completed && "opacity-75",
                        flags.overdue &&
                          "border-destructive/40 bg-destructive/5 text-muted-foreground",
                        flags.inProgress && "border-sky-500/40 bg-sky-500/10",
                        conflictDueAt &&
                          todo.dueAt === conflictDueAt &&
                          "border-destructive/60 bg-destructive/5 ring-1 ring-destructive/30"
                      )}
                    >
                      <div className="flex items-start justify-between gap-3">
                        <label className="flex cursor-pointer items-start gap-3">
                        <Checkbox
                          checked={todo.completed}
                          onCheckedChange={(v) => {
                            const next = Boolean(v)
                            toggleTodo(todo.id, next)
                            if (next && !todo.completed) {
                              requestAttachmentsForTodo(todo.id)
                            }
                          }}
                          aria-label={`Mark "${todo.title}" as ${
                            todo.completed ? "not completed" : "completed"
                          }`}
                          className="mt-0.5"
                        />
                        <span
                          className={cn(
                            "leading-6",
                            todo.completed && "text-muted-foreground line-through"
                          )}
                        >
                          <span className="flex flex-wrap items-center gap-2">
                            <span className="block">{todo.title}</span>
                              <span className="flex flex-wrap items-center gap-2">
                                <TaskBadges {...flags} />
                              </span>
                            {todo.description && (
                              <TooltipProvider>
                                <Tooltip>
                                  <TooltipTrigger asChild>
                                    <button
                                      type="button"
                                      className="text-muted-foreground hover:text-foreground inline-flex h-7 w-7 items-center justify-center rounded-md border bg-background"
                                      aria-label="View description"
                                    >
                                      <Info className="h-4 w-4" />
                                    </button>
                                  </TooltipTrigger>
                                  <TooltipContent className="max-w-xs">
                                    <p className="whitespace-pre-wrap text-sm">
                                      {todo.description}
                                    </p>
                                  </TooltipContent>
                                </Tooltip>
                              </TooltipProvider>
                            )}
                          </span>
                          <span className="text-muted-foreground block text-xs">
                            Due: {formatLocalDateTime(todo.dueAt)}
                          </span>
                        </span>
                      </label>

                      <div className="flex items-center gap-1">
                        {!todo.completed && (
                          <Button
                            type="button"
                            variant={flags.inProgress ? "default" : "outline"}
                            size="sm"
                            onClick={() => void setInProgress(flags.inProgress ? null : todo.id)}
                            className={cn(
                              flags.inProgress && "bg-sky-600 hover:bg-sky-600"
                            )}
                          >
                            {flags.inProgress ? (
                              <>
                                <CircleStop className="mr-1 h-4 w-4" />
                                Stop
                              </>
                            ) : (
                              <>
                                <CirclePlay className="mr-1 h-4 w-4" />
                                Start
                              </>
                            )}
                          </Button>
                        )}
                        {todo.completed && (
                          <Button
                            type="button"
                            variant="outline"
                            size="sm"
                            onClick={() => requestAttachmentsForTodo(todo.id)}
                          >
                            Add files
                          </Button>
                        )}
                        <Button
                          type="button"
                          variant="ghost"
                          size="icon"
                          aria-label={`Delete "${todo.title}"`}
                          onClick={() => deleteTodo(todo.id)}
                        >
                          <Trash2 className="h-4 w-4" />
                        </Button>
                      </div>
                    </div>

                    {todo.completed && todo.attachments.length > 0 && (
                      <div className="mt-3 space-y-2">
                        <p className="text-muted-foreground text-xs">Attachments</p>
                        <ul className="space-y-1">
                          {todo.attachments.map((a) => (
                            <li
                              key={a.id}
                              className="flex items-center justify-between gap-3 rounded-md bg-muted/30 px-2 py-1"
                            >
                              <div className="flex min-w-0 items-center gap-2">
                                <AttachmentIcon kind={a.kind} />
                                <span className="truncate text-sm">{a.name}</span>
                              </div>
                              <button
                                type="button"
                                onClick={() => void downloadAttachment(a)}
                                className="inline-flex items-center gap-1 text-sm font-medium underline underline-offset-4"
                              >
                                <Download className="h-4 w-4" />
                                Download
                              </button>
                            </li>
                          ))}
                        </ul>
                      </div>
                    )}
                  </div>
                  )
                })}
              </div>
            ))
          )}
        </div>

        {groupedTodos.length > 0 && (
          <div className="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
            <div className="flex items-center gap-2">
              <span className="text-muted-foreground text-sm">Items per page</span>
              <Select
                value={String(pageSize)}
                onValueChange={(v) => {
                  const next = Number(v)
                  setPageSize(next)
                  setPage(1)
                }}
              >
                <SelectTrigger className="w-[110px]">
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="5">5</SelectItem>
                  <SelectItem value="10">10</SelectItem>
                  <SelectItem value="15">15</SelectItem>
                  <SelectItem value="20">20</SelectItem>
                </SelectContent>
              </Select>
            </div>

            {showPagination && (
              <div className="flex items-center justify-between gap-3 sm:justify-end">
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={() => setPage((p) => Math.max(1, p - 1))}
                  disabled={page <= 1}
                >
                  Prev
                </Button>
                <span className="text-muted-foreground text-sm">
                  Page {page} of {totalPages}
                </span>
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={() => setPage((p) => Math.min(totalPages, p + 1))}
                  disabled={page >= totalPages}
                >
                  Next
                </Button>
              </div>
            )}
          </div>
        )}

        <div className="flex items-center justify-between gap-2">
          <Button
            type="button"
            variant="secondary"
            onClick={clearCompleted}
            disabled={completedCount === 0}
          >
            Clear completed
          </Button>
          <span className="text-muted-foreground text-sm">
            Mock data only (no backend)
          </span>
    </div>
      </CardContent>
    </Card>
  )
}

```

### Supabase integrated (auth + persistent tasks + file uploads)
- **Auth (email/password)**: In-app Sign in/Sign up screen (no separate route). Includes **Sign out** button.
- **Persistent tasks**: Tasks are loaded from / saved to a Supabase **`tasks`** table (create, complete, delete, clear completed, set single “In Progress”).
- **File uploads**: Attachments upload to Supabase Storage bucket **`task-attachments`**, metadata stored in `tasks.attachments` (jsonb). Downloads use **signed URLs** (private bucket).

### Setup files added
- **Env template**: `supabase.env.example` (workspace blocks dotfiles)
- **Setup guide**: `SUPABASE_SETUP.md`
- **SQL schema + RLS + bucket policies**: `supabase/schema.sql`
- **Supabase client helper**: `src/lib/supabase/client.ts`

### What you need to do in Supabase
- **Add env vars** (create `.env.local` manually):
  - `NEXT_PUBLIC_SUPABASE_URL`
  - `NEXT_PUBLIC_SUPABASE_ANON_KEY`
- In Supabase **SQL Editor**, run: `supabase/schema.sql`

### Run locally
```bash
npm run dev
```

```shellscript
npm run dev
```

---

**User**

All operations and event handling should be implemented inside the API folder, not directly within the page components. Please follow clean and logical implementation patterns, and also review and fix the error currently shown on the page.

---

**Cursor**

Got it. I’ll refactor so the UI **only calls Next.js API routes** and all Supabase work (auth, tasks CRUD, file uploads, signed download URLs) happens under `src/app/api/**`. While doing that, I’ll also replace the current “failed to load tasks” toast with a clearer in-app message that tells you exactly what to do when the `tasks` table isn’t created yet.

```typescript
import { createClient } from "@supabase/supabase-js"

export function createServerSupabaseClient(accessToken?: string) {
  const url = process.env.NEXT_PUBLIC_SUPABASE_URL
  const anonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY

  if (!url || !anonKey) {
    throw new Error(
      "Missing Supabase env vars. Set NEXT_PUBLIC_SUPABASE_URL and NEXT_PUBLIC_SUPABASE_ANON_KEY."
    )
  }

  return createClient(url, anonKey, {
    global: accessToken
      ? {
          headers: {
            Authorization: `Bearer ${accessToken}`,
          },
        }
      : undefined,
  })
}


```

```typescript
import { cookies } from "next/headers"
import { NextResponse } from "next/server"

export const ACCESS_TOKEN_COOKIE = "sb-access-token"
export const REFRESH_TOKEN_COOKIE = "sb-refresh-token"

export function getAccessTokenFromCookies() {
  return cookies().get(ACCESS_TOKEN_COOKIE)?.value
}

export function getRefreshTokenFromCookies() {
  return cookies().get(REFRESH_TOKEN_COOKIE)?.value
}

export function setAuthCookies(res: NextResponse, accessToken: string, refreshToken: string) {
  const secure = process.env.NODE_ENV === "production"

  res.cookies.set(ACCESS_TOKEN_COOKIE, accessToken, {
    httpOnly: true,
    secure,
    sameSite: "lax",
    path: "/",
  })
  res.cookies.set(REFRESH_TOKEN_COOKIE, refreshToken, {
    httpOnly: true,
    secure,
    sameSite: "lax",
    path: "/",
  })
}

export function clearAuthCookies(res: NextResponse) {
  res.cookies.set(ACCESS_TOKEN_COOKIE, "", { httpOnly: true, path: "/", maxAge: 0 })
  res.cookies.set(REFRESH_TOKEN_COOKIE, "", { httpOnly: true, path: "/", maxAge: 0 })
}


```

```typescript
import { NextResponse } from "next/server"

export function jsonOk<T>(data: T, init?: ResponseInit) {
  return NextResponse.json({ ok: true, data }, init)
}

export function jsonError(message: string, code?: string, status = 400, extra?: unknown) {
  return NextResponse.json(
    { ok: false, error: { message, code, extra } },
    { status }
  )
}


```

```typescript
import { createServerSupabaseClient } from "@/lib/supabase/server"
import { getAccessTokenFromCookies, getRefreshTokenFromCookies, setAuthCookies } from "./auth"
import { NextResponse } from "next/server"

export function getSupabaseForRequest() {
  return createServerSupabaseClient(getAccessTokenFromCookies())
}

export async function requireUser() {
  const accessToken = getAccessTokenFromCookies()
  const refreshToken = getRefreshTokenFromCookies()

  if (!accessToken && !refreshToken) return { user: null as const, res: null as const }

  const supabase = createServerSupabaseClient(accessToken)

  // Try current access token
  if (accessToken) {
    const { data } = await supabase.auth.getUser(accessToken)
    if (data.user) return { user: data.user, res: null as const }
  }

  // Refresh if possible
  if (refreshToken) {
    const anon = createServerSupabaseClient()
    const { data, error } = await anon.auth.refreshSession({ refresh_token: refreshToken })
    if (error || !data.session?.access_token || !data.session.refresh_token) {
      return { user: null as const, res: null as const }
    }

    const refreshed = createServerSupabaseClient(data.session.access_token)
    const userRes = await refreshed.auth.getUser(data.session.access_token)
    if (!userRes.data.user) return { user: null as const, res: null as const }

    const res = NextResponse.next()
    setAuthCookies(res, data.session.access_token, data.session.refresh_token)
    return { user: userRes.data.user, res }
  }

  return { user: null as const, res: null as const }
}


```

```typescript
import { NextResponse } from "next/server"
import { jsonOk } from "@/app/api/_lib/response"
import { requireUser } from "@/app/api/_lib/supabase"

export async function GET() {
  const { user, res } = await requireUser()
  const out = NextResponse.json({ ok: true, data: { user } })
  if (res) {
    // Copy any refreshed cookies onto this response
    for (const c of res.cookies.getAll()) out.cookies.set(c)
  }
  return out
}


```

```typescript
import { NextResponse } from "next/server"
import { z } from "zod"
import { createServerSupabaseClient } from "@/lib/supabase/server"
import { jsonError, jsonOk } from "@/app/api/_lib/response"
import { setAuthCookies } from "@/app/api/_lib/auth"

const schema = z.object({
  email: z.string().email(),
  password: z.string().min(6),
})

export async function POST(req: Request) {
  const body = await req.json().catch(() => null)
  const parsed = schema.safeParse(body)
  if (!parsed.success) return jsonError("Invalid request body.", "BAD_REQUEST", 400)

  const supabase = createServerSupabaseClient()
  const { data, error } = await supabase.auth.signInWithPassword(parsed.data)
  if (error || !data.session) return jsonError(error?.message ?? "Sign-in failed.", "AUTH", 401)

  const res = jsonOk({ user: data.user })
  setAuthCookies(res, data.session.access_token, data.session.refresh_token)
  return res
}


```

```typescript
import { z } from "zod"
import { createServerSupabaseClient } from "@/lib/supabase/server"
import { jsonError, jsonOk } from "@/app/api/_lib/response"

const schema = z.object({
  email: z.string().email(),
  password: z.string().min(6),
})

export async function POST(req: Request) {
  const body = await req.json().catch(() => null)
  const parsed = schema.safeParse(body)
  if (!parsed.success) return jsonError("Invalid request body.", "BAD_REQUEST", 400)

  const supabase = createServerSupabaseClient()
  const { error } = await supabase.auth.signUp(parsed.data)
  if (error) return jsonError(error.message, "AUTH", 400)

  // Note: if email confirmations are enabled, user must confirm before signing in.
  return jsonOk({ ok: true })
}


```

```typescript
import { jsonOk } from "@/app/api/_lib/response"
import { clearAuthCookies } from "@/app/api/_lib/auth"

export async function POST() {
  const res = jsonOk({ ok: true })
  clearAuthCookies(res)
  return res
}


```

```typescript
export type Attachment = {
  id: string
  name: string
  type: string
  size: number
  bucket: string
  path: string
  kind:
    | "image"
    | "audio"
    | "video"
    | "pdf"
    | "spreadsheet"
    | "document"
    | "text"
    | "file"
}

export type Task = {
  id: string
  title: string
  description?: string
  completed: boolean
  dueAt: string
  attachments: Attachment[]
}

export type DbTaskRow = {
  id: string
  user_id: string
  title: string
  description: string | null
  due_at: string
  completed: boolean
  in_progress: boolean
  attachments: unknown
}

export function coerceAttachments(raw: unknown): Attachment[] {
  if (!Array.isArray(raw)) return []
  return raw.filter(Boolean) as Attachment[]
}

export function fromDbTask(row: DbTaskRow): Task {
  return {
    id: row.id,
    title: row.title,
    description: row.description ?? undefined,
    completed: row.completed,
    dueAt: row.due_at,
    attachments: coerceAttachments(row.attachments),
  }
}


```

```typescript
import { z } from "zod"
import { jsonError, jsonOk } from "@/app/api/_lib/response"
import { requireUser } from "@/app/api/_lib/supabase"
import { createServerSupabaseClient } from "@/lib/supabase/server"
import type { DbTaskRow } from "./types"
import { fromDbTask } from "./types"

const createSchema = z.object({
  title: z.string().min(1).max(80),
  description: z.string().max(500).optional().or(z.literal("")),
  dueAt: z.string().regex(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}$/),
})

export async function GET() {
  const { user, res } = await requireUser()
  if (!user) return jsonError("Unauthorized", "UNAUTHORIZED", 401)

  const token = res?.cookies.get("sb-access-token")?.value
  const supabase = createServerSupabaseClient(token)

  const { data, error } = await supabase
    .from("tasks")
    .select("*")
    .eq("user_id", user.id)
    .order("due_at", { ascending: true })

  if (error) {
    const msg = error.message ?? "Failed to load tasks."
    const code =
      msg.includes("Could not find the table") || msg.includes("schema cache")
        ? "MISSING_TABLE"
        : "DB"
    return jsonError(msg, code, 500)
  }

  const rows = (data ?? []) as DbTaskRow[]
  return jsonOk({
    tasks: rows.map(fromDbTask),
    inProgressTaskId: rows.find((r) => r.in_progress)?.id ?? null,
  })
}

export async function POST(req: Request) {
  const { user, res } = await requireUser()
  if (!user) return jsonError("Unauthorized", "UNAUTHORIZED", 401)

  const body = await req.json().catch(() => null)
  const parsed = createSchema.safeParse(body)
  if (!parsed.success) return jsonError("Invalid request body.", "BAD_REQUEST", 400)

  const token = res?.cookies.get("sb-access-token")?.value
  const supabase = createServerSupabaseClient(token)

  const { data, error } = await supabase
    .from("tasks")
    .insert({
      user_id: user.id,
      title: parsed.data.title.trim(),
      description: (parsed.data.description ?? "").trim() || null,
      due_at: parsed.data.dueAt,
      completed: false,
      in_progress: false,
      attachments: [],
    })
    .select("*")
    .single()

  if (error) return jsonError(error.message, "DB", 500)

  return jsonOk({ task: fromDbTask(data as DbTaskRow) })
}


```

```typescript
import { z } from "zod"
import { jsonError, jsonOk } from "@/app/api/_lib/response"
import { requireUser } from "@/app/api/_lib/supabase"
import { createServerSupabaseClient } from "@/lib/supabase/server"

const patchSchema = z
  .object({
    completed: z.boolean().optional(),
    description: z.string().max(500).nullable().optional(),
    title: z.string().min(1).max(80).optional(),
    dueAt: z.string().regex(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}$/).optional(),
    attachments: z.any().optional(),
  })
  .strict()

export async function PATCH(req: Request, ctx: { params: Promise<{ id: string }> }) {
  const { user, res } = await requireUser()
  if (!user) return jsonError("Unauthorized", "UNAUTHORIZED", 401)

  const { id } = await ctx.params
  const body = await req.json().catch(() => null)
  const parsed = patchSchema.safeParse(body)
  if (!parsed.success) return jsonError("Invalid request body.", "BAD_REQUEST", 400)

  const token = res?.cookies.get("sb-access-token")?.value
  const supabase = createServerSupabaseClient(token)

  const update: Record<string, unknown> = {}
  if (typeof parsed.data.completed === "boolean") {
    update.completed = parsed.data.completed
    if (parsed.data.completed) update.in_progress = false
  }
  if (typeof parsed.data.title === "string") update.title = parsed.data.title.trim()
  if (typeof parsed.data.dueAt === "string") update.due_at = parsed.data.dueAt
  if (parsed.data.description !== undefined)
    update.description = parsed.data.description ? parsed.data.description.trim() : null
  if (parsed.data.attachments !== undefined) update.attachments = parsed.data.attachments

  const { error } = await supabase.from("tasks").update(update).eq("id", id).eq("user_id", user.id)
  if (error) return jsonError(error.message, "DB", 500)

  return jsonOk({ ok: true })
}

export async function DELETE(_req: Request, ctx: { params: Promise<{ id: string }> }) {
  const { user, res } = await requireUser()
  if (!user) return jsonError("Unauthorized", "UNAUTHORIZED", 401)
  const { id } = await ctx.params

  const token = res?.cookies.get("sb-access-token")?.value
  const supabase = createServerSupabaseClient(token)

  const { error } = await supabase.from("tasks").delete().eq("id", id).eq("user_id", user.id)
  if (error) return jsonError(error.message, "DB", 500)
  return jsonOk({ ok: true })
}


```

```typescript
import { jsonError, jsonOk } from "@/app/api/_lib/response"
import { requireUser } from "@/app/api/_lib/supabase"
import { createServerSupabaseClient } from "@/lib/supabase/server"

export async function POST() {
  const { user, res } = await requireUser()
  if (!user) return jsonError("Unauthorized", "UNAUTHORIZED", 401)

  const token = res?.cookies.get("sb-access-token")?.value
  const supabase = createServerSupabaseClient(token)

  const { error } = await supabase
    .from("tasks")
    .delete()
    .eq("user_id", user.id)
    .eq("completed", true)

  if (error) return jsonError(error.message, "DB", 500)
  return jsonOk({ ok: true })
}


```

```typescript
import { z } from "zod"
import { jsonError, jsonOk } from "@/app/api/_lib/response"
import { requireUser } from "@/app/api/_lib/supabase"
import { createServerSupabaseClient } from "@/lib/supabase/server"

const schema = z.object({ id: z.string().uuid().nullable() })

export async function POST(req: Request) {
  const { user, res } = await requireUser()
  if (!user) return jsonError("Unauthorized", "UNAUTHORIZED", 401)

  const body = await req.json().catch(() => null)
  const parsed = schema.safeParse(body)
  if (!parsed.success) return jsonError("Invalid request body.", "BAD_REQUEST", 400)

  const token = res?.cookies.get("sb-access-token")?.value
  const supabase = createServerSupabaseClient(token)

  // Clear current in-progress
  const clearRes = await supabase
    .from("tasks")
    .update({ in_progress: false })
    .eq("user_id", user.id)
    .eq("in_progress", true)
  if (clearRes.error) return jsonError(clearRes.error.message, "DB", 500)

  if (!parsed.data.id) return jsonOk({ inProgressTaskId: null })

  const setRes = await supabase
    .from("tasks")
    .update({ in_progress: true })
    .eq("user_id", user.id)
    .eq("id", parsed.data.id)
  if (setRes.error) return jsonError(setRes.error.message, "DB", 500)

  return jsonOk({ inProgressTaskId: parsed.data.id })
}


```

```typescript
import { z } from "zod"
import { jsonError, jsonOk } from "@/app/api/_lib/response"
import { requireUser } from "@/app/api/_lib/supabase"
import { createServerSupabaseClient } from "@/lib/supabase/server"

const schema = z.object({
  bucket: z.string().min(1),
  path: z.string().min(1),
})

export async function POST(req: Request) {
  const { user, res } = await requireUser()
  if (!user) return jsonError("Unauthorized", "UNAUTHORIZED", 401)

  const body = await req.json().catch(() => null)
  const parsed = schema.safeParse(body)
  if (!parsed.success) return jsonError("Invalid request body.", "BAD_REQUEST", 400)

  const token = res?.cookies.get("sb-access-token")?.value
  const supabase = createServerSupabaseClient(token)

  const { data, error } = await supabase.storage
    .from(parsed.data.bucket)
    .createSignedUrl(parsed.data.path, 60)

  if (error || !data?.signedUrl) return jsonError(error?.message ?? "Failed.", "STORAGE", 500)
  return jsonOk({ signedUrl: data.signedUrl })
}


```

```typescript
import { jsonError, jsonOk } from "@/app/api/_lib/response"
import { requireUser } from "@/app/api/_lib/supabase"
import { createServerSupabaseClient } from "@/lib/supabase/server"
import type { Attachment, DbTaskRow } from "../../types"
import { coerceAttachments, fromDbTask } from "../../types"

function sanitizePathSegment(s: string) {
  return s.replace(/[^\w.\-]+/g, "_")
}

function getAttachmentKind(file: File) {
  const type = (file.type || "").toLowerCase()
  const name = file.name.toLowerCase()
  const ext = name.includes(".") ? name.split(".").pop() ?? "" : ""

  if (type.startsWith("image/")) return "image" as const
  if (type.startsWith("audio/")) return "audio" as const
  if (type.startsWith("video/")) return "video" as const

  if (ext === "pdf") return "pdf" as const
  if (["xls", "xlsx", "csv"].includes(ext)) return "spreadsheet" as const
  if (["doc", "docx"].includes(ext)) return "document" as const
  if (["txt", "md", "rtf"].includes(ext)) return "text" as const
  return "file" as const
}

export async function POST(req: Request, ctx: { params: Promise<{ id: string }> }) {
  const { user, res } = await requireUser()
  if (!user) return jsonError("Unauthorized", "UNAUTHORIZED", 401)
  const { id } = await ctx.params

  const token = res?.cookies.get("sb-access-token")?.value
  const supabase = createServerSupabaseClient(token)

  const form = await req.formData()
  const files = form.getAll("files").filter((x): x is File => x instanceof File)
  if (files.length === 0) return jsonError("No files provided.", "BAD_REQUEST", 400)

  const { data: taskRow, error: taskErr } = await supabase
    .from("tasks")
    .select("*")
    .eq("id", id)
    .eq("user_id", user.id)
    .single()

  if (taskErr || !taskRow) return jsonError(taskErr?.message ?? "Task not found.", "DB", 404)

  const bucket = "task-attachments"
  const current = coerceAttachments((taskRow as DbTaskRow).attachments)
  const uploaded: Attachment[] = []

  for (const file of files) {
    const safeName = sanitizePathSegment(file.name)
    const path = `${user.id}/${id}/${crypto.randomUUID()}-${safeName}`
    const { error } = await supabase.storage.from(bucket).upload(path, file, {
      contentType: file.type,
      upsert: false,
    })
    if (error) return jsonError(error.message, "STORAGE", 500)

    uploaded.push({
      id: crypto.randomUUID(),
      name: file.name,
      type: file.type,
      size: file.size,
      bucket,
      path,
      kind: getAttachmentKind(file),
    })
  }

  const nextAttachments = [...current, ...uploaded]
  const { error: updErr, data: updated } = await supabase
    .from("tasks")
    .update({ attachments: nextAttachments })
    .eq("id", id)
    .eq("user_id", user.id)
    .select("*")
    .single()

  if (updErr || !updated) return jsonError(updErr?.message ?? "Failed to update.", "DB", 500)
  return jsonOk({ task: fromDbTask(updated as DbTaskRow) })
}


```

```typescript
export type ApiOk<T> = { ok: true; data: T }
export type ApiErr = { ok: false; error: { message: string; code?: string; extra?: unknown } }
export type ApiResponse<T> = ApiOk<T> | ApiErr

export async function apiFetch<T>(input: RequestInfo, init?: RequestInit): Promise<T> {
  const res = await fetch(input, {
    credentials: "include",
    headers: { "Content-Type": "application/json", ...(init?.headers ?? {}) },
    ...init,
  })

  const json = (await res.json().catch(() => null)) as ApiResponse<T> | null
  if (!json) throw new Error("Unexpected response from server.")
  if (!json.ok) throw new Error(json.error.message)
  return json.data
}


```

```typescriptreact
*** Begin Patch
*** Update File: src/app/page.tsx
@@
 import * as React from "react"
 import { useForm } from "react-hook-form"
 import { toast } from "sonner"
 import { z } from "zod"
-import type { SupabaseClient, User } from "@supabase/supabase-js"
 
 import { ModeToggle } from "@/components/mode-toggle"
 import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert"
 import { Badge } from "@/components/ui/badge"
 import { Button } from "@/components/ui/button"
@@
   TooltipProvider,
   TooltipTrigger,
 } from "@/components/ui/tooltip"
 import { cn } from "@/lib/utils"
-import { createBrowserSupabaseClient } from "@/lib/supabase/client"
+import { apiFetch } from "@/lib/api-client"
@@
 type Attachment = {
   id: string
   name: string
   type: string
   size: number
   bucket: string
   path: string
   kind: AttachmentKind
 }
@@
 type Todo = {
   id: string
   title: string
   description?: string
   completed: boolean
   // Stored as `datetime-local` string (YYYY-MM-DDTHH:mm) in local time.
   dueAt: string
   attachments: Attachment[]
 }
@@
-type DbTaskRow = {
-  id: string
-  user_id: string
-  title: string
-  description: string | null
-  due_at: string
-  completed: boolean
-  in_progress: boolean
-  attachments: unknown
-}
-
-function coerceAttachments(raw: unknown): Attachment[] {
-  if (!raw || typeof raw !== "object") return []
-  if (!Array.isArray(raw)) return []
-  return raw.filter(Boolean) as Attachment[]
-}
-
-function toDbTaskInsert(values: TodoFormValues, userId: string) {
-  return {
-    user_id: userId,
-    title: values.title.trim(),
-    description: (values.description ?? "").trim() || null,
-    due_at: values.dueAt,
-    completed: false,
-    in_progress: false,
-    attachments: [],
-  }
-}
-
-function fromDbTask(row: DbTaskRow): Todo {
-  return {
-    id: row.id,
-    title: row.title,
-    description: row.description ?? undefined,
-    completed: row.completed,
-    dueAt: row.due_at,
-    attachments: coerceAttachments(row.attachments),
-  }
-}
-
 function getAttachmentKind(file: File): AttachmentKind {
@@
   return "file"
 }
 
-function sanitizePathSegment(s: string) {
-  return s.replace(/[^\w.\-]+/g, "_")
-}
-
-function buildAttachmentRecord(file: File, bucket: string, path: string): Attachment {
-  return {
-    id: crypto.randomUUID(),
-    name: file.name,
-    type: file.type,
-    size: file.size,
-    bucket,
-    path,
-    kind: getAttachmentKind(file),
-  }
-}
-
 const authSchema = z.object({
   email: z.string().email("Enter a valid email."),
   password: z.string().min(6, "Password must be at least 6 characters."),
 })
 type AuthValues = z.infer<typeof authSchema>
 
-function AuthCard({ supabase }: { supabase: SupabaseClient }) {
+function AuthCard() {
   const [mode, setMode] = React.useState<"sign_in" | "sign_up">("sign_in")
   const [busy, setBusy] = React.useState(false)
@@
   async function onSubmit(values: AuthValues) {
     setBusy(true)
     try {
       if (mode === "sign_in") {
-        const { error } = await supabase.auth.signInWithPassword(values)
-        if (error) throw error
+        await apiFetch("/api/auth/sign-in", {
+          method: "POST",
+          body: JSON.stringify(values),
+        })
       } else {
-        const { error } = await supabase.auth.signUp(values)
-        if (error) throw error
+        await apiFetch("/api/auth/sign-up", {
+          method: "POST",
+          body: JSON.stringify(values),
+        })
         toast.success("Account created", { description: "You can now sign in." })
         setMode("sign_in")
       }
     } catch (e) {
       toast.error("Authentication failed", {
         description: e instanceof Error ? e.message : "Please try again.",
       })
     } finally {
       setBusy(false)
     }
   }
@@
 }
 
 export default function Home() {
-  const [supabaseError, setSupabaseError] = React.useState<string | null>(null)
-  const supabase = React.useMemo(() => {
-    try {
-      return createBrowserSupabaseClient()
-    } catch (e) {
-      setSupabaseError(e instanceof Error ? e.message : "Supabase is not configured.")
-      return null
-    }
-    // eslint-disable-next-line react-hooks/exhaustive-deps
-  }, [])
-
-  const [user, setUser] = React.useState<User | null>(null)
-  const [authLoading, setAuthLoading] = React.useState(true)
-
-  React.useEffect(() => {
-    if (!supabase) return
-    let alive = true
-    supabase.auth.getUser().then(({ data }) => {
-      if (!alive) return
-      setUser(data.user ?? null)
-      setAuthLoading(false)
-    })
-    const { data } = supabase.auth.onAuthStateChange((_event, session) => {
-      setUser(session?.user ?? null)
-    })
-    return () => {
-      alive = false
-      data.subscription.unsubscribe()
-    }
-  }, [supabase])
-
-  if (supabaseError) {
-    return (
-      <div className="mx-auto flex min-h-screen max-w-2xl flex-col justify-center gap-4 px-4 py-10">
-        <Card>
-          <CardHeader>
-            <CardTitle>Supabase not configured</CardTitle>
-          </CardHeader>
-          <CardContent className="space-y-2">
-            <p className="text-muted-foreground text-sm">{supabaseError}</p>
-            <p className="text-muted-foreground text-sm">
-              See <code>SUPABASE_SETUP.md</code> and <code>supabase.env.example</code>.
-            </p>
-          </CardContent>
-        </Card>
-      </div>
-    )
-  }
-
-  if (!supabase) return null
-  if (authLoading) {
+  const [authLoading, setAuthLoading] = React.useState(true)
+  const [user, setUser] = React.useState<{ id: string; email?: string } | null>(null)
+
+  React.useEffect(() => {
+    let alive = true
+    apiFetch<{ user: { id: string; email?: string } | null }>("/api/auth/me")
+      .then((data) => {
+        if (!alive) return
+        setUser(data.user)
+      })
+      .catch(() => {
+        if (!alive) return
+        setUser(null)
+      })
+      .finally(() => {
+        if (!alive) return
+        setAuthLoading(false)
+      })
+    return () => {
+      alive = false
+    }
+  }, [])
+
+  if (authLoading) {
     return (
       <div className="mx-auto flex min-h-screen max-w-2xl flex-col justify-center px-4 py-10">
         <p className="text-muted-foreground text-sm">Loading…</p>
       </div>
     )
   }
 
-  if (!user) return <AuthCard supabase={supabase} />
+  if (!user) return <AuthCard />
 
   return (
     <div className="mx-auto flex min-h-screen max-w-2xl flex-col gap-6 px-4 py-10">
-      <TodoApp supabase={supabase} user={user} />
+      <TodoApp userId={user.id} />
     </div>
   )
 }
 
-function TodoApp({ supabase, user }: { supabase: SupabaseClient; user: User }) {
-  const userId = user.id
+function TodoApp({ userId }: { userId: string }) {
   const [todos, setTodos] = React.useState<Todo[]>([])
   const [tasksLoading, setTasksLoading] = React.useState(true)
+  const [tasksError, setTasksError] = React.useState<{ code?: string; message: string } | null>(
+    null
+  )
   const [attachTargetTodoId, setAttachTargetTodoId] = React.useState<string | null>(
     null
   )
@@
   React.useEffect(() => {
     let alive = true
     async function load() {
       setTasksLoading(true)
-      const { data, error } = await supabase
-        .from("tasks")
-        .select("*")
-        .eq("user_id", userId)
-        .order("due_at", { ascending: true })
       if (!alive) return
-      if (error) {
-        toast.error("Failed to load tasks", { description: error.message })
-        setTodos([])
-        setInProgressTaskId(null)
-      } else {
-        const rows = (data ?? []) as DbTaskRow[]
-        setTodos(rows.map(fromDbTask))
-        setInProgressTaskId(rows.find((r) => r.in_progress)?.id ?? null)
-      }
+      try {
+        const data = await apiFetch<{ tasks: Todo[]; inProgressTaskId: string | null }>(
+          "/api/tasks"
+        )
+        if (!alive) return
+        setTodos(data.tasks)
+        setInProgressTaskId(data.inProgressTaskId)
+        setTasksError(null)
+      } catch (e) {
+        const message = e instanceof Error ? e.message : "Failed to load tasks."
+        setTodos([])
+        setInProgressTaskId(null)
+        setTasksError({ message })
+      }
       setTasksLoading(false)
     }
     load()
     return () => {
       alive = false
     }
-  }, [supabase, userId])
+  }, [userId])
*** End Patch
```

Nice—this is the last big refactor: we’ll remove all direct Supabase calls from `page.tsx` and replace them with clean `fetch` calls into `src/app/api/**`. Next I’ll re-open the current `page.tsx` around the Supabase-related blocks (auth, load tasks, attachments) and apply the refactor in smaller patches so nothing gets missed.

Nice—this confirms the current UX error is coming from the page calling Supabase directly before the `tasks` table exists. Next I’ll (1) move all Supabase calls into `src/app/api/**` routes, (2) make the UI call those routes only, and (3) replace the toast with a clear inline “missing table” setup message pointing to `supabase/schema.sql`.

```typescript
export type ApiOk<T> = { ok: true; data: T }
export type ApiErr = { ok: false; error: { message: string; code?: string; extra?: unknown } }
export type ApiResponse<T> = ApiOk<T> | ApiErr

export class ApiError extends Error {
  code?: string
  extra?: unknown
  constructor(message: string, code?: string, extra?: unknown) {
    super(message)
    this.name = "ApiError"
    this.code = code
    this.extra = extra
  }
}

export async function apiFetch<T>(input: RequestInfo, init?: RequestInit): Promise<T> {
  const res = await fetch(input, {
    credentials: "include",
    headers: { "Content-Type": "application/json", ...(init?.headers ?? {}) },
    ...init,
  })

  const json = (await res.json().catch(() => null)) as ApiResponse<T> | null
  if (!json) throw new Error("Unexpected response from server.")
  if (!json.ok) throw new ApiError(json.error.message, json.error.code, json.error.extra)
  return json.data
}


```

```typescript
import { z } from "zod"
import { jsonError, jsonOk } from "@/app/api/_lib/response"
import { requireUser } from "@/app/api/_lib/supabase"
import { createServerSupabaseClient } from "@/lib/supabase/server"
import type { DbTaskRow } from "../types"
import { fromDbTask } from "../types"

const taskSchema = z.object({
  title: z.string().min(1).max(80),
  description: z.string().max(500).optional(),
  dueAt: z.string().regex(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}$/),
  completed: z.boolean().optional(),
})

const schema = z.object({ tasks: z.array(taskSchema).min(1) })

export async function POST(req: Request) {
  const { user, res } = await requireUser()
  if (!user) return jsonError("Unauthorized", "UNAUTHORIZED", 401)

  const body = await req.json().catch(() => null)
  const parsed = schema.safeParse(body)
  if (!parsed.success) return jsonError("Invalid request body.", "BAD_REQUEST", 400)

  const token = res?.cookies.get("sb-access-token")?.value
  const supabase = createServerSupabaseClient(token)

  const payload = parsed.data.tasks.map((t) => ({
    user_id: user.id,
    title: t.title.trim(),
    description: (t.description ?? "").trim() || null,
    due_at: t.dueAt,
    completed: t.completed ?? false,
    in_progress: false,
    attachments: [],
  }))

  const { data, error } = await supabase.from("tasks").insert(payload).select("*")
  if (error) return jsonError(error.message, "DB", 500)

  const rows = (data ?? []) as DbTaskRow[]
  return jsonOk({ tasks: rows.map(fromDbTask) })
}


```

```typescriptreact
"use client"

import { zodResolver } from "@hookform/resolvers/zod"
import {
  AlertTriangle,
  CirclePlay,
  CircleStop,
  CalendarClock,
  CheckCircle2,
  Download,
  File,
  FileSpreadsheet,
  FileText,
  Image as ImageIcon,
  Info,
  Music,
  Bell,
  Timer,
  Trash2,
  Video,
} from "lucide-react"
import * as React from "react"
import { useForm } from "react-hook-form"
import { toast } from "sonner"
import { z } from "zod"
import type { SupabaseClient, User } from "@supabase/supabase-js"

import { ModeToggle } from "@/components/mode-toggle"
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert"
import { Badge } from "@/components/ui/badge"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Checkbox } from "@/components/ui/checkbox"
import { Form, FormControl, FormField, FormItem, FormMessage } from "@/components/ui/form"
import { Input } from "@/components/ui/input"
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select"
import { Separator } from "@/components/ui/separator"
import { Textarea } from "@/components/ui/textarea"
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip"
import { cn } from "@/lib/utils"
import { apiFetch, ApiError } from "@/lib/api-client"

type AttachmentKind =
  | "image"
  | "audio"
  | "video"
  | "pdf"
  | "spreadsheet"
  | "document"
  | "text"
  | "file"

type Attachment = {
  id: string
  name: string
  type: string
  size: number
  bucket: string
  path: string
  kind: AttachmentKind
}

type Todo = {
  id: string
  title: string
  description?: string
  completed: boolean
  // Stored as `datetime-local` string (YYYY-MM-DDTHH:mm) in local time.
  dueAt: string
  attachments: Attachment[]
}

type TaskState = "planned" | "in_progress" | "completed" | "overdue"
type DailyLoad = "light" | "balanced" | "heavy"

const todoSchema = z.object({
  title: z
    .string()
    .trim()
    .min(1, "Title is required.")
    .max(80, "Keep it under 80 characters."),
  description: z
    .string()
    .trim()
    .max(500, "Keep it under 500 characters.")
    .optional()
    .or(z.literal("")),
  dueAt: z
    .string()
    .min(1, "Due date & time is required.")
    .regex(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}$/, "Invalid date/time."),
})

type TodoFormValues = z.infer<typeof todoSchema>

const initialTodos: Todo[] = [
  {
    id: "1",
    title: "Create a Next.js app",
    description: "Scaffold with TypeScript + Tailwind and confirm it runs locally.",
    completed: true,
    dueAt: "2026-01-16T09:00",
    attachments: [],
  },
  {
    id: "2",
    title: "Add shadcn/ui + dark theme",
    description: "Initialize shadcn, set up theme provider, and verify dark mode.",
    completed: true,
    dueAt: "2026-01-16T10:30",
    attachments: [],
  },
  {
    id: "3",
    title: "Build a mock-data to-do list",
    completed: false,
    dueAt: "2026-01-16T15:00",
    attachments: [],
  },
  {
    id: "4",
    title: "Yesterday: review requirements",
    completed: true,
    dueAt: "2026-01-15T11:15",
    attachments: [],
  },
  {
    id: "5",
    title: "Yesterday: sketch UI layout",
    completed: true,
    dueAt: "2026-01-15T17:45",
    attachments: [],
  },
  {
    id: "6",
    title: "Today: add attachments support",
    completed: false,
    dueAt: "2026-01-16T18:20",
    attachments: [],
  },
  {
    id: "7",
    title: "Tomorrow: QA the filters",
    description: "Test date-only, time-only, exact, and between behaviors.",
    completed: false,
    dueAt: "2026-01-17T08:05",
    attachments: [],
  },
  {
    id: "8",
    title: "Tomorrow: polish summary cards",
    completed: false,
    dueAt: "2026-01-17T13:30",
    attachments: [],
  },
  {
    id: "9",
    title: "Tomorrow: write small UX notes",
    completed: false,
    dueAt: "2026-01-17T20:10",
    attachments: [],
  },
  {
    id: "10",
    title: "This weekend: add more mock tasks",
    completed: false,
    dueAt: "2026-01-18T10:00",
    attachments: [],
  },
  {
    id: "11",
    title: "This weekend: check time-only filter",
    completed: false,
    dueAt: "2026-01-18T22:15",
    attachments: [],
  },
  {
    id: "12",
    title: "Next week: sync with team",
    completed: false,
    dueAt: "2026-01-19T09:30",
    attachments: [],
  },
  {
    id: "13",
    title: "Next week: test date-only filter",
    completed: false,
    dueAt: "2026-01-20T14:05",
    attachments: [],
  },
  {
    id: "14",
    title: "Next week: test exact date+time filter",
    completed: false,
    dueAt: "2026-01-21T12:00",
    attachments: [],
  },
  {
    id: "15",
    title: "Next week: attach docs to completed tasks",
    completed: false,
    dueAt: "2026-01-22T16:40",
    attachments: [],
  },
  {
    id: "16",
    title: "Next week: final review",
    completed: false,
    dueAt: "2026-01-23T11:00",
    attachments: [],
  },
]

type DbTaskRow = {
  id: string
  user_id: string
  title: string
  description: string | null
  due_at: string
  completed: boolean
  in_progress: boolean
  attachments: unknown
}

function coerceAttachments(raw: unknown): Attachment[] {
  if (!raw || typeof raw !== "object") return []
  if (!Array.isArray(raw)) return []
  return raw.filter(Boolean) as Attachment[]
}

function toDbTaskInsert(values: TodoFormValues, userId: string) {
  return {
    user_id: userId,
    title: values.title.trim(),
    description: (values.description ?? "").trim() || null,
    due_at: values.dueAt,
    completed: false,
    in_progress: false,
    attachments: [],
  }
}

function fromDbTask(row: DbTaskRow): Todo {
  return {
    id: row.id,
    title: row.title,
    description: row.description ?? undefined,
    completed: row.completed,
    dueAt: row.due_at,
    attachments: coerceAttachments(row.attachments),
  }
}

function parseLocalDateTime(value: string): number {
  // value: "YYYY-MM-DDTHH:mm"
  const [datePart, timePart] = value.split("T")
  const [y, m, d] = datePart.split("-").map(Number)
  const [hh, mm] = timePart.split(":").map(Number)
  return new Date(y, m - 1, d, hh, mm, 0, 0).getTime()
}

function pad2(n: number) {
  return String(n).padStart(2, "0")
}

function localDateKey(d: Date) {
  return `${d.getFullYear()}-${pad2(d.getMonth() + 1)}-${pad2(d.getDate())}`
}

function addDays(date: Date, days: number) {
  const d = new Date(date)
  d.setDate(d.getDate() + days)
  return d
}

function startOfDay(date: Date) {
  return new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0, 0)
}

function endOfDay(date: Date) {
  return new Date(
    date.getFullYear(),
    date.getMonth(),
    date.getDate(),
    23,
    59,
    59,
    999
  )
}

function getDatePart(dueAt: string) {
  return dueAt.split("T")[0] ?? ""
}

function getTimePart(dueAt: string) {
  return dueAt.split("T")[1] ?? ""
}

function parseLocalDateOnly(value: string): Date {
  // value: "YYYY-MM-DD"
  const [y, m, d] = value.split("-").map(Number)
  return new Date(y, m - 1, d, 0, 0, 0, 0)
}

function parseLocalTimeToMinutes(value: string): number {
  // value: "HH:mm"
  const [hh, mm] = value.split(":").map(Number)
  return hh * 60 + mm
}

function formatLocalDateTime(value: string): string {
  const ms = parseLocalDateTime(value)
  if (!Number.isFinite(ms)) return value
  return new Intl.DateTimeFormat(undefined, {
    year: "numeric",
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  }).format(new Date(ms))
}

function formatDateTimeFromMs(ms: number): string {
  return new Intl.DateTimeFormat(undefined, {
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  }).format(new Date(ms))
}

function minutesUntil(targetMs: number, nowMs: number) {
  return Math.ceil((targetMs - nowMs) / 60_000)
}

function getTaskFlags(todo: Todo, nowMs: number, inProgressTaskId: string | null) {
  const completed = todo.completed
  const dueMs = parseLocalDateTime(todo.dueAt)
  const overdue = !completed && dueMs < nowMs
  const inProgress = !completed && inProgressTaskId === todo.id
  const planned = !completed && !overdue && !inProgress
  return { completed, overdue, inProgress, planned }
}

function getDailyLoad(todosForDay: Todo[]) {
  // 4-hour windows across the day (local).
  const labels = [
    "00:00–04:00",
    "04:00–08:00",
    "08:00–12:00",
    "12:00–16:00",
    "16:00–20:00",
    "20:00–24:00",
  ]
  const buckets = Array.from({ length: 6 }, () => 0) as number[]
  for (const t of todosForDay) {
    const ms = parseLocalDateTime(t.dueAt)
    const hour = new Date(ms).getHours()
    const idx = Math.floor(hour / 4)
    buckets[idx] = (buckets[idx] ?? 0) + 1
  }

  const total = todosForDay.length
  const peak = Math.max(0, ...buckets)
  const spread = buckets.filter((c) => c > 0).length
  const busiestIdx = buckets.findIndex((c) => c === peak)
  const busiestWindow = busiestIdx >= 0 ? labels[busiestIdx] : labels[0]

  // Heuristic: more tasks + higher concentration in one window => heavier day.
  const score = total + peak * 1.5 + Math.max(0, spread - 1) * 0.5
  const load: DailyLoad = score <= 5 ? "light" : score <= 10 ? "balanced" : "heavy"

  return { load, total, peak, spread, busiestWindow }
}

function DailyLoadBadge({ load }: { load: DailyLoad }) {
  if (load === "heavy") return <Badge variant="destructive">Heavy</Badge>
  if (load === "balanced") return <Badge variant="secondary">Balanced</Badge>
  return <Badge variant="outline">Light</Badge>
}

function TaskBadges({
  completed,
  overdue,
  inProgress,
  planned,
}: {
  completed: boolean
  overdue: boolean
  inProgress: boolean
  planned: boolean
}) {
  if (completed) {
    return (
      <Badge className="gap-1 bg-emerald-600 text-white hover:bg-emerald-600">
        <CheckCircle2 className="h-3.5 w-3.5" />
        Completed
      </Badge>
    )
  }

  return (
    <>
      {inProgress && (
        <Badge className="gap-1 bg-sky-600 text-white hover:bg-sky-600">
          <Timer className="h-3.5 w-3.5 text-white" />
          In progress
        </Badge>
      )}
      {overdue && (
        <Badge variant="destructive" className="gap-1">
          <AlertTriangle className="h-3.5 w-3.5" />
          Overdue
        </Badge>
      )}
      {planned && (
        <Badge variant="outline" className="gap-1">
          <CalendarClock className="h-3.5 w-3.5" />
          Planned
        </Badge>
      )}
    </>
  )
}

function getAttachmentKind(file: File): AttachmentKind {
  const type = (file.type || "").toLowerCase()
  const name = file.name.toLowerCase()
  const ext = name.includes(".") ? name.split(".").pop() ?? "" : ""

  if (type.startsWith("image/")) return "image"
  if (type.startsWith("audio/")) return "audio"
  if (type.startsWith("video/")) return "video"

  if (ext === "pdf") return "pdf"
  if (["xls", "xlsx", "csv"].includes(ext)) return "spreadsheet"
  if (["doc", "docx"].includes(ext)) return "document"
  if (["txt", "md", "rtf"].includes(ext)) return "text"

  return "file"
}

function sanitizePathSegment(s: string) {
  return s.replace(/[^\w.\-]+/g, "_")
}

function buildAttachmentRecord(file: File, bucket: string, path: string): Attachment {
  return {
    id: crypto.randomUUID(),
    name: file.name,
    type: file.type,
    size: file.size,
    bucket,
    path,
    kind: getAttachmentKind(file),
  }
}

function AttachmentIcon({ kind }: { kind: AttachmentKind }) {
  const className = "h-4 w-4 text-muted-foreground"

  switch (kind) {
    case "image":
      return <ImageIcon className={className} />
    case "audio":
      return <Music className={className} />
    case "video":
      return <Video className={className} />
    case "spreadsheet":
      return <FileSpreadsheet className={className} />
    case "pdf":
    case "document":
    case "text":
      return <FileText className={className} />
    default:
      return <File className={className} />
  }
}

const authSchema = z.object({
  email: z.string().email("Enter a valid email."),
  password: z.string().min(6, "Password must be at least 6 characters."),
})
type AuthValues = z.infer<typeof authSchema>

function AuthCard({ supabase }: { supabase: SupabaseClient }) {
  const [mode, setMode] = React.useState<"sign_in" | "sign_up">("sign_in")
  const [busy, setBusy] = React.useState(false)

  const form = useForm<AuthValues>({
    resolver: zodResolver(authSchema),
    defaultValues: { email: "", password: "" },
  })

  async function onSubmit(values: AuthValues) {
    setBusy(true)
    try {
      if (mode === "sign_in") {
        const { error } = await supabase.auth.signInWithPassword(values)
        if (error) throw error
      } else {
        const { error } = await supabase.auth.signUp(values)
        if (error) throw error
        toast.success("Account created", { description: "You can now sign in." })
        setMode("sign_in")
      }
    } catch (e) {
      toast.error("Authentication failed", {
        description: e instanceof Error ? e.message : "Please try again.",
      })
    } finally {
      setBusy(false)
    }
  }

  return (
    <div className="mx-auto flex min-h-screen max-w-md flex-col justify-center px-4 py-10">
      <Card>
        <CardHeader>
          <CardTitle className="text-2xl">Sign in</CardTitle>
          <p className="text-muted-foreground text-sm">
            {mode === "sign_in"
              ? "Use your email and password."
              : "Create an account with email and password."}
          </p>
        </CardHeader>
        <CardContent className="space-y-4">
          <Form {...form}>
            <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-3" noValidate>
              <FormField
                control={form.control}
                name="email"
                render={({ field }) => (
                  <FormItem>
                    <FormControl>
                      <Input placeholder="Email" autoComplete="email" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="password"
                render={({ field }) => (
                  <FormItem>
                    <FormControl>
                      <Input
                        type="password"
                        placeholder="Password"
                        autoComplete={
                          mode === "sign_in" ? "current-password" : "new-password"
                        }
                        {...field}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <Button type="submit" className="w-full" disabled={busy}>
                {mode === "sign_in" ? "Sign in" : "Sign up"}
              </Button>
            </form>
          </Form>

          <div className="flex items-center justify-between gap-3 text-sm">
            <span className="text-muted-foreground">
              {mode === "sign_in" ? "No account?" : "Already have an account?"}
            </span>
            <Button
              type="button"
              variant="link"
              className="px-0"
              onClick={() => setMode((m) => (m === "sign_in" ? "sign_up" : "sign_in"))}
            >
              {mode === "sign_in" ? "Sign up" : "Sign in"}
            </Button>
          </div>
        </CardContent>
      </Card>
    </div>
  )
}

export default function Home() {
  const [supabaseError, setSupabaseError] = React.useState<string | null>(null)
  const supabase = React.useMemo(() => {
    try {
      return createBrowserSupabaseClient()
    } catch (e) {
      setSupabaseError(e instanceof Error ? e.message : "Supabase is not configured.")
      return null
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [])

  const [user, setUser] = React.useState<User | null>(null)
  const [authLoading, setAuthLoading] = React.useState(true)

  React.useEffect(() => {
    if (!supabase) return
    let alive = true
    supabase.auth.getUser().then(({ data }) => {
      if (!alive) return
      setUser(data.user ?? null)
      setAuthLoading(false)
    })
    const { data } = supabase.auth.onAuthStateChange((_event, session) => {
      setUser(session?.user ?? null)
    })
    return () => {
      alive = false
      data.subscription.unsubscribe()
    }
  }, [supabase])

  if (supabaseError) {
    return (
      <div className="mx-auto flex min-h-screen max-w-2xl flex-col justify-center gap-4 px-4 py-10">
        <Card>
          <CardHeader>
            <CardTitle>Supabase not configured</CardTitle>
          </CardHeader>
          <CardContent className="space-y-2">
            <p className="text-muted-foreground text-sm">{supabaseError}</p>
            <p className="text-muted-foreground text-sm">
              See <code>SUPABASE_SETUP.md</code> and <code>supabase.env.example</code>.
            </p>
          </CardContent>
        </Card>
      </div>
    )
  }

  if (!supabase) return null
  if (authLoading) {
    return (
      <div className="mx-auto flex min-h-screen max-w-2xl flex-col justify-center px-4 py-10">
        <p className="text-muted-foreground text-sm">Loading…</p>
      </div>
    )
  }

  if (!user) return <AuthCard supabase={supabase} />

  return (
    <div className="mx-auto flex min-h-screen max-w-2xl flex-col gap-6 px-4 py-10">
      <TodoApp supabase={supabase} user={user} />
    </div>
  )
}

function TodoApp({ supabase, user }: { supabase: SupabaseClient; user: User }) {
  const userId = user.id
  const [todos, setTodos] = React.useState<Todo[]>([])
  const [tasksLoading, setTasksLoading] = React.useState(true)
  const [attachTargetTodoId, setAttachTargetTodoId] = React.useState<string | null>(
    null
  )
  const [conflictDueAt, setConflictDueAt] = React.useState<string | null>(null)
  const clearConflictTimerRef = React.useRef<number | null>(null)
  const [focusMode, setFocusMode] = React.useState(false)
  const [nowMs, setNowMs] = React.useState(() => Date.now())
  const [inProgressTaskId, setInProgressTaskId] = React.useState<string | null>(null)
  const [dismissedReminderTaskId, setDismissedReminderTaskId] = React.useState<
    string | null
  >(null)
  const [filterMode, setFilterMode] = React.useState<"between" | "exact">("between")
  const [filterFromDate, setFilterFromDate] = React.useState<string>("")
  const [filterFromTime, setFilterFromTime] = React.useState<string>("")
  const [filterToDate, setFilterToDate] = React.useState<string>("")
  const [filterToTime, setFilterToTime] = React.useState<string>("")
  const [filterExactDate, setFilterExactDate] = React.useState<string>("")
  const [filterExactTime, setFilterExactTime] = React.useState<string>("")
  const fileInputRef = React.useRef<HTMLInputElement>(null)
  const [pageSize, setPageSize] = React.useState<number>(5)
  const [page, setPage] = React.useState<number>(1)

  React.useEffect(() => {
    let alive = true
    async function load() {
      setTasksLoading(true)
      const { data, error } = await supabase
        .from("tasks")
        .select("*")
        .eq("user_id", userId)
        .order("due_at", { ascending: true })
      if (!alive) return
      if (error) {
        toast.error("Failed to load tasks", { description: error.message })
        setTodos([])
        setInProgressTaskId(null)
      } else {
        const rows = (data ?? []) as DbTaskRow[]
        setTodos(rows.map(fromDbTask))
        setInProgressTaskId(rows.find((r) => r.in_progress)?.id ?? null)
      }
      setTasksLoading(false)
    }
    load()
    return () => {
      alive = false
    }
  }, [supabase, userId])

  // Keep "now" fresh so overdue/in-progress states stay accurate without user interaction.
  React.useEffect(() => {
    const id = window.setInterval(() => setNowMs(Date.now()), 30_000)
    return () => window.clearInterval(id)
  }, [])

  // Only one task can be "In Progress"; auto-clear if completed, deleted, or overdue.
  React.useEffect(() => {
    if (!inProgressTaskId) return
    const t = todos.find((x) => x.id === inProgressTaskId)
    if (!t || t.completed) {
      setInProgressTaskId(null)
      return
    }
  }, [inProgressTaskId, nowMs, todos])

  const nextUpcoming = React.useMemo(() => {
    const upcoming = todos
      .filter((t) => !t.completed)
      .map((t) => ({ todo: t, dueMs: parseLocalDateTime(t.dueAt) }))
      .filter((x) => x.dueMs >= nowMs)
      .sort((a, b) => a.dueMs - b.dueMs)[0]
    return upcoming ?? null
  }, [nowMs, todos])

  React.useEffect(() => {
    // If "next upcoming" changed, allow reminder again (dismiss is per-task).
    if (nextUpcoming && nextUpcoming.todo.id !== dismissedReminderTaskId) return
    if (!nextUpcoming) setDismissedReminderTaskId(null)
  }, [dismissedReminderTaskId, nextUpcoming])

  const reminder = React.useMemo(() => {
    const REMINDER_WINDOW_MIN = 15
    if (!nextUpcoming) return null
    if (dismissedReminderTaskId === nextUpcoming.todo.id) return null
    const mins = minutesUntil(nextUpcoming.dueMs, nowMs)
    if (mins < 0 || mins > REMINDER_WINDOW_MIN) return null
    return { ...nextUpcoming, mins }
  }, [dismissedReminderTaskId, nextUpcoming, nowMs])

  const form = useForm<TodoFormValues>({
    resolver: zodResolver(todoSchema),
    defaultValues: { title: "", description: "", dueAt: "" },
    mode: "onSubmit",
  })

  const summary = React.useMemo(() => {
    const now = new Date()
    const todayKey = localDateKey(now)
    const tomorrow = addDays(now, 1)
    const tomorrowKey = localDateKey(tomorrow)

    const todays = todos.filter((t) => t.dueAt.startsWith(todayKey))
    const todayCompleted = todays.filter((t) => t.completed).length
    const todayPending = todays.length - todayCompleted

    const labels = [
      "00:00–04:00",
      "04:00–08:00",
      "08:00–12:00",
      "12:00–16:00",
      "16:00–20:00",
      "20:00–24:00",
    ]

    // Tomorrow: same 4-hour windows breakdown
    const tomorrowTasks = todos.filter((t) => t.dueAt.startsWith(tomorrowKey))
    const tomorrowBuckets = Array.from({ length: 6 }, () => 0) as number[]
    for (const t of tomorrowTasks) {
      const ms = parseLocalDateTime(t.dueAt)
      const hour = new Date(ms).getHours()
      const idx = Math.floor(hour / 4)
      tomorrowBuckets[idx] = (tomorrowBuckets[idx] ?? 0) + 1
    }

    // Until next week = next 7 days starting tomorrow (local), grouped into 4-hour windows.
    const rangeStart = startOfDay(tomorrow).getTime()
    const rangeEnd = addDays(startOfDay(tomorrow), 7).getTime()
    const buckets = Array.from({ length: 6 }, () => 0) as number[]

    const upcoming = todos.filter((t) => {
      const ms = parseLocalDateTime(t.dueAt)
      return ms >= rangeStart && ms < rangeEnd
    })

    for (const t of upcoming) {
      const ms = parseLocalDateTime(t.dueAt)
      const hour = new Date(ms).getHours()
      const idx = Math.floor(hour / 4)
      buckets[idx] = (buckets[idx] ?? 0) + 1
    }

    return {
      todayCompleted,
      todayPending,
      tomorrowTotal: tomorrowTasks.length,
      tomorrowBuckets: labels.map((label, i) => ({ label, count: tomorrowBuckets[i] ?? 0 })),
      upcomingTotal: upcoming.length,
      upcomingBuckets: labels.map((label, i) => ({ label, count: buckets[i] ?? 0 })),
    }
  }, [todos])

  const loadDayKey = React.useMemo(() => {
    // Prefer an explicitly selected date from filters; otherwise use today.
    if (filterMode === "exact" && filterExactDate) return filterExactDate
    if (filterFromDate && !filterToDate) return filterFromDate
    if (filterFromDate && filterToDate && filterFromDate === filterToDate) return filterFromDate
    if (!filterFromDate && filterToDate) return filterToDate
    return localDateKey(new Date(nowMs))
  }, [filterExactDate, filterFromDate, filterMode, filterToDate, nowMs])

  const dailyLoad = React.useMemo(() => {
    const dayTodos = todos.filter((t) => getDatePart(t.dueAt) === loadDayKey)
    return getDailyLoad(dayTodos)
  }, [loadDayKey, todos])

  const filteredTodos = React.useMemo(() => {
    if (focusMode) {
      const endMs = nowMs + 4 * 60 * 60 * 1000
      const withMs = todos.map((t) => ({ ...t, _dueMs: parseLocalDateTime(t.dueAt) }))
      return withMs.filter((t) => t._dueMs >= nowMs && t._dueMs <= endMs)
    }

    const withMs = todos.map((t) => ({ ...t, _dueMs: parseLocalDateTime(t.dueAt) }))
    if (filterMode === "exact") {
      // If only date is selected -> show tasks for that date.
      // If time is selected too -> match exact date+time.
      // If only time is selected -> match time-of-day across all dates.
      if (!filterExactDate && !filterExactTime) return withMs

      if (filterExactDate && !filterExactTime) {
        return withMs.filter((t) => getDatePart(t.dueAt) === filterExactDate)
      }

      if (filterExactDate && filterExactTime) {
        const exactMs = parseLocalDateTime(`${filterExactDate}T${filterExactTime}`)
        return withMs.filter((t) => t._dueMs === exactMs)
      }

      // time only
      return withMs.filter((t) => getTimePart(t.dueAt) === filterExactTime)
    }
    // between
    const hasAnyDate = Boolean(filterFromDate || filterToDate)
    const hasAnyTime = Boolean(filterFromTime || filterToTime)

    // Date range (optional)
    const fromDateMs = filterFromDate
      ? startOfDay(parseLocalDateOnly(filterFromDate)).getTime()
      : Number.NEGATIVE_INFINITY
    const toDateMs = filterToDate
      ? endOfDay(parseLocalDateOnly(filterToDate)).getTime()
      : Number.POSITIVE_INFINITY

    // Time-of-day range (optional)
    const fromTimeMin = filterFromTime ? parseLocalTimeToMinutes(filterFromTime) : 0
    const toTimeMin = filterToTime ? parseLocalTimeToMinutes(filterToTime) : 24 * 60 - 1

    return withMs.filter((t) => {
      const ms = t._dueMs
      if (hasAnyDate && (ms < fromDateMs || ms > toDateMs)) return false

      if (hasAnyTime) {
        const time = getTimePart(t.dueAt)
        if (!time) return false
        const mins = parseLocalTimeToMinutes(time)
        // Simple (non-wrapping) range. If you want wrap-around (e.g. 22:00–02:00), tell me.
        if (mins < fromTimeMin || mins > toTimeMin) return false
      }

      // If neither date nor time selected, pass through (handled above anyway)
      return true
    })
  }, [
    todos,
    focusMode,
    nowMs,
    filterExactDate,
    filterExactTime,
    filterFromDate,
    filterFromTime,
    filterMode,
    filterToDate,
    filterToTime,
  ])

  const sortedFilteredTodos = React.useMemo(
    () =>
      filteredTodos
        .slice()
        .sort((a, b) => parseLocalDateTime(a.dueAt) - parseLocalDateTime(b.dueAt)),
    [filteredTodos]
  )

  // Clamp page when filters/pageSize change.
  React.useEffect(() => {
    const totalPages = Math.max(1, Math.ceil(sortedFilteredTodos.length / pageSize))
    setPage((p) => Math.min(Math.max(1, p), totalPages))
  }, [pageSize, sortedFilteredTodos.length])

  const totalItems = sortedFilteredTodos.length
  const totalPages = Math.max(1, Math.ceil(totalItems / pageSize))
  const showPagination = totalPages > 1

  const pageItems = React.useMemo(() => {
    const start = (page - 1) * pageSize
    return sortedFilteredTodos.slice(start, start + pageSize)
  }, [page, pageSize, sortedFilteredTodos])

  const groupedTodos = React.useMemo(() => {
    const groups: Array<{ date: string; items: typeof pageItems }> = []
    for (const t of pageItems) {
      const date = getDatePart(t.dueAt)
      const last = groups[groups.length - 1]
      if (!last || last.date !== date) groups.push({ date, items: [t] })
      else last.items.push(t)
    }
    return groups
  }, [pageItems])

  const completedCount = filteredTodos.filter((t) => t.completed).length

  async function addTodo(values: TodoFormValues) {
    const conflicts = todos.filter((t) => t.dueAt === values.dueAt)
    if (conflicts.length > 0) {
      setConflictDueAt(values.dueAt)
      if (clearConflictTimerRef.current) window.clearTimeout(clearConflictTimerRef.current)
      clearConflictTimerRef.current = window.setTimeout(() => {
        setConflictDueAt(null)
      }, 8000)

      // Make sure the user can see the conflicting tasks even if they were filtered out.
      const [d, time] = values.dueAt.split("T")
      setFilterMode("exact")
      setFilterExactDate(d ?? "")
      setFilterExactTime(time ?? "")
      setPage(1)

      toast.error("Time conflict", {
        description: `You already have ${conflicts.length} task(s) scheduled at ${formatLocalDateTime(
          values.dueAt
        )}.`,
      })
    }

    const { data, error } = await supabase
      .from("tasks")
      .insert(toDbTaskInsert(values, userId))
      .select("*")
      .single()
    if (error) {
      toast.error("Failed to add task", { description: error.message })
      return
    }

    setTodos((prev) => [fromDbTask(data as DbTaskRow), ...prev])
    form.reset()
  }

  async function toggleTodo(id: string, completed: boolean) {
    // optimistic
    setTodos((prev) =>
      prev.map((t) =>
        t.id === id ? { ...t, completed, attachments: t.attachments } : t
      )
    )
    if (completed) setInProgressTaskId((cur) => (cur === id ? null : cur))

    const update: { completed: boolean; in_progress?: boolean } = { completed }
    if (completed) update.in_progress = false

    const { error } = await supabase
      .from("tasks")
      .update(update)
      .eq("id", id)
      .eq("user_id", userId)
    if (error) {
      toast.error("Failed to update task", { description: error.message })
    }
  }

  function requestAttachmentsForTodo(todoId: string) {
    setAttachTargetTodoId(todoId)
    // Let state update before opening picker (some browsers are picky).
    queueMicrotask(() => fileInputRef.current?.click())
  }

  async function handleFilesPicked(e: React.ChangeEvent<HTMLInputElement>) {
    const files = Array.from(e.target.files ?? [])
    const targetId = attachTargetTodoId

    // reset input so picking the same file again triggers onChange
    e.target.value = ""
    setAttachTargetTodoId(null)

    if (!targetId || files.length === 0) return
    const targetTodo = todos.find((t) => t.id === targetId)
    if (!targetTodo) return

    const bucket = "task-attachments"
    const uploaded: Attachment[] = []

    for (const file of files) {
      const safeName = sanitizePathSegment(file.name)
      const path = `${userId}/${targetId}/${crypto.randomUUID()}-${safeName}`
      const { error } = await supabase.storage
        .from(bucket)
        .upload(path, file, { contentType: file.type, upsert: false })
      if (error) {
        toast.error("Upload failed", { description: error.message })
        continue
      }
      uploaded.push(buildAttachmentRecord(file, bucket, path))
    }

    if (uploaded.length === 0) return
    const nextAttachments = [...targetTodo.attachments, ...uploaded]

    // optimistic
    setTodos((prev) =>
      prev.map((t) => (t.id === targetId ? { ...t, attachments: nextAttachments } : t))
    )

    const { error } = await supabase
      .from("tasks")
      .update({ attachments: nextAttachments })
      .eq("id", targetId)
      .eq("user_id", userId)
    if (error) {
      toast.error("Failed to save attachments", { description: error.message })
    }
  }

  async function deleteTodo(id: string) {
    // optimistic
    setTodos((prev) => prev.filter((t) => t.id !== id))
    setInProgressTaskId((cur) => (cur === id ? null : cur))

    const { error } = await supabase.from("tasks").delete().eq("id", id).eq("user_id", userId)
    if (error) toast.error("Failed to delete task", { description: error.message })
  }

  async function setInProgress(taskId: string | null) {
    // optimistic
    setInProgressTaskId(taskId)

    // Clear any previous in-progress tasks first (enforces the single-task rule).
    const clearRes = await supabase
      .from("tasks")
      .update({ in_progress: false })
      .eq("user_id", userId)
      .eq("in_progress", true)
    if (clearRes.error) {
      toast.error("Failed to update in-progress", { description: clearRes.error.message })
      return
    }

    if (!taskId) return

    const setRes = await supabase
      .from("tasks")
      .update({ in_progress: true })
      .eq("id", taskId)
      .eq("user_id", userId)
    if (setRes.error) {
      toast.error("Failed to update in-progress", { description: setRes.error.message })
    }
  }

  async function downloadAttachment(a: Attachment) {
    const { data, error } = await supabase.storage.from(a.bucket).createSignedUrl(a.path, 60)
    if (error || !data?.signedUrl) {
      toast.error("Download failed", { description: error?.message ?? "Please try again." })
      return
    }
    window.open(data.signedUrl, "_blank", "noopener,noreferrer")
  }

  async function seedDemoTasks() {
    if (todos.length > 0) return
    const payload = initialTodos.map((t) => ({
      user_id: userId,
      title: t.title,
      description: t.description ?? null,
      due_at: t.dueAt,
      completed: t.completed,
      in_progress: false,
      attachments: [],
    }))
    const { data, error } = await supabase.from("tasks").insert(payload).select("*")
    if (error) {
      toast.error("Failed to seed demo tasks", { description: error.message })
      return
    }
    const rows = (data ?? []) as DbTaskRow[]
    setTodos(rows.map(fromDbTask))
  }

  async function clearCompleted() {
    const completedIds = new Set(todos.filter((t) => t.completed).map((t) => t.id))
    if (completedIds.size === 0) return

    // optimistic
    setTodos((prev) => prev.filter((t) => !completedIds.has(t.id)))

    const { error } = await supabase
      .from("tasks")
      .delete()
      .eq("user_id", userId)
      .eq("completed", true)
    if (error) toast.error("Failed to clear completed", { description: error.message })
  }

  return (
    <Card>
      <CardHeader className="flex flex-row items-center justify-between gap-4">
        <div className="space-y-1">
          <CardTitle className="text-2xl">To‑Do</CardTitle>
          <p className="text-muted-foreground text-sm">
            {completedCount}/{filteredTodos.length} completed
          </p>
        </div>
        <div className="flex items-center gap-2">
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <Button
                  type="button"
                  variant={focusMode ? "default" : "outline"}
                  size="sm"
                  onClick={() => {
                    setFocusMode((v) => !v)
                    setPage(1)
                  }}
                >
                  Focus Mode
                </Button>
              </TooltipTrigger>
              <TooltipContent>
                <p>Show tasks for the next 4 hours.</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
          <Button
            type="button"
            variant="outline"
            size="sm"
            onClick={async () => {
              await supabase.auth.signOut()
            }}
          >
            Sign out
          </Button>
          <ModeToggle />
        </div>
      </CardHeader>

      <CardContent className="space-y-6">
        {tasksLoading && (
          <p className="text-muted-foreground text-sm">Loading tasks…</p>
        )}

        {!tasksLoading && todos.length === 0 && (
          <div className="flex items-center justify-between gap-3 rounded-lg border bg-muted/20 px-3 py-2">
            <p className="text-muted-foreground text-sm">No tasks yet.</p>
            <Button type="button" variant="outline" size="sm" onClick={() => void seedDemoTasks()}>
              Seed demo tasks
            </Button>
          </div>
        )}

        <input
          ref={fileInputRef}
          type="file"
          multiple
          className="hidden"
          accept={[
            "image/*",
            "audio/*",
            "video/*",
            ".pdf",
            ".doc",
            ".docx",
            ".xls",
            ".xlsx",
            ".csv",
            ".txt",
            ".md",
            ".rtf",
          ].join(",")}
          onChange={handleFilesPicked}
        />

        {reminder && (
          <Alert className="border-primary/30 bg-primary/5">
            <Bell className="h-4 w-4" />
            <div className="flex flex-1 flex-col gap-1">
              <div className="flex flex-wrap items-center justify-between gap-2">
                <AlertTitle className="text-sm">
                  Next task starts in {reminder.mins} minute{reminder.mins === 1 ? "" : "s"}
                </AlertTitle>
                <Button
                  type="button"
                  variant="ghost"
                  size="sm"
                  onClick={() => setDismissedReminderTaskId(reminder.todo.id)}
                >
                  Dismiss
                </Button>
              </div>
              <AlertDescription className="text-sm">
                <span className="font-medium">{reminder.todo.title}</span> ·{" "}
                {formatDateTimeFromMs(reminder.dueMs)}
              </AlertDescription>
            </div>
          </Alert>
        )}

        <div className="rounded-xl border bg-card p-4">
          <div className="flex flex-wrap items-center justify-between gap-2">
            <p className="text-sm font-medium">
              Daily load{" "}
              <span className="text-muted-foreground font-normal">
                ({new Intl.DateTimeFormat(undefined, {
                  weekday: "short",
                  year: "numeric",
                  month: "short",
                  day: "2-digit",
                }).format(parseLocalDateOnly(loadDayKey))})
              </span>
            </p>
            <DailyLoadBadge load={dailyLoad.load} />
          </div>
          <p className="text-muted-foreground mt-2 text-sm">
            {dailyLoad.total} task(s) · busiest window {dailyLoad.busiestWindow} ({dailyLoad.peak})
          </p>
        </div>

        <div className="grid gap-3 sm:grid-cols-3">
          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Today’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">
              {summary.todayCompleted} completed
            </p>
            <p className="text-muted-foreground text-sm">{summary.todayPending} pending</p>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tomorrow’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">{summary.tomorrowTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.tomorrowBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tasks Until Next Week</p>
            <p className="mt-2 text-2xl font-semibold">{summary.upcomingTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.upcomingBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>
        </div>

        {focusMode && (
          <div className="flex flex-col gap-1 rounded-lg border bg-muted/20 px-3 py-2 sm:flex-row sm:items-center sm:justify-between">
            <p className="text-sm">
              <span className="font-medium">Focus Mode:</span>{" "}
              showing tasks due in the next 4 hours (until{" "}
              <span className="font-medium">
                {formatDateTimeFromMs(nowMs + 4 * 60 * 60 * 1000)}
              </span>
              )
            </p>
            <Button type="button" variant="ghost" size="sm" onClick={() => setFocusMode(false)}>
              Exit
            </Button>
          </div>
        )}

        <Form {...form}>
          <form
            onSubmit={form.handleSubmit(addTodo)}
            className="space-y-2"
            noValidate
          >
            <div className="flex flex-col gap-2 sm:flex-row">
              <FormField
                control={form.control}
                name="title"
                render={({ field }) => (
                  <FormItem className="flex-1">
                    <FormControl>
                      <Input
                        placeholder="Add a task…"
                        autoComplete="off"
                        {...field}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="dueAt"
                render={({ field }) => (
                  <FormItem className="sm:w-64">
                    <FormControl>
                      <Input type="datetime-local" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <Button type="submit">Add</Button>
            </div>

            <FormField
              control={form.control}
              name="description"
              render={({ field }) => (
                <FormItem>
                  <FormControl>
                    <Textarea
                      rows={3}
                      placeholder="Description (optional)…"
                      {...field}
                    />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />
          </form>
        </Form>

        <Separator />

        <div className="space-y-3">
          <div className="flex flex-wrap items-center justify-between gap-2">
            <p className="text-sm font-medium">Filter by date & time</p>
            <div className="flex items-center gap-2">
              <Button
                type="button"
                size="sm"
                variant={filterMode === "between" ? "default" : "outline"}
                onClick={() => setFilterMode("between")}
              >
                Between
              </Button>
              <Button
                type="button"
                size="sm"
                variant={filterMode === "exact" ? "default" : "outline"}
                onClick={() => setFilterMode("exact")}
              >
                Exact
              </Button>
              <Button
                type="button"
                size="sm"
                variant="ghost"
                onClick={() => {
                  setFilterFromDate("")
                  setFilterFromTime("")
                  setFilterToDate("")
                  setFilterToTime("")
                  setFilterExactDate("")
                  setFilterExactTime("")
                }}
              >
                Clear
              </Button>
            </div>
          </div>

          {filterMode === "between" ? (
            <div className="grid gap-2 sm:grid-cols-2">
              <div className="grid gap-2 sm:grid-cols-2">
                <Input
                  type="date"
                  value={filterFromDate}
                  onChange={(e) => setFilterFromDate(e.target.value)}
                />
                <Input
                  type="time"
                  value={filterFromTime}
                  onChange={(e) => setFilterFromTime(e.target.value)}
                />
              </div>
              <div className="grid gap-2 sm:grid-cols-2">
                <Input
                  type="date"
                  value={filterToDate}
                  onChange={(e) => setFilterToDate(e.target.value)}
                />
                <Input
                  type="time"
                  value={filterToTime}
                  onChange={(e) => setFilterToTime(e.target.value)}
                />
              </div>
            </div>
          ) : (
            <div className="grid gap-2 sm:grid-cols-2">
              <Input
                type="date"
                value={filterExactDate}
                onChange={(e) => setFilterExactDate(e.target.value)}
              />
              <Input
                type="time"
                value={filterExactTime}
                onChange={(e) => setFilterExactTime(e.target.value)}
              />
            </div>
          )}
        </div>

        <Separator />

        <div className="space-y-2">
          {groupedTodos.length === 0 ? (
            <p className="text-muted-foreground text-sm">No tasks yet.</p>
          ) : (
            groupedTodos.map((group) => (
              <div key={group.date} className="space-y-2">
                <div className="flex items-center gap-3 pt-2">
                  <Separator className="flex-1" />
                  <span className="text-muted-foreground whitespace-nowrap text-xs font-medium">
                    {new Intl.DateTimeFormat(undefined, {
                      weekday: "short",
                      year: "numeric",
                      month: "short",
                      day: "2-digit",
                    }).format(parseLocalDateOnly(group.date))}
                  </span>
                  <Separator className="flex-1" />
                </div>

                {group.items.map((todo) => {
                  const flags = getTaskFlags(todo, nowMs, inProgressTaskId)

                  return (
                    <div
                      key={todo.id}
                      className={cn(
                        "rounded-lg border px-3 py-2",
                        flags.completed && "opacity-75",
                        flags.overdue &&
                          "border-destructive/40 bg-destructive/5 text-muted-foreground",
                        flags.inProgress && "border-sky-500/40 bg-sky-500/10",
                        conflictDueAt &&
                          todo.dueAt === conflictDueAt &&
                          "border-destructive/60 bg-destructive/5 ring-1 ring-destructive/30"
                      )}
                    >
                      <div className="flex items-start justify-between gap-3">
                        <label className="flex cursor-pointer items-start gap-3">
                        <Checkbox
                          checked={todo.completed}
                          onCheckedChange={(v) => {
                            const next = Boolean(v)
                            toggleTodo(todo.id, next)
                            if (next && !todo.completed) {
                              requestAttachmentsForTodo(todo.id)
                            }
                          }}
                          aria-label={`Mark "${todo.title}" as ${
                            todo.completed ? "not completed" : "completed"
                          }`}
                          className="mt-0.5"
                        />
                        <span
                          className={cn(
                            "leading-6",
                            todo.completed && "text-muted-foreground line-through"
                          )}
                        >
                          <span className="flex flex-wrap items-center gap-2">
                            <span className="block">{todo.title}</span>
                              <span className="flex flex-wrap items-center gap-2">
                                <TaskBadges {...flags} />
                              </span>
                            {todo.description && (
                              <TooltipProvider>
                                <Tooltip>
                                  <TooltipTrigger asChild>
                                    <button
                                      type="button"
                                      className="text-muted-foreground hover:text-foreground inline-flex h-7 w-7 items-center justify-center rounded-md border bg-background"
                                      aria-label="View description"
                                    >
                                      <Info className="h-4 w-4" />
                                    </button>
                                  </TooltipTrigger>
                                  <TooltipContent className="max-w-xs">
                                    <p className="whitespace-pre-wrap text-sm">
                                      {todo.description}
                                    </p>
                                  </TooltipContent>
                                </Tooltip>
                              </TooltipProvider>
                            )}
                          </span>
                          <span className="text-muted-foreground block text-xs">
                            Due: {formatLocalDateTime(todo.dueAt)}
                          </span>
                        </span>
                      </label>

                      <div className="flex items-center gap-1">
                        {!todo.completed && (
                          <Button
                            type="button"
                            variant={flags.inProgress ? "default" : "outline"}
                            size="sm"
                            onClick={() => void setInProgress(flags.inProgress ? null : todo.id)}
                            className={cn(
                              flags.inProgress && "bg-sky-600 hover:bg-sky-600"
                            )}
                          >
                            {flags.inProgress ? (
                              <>
                                <CircleStop className="mr-1 h-4 w-4" />
                                Stop
                              </>
                            ) : (
                              <>
                                <CirclePlay className="mr-1 h-4 w-4" />
                                Start
                              </>
                            )}
                          </Button>
                        )}
                        {todo.completed && (
                          <Button
                            type="button"
                            variant="outline"
                            size="sm"
                            onClick={() => requestAttachmentsForTodo(todo.id)}
                          >
                            Add files
                          </Button>
                        )}
                        <Button
                          type="button"
                          variant="ghost"
                          size="icon"
                          aria-label={`Delete "${todo.title}"`}
                          onClick={() => deleteTodo(todo.id)}
                        >
                          <Trash2 className="h-4 w-4" />
                        </Button>
                      </div>
                    </div>

                    {todo.completed && todo.attachments.length > 0 && (
                      <div className="mt-3 space-y-2">
                        <p className="text-muted-foreground text-xs">Attachments</p>
                        <ul className="space-y-1">
                          {todo.attachments.map((a) => (
                            <li
                              key={a.id}
                              className="flex items-center justify-between gap-3 rounded-md bg-muted/30 px-2 py-1"
                            >
                              <div className="flex min-w-0 items-center gap-2">
                                <AttachmentIcon kind={a.kind} />
                                <span className="truncate text-sm">{a.name}</span>
                              </div>
                              <button
                                type="button"
                                onClick={() => void downloadAttachment(a)}
                                className="inline-flex items-center gap-1 text-sm font-medium underline underline-offset-4"
                              >
                                <Download className="h-4 w-4" />
                                Download
                              </button>
                            </li>
                          ))}
                        </ul>
                      </div>
                    )}
                  </div>
                  )
                })}
              </div>
            ))
          )}
        </div>

        {groupedTodos.length > 0 && (
          <div className="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
            <div className="flex items-center gap-2">
              <span className="text-muted-foreground text-sm">Items per page</span>
              <Select
                value={String(pageSize)}
                onValueChange={(v) => {
                  const next = Number(v)
                  setPageSize(next)
                  setPage(1)
                }}
              >
                <SelectTrigger className="w-[110px]">
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="5">5</SelectItem>
                  <SelectItem value="10">10</SelectItem>
                  <SelectItem value="15">15</SelectItem>
                  <SelectItem value="20">20</SelectItem>
                </SelectContent>
              </Select>
            </div>

            {showPagination && (
              <div className="flex items-center justify-between gap-3 sm:justify-end">
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={() => setPage((p) => Math.max(1, p - 1))}
                  disabled={page <= 1}
                >
                  Prev
                </Button>
                <span className="text-muted-foreground text-sm">
                  Page {page} of {totalPages}
                </span>
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={() => setPage((p) => Math.min(totalPages, p + 1))}
                  disabled={page >= totalPages}
                >
                  Next
                </Button>
              </div>
            )}
          </div>
        )}

        <div className="flex items-center justify-between gap-2">
          <Button
            type="button"
            variant="secondary"
            onClick={clearCompleted}
            disabled={completedCount === 0}
          >
            Clear completed
          </Button>
          <span className="text-muted-foreground text-sm">
            v 1.1.0
          </span>
    </div>
      </CardContent>
    </Card>
  )
}

```

```typescriptreact
"use client"

import { zodResolver } from "@hookform/resolvers/zod"
import {
  AlertTriangle,
  CirclePlay,
  CircleStop,
  CalendarClock,
  CheckCircle2,
  Download,
  File,
  FileSpreadsheet,
  FileText,
  Image as ImageIcon,
  Info,
  Music,
  Bell,
  Timer,
  Trash2,
  Video,
} from "lucide-react"
import * as React from "react"
import { useForm } from "react-hook-form"
import { toast } from "sonner"
import { z } from "zod"
// Supabase is accessed via Next.js API routes (see src/app/api/**). No direct client usage here.

import { ModeToggle } from "@/components/mode-toggle"
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert"
import { Badge } from "@/components/ui/badge"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Checkbox } from "@/components/ui/checkbox"
import { Form, FormControl, FormField, FormItem, FormMessage } from "@/components/ui/form"
import { Input } from "@/components/ui/input"
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select"
import { Separator } from "@/components/ui/separator"
import { Textarea } from "@/components/ui/textarea"
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip"
import { cn } from "@/lib/utils"
import { apiFetch, ApiError } from "@/lib/api-client"

type AttachmentKind =
  | "image"
  | "audio"
  | "video"
  | "pdf"
  | "spreadsheet"
  | "document"
  | "text"
  | "file"

type Attachment = {
  id: string
  name: string
  type: string
  size: number
  bucket: string
  path: string
  kind: AttachmentKind
}

type Todo = {
  id: string
  title: string
  description?: string
  completed: boolean
  // Stored as `datetime-local` string (YYYY-MM-DDTHH:mm) in local time.
  dueAt: string
  attachments: Attachment[]
}

type TaskState = "planned" | "in_progress" | "completed" | "overdue"
type DailyLoad = "light" | "balanced" | "heavy"

const todoSchema = z.object({
  title: z
    .string()
    .trim()
    .min(1, "Title is required.")
    .max(80, "Keep it under 80 characters."),
  description: z
    .string()
    .trim()
    .max(500, "Keep it under 500 characters.")
    .optional()
    .or(z.literal("")),
  dueAt: z
    .string()
    .min(1, "Due date & time is required.")
    .regex(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}$/, "Invalid date/time."),
})

type TodoFormValues = z.infer<typeof todoSchema>

const initialTodos: Todo[] = [
  {
    id: "1",
    title: "Create a Next.js app",
    description: "Scaffold with TypeScript + Tailwind and confirm it runs locally.",
    completed: true,
    dueAt: "2026-01-16T09:00",
    attachments: [],
  },
  {
    id: "2",
    title: "Add shadcn/ui + dark theme",
    description: "Initialize shadcn, set up theme provider, and verify dark mode.",
    completed: true,
    dueAt: "2026-01-16T10:30",
    attachments: [],
  },
  {
    id: "3",
    title: "Build a mock-data to-do list",
    completed: false,
    dueAt: "2026-01-16T15:00",
    attachments: [],
  },
  {
    id: "4",
    title: "Yesterday: review requirements",
    completed: true,
    dueAt: "2026-01-15T11:15",
    attachments: [],
  },
  {
    id: "5",
    title: "Yesterday: sketch UI layout",
    completed: true,
    dueAt: "2026-01-15T17:45",
    attachments: [],
  },
  {
    id: "6",
    title: "Today: add attachments support",
    completed: false,
    dueAt: "2026-01-16T18:20",
    attachments: [],
  },
  {
    id: "7",
    title: "Tomorrow: QA the filters",
    description: "Test date-only, time-only, exact, and between behaviors.",
    completed: false,
    dueAt: "2026-01-17T08:05",
    attachments: [],
  },
  {
    id: "8",
    title: "Tomorrow: polish summary cards",
    completed: false,
    dueAt: "2026-01-17T13:30",
    attachments: [],
  },
  {
    id: "9",
    title: "Tomorrow: write small UX notes",
    completed: false,
    dueAt: "2026-01-17T20:10",
    attachments: [],
  },
  {
    id: "10",
    title: "This weekend: add more mock tasks",
    completed: false,
    dueAt: "2026-01-18T10:00",
    attachments: [],
  },
  {
    id: "11",
    title: "This weekend: check time-only filter",
    completed: false,
    dueAt: "2026-01-18T22:15",
    attachments: [],
  },
  {
    id: "12",
    title: "Next week: sync with team",
    completed: false,
    dueAt: "2026-01-19T09:30",
    attachments: [],
  },
  {
    id: "13",
    title: "Next week: test date-only filter",
    completed: false,
    dueAt: "2026-01-20T14:05",
    attachments: [],
  },
  {
    id: "14",
    title: "Next week: test exact date+time filter",
    completed: false,
    dueAt: "2026-01-21T12:00",
    attachments: [],
  },
  {
    id: "15",
    title: "Next week: attach docs to completed tasks",
    completed: false,
    dueAt: "2026-01-22T16:40",
    attachments: [],
  },
  {
    id: "16",
    title: "Next week: final review",
    completed: false,
    dueAt: "2026-01-23T11:00",
    attachments: [],
  },
]

type DbTaskRow = {
  id: string
  user_id: string
  title: string
  description: string | null
  due_at: string
  completed: boolean
  in_progress: boolean
  attachments: unknown
}

function coerceAttachments(raw: unknown): Attachment[] {
  if (!raw || typeof raw !== "object") return []
  if (!Array.isArray(raw)) return []
  return raw.filter(Boolean) as Attachment[]
}

function toDbTaskInsert(values: TodoFormValues, userId: string) {
  return {
    user_id: userId,
    title: values.title.trim(),
    description: (values.description ?? "").trim() || null,
    due_at: values.dueAt,
    completed: false,
    in_progress: false,
    attachments: [],
  }
}

function fromDbTask(row: DbTaskRow): Todo {
  return {
    id: row.id,
    title: row.title,
    description: row.description ?? undefined,
    completed: row.completed,
    dueAt: row.due_at,
    attachments: coerceAttachments(row.attachments),
  }
}

function parseLocalDateTime(value: string): number {
  // value: "YYYY-MM-DDTHH:mm"
  const [datePart, timePart] = value.split("T")
  const [y, m, d] = datePart.split("-").map(Number)
  const [hh, mm] = timePart.split(":").map(Number)
  return new Date(y, m - 1, d, hh, mm, 0, 0).getTime()
}

function pad2(n: number) {
  return String(n).padStart(2, "0")
}

function localDateKey(d: Date) {
  return `${d.getFullYear()}-${pad2(d.getMonth() + 1)}-${pad2(d.getDate())}`
}

function addDays(date: Date, days: number) {
  const d = new Date(date)
  d.setDate(d.getDate() + days)
  return d
}

function startOfDay(date: Date) {
  return new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0, 0)
}

function endOfDay(date: Date) {
  return new Date(
    date.getFullYear(),
    date.getMonth(),
    date.getDate(),
    23,
    59,
    59,
    999
  )
}

function getDatePart(dueAt: string) {
  return dueAt.split("T")[0] ?? ""
}

function getTimePart(dueAt: string) {
  return dueAt.split("T")[1] ?? ""
}

function parseLocalDateOnly(value: string): Date {
  // value: "YYYY-MM-DD"
  const [y, m, d] = value.split("-").map(Number)
  return new Date(y, m - 1, d, 0, 0, 0, 0)
}

function parseLocalTimeToMinutes(value: string): number {
  // value: "HH:mm"
  const [hh, mm] = value.split(":").map(Number)
  return hh * 60 + mm
}

function formatLocalDateTime(value: string): string {
  const ms = parseLocalDateTime(value)
  if (!Number.isFinite(ms)) return value
  return new Intl.DateTimeFormat(undefined, {
    year: "numeric",
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  }).format(new Date(ms))
}

function formatDateTimeFromMs(ms: number): string {
  return new Intl.DateTimeFormat(undefined, {
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  }).format(new Date(ms))
}

function minutesUntil(targetMs: number, nowMs: number) {
  return Math.ceil((targetMs - nowMs) / 60_000)
}

function getTaskFlags(todo: Todo, nowMs: number, inProgressTaskId: string | null) {
  const completed = todo.completed
  const dueMs = parseLocalDateTime(todo.dueAt)
  const overdue = !completed && dueMs < nowMs
  const inProgress = !completed && inProgressTaskId === todo.id
  const planned = !completed && !overdue && !inProgress
  return { completed, overdue, inProgress, planned }
}

function getDailyLoad(todosForDay: Todo[]) {
  // 4-hour windows across the day (local).
  const labels = [
    "00:00–04:00",
    "04:00–08:00",
    "08:00–12:00",
    "12:00–16:00",
    "16:00–20:00",
    "20:00–24:00",
  ]
  const buckets = Array.from({ length: 6 }, () => 0) as number[]
  for (const t of todosForDay) {
    const ms = parseLocalDateTime(t.dueAt)
    const hour = new Date(ms).getHours()
    const idx = Math.floor(hour / 4)
    buckets[idx] = (buckets[idx] ?? 0) + 1
  }

  const total = todosForDay.length
  const peak = Math.max(0, ...buckets)
  const spread = buckets.filter((c) => c > 0).length
  const busiestIdx = buckets.findIndex((c) => c === peak)
  const busiestWindow = busiestIdx >= 0 ? labels[busiestIdx] : labels[0]

  // Heuristic: more tasks + higher concentration in one window => heavier day.
  const score = total + peak * 1.5 + Math.max(0, spread - 1) * 0.5
  const load: DailyLoad = score <= 5 ? "light" : score <= 10 ? "balanced" : "heavy"

  return { load, total, peak, spread, busiestWindow }
}

function DailyLoadBadge({ load }: { load: DailyLoad }) {
  if (load === "heavy") return <Badge variant="destructive">Heavy</Badge>
  if (load === "balanced") return <Badge variant="secondary">Balanced</Badge>
  return <Badge variant="outline">Light</Badge>
}

function TaskBadges({
  completed,
  overdue,
  inProgress,
  planned,
}: {
  completed: boolean
  overdue: boolean
  inProgress: boolean
  planned: boolean
}) {
  if (completed) {
    return (
      <Badge className="gap-1 bg-emerald-600 text-white hover:bg-emerald-600">
        <CheckCircle2 className="h-3.5 w-3.5" />
        Completed
      </Badge>
    )
  }

  return (
    <>
      {inProgress && (
        <Badge className="gap-1 bg-sky-600 text-white hover:bg-sky-600">
          <Timer className="h-3.5 w-3.5 text-white" />
          In progress
        </Badge>
      )}
      {overdue && (
        <Badge variant="destructive" className="gap-1">
          <AlertTriangle className="h-3.5 w-3.5" />
          Overdue
        </Badge>
      )}
      {planned && (
        <Badge variant="outline" className="gap-1">
          <CalendarClock className="h-3.5 w-3.5" />
          Planned
        </Badge>
      )}
    </>
  )
}

function getAttachmentKind(file: File): AttachmentKind {
  const type = (file.type || "").toLowerCase()
  const name = file.name.toLowerCase()
  const ext = name.includes(".") ? name.split(".").pop() ?? "" : ""

  if (type.startsWith("image/")) return "image"
  if (type.startsWith("audio/")) return "audio"
  if (type.startsWith("video/")) return "video"

  if (ext === "pdf") return "pdf"
  if (["xls", "xlsx", "csv"].includes(ext)) return "spreadsheet"
  if (["doc", "docx"].includes(ext)) return "document"
  if (["txt", "md", "rtf"].includes(ext)) return "text"

  return "file"
}

function sanitizePathSegment(s: string) {
  return s.replace(/[^\w.\-]+/g, "_")
}

function buildAttachmentRecord(file: File, bucket: string, path: string): Attachment {
  return {
    id: crypto.randomUUID(),
    name: file.name,
    type: file.type,
    size: file.size,
    bucket,
    path,
    kind: getAttachmentKind(file),
  }
}

function AttachmentIcon({ kind }: { kind: AttachmentKind }) {
  const className = "h-4 w-4 text-muted-foreground"

  switch (kind) {
    case "image":
      return <ImageIcon className={className} />
    case "audio":
      return <Music className={className} />
    case "video":
      return <Video className={className} />
    case "spreadsheet":
      return <FileSpreadsheet className={className} />
    case "pdf":
    case "document":
    case "text":
      return <FileText className={className} />
    default:
      return <File className={className} />
  }
}

const authSchema = z.object({
  email: z.string().email("Enter a valid email."),
  password: z.string().min(6, "Password must be at least 6 characters."),
})
type AuthValues = z.infer<typeof authSchema>

function AuthCard({ onAuthed }: { onAuthed: () => void }) {
  const [mode, setMode] = React.useState<"sign_in" | "sign_up">("sign_in")
  const [busy, setBusy] = React.useState(false)

  const form = useForm<AuthValues>({
    resolver: zodResolver(authSchema),
    defaultValues: { email: "", password: "" },
  })

  async function onSubmit(values: AuthValues) {
    setBusy(true)
    try {
      if (mode === "sign_in") {
        await apiFetch("/api/auth/sign-in", {
          method: "POST",
          body: JSON.stringify(values),
        })
        onAuthed()
      } else {
        await apiFetch("/api/auth/sign-up", {
          method: "POST",
          body: JSON.stringify(values),
        })
        toast.success("Account created", {
          description: "You can now sign in (or confirm email if required).",
        })
        setMode("sign_in")
      }
    } catch (e) {
      toast.error("Authentication failed", {
        description: e instanceof Error ? e.message : "Please try again.",
      })
    } finally {
      setBusy(false)
    }
  }

  return (
    <div className="mx-auto flex min-h-screen max-w-md flex-col justify-center px-4 py-10">
      <Card>
        <CardHeader>
          <CardTitle className="text-2xl">Sign in</CardTitle>
          <p className="text-muted-foreground text-sm">
            {mode === "sign_in"
              ? "Use your email and password."
              : "Create an account with email and password."}
          </p>
        </CardHeader>
        <CardContent className="space-y-4">
          <Form {...form}>
            <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-3" noValidate>
              <FormField
                control={form.control}
                name="email"
                render={({ field }) => (
                  <FormItem>
                    <FormControl>
                      <Input placeholder="Email" autoComplete="email" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="password"
                render={({ field }) => (
                  <FormItem>
                    <FormControl>
                      <Input
                        type="password"
                        placeholder="Password"
                        autoComplete={
                          mode === "sign_in" ? "current-password" : "new-password"
                        }
                        {...field}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <Button type="submit" className="w-full" disabled={busy}>
                {mode === "sign_in" ? "Sign in" : "Sign up"}
              </Button>
            </form>
          </Form>

          <div className="flex items-center justify-between gap-3 text-sm">
            <span className="text-muted-foreground">
              {mode === "sign_in" ? "No account?" : "Already have an account?"}
            </span>
            <Button
              type="button"
              variant="link"
              className="px-0"
              onClick={() => setMode((m) => (m === "sign_in" ? "sign_up" : "sign_in"))}
            >
              {mode === "sign_in" ? "Sign up" : "Sign in"}
            </Button>
          </div>
        </CardContent>
      </Card>
    </div>
  )
}

export default function Home() {
  const [user, setUser] = React.useState<{ id: string; email?: string } | null>(null)
  const [authLoading, setAuthLoading] = React.useState(true)
  const [authError, setAuthError] = React.useState<string | null>(null)

  const refreshAuth = React.useCallback(async () => {
    setAuthLoading(true)
    try {
      const data = await apiFetch<{ user: { id: string; email?: string } | null }>("/api/auth/me")
      setUser(data.user)
      setAuthError(null)
    } catch (e) {
      setUser(null)
      setAuthError(e instanceof Error ? e.message : "Auth check failed.")
    } finally {
      setAuthLoading(false)
    }
  }, [])

  React.useEffect(() => {
    void refreshAuth()
  }, [refreshAuth])

  if (authLoading) {
    return (
      <div className="mx-auto flex min-h-screen max-w-2xl flex-col justify-center px-4 py-10">
        <p className="text-muted-foreground text-sm">Loading…</p>
      </div>
    )
  }

  if (authError) {
    return (
      <div className="mx-auto flex min-h-screen max-w-2xl flex-col justify-center gap-4 px-4 py-10">
        <Card>
          <CardHeader>
            <CardTitle>Auth unavailable</CardTitle>
          </CardHeader>
          <CardContent className="space-y-2">
            <p className="text-muted-foreground text-sm">{authError}</p>
            <p className="text-muted-foreground text-sm">
              Check <code>SUPABASE_SETUP.md</code> and set env vars from{" "}
              <code>supabase.env.example</code>.
            </p>
            <Button type="button" variant="outline" onClick={() => void refreshAuth()}>
              Retry
            </Button>
          </CardContent>
        </Card>
      </div>
    )
  }

  if (!user) return <AuthCard onAuthed={() => void refreshAuth()} />

  return (
    <div className="mx-auto flex min-h-screen max-w-2xl flex-col gap-6 px-4 py-10">
      <TodoApp userId={user.id} onSignedOut={() => void refreshAuth()} />
    </div>
  )
}

function TodoApp({ userId, onSignedOut }: { userId: string; onSignedOut: () => void }) {
  const [todos, setTodos] = React.useState<Todo[]>([])
  const [tasksLoading, setTasksLoading] = React.useState(true)
  const [tasksError, setTasksError] = React.useState<{ code?: string; message: string } | null>(
    null
  )
  const [attachTargetTodoId, setAttachTargetTodoId] = React.useState<string | null>(
    null
  )
  const [conflictDueAt, setConflictDueAt] = React.useState<string | null>(null)
  const clearConflictTimerRef = React.useRef<number | null>(null)
  const [focusMode, setFocusMode] = React.useState(false)
  const [nowMs, setNowMs] = React.useState(() => Date.now())
  const [inProgressTaskId, setInProgressTaskId] = React.useState<string | null>(null)
  const [dismissedReminderTaskId, setDismissedReminderTaskId] = React.useState<
    string | null
  >(null)
  const [filterMode, setFilterMode] = React.useState<"between" | "exact">("between")
  const [filterFromDate, setFilterFromDate] = React.useState<string>("")
  const [filterFromTime, setFilterFromTime] = React.useState<string>("")
  const [filterToDate, setFilterToDate] = React.useState<string>("")
  const [filterToTime, setFilterToTime] = React.useState<string>("")
  const [filterExactDate, setFilterExactDate] = React.useState<string>("")
  const [filterExactTime, setFilterExactTime] = React.useState<string>("")
  const fileInputRef = React.useRef<HTMLInputElement>(null)
  const [pageSize, setPageSize] = React.useState<number>(5)
  const [page, setPage] = React.useState<number>(1)

  React.useEffect(() => {
    let alive = true
    async function load() {
      setTasksLoading(true)
      if (!alive) return
      try {
        const data = await apiFetch<{ tasks: Todo[]; inProgressTaskId: string | null }>("/api/tasks")
        if (!alive) return
        setTodos(data.tasks)
        setInProgressTaskId(data.inProgressTaskId)
        setTasksError(null)
      } catch (e) {
        if (!alive) return
        if (e instanceof ApiError) setTasksError({ code: e.code, message: e.message })
        else setTasksError({ message: e instanceof Error ? e.message : "Failed to load tasks." })
        setTodos([])
        setInProgressTaskId(null)
      } finally {
        setTasksLoading(false)
      }
    }
    load()
    return () => {
      alive = false
    }
  }, [userId])

  // Keep "now" fresh so overdue/in-progress states stay accurate without user interaction.
  React.useEffect(() => {
    const id = window.setInterval(() => setNowMs(Date.now()), 30_000)
    return () => window.clearInterval(id)
  }, [])

  // Only one task can be "In Progress"; auto-clear if completed, deleted, or overdue.
  React.useEffect(() => {
    if (!inProgressTaskId) return
    const t = todos.find((x) => x.id === inProgressTaskId)
    if (!t || t.completed) {
      setInProgressTaskId(null)
      return
    }
  }, [inProgressTaskId, nowMs, todos])

  const nextUpcoming = React.useMemo(() => {
    const upcoming = todos
      .filter((t) => !t.completed)
      .map((t) => ({ todo: t, dueMs: parseLocalDateTime(t.dueAt) }))
      .filter((x) => x.dueMs >= nowMs)
      .sort((a, b) => a.dueMs - b.dueMs)[0]
    return upcoming ?? null
  }, [nowMs, todos])

  React.useEffect(() => {
    // If "next upcoming" changed, allow reminder again (dismiss is per-task).
    if (nextUpcoming && nextUpcoming.todo.id !== dismissedReminderTaskId) return
    if (!nextUpcoming) setDismissedReminderTaskId(null)
  }, [dismissedReminderTaskId, nextUpcoming])

  const reminder = React.useMemo(() => {
    const REMINDER_WINDOW_MIN = 15
    if (!nextUpcoming) return null
    if (dismissedReminderTaskId === nextUpcoming.todo.id) return null
    const mins = minutesUntil(nextUpcoming.dueMs, nowMs)
    if (mins < 0 || mins > REMINDER_WINDOW_MIN) return null
    return { ...nextUpcoming, mins }
  }, [dismissedReminderTaskId, nextUpcoming, nowMs])

  const form = useForm<TodoFormValues>({
    resolver: zodResolver(todoSchema),
    defaultValues: { title: "", description: "", dueAt: "" },
    mode: "onSubmit",
  })

  const summary = React.useMemo(() => {
    const now = new Date()
    const todayKey = localDateKey(now)
    const tomorrow = addDays(now, 1)
    const tomorrowKey = localDateKey(tomorrow)

    const todays = todos.filter((t) => t.dueAt.startsWith(todayKey))
    const todayCompleted = todays.filter((t) => t.completed).length
    const todayPending = todays.length - todayCompleted

    const labels = [
      "00:00–04:00",
      "04:00–08:00",
      "08:00–12:00",
      "12:00–16:00",
      "16:00–20:00",
      "20:00–24:00",
    ]

    // Tomorrow: same 4-hour windows breakdown
    const tomorrowTasks = todos.filter((t) => t.dueAt.startsWith(tomorrowKey))
    const tomorrowBuckets = Array.from({ length: 6 }, () => 0) as number[]
    for (const t of tomorrowTasks) {
      const ms = parseLocalDateTime(t.dueAt)
      const hour = new Date(ms).getHours()
      const idx = Math.floor(hour / 4)
      tomorrowBuckets[idx] = (tomorrowBuckets[idx] ?? 0) + 1
    }

    // Until next week = next 7 days starting tomorrow (local), grouped into 4-hour windows.
    const rangeStart = startOfDay(tomorrow).getTime()
    const rangeEnd = addDays(startOfDay(tomorrow), 7).getTime()
    const buckets = Array.from({ length: 6 }, () => 0) as number[]

    const upcoming = todos.filter((t) => {
      const ms = parseLocalDateTime(t.dueAt)
      return ms >= rangeStart && ms < rangeEnd
    })

    for (const t of upcoming) {
      const ms = parseLocalDateTime(t.dueAt)
      const hour = new Date(ms).getHours()
      const idx = Math.floor(hour / 4)
      buckets[idx] = (buckets[idx] ?? 0) + 1
    }

    return {
      todayCompleted,
      todayPending,
      tomorrowTotal: tomorrowTasks.length,
      tomorrowBuckets: labels.map((label, i) => ({ label, count: tomorrowBuckets[i] ?? 0 })),
      upcomingTotal: upcoming.length,
      upcomingBuckets: labels.map((label, i) => ({ label, count: buckets[i] ?? 0 })),
    }
  }, [todos])

  const loadDayKey = React.useMemo(() => {
    // Prefer an explicitly selected date from filters; otherwise use today.
    if (filterMode === "exact" && filterExactDate) return filterExactDate
    if (filterFromDate && !filterToDate) return filterFromDate
    if (filterFromDate && filterToDate && filterFromDate === filterToDate) return filterFromDate
    if (!filterFromDate && filterToDate) return filterToDate
    return localDateKey(new Date(nowMs))
  }, [filterExactDate, filterFromDate, filterMode, filterToDate, nowMs])

  const dailyLoad = React.useMemo(() => {
    const dayTodos = todos.filter((t) => getDatePart(t.dueAt) === loadDayKey)
    return getDailyLoad(dayTodos)
  }, [loadDayKey, todos])

  const filteredTodos = React.useMemo(() => {
    if (focusMode) {
      const endMs = nowMs + 4 * 60 * 60 * 1000
      const withMs = todos.map((t) => ({ ...t, _dueMs: parseLocalDateTime(t.dueAt) }))
      return withMs.filter((t) => t._dueMs >= nowMs && t._dueMs <= endMs)
    }

    const withMs = todos.map((t) => ({ ...t, _dueMs: parseLocalDateTime(t.dueAt) }))
    if (filterMode === "exact") {
      // If only date is selected -> show tasks for that date.
      // If time is selected too -> match exact date+time.
      // If only time is selected -> match time-of-day across all dates.
      if (!filterExactDate && !filterExactTime) return withMs

      if (filterExactDate && !filterExactTime) {
        return withMs.filter((t) => getDatePart(t.dueAt) === filterExactDate)
      }

      if (filterExactDate && filterExactTime) {
        const exactMs = parseLocalDateTime(`${filterExactDate}T${filterExactTime}`)
        return withMs.filter((t) => t._dueMs === exactMs)
      }

      // time only
      return withMs.filter((t) => getTimePart(t.dueAt) === filterExactTime)
    }
    // between
    const hasAnyDate = Boolean(filterFromDate || filterToDate)
    const hasAnyTime = Boolean(filterFromTime || filterToTime)

    // Date range (optional)
    const fromDateMs = filterFromDate
      ? startOfDay(parseLocalDateOnly(filterFromDate)).getTime()
      : Number.NEGATIVE_INFINITY
    const toDateMs = filterToDate
      ? endOfDay(parseLocalDateOnly(filterToDate)).getTime()
      : Number.POSITIVE_INFINITY

    // Time-of-day range (optional)
    const fromTimeMin = filterFromTime ? parseLocalTimeToMinutes(filterFromTime) : 0
    const toTimeMin = filterToTime ? parseLocalTimeToMinutes(filterToTime) : 24 * 60 - 1

    return withMs.filter((t) => {
      const ms = t._dueMs
      if (hasAnyDate && (ms < fromDateMs || ms > toDateMs)) return false

      if (hasAnyTime) {
        const time = getTimePart(t.dueAt)
        if (!time) return false
        const mins = parseLocalTimeToMinutes(time)
        // Simple (non-wrapping) range. If you want wrap-around (e.g. 22:00–02:00), tell me.
        if (mins < fromTimeMin || mins > toTimeMin) return false
      }

      // If neither date nor time selected, pass through (handled above anyway)
      return true
    })
  }, [
    todos,
    focusMode,
    nowMs,
    filterExactDate,
    filterExactTime,
    filterFromDate,
    filterFromTime,
    filterMode,
    filterToDate,
    filterToTime,
  ])

  const sortedFilteredTodos = React.useMemo(
    () =>
      filteredTodos
        .slice()
        .sort((a, b) => parseLocalDateTime(a.dueAt) - parseLocalDateTime(b.dueAt)),
    [filteredTodos]
  )

  // Clamp page when filters/pageSize change.
  React.useEffect(() => {
    const totalPages = Math.max(1, Math.ceil(sortedFilteredTodos.length / pageSize))
    setPage((p) => Math.min(Math.max(1, p), totalPages))
  }, [pageSize, sortedFilteredTodos.length])

  const totalItems = sortedFilteredTodos.length
  const totalPages = Math.max(1, Math.ceil(totalItems / pageSize))
  const showPagination = totalPages > 1

  const pageItems = React.useMemo(() => {
    const start = (page - 1) * pageSize
    return sortedFilteredTodos.slice(start, start + pageSize)
  }, [page, pageSize, sortedFilteredTodos])

  const groupedTodos = React.useMemo(() => {
    const groups: Array<{ date: string; items: typeof pageItems }> = []
    for (const t of pageItems) {
      const date = getDatePart(t.dueAt)
      const last = groups[groups.length - 1]
      if (!last || last.date !== date) groups.push({ date, items: [t] })
      else last.items.push(t)
    }
    return groups
  }, [pageItems])

  const completedCount = filteredTodos.filter((t) => t.completed).length

  async function addTodo(values: TodoFormValues) {
    const conflicts = todos.filter((t) => t.dueAt === values.dueAt)
    if (conflicts.length > 0) {
      setConflictDueAt(values.dueAt)
      if (clearConflictTimerRef.current) window.clearTimeout(clearConflictTimerRef.current)
      clearConflictTimerRef.current = window.setTimeout(() => {
        setConflictDueAt(null)
      }, 8000)

      // Make sure the user can see the conflicting tasks even if they were filtered out.
      const [d, time] = values.dueAt.split("T")
      setFilterMode("exact")
      setFilterExactDate(d ?? "")
      setFilterExactTime(time ?? "")
      setPage(1)

      toast.error("Time conflict", {
        description: `You already have ${conflicts.length} task(s) scheduled at ${formatLocalDateTime(
          values.dueAt
        )}.`,
      })
    }

    const { data, error } = await supabase
      .from("tasks")
      .insert(toDbTaskInsert(values, userId))
      .select("*")
      .single()
    if (error) {
      toast.error("Failed to add task", { description: error.message })
      return
    }

    setTodos((prev) => [fromDbTask(data as DbTaskRow), ...prev])
    form.reset()
  }

  async function toggleTodo(id: string, completed: boolean) {
    // optimistic
    setTodos((prev) =>
      prev.map((t) =>
        t.id === id ? { ...t, completed, attachments: t.attachments } : t
      )
    )
    if (completed) setInProgressTaskId((cur) => (cur === id ? null : cur))

    const update: { completed: boolean; in_progress?: boolean } = { completed }
    if (completed) update.in_progress = false

    const { error } = await supabase
      .from("tasks")
      .update(update)
      .eq("id", id)
      .eq("user_id", userId)
    if (error) {
      toast.error("Failed to update task", { description: error.message })
    }
  }

  function requestAttachmentsForTodo(todoId: string) {
    setAttachTargetTodoId(todoId)
    // Let state update before opening picker (some browsers are picky).
    queueMicrotask(() => fileInputRef.current?.click())
  }

  async function handleFilesPicked(e: React.ChangeEvent<HTMLInputElement>) {
    const files = Array.from(e.target.files ?? [])
    const targetId = attachTargetTodoId

    // reset input so picking the same file again triggers onChange
    e.target.value = ""
    setAttachTargetTodoId(null)

    if (!targetId || files.length === 0) return
    const targetTodo = todos.find((t) => t.id === targetId)
    if (!targetTodo) return

    const bucket = "task-attachments"
    const uploaded: Attachment[] = []

    for (const file of files) {
      const safeName = sanitizePathSegment(file.name)
      const path = `${userId}/${targetId}/${crypto.randomUUID()}-${safeName}`
      const { error } = await supabase.storage
        .from(bucket)
        .upload(path, file, { contentType: file.type, upsert: false })
      if (error) {
        toast.error("Upload failed", { description: error.message })
        continue
      }
      uploaded.push(buildAttachmentRecord(file, bucket, path))
    }

    if (uploaded.length === 0) return
    const nextAttachments = [...targetTodo.attachments, ...uploaded]

    // optimistic
    setTodos((prev) =>
      prev.map((t) => (t.id === targetId ? { ...t, attachments: nextAttachments } : t))
    )

    const { error } = await supabase
      .from("tasks")
      .update({ attachments: nextAttachments })
      .eq("id", targetId)
      .eq("user_id", userId)
    if (error) {
      toast.error("Failed to save attachments", { description: error.message })
    }
  }

  async function deleteTodo(id: string) {
    // optimistic
    setTodos((prev) => prev.filter((t) => t.id !== id))
    setInProgressTaskId((cur) => (cur === id ? null : cur))

    const { error } = await supabase.from("tasks").delete().eq("id", id).eq("user_id", userId)
    if (error) toast.error("Failed to delete task", { description: error.message })
  }

  async function setInProgress(taskId: string | null) {
    // optimistic
    setInProgressTaskId(taskId)

    // Clear any previous in-progress tasks first (enforces the single-task rule).
    const clearRes = await supabase
      .from("tasks")
      .update({ in_progress: false })
      .eq("user_id", userId)
      .eq("in_progress", true)
    if (clearRes.error) {
      toast.error("Failed to update in-progress", { description: clearRes.error.message })
      return
    }

    if (!taskId) return

    const setRes = await supabase
      .from("tasks")
      .update({ in_progress: true })
      .eq("id", taskId)
      .eq("user_id", userId)
    if (setRes.error) {
      toast.error("Failed to update in-progress", { description: setRes.error.message })
    }
  }

  async function downloadAttachment(a: Attachment) {
    const { data, error } = await supabase.storage.from(a.bucket).createSignedUrl(a.path, 60)
    if (error || !data?.signedUrl) {
      toast.error("Download failed", { description: error?.message ?? "Please try again." })
      return
    }
    window.open(data.signedUrl, "_blank", "noopener,noreferrer")
  }

  async function seedDemoTasks() {
    if (todos.length > 0) return
    const payload = initialTodos.map((t) => ({
      user_id: userId,
      title: t.title,
      description: t.description ?? null,
      due_at: t.dueAt,
      completed: t.completed,
      in_progress: false,
      attachments: [],
    }))
    const { data, error } = await supabase.from("tasks").insert(payload).select("*")
    if (error) {
      toast.error("Failed to seed demo tasks", { description: error.message })
      return
    }
    const rows = (data ?? []) as DbTaskRow[]
    setTodos(rows.map(fromDbTask))
  }

  async function clearCompleted() {
    const completedIds = new Set(todos.filter((t) => t.completed).map((t) => t.id))
    if (completedIds.size === 0) return

    // optimistic
    setTodos((prev) => prev.filter((t) => !completedIds.has(t.id)))

    const { error } = await supabase
      .from("tasks")
      .delete()
      .eq("user_id", userId)
      .eq("completed", true)
    if (error) toast.error("Failed to clear completed", { description: error.message })
  }

  return (
    <Card>
      <CardHeader className="flex flex-row items-center justify-between gap-4">
        <div className="space-y-1">
          <CardTitle className="text-2xl">To‑Do</CardTitle>
          <p className="text-muted-foreground text-sm">
            {completedCount}/{filteredTodos.length} completed
          </p>
        </div>
        <div className="flex items-center gap-2">
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <Button
                  type="button"
                  variant={focusMode ? "default" : "outline"}
                  size="sm"
                  onClick={() => {
                    setFocusMode((v) => !v)
                    setPage(1)
                  }}
                >
                  Focus Mode
                </Button>
              </TooltipTrigger>
              <TooltipContent>
                <p>Show tasks for the next 4 hours.</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
          <Button
            type="button"
            variant="outline"
            size="sm"
            onClick={async () => {
              await supabase.auth.signOut()
            }}
          >
            Sign out
          </Button>
          <ModeToggle />
        </div>
      </CardHeader>

      <CardContent className="space-y-6">
        {tasksLoading && (
          <p className="text-muted-foreground text-sm">Loading tasks…</p>
        )}

        {!tasksLoading && todos.length === 0 && (
          <div className="flex items-center justify-between gap-3 rounded-lg border bg-muted/20 px-3 py-2">
            <p className="text-muted-foreground text-sm">No tasks yet.</p>
            <Button type="button" variant="outline" size="sm" onClick={() => void seedDemoTasks()}>
              Seed demo tasks
            </Button>
          </div>
        )}

        <input
          ref={fileInputRef}
          type="file"
          multiple
          className="hidden"
          accept={[
            "image/*",
            "audio/*",
            "video/*",
            ".pdf",
            ".doc",
            ".docx",
            ".xls",
            ".xlsx",
            ".csv",
            ".txt",
            ".md",
            ".rtf",
          ].join(",")}
          onChange={handleFilesPicked}
        />

        {reminder && (
          <Alert className="border-primary/30 bg-primary/5">
            <Bell className="h-4 w-4" />
            <div className="flex flex-1 flex-col gap-1">
              <div className="flex flex-wrap items-center justify-between gap-2">
                <AlertTitle className="text-sm">
                  Next task starts in {reminder.mins} minute{reminder.mins === 1 ? "" : "s"}
                </AlertTitle>
                <Button
                  type="button"
                  variant="ghost"
                  size="sm"
                  onClick={() => setDismissedReminderTaskId(reminder.todo.id)}
                >
                  Dismiss
                </Button>
              </div>
              <AlertDescription className="text-sm">
                <span className="font-medium">{reminder.todo.title}</span> ·{" "}
                {formatDateTimeFromMs(reminder.dueMs)}
              </AlertDescription>
            </div>
          </Alert>
        )}

        <div className="rounded-xl border bg-card p-4">
          <div className="flex flex-wrap items-center justify-between gap-2">
            <p className="text-sm font-medium">
              Daily load{" "}
              <span className="text-muted-foreground font-normal">
                ({new Intl.DateTimeFormat(undefined, {
                  weekday: "short",
                  year: "numeric",
                  month: "short",
                  day: "2-digit",
                }).format(parseLocalDateOnly(loadDayKey))})
              </span>
            </p>
            <DailyLoadBadge load={dailyLoad.load} />
          </div>
          <p className="text-muted-foreground mt-2 text-sm">
            {dailyLoad.total} task(s) · busiest window {dailyLoad.busiestWindow} ({dailyLoad.peak})
          </p>
        </div>

        <div className="grid gap-3 sm:grid-cols-3">
          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Today’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">
              {summary.todayCompleted} completed
            </p>
            <p className="text-muted-foreground text-sm">{summary.todayPending} pending</p>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tomorrow’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">{summary.tomorrowTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.tomorrowBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tasks Until Next Week</p>
            <p className="mt-2 text-2xl font-semibold">{summary.upcomingTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.upcomingBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>
        </div>

        {focusMode && (
          <div className="flex flex-col gap-1 rounded-lg border bg-muted/20 px-3 py-2 sm:flex-row sm:items-center sm:justify-between">
            <p className="text-sm">
              <span className="font-medium">Focus Mode:</span>{" "}
              showing tasks due in the next 4 hours (until{" "}
              <span className="font-medium">
                {formatDateTimeFromMs(nowMs + 4 * 60 * 60 * 1000)}
              </span>
              )
            </p>
            <Button type="button" variant="ghost" size="sm" onClick={() => setFocusMode(false)}>
              Exit
            </Button>
          </div>
        )}

        <Form {...form}>
          <form
            onSubmit={form.handleSubmit(addTodo)}
            className="space-y-2"
            noValidate
          >
            <div className="flex flex-col gap-2 sm:flex-row">
              <FormField
                control={form.control}
                name="title"
                render={({ field }) => (
                  <FormItem className="flex-1">
                    <FormControl>
                      <Input
                        placeholder="Add a task…"
                        autoComplete="off"
                        {...field}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="dueAt"
                render={({ field }) => (
                  <FormItem className="sm:w-64">
                    <FormControl>
                      <Input type="datetime-local" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <Button type="submit">Add</Button>
            </div>

            <FormField
              control={form.control}
              name="description"
              render={({ field }) => (
                <FormItem>
                  <FormControl>
                    <Textarea
                      rows={3}
                      placeholder="Description (optional)…"
                      {...field}
                    />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />
          </form>
        </Form>

        <Separator />

        <div className="space-y-3">
          <div className="flex flex-wrap items-center justify-between gap-2">
            <p className="text-sm font-medium">Filter by date & time</p>
            <div className="flex items-center gap-2">
              <Button
                type="button"
                size="sm"
                variant={filterMode === "between" ? "default" : "outline"}
                onClick={() => setFilterMode("between")}
              >
                Between
              </Button>
              <Button
                type="button"
                size="sm"
                variant={filterMode === "exact" ? "default" : "outline"}
                onClick={() => setFilterMode("exact")}
              >
                Exact
              </Button>
              <Button
                type="button"
                size="sm"
                variant="ghost"
                onClick={() => {
                  setFilterFromDate("")
                  setFilterFromTime("")
                  setFilterToDate("")
                  setFilterToTime("")
                  setFilterExactDate("")
                  setFilterExactTime("")
                }}
              >
                Clear
              </Button>
            </div>
          </div>

          {filterMode === "between" ? (
            <div className="grid gap-2 sm:grid-cols-2">
              <div className="grid gap-2 sm:grid-cols-2">
                <Input
                  type="date"
                  value={filterFromDate}
                  onChange={(e) => setFilterFromDate(e.target.value)}
                />
                <Input
                  type="time"
                  value={filterFromTime}
                  onChange={(e) => setFilterFromTime(e.target.value)}
                />
              </div>
              <div className="grid gap-2 sm:grid-cols-2">
                <Input
                  type="date"
                  value={filterToDate}
                  onChange={(e) => setFilterToDate(e.target.value)}
                />
                <Input
                  type="time"
                  value={filterToTime}
                  onChange={(e) => setFilterToTime(e.target.value)}
                />
              </div>
            </div>
          ) : (
            <div className="grid gap-2 sm:grid-cols-2">
              <Input
                type="date"
                value={filterExactDate}
                onChange={(e) => setFilterExactDate(e.target.value)}
              />
              <Input
                type="time"
                value={filterExactTime}
                onChange={(e) => setFilterExactTime(e.target.value)}
              />
            </div>
          )}
        </div>

        <Separator />

        <div className="space-y-2">
          {groupedTodos.length === 0 ? (
            <p className="text-muted-foreground text-sm">No tasks yet.</p>
          ) : (
            groupedTodos.map((group) => (
              <div key={group.date} className="space-y-2">
                <div className="flex items-center gap-3 pt-2">
                  <Separator className="flex-1" />
                  <span className="text-muted-foreground whitespace-nowrap text-xs font-medium">
                    {new Intl.DateTimeFormat(undefined, {
                      weekday: "short",
                      year: "numeric",
                      month: "short",
                      day: "2-digit",
                    }).format(parseLocalDateOnly(group.date))}
                  </span>
                  <Separator className="flex-1" />
                </div>

                {group.items.map((todo) => {
                  const flags = getTaskFlags(todo, nowMs, inProgressTaskId)

                  return (
                    <div
                      key={todo.id}
                      className={cn(
                        "rounded-lg border px-3 py-2",
                        flags.completed && "opacity-75",
                        flags.overdue &&
                          "border-destructive/40 bg-destructive/5 text-muted-foreground",
                        flags.inProgress && "border-sky-500/40 bg-sky-500/10",
                        conflictDueAt &&
                          todo.dueAt === conflictDueAt &&
                          "border-destructive/60 bg-destructive/5 ring-1 ring-destructive/30"
                      )}
                    >
                      <div className="flex items-start justify-between gap-3">
                        <label className="flex cursor-pointer items-start gap-3">
                        <Checkbox
                          checked={todo.completed}
                          onCheckedChange={(v) => {
                            const next = Boolean(v)
                            toggleTodo(todo.id, next)
                            if (next && !todo.completed) {
                              requestAttachmentsForTodo(todo.id)
                            }
                          }}
                          aria-label={`Mark "${todo.title}" as ${
                            todo.completed ? "not completed" : "completed"
                          }`}
                          className="mt-0.5"
                        />
                        <span
                          className={cn(
                            "leading-6",
                            todo.completed && "text-muted-foreground line-through"
                          )}
                        >
                          <span className="flex flex-wrap items-center gap-2">
                            <span className="block">{todo.title}</span>
                              <span className="flex flex-wrap items-center gap-2">
                                <TaskBadges {...flags} />
                              </span>
                            {todo.description && (
                              <TooltipProvider>
                                <Tooltip>
                                  <TooltipTrigger asChild>
                                    <button
                                      type="button"
                                      className="text-muted-foreground hover:text-foreground inline-flex h-7 w-7 items-center justify-center rounded-md border bg-background"
                                      aria-label="View description"
                                    >
                                      <Info className="h-4 w-4" />
                                    </button>
                                  </TooltipTrigger>
                                  <TooltipContent className="max-w-xs">
                                    <p className="whitespace-pre-wrap text-sm">
                                      {todo.description}
                                    </p>
                                  </TooltipContent>
                                </Tooltip>
                              </TooltipProvider>
                            )}
                          </span>
                          <span className="text-muted-foreground block text-xs">
                            Due: {formatLocalDateTime(todo.dueAt)}
                          </span>
                        </span>
                      </label>

                      <div className="flex items-center gap-1">
                        {!todo.completed && (
                          <Button
                            type="button"
                            variant={flags.inProgress ? "default" : "outline"}
                            size="sm"
                            onClick={() => void setInProgress(flags.inProgress ? null : todo.id)}
                            className={cn(
                              flags.inProgress && "bg-sky-600 hover:bg-sky-600"
                            )}
                          >
                            {flags.inProgress ? (
                              <>
                                <CircleStop className="mr-1 h-4 w-4" />
                                Stop
                              </>
                            ) : (
                              <>
                                <CirclePlay className="mr-1 h-4 w-4" />
                                Start
                              </>
                            )}
                          </Button>
                        )}
                        {todo.completed && (
                          <Button
                            type="button"
                            variant="outline"
                            size="sm"
                            onClick={() => requestAttachmentsForTodo(todo.id)}
                          >
                            Add files
                          </Button>
                        )}
                        <Button
                          type="button"
                          variant="ghost"
                          size="icon"
                          aria-label={`Delete "${todo.title}"`}
                          onClick={() => deleteTodo(todo.id)}
                        >
                          <Trash2 className="h-4 w-4" />
                        </Button>
                      </div>
                    </div>

                    {todo.completed && todo.attachments.length > 0 && (
                      <div className="mt-3 space-y-2">
                        <p className="text-muted-foreground text-xs">Attachments</p>
                        <ul className="space-y-1">
                          {todo.attachments.map((a) => (
                            <li
                              key={a.id}
                              className="flex items-center justify-between gap-3 rounded-md bg-muted/30 px-2 py-1"
                            >
                              <div className="flex min-w-0 items-center gap-2">
                                <AttachmentIcon kind={a.kind} />
                                <span className="truncate text-sm">{a.name}</span>
                              </div>
                              <button
                                type="button"
                                onClick={() => void downloadAttachment(a)}
                                className="inline-flex items-center gap-1 text-sm font-medium underline underline-offset-4"
                              >
                                <Download className="h-4 w-4" />
                                Download
                              </button>
                            </li>
                          ))}
                        </ul>
                      </div>
                    )}
                  </div>
                  )
                })}
              </div>
            ))
          )}
        </div>

        {groupedTodos.length > 0 && (
          <div className="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
            <div className="flex items-center gap-2">
              <span className="text-muted-foreground text-sm">Items per page</span>
              <Select
                value={String(pageSize)}
                onValueChange={(v) => {
                  const next = Number(v)
                  setPageSize(next)
                  setPage(1)
                }}
              >
                <SelectTrigger className="w-[110px]">
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="5">5</SelectItem>
                  <SelectItem value="10">10</SelectItem>
                  <SelectItem value="15">15</SelectItem>
                  <SelectItem value="20">20</SelectItem>
                </SelectContent>
              </Select>
            </div>

            {showPagination && (
              <div className="flex items-center justify-between gap-3 sm:justify-end">
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={() => setPage((p) => Math.max(1, p - 1))}
                  disabled={page <= 1}
                >
                  Prev
                </Button>
                <span className="text-muted-foreground text-sm">
                  Page {page} of {totalPages}
                </span>
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={() => setPage((p) => Math.min(totalPages, p + 1))}
                  disabled={page >= totalPages}
                >
                  Next
                </Button>
              </div>
            )}
          </div>
        )}

        <div className="flex items-center justify-between gap-2">
          <Button
            type="button"
            variant="secondary"
            onClick={clearCompleted}
            disabled={completedCount === 0}
          >
            Clear completed
          </Button>
          <span className="text-muted-foreground text-sm">
            v 1.1.0
          </span>
    </div>
      </CardContent>
    </Card>
  )
}

```

```typescriptreact
"use client"

import { zodResolver } from "@hookform/resolvers/zod"
import {
  AlertTriangle,
  CirclePlay,
  CircleStop,
  CalendarClock,
  CheckCircle2,
  Download,
  File,
  FileSpreadsheet,
  FileText,
  Image as ImageIcon,
  Info,
  Music,
  Bell,
  Timer,
  Trash2,
  Video,
} from "lucide-react"
import * as React from "react"
import { useForm } from "react-hook-form"
import { toast } from "sonner"
import { z } from "zod"
// Supabase is accessed via Next.js API routes (see src/app/api/**). No direct client usage here.

import { ModeToggle } from "@/components/mode-toggle"
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert"
import { Badge } from "@/components/ui/badge"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Checkbox } from "@/components/ui/checkbox"
import { Form, FormControl, FormField, FormItem, FormMessage } from "@/components/ui/form"
import { Input } from "@/components/ui/input"
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select"
import { Separator } from "@/components/ui/separator"
import { Textarea } from "@/components/ui/textarea"
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip"
import { cn } from "@/lib/utils"
import { apiFetch, ApiError } from "@/lib/api-client"

type AttachmentKind =
  | "image"
  | "audio"
  | "video"
  | "pdf"
  | "spreadsheet"
  | "document"
  | "text"
  | "file"

type Attachment = {
  id: string
  name: string
  type: string
  size: number
  bucket: string
  path: string
  kind: AttachmentKind
}

type Todo = {
  id: string
  title: string
  description?: string
  completed: boolean
  // Stored as `datetime-local` string (YYYY-MM-DDTHH:mm) in local time.
  dueAt: string
  attachments: Attachment[]
}

type TaskState = "planned" | "in_progress" | "completed" | "overdue"
type DailyLoad = "light" | "balanced" | "heavy"

const todoSchema = z.object({
  title: z
    .string()
    .trim()
    .min(1, "Title is required.")
    .max(80, "Keep it under 80 characters."),
  description: z
    .string()
    .trim()
    .max(500, "Keep it under 500 characters.")
    .optional()
    .or(z.literal("")),
  dueAt: z
    .string()
    .min(1, "Due date & time is required.")
    .regex(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}$/, "Invalid date/time."),
})

type TodoFormValues = z.infer<typeof todoSchema>

const initialTodos: Todo[] = [
  {
    id: "1",
    title: "Create a Next.js app",
    description: "Scaffold with TypeScript + Tailwind and confirm it runs locally.",
    completed: true,
    dueAt: "2026-01-16T09:00",
    attachments: [],
  },
  {
    id: "2",
    title: "Add shadcn/ui + dark theme",
    description: "Initialize shadcn, set up theme provider, and verify dark mode.",
    completed: true,
    dueAt: "2026-01-16T10:30",
    attachments: [],
  },
  {
    id: "3",
    title: "Build a mock-data to-do list",
    completed: false,
    dueAt: "2026-01-16T15:00",
    attachments: [],
  },
  {
    id: "4",
    title: "Yesterday: review requirements",
    completed: true,
    dueAt: "2026-01-15T11:15",
    attachments: [],
  },
  {
    id: "5",
    title: "Yesterday: sketch UI layout",
    completed: true,
    dueAt: "2026-01-15T17:45",
    attachments: [],
  },
  {
    id: "6",
    title: "Today: add attachments support",
    completed: false,
    dueAt: "2026-01-16T18:20",
    attachments: [],
  },
  {
    id: "7",
    title: "Tomorrow: QA the filters",
    description: "Test date-only, time-only, exact, and between behaviors.",
    completed: false,
    dueAt: "2026-01-17T08:05",
    attachments: [],
  },
  {
    id: "8",
    title: "Tomorrow: polish summary cards",
    completed: false,
    dueAt: "2026-01-17T13:30",
    attachments: [],
  },
  {
    id: "9",
    title: "Tomorrow: write small UX notes",
    completed: false,
    dueAt: "2026-01-17T20:10",
    attachments: [],
  },
  {
    id: "10",
    title: "This weekend: add more mock tasks",
    completed: false,
    dueAt: "2026-01-18T10:00",
    attachments: [],
  },
  {
    id: "11",
    title: "This weekend: check time-only filter",
    completed: false,
    dueAt: "2026-01-18T22:15",
    attachments: [],
  },
  {
    id: "12",
    title: "Next week: sync with team",
    completed: false,
    dueAt: "2026-01-19T09:30",
    attachments: [],
  },
  {
    id: "13",
    title: "Next week: test date-only filter",
    completed: false,
    dueAt: "2026-01-20T14:05",
    attachments: [],
  },
  {
    id: "14",
    title: "Next week: test exact date+time filter",
    completed: false,
    dueAt: "2026-01-21T12:00",
    attachments: [],
  },
  {
    id: "15",
    title: "Next week: attach docs to completed tasks",
    completed: false,
    dueAt: "2026-01-22T16:40",
    attachments: [],
  },
  {
    id: "16",
    title: "Next week: final review",
    completed: false,
    dueAt: "2026-01-23T11:00",
    attachments: [],
  },
]

function parseLocalDateTime(value: string): number {
  // value: "YYYY-MM-DDTHH:mm"
  const [datePart, timePart] = value.split("T")
  const [y, m, d] = datePart.split("-").map(Number)
  const [hh, mm] = timePart.split(":").map(Number)
  return new Date(y, m - 1, d, hh, mm, 0, 0).getTime()
}

function pad2(n: number) {
  return String(n).padStart(2, "0")
}

function localDateKey(d: Date) {
  return `${d.getFullYear()}-${pad2(d.getMonth() + 1)}-${pad2(d.getDate())}`
}

function addDays(date: Date, days: number) {
  const d = new Date(date)
  d.setDate(d.getDate() + days)
  return d
}

function startOfDay(date: Date) {
  return new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0, 0)
}

function endOfDay(date: Date) {
  return new Date(
    date.getFullYear(),
    date.getMonth(),
    date.getDate(),
    23,
    59,
    59,
    999
  )
}

function getDatePart(dueAt: string) {
  return dueAt.split("T")[0] ?? ""
}

function getTimePart(dueAt: string) {
  return dueAt.split("T")[1] ?? ""
}

function parseLocalDateOnly(value: string): Date {
  // value: "YYYY-MM-DD"
  const [y, m, d] = value.split("-").map(Number)
  return new Date(y, m - 1, d, 0, 0, 0, 0)
}

function parseLocalTimeToMinutes(value: string): number {
  // value: "HH:mm"
  const [hh, mm] = value.split(":").map(Number)
  return hh * 60 + mm
}

function formatLocalDateTime(value: string): string {
  const ms = parseLocalDateTime(value)
  if (!Number.isFinite(ms)) return value
  return new Intl.DateTimeFormat(undefined, {
    year: "numeric",
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  }).format(new Date(ms))
}

function formatDateTimeFromMs(ms: number): string {
  return new Intl.DateTimeFormat(undefined, {
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  }).format(new Date(ms))
}

function minutesUntil(targetMs: number, nowMs: number) {
  return Math.ceil((targetMs - nowMs) / 60_000)
}

function getTaskFlags(todo: Todo, nowMs: number, inProgressTaskId: string | null) {
  const completed = todo.completed
  const dueMs = parseLocalDateTime(todo.dueAt)
  const overdue = !completed && dueMs < nowMs
  const inProgress = !completed && inProgressTaskId === todo.id
  const planned = !completed && !overdue && !inProgress
  return { completed, overdue, inProgress, planned }
}

function getDailyLoad(todosForDay: Todo[]) {
  // 4-hour windows across the day (local).
  const labels = [
    "00:00–04:00",
    "04:00–08:00",
    "08:00–12:00",
    "12:00–16:00",
    "16:00–20:00",
    "20:00–24:00",
  ]
  const buckets = Array.from({ length: 6 }, () => 0) as number[]
  for (const t of todosForDay) {
    const ms = parseLocalDateTime(t.dueAt)
    const hour = new Date(ms).getHours()
    const idx = Math.floor(hour / 4)
    buckets[idx] = (buckets[idx] ?? 0) + 1
  }

  const total = todosForDay.length
  const peak = Math.max(0, ...buckets)
  const spread = buckets.filter((c) => c > 0).length
  const busiestIdx = buckets.findIndex((c) => c === peak)
  const busiestWindow = busiestIdx >= 0 ? labels[busiestIdx] : labels[0]

  // Heuristic: more tasks + higher concentration in one window => heavier day.
  const score = total + peak * 1.5 + Math.max(0, spread - 1) * 0.5
  const load: DailyLoad = score <= 5 ? "light" : score <= 10 ? "balanced" : "heavy"

  return { load, total, peak, spread, busiestWindow }
}

function DailyLoadBadge({ load }: { load: DailyLoad }) {
  if (load === "heavy") return <Badge variant="destructive">Heavy</Badge>
  if (load === "balanced") return <Badge variant="secondary">Balanced</Badge>
  return <Badge variant="outline">Light</Badge>
}

function TaskBadges({
  completed,
  overdue,
  inProgress,
  planned,
}: {
  completed: boolean
  overdue: boolean
  inProgress: boolean
  planned: boolean
}) {
  if (completed) {
    return (
      <Badge className="gap-1 bg-emerald-600 text-white hover:bg-emerald-600">
        <CheckCircle2 className="h-3.5 w-3.5" />
        Completed
      </Badge>
    )
  }

  return (
    <>
      {inProgress && (
        <Badge className="gap-1 bg-sky-600 text-white hover:bg-sky-600">
          <Timer className="h-3.5 w-3.5 text-white" />
          In progress
        </Badge>
      )}
      {overdue && (
        <Badge variant="destructive" className="gap-1">
          <AlertTriangle className="h-3.5 w-3.5" />
          Overdue
        </Badge>
      )}
      {planned && (
        <Badge variant="outline" className="gap-1">
          <CalendarClock className="h-3.5 w-3.5" />
          Planned
        </Badge>
      )}
    </>
  )
}

function getAttachmentKind(file: File): AttachmentKind {
  const type = (file.type || "").toLowerCase()
  const name = file.name.toLowerCase()
  const ext = name.includes(".") ? name.split(".").pop() ?? "" : ""

  if (type.startsWith("image/")) return "image"
  if (type.startsWith("audio/")) return "audio"
  if (type.startsWith("video/")) return "video"

  if (ext === "pdf") return "pdf"
  if (["xls", "xlsx", "csv"].includes(ext)) return "spreadsheet"
  if (["doc", "docx"].includes(ext)) return "document"
  if (["txt", "md", "rtf"].includes(ext)) return "text"

  return "file"
}

function sanitizePathSegment(s: string) {
  return s.replace(/[^\w.\-]+/g, "_")
}

function buildAttachmentRecord(file: File, bucket: string, path: string): Attachment {
  return {
    id: crypto.randomUUID(),
    name: file.name,
    type: file.type,
    size: file.size,
    bucket,
    path,
    kind: getAttachmentKind(file),
  }
}

function AttachmentIcon({ kind }: { kind: AttachmentKind }) {
  const className = "h-4 w-4 text-muted-foreground"

  switch (kind) {
    case "image":
      return <ImageIcon className={className} />
    case "audio":
      return <Music className={className} />
    case "video":
      return <Video className={className} />
    case "spreadsheet":
      return <FileSpreadsheet className={className} />
    case "pdf":
    case "document":
    case "text":
      return <FileText className={className} />
    default:
      return <File className={className} />
  }
}

const authSchema = z.object({
  email: z.string().email("Enter a valid email."),
  password: z.string().min(6, "Password must be at least 6 characters."),
})
type AuthValues = z.infer<typeof authSchema>

function AuthCard({ onAuthed }: { onAuthed: () => void }) {
  const [mode, setMode] = React.useState<"sign_in" | "sign_up">("sign_in")
  const [busy, setBusy] = React.useState(false)

  const form = useForm<AuthValues>({
    resolver: zodResolver(authSchema),
    defaultValues: { email: "", password: "" },
  })

  async function onSubmit(values: AuthValues) {
    setBusy(true)
    try {
      if (mode === "sign_in") {
        await apiFetch("/api/auth/sign-in", {
          method: "POST",
          body: JSON.stringify(values),
        })
        onAuthed()
      } else {
        await apiFetch("/api/auth/sign-up", {
          method: "POST",
          body: JSON.stringify(values),
        })
        toast.success("Account created", {
          description: "You can now sign in (or confirm email if required).",
        })
        setMode("sign_in")
      }
    } catch (e) {
      toast.error("Authentication failed", {
        description: e instanceof Error ? e.message : "Please try again.",
      })
    } finally {
      setBusy(false)
    }
  }

  return (
    <div className="mx-auto flex min-h-screen max-w-md flex-col justify-center px-4 py-10">
      <Card>
        <CardHeader>
          <CardTitle className="text-2xl">Sign in</CardTitle>
          <p className="text-muted-foreground text-sm">
            {mode === "sign_in"
              ? "Use your email and password."
              : "Create an account with email and password."}
          </p>
        </CardHeader>
        <CardContent className="space-y-4">
          <Form {...form}>
            <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-3" noValidate>
              <FormField
                control={form.control}
                name="email"
                render={({ field }) => (
                  <FormItem>
                    <FormControl>
                      <Input placeholder="Email" autoComplete="email" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="password"
                render={({ field }) => (
                  <FormItem>
                    <FormControl>
                      <Input
                        type="password"
                        placeholder="Password"
                        autoComplete={
                          mode === "sign_in" ? "current-password" : "new-password"
                        }
                        {...field}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <Button type="submit" className="w-full" disabled={busy}>
                {mode === "sign_in" ? "Sign in" : "Sign up"}
              </Button>
            </form>
          </Form>

          <div className="flex items-center justify-between gap-3 text-sm">
            <span className="text-muted-foreground">
              {mode === "sign_in" ? "No account?" : "Already have an account?"}
            </span>
            <Button
              type="button"
              variant="link"
              className="px-0"
              onClick={() => setMode((m) => (m === "sign_in" ? "sign_up" : "sign_in"))}
            >
              {mode === "sign_in" ? "Sign up" : "Sign in"}
            </Button>
          </div>
        </CardContent>
      </Card>
    </div>
  )
}

export default function Home() {
  const [user, setUser] = React.useState<{ id: string; email?: string } | null>(null)
  const [authLoading, setAuthLoading] = React.useState(true)
  const [authError, setAuthError] = React.useState<string | null>(null)

  const refreshAuth = React.useCallback(async () => {
    setAuthLoading(true)
    try {
      const data = await apiFetch<{ user: { id: string; email?: string } | null }>("/api/auth/me")
      setUser(data.user)
      setAuthError(null)
    } catch (e) {
      setUser(null)
      setAuthError(e instanceof Error ? e.message : "Auth check failed.")
    } finally {
      setAuthLoading(false)
    }
  }, [])

  React.useEffect(() => {
    void refreshAuth()
  }, [refreshAuth])

  if (authLoading) {
    return (
      <div className="mx-auto flex min-h-screen max-w-2xl flex-col justify-center px-4 py-10">
        <p className="text-muted-foreground text-sm">Loading…</p>
      </div>
    )
  }

  if (authError) {
    return (
      <div className="mx-auto flex min-h-screen max-w-2xl flex-col justify-center gap-4 px-4 py-10">
        <Card>
          <CardHeader>
            <CardTitle>Auth unavailable</CardTitle>
          </CardHeader>
          <CardContent className="space-y-2">
            <p className="text-muted-foreground text-sm">{authError}</p>
            <p className="text-muted-foreground text-sm">
              Check <code>SUPABASE_SETUP.md</code> and set env vars from{" "}
              <code>supabase.env.example</code>.
            </p>
            <Button type="button" variant="outline" onClick={() => void refreshAuth()}>
              Retry
            </Button>
          </CardContent>
        </Card>
      </div>
    )
  }

  if (!user) return <AuthCard onAuthed={() => void refreshAuth()} />

  return (
    <div className="mx-auto flex min-h-screen max-w-2xl flex-col gap-6 px-4 py-10">
      <TodoApp userId={user.id} onSignedOut={() => void refreshAuth()} />
    </div>
  )
}

function TodoApp({ userId, onSignedOut }: { userId: string; onSignedOut: () => void }) {
  const [todos, setTodos] = React.useState<Todo[]>([])
  const [tasksLoading, setTasksLoading] = React.useState(true)
  const [tasksError, setTasksError] = React.useState<{ code?: string; message: string } | null>(
    null
  )
  const [attachTargetTodoId, setAttachTargetTodoId] = React.useState<string | null>(
    null
  )
  const [conflictDueAt, setConflictDueAt] = React.useState<string | null>(null)
  const clearConflictTimerRef = React.useRef<number | null>(null)
  const [focusMode, setFocusMode] = React.useState(false)
  const [nowMs, setNowMs] = React.useState(() => Date.now())
  const [inProgressTaskId, setInProgressTaskId] = React.useState<string | null>(null)
  const [dismissedReminderTaskId, setDismissedReminderTaskId] = React.useState<
    string | null
  >(null)
  const [filterMode, setFilterMode] = React.useState<"between" | "exact">("between")
  const [filterFromDate, setFilterFromDate] = React.useState<string>("")
  const [filterFromTime, setFilterFromTime] = React.useState<string>("")
  const [filterToDate, setFilterToDate] = React.useState<string>("")
  const [filterToTime, setFilterToTime] = React.useState<string>("")
  const [filterExactDate, setFilterExactDate] = React.useState<string>("")
  const [filterExactTime, setFilterExactTime] = React.useState<string>("")
  const fileInputRef = React.useRef<HTMLInputElement>(null)
  const [pageSize, setPageSize] = React.useState<number>(5)
  const [page, setPage] = React.useState<number>(1)

  React.useEffect(() => {
    let alive = true
    async function load() {
      setTasksLoading(true)
      if (!alive) return
      try {
        const data = await apiFetch<{ tasks: Todo[]; inProgressTaskId: string | null }>("/api/tasks")
        if (!alive) return
        setTodos(data.tasks)
        setInProgressTaskId(data.inProgressTaskId)
        setTasksError(null)
      } catch (e) {
        if (!alive) return
        if (e instanceof ApiError) setTasksError({ code: e.code, message: e.message })
        else setTasksError({ message: e instanceof Error ? e.message : "Failed to load tasks." })
        setTodos([])
        setInProgressTaskId(null)
      } finally {
        setTasksLoading(false)
      }
    }
    load()
    return () => {
      alive = false
    }
  }, [userId])

  // Keep "now" fresh so overdue/in-progress states stay accurate without user interaction.
  React.useEffect(() => {
    const id = window.setInterval(() => setNowMs(Date.now()), 30_000)
    return () => window.clearInterval(id)
  }, [])

  // Only one task can be "In Progress"; auto-clear if completed, deleted, or overdue.
  React.useEffect(() => {
    if (!inProgressTaskId) return
    const t = todos.find((x) => x.id === inProgressTaskId)
    if (!t || t.completed) {
      setInProgressTaskId(null)
      return
    }
  }, [inProgressTaskId, nowMs, todos])

  const nextUpcoming = React.useMemo(() => {
    const upcoming = todos
      .filter((t) => !t.completed)
      .map((t) => ({ todo: t, dueMs: parseLocalDateTime(t.dueAt) }))
      .filter((x) => x.dueMs >= nowMs)
      .sort((a, b) => a.dueMs - b.dueMs)[0]
    return upcoming ?? null
  }, [nowMs, todos])

  React.useEffect(() => {
    // If "next upcoming" changed, allow reminder again (dismiss is per-task).
    if (nextUpcoming && nextUpcoming.todo.id !== dismissedReminderTaskId) return
    if (!nextUpcoming) setDismissedReminderTaskId(null)
  }, [dismissedReminderTaskId, nextUpcoming])

  const reminder = React.useMemo(() => {
    const REMINDER_WINDOW_MIN = 15
    if (!nextUpcoming) return null
    if (dismissedReminderTaskId === nextUpcoming.todo.id) return null
    const mins = minutesUntil(nextUpcoming.dueMs, nowMs)
    if (mins < 0 || mins > REMINDER_WINDOW_MIN) return null
    return { ...nextUpcoming, mins }
  }, [dismissedReminderTaskId, nextUpcoming, nowMs])

  const form = useForm<TodoFormValues>({
    resolver: zodResolver(todoSchema),
    defaultValues: { title: "", description: "", dueAt: "" },
    mode: "onSubmit",
  })

  const summary = React.useMemo(() => {
    const now = new Date()
    const todayKey = localDateKey(now)
    const tomorrow = addDays(now, 1)
    const tomorrowKey = localDateKey(tomorrow)

    const todays = todos.filter((t) => t.dueAt.startsWith(todayKey))
    const todayCompleted = todays.filter((t) => t.completed).length
    const todayPending = todays.length - todayCompleted

    const labels = [
      "00:00–04:00",
      "04:00–08:00",
      "08:00–12:00",
      "12:00–16:00",
      "16:00–20:00",
      "20:00–24:00",
    ]

    // Tomorrow: same 4-hour windows breakdown
    const tomorrowTasks = todos.filter((t) => t.dueAt.startsWith(tomorrowKey))
    const tomorrowBuckets = Array.from({ length: 6 }, () => 0) as number[]
    for (const t of tomorrowTasks) {
      const ms = parseLocalDateTime(t.dueAt)
      const hour = new Date(ms).getHours()
      const idx = Math.floor(hour / 4)
      tomorrowBuckets[idx] = (tomorrowBuckets[idx] ?? 0) + 1
    }

    // Until next week = next 7 days starting tomorrow (local), grouped into 4-hour windows.
    const rangeStart = startOfDay(tomorrow).getTime()
    const rangeEnd = addDays(startOfDay(tomorrow), 7).getTime()
    const buckets = Array.from({ length: 6 }, () => 0) as number[]

    const upcoming = todos.filter((t) => {
      const ms = parseLocalDateTime(t.dueAt)
      return ms >= rangeStart && ms < rangeEnd
    })

    for (const t of upcoming) {
      const ms = parseLocalDateTime(t.dueAt)
      const hour = new Date(ms).getHours()
      const idx = Math.floor(hour / 4)
      buckets[idx] = (buckets[idx] ?? 0) + 1
    }

    return {
      todayCompleted,
      todayPending,
      tomorrowTotal: tomorrowTasks.length,
      tomorrowBuckets: labels.map((label, i) => ({ label, count: tomorrowBuckets[i] ?? 0 })),
      upcomingTotal: upcoming.length,
      upcomingBuckets: labels.map((label, i) => ({ label, count: buckets[i] ?? 0 })),
    }
  }, [todos])

  const loadDayKey = React.useMemo(() => {
    // Prefer an explicitly selected date from filters; otherwise use today.
    if (filterMode === "exact" && filterExactDate) return filterExactDate
    if (filterFromDate && !filterToDate) return filterFromDate
    if (filterFromDate && filterToDate && filterFromDate === filterToDate) return filterFromDate
    if (!filterFromDate && filterToDate) return filterToDate
    return localDateKey(new Date(nowMs))
  }, [filterExactDate, filterFromDate, filterMode, filterToDate, nowMs])

  const dailyLoad = React.useMemo(() => {
    const dayTodos = todos.filter((t) => getDatePart(t.dueAt) === loadDayKey)
    return getDailyLoad(dayTodos)
  }, [loadDayKey, todos])

  const filteredTodos = React.useMemo(() => {
    if (focusMode) {
      const endMs = nowMs + 4 * 60 * 60 * 1000
      const withMs = todos.map((t) => ({ ...t, _dueMs: parseLocalDateTime(t.dueAt) }))
      return withMs.filter((t) => t._dueMs >= nowMs && t._dueMs <= endMs)
    }

    const withMs = todos.map((t) => ({ ...t, _dueMs: parseLocalDateTime(t.dueAt) }))
    if (filterMode === "exact") {
      // If only date is selected -> show tasks for that date.
      // If time is selected too -> match exact date+time.
      // If only time is selected -> match time-of-day across all dates.
      if (!filterExactDate && !filterExactTime) return withMs

      if (filterExactDate && !filterExactTime) {
        return withMs.filter((t) => getDatePart(t.dueAt) === filterExactDate)
      }

      if (filterExactDate && filterExactTime) {
        const exactMs = parseLocalDateTime(`${filterExactDate}T${filterExactTime}`)
        return withMs.filter((t) => t._dueMs === exactMs)
      }

      // time only
      return withMs.filter((t) => getTimePart(t.dueAt) === filterExactTime)
    }
    // between
    const hasAnyDate = Boolean(filterFromDate || filterToDate)
    const hasAnyTime = Boolean(filterFromTime || filterToTime)

    // Date range (optional)
    const fromDateMs = filterFromDate
      ? startOfDay(parseLocalDateOnly(filterFromDate)).getTime()
      : Number.NEGATIVE_INFINITY
    const toDateMs = filterToDate
      ? endOfDay(parseLocalDateOnly(filterToDate)).getTime()
      : Number.POSITIVE_INFINITY

    // Time-of-day range (optional)
    const fromTimeMin = filterFromTime ? parseLocalTimeToMinutes(filterFromTime) : 0
    const toTimeMin = filterToTime ? parseLocalTimeToMinutes(filterToTime) : 24 * 60 - 1

    return withMs.filter((t) => {
      const ms = t._dueMs
      if (hasAnyDate && (ms < fromDateMs || ms > toDateMs)) return false

      if (hasAnyTime) {
        const time = getTimePart(t.dueAt)
        if (!time) return false
        const mins = parseLocalTimeToMinutes(time)
        // Simple (non-wrapping) range. If you want wrap-around (e.g. 22:00–02:00), tell me.
        if (mins < fromTimeMin || mins > toTimeMin) return false
      }

      // If neither date nor time selected, pass through (handled above anyway)
      return true
    })
  }, [
    todos,
    focusMode,
    nowMs,
    filterExactDate,
    filterExactTime,
    filterFromDate,
    filterFromTime,
    filterMode,
    filterToDate,
    filterToTime,
  ])

  const sortedFilteredTodos = React.useMemo(
    () =>
      filteredTodos
        .slice()
        .sort((a, b) => parseLocalDateTime(a.dueAt) - parseLocalDateTime(b.dueAt)),
    [filteredTodos]
  )

  // Clamp page when filters/pageSize change.
  React.useEffect(() => {
    const totalPages = Math.max(1, Math.ceil(sortedFilteredTodos.length / pageSize))
    setPage((p) => Math.min(Math.max(1, p), totalPages))
  }, [pageSize, sortedFilteredTodos.length])

  const totalItems = sortedFilteredTodos.length
  const totalPages = Math.max(1, Math.ceil(totalItems / pageSize))
  const showPagination = totalPages > 1

  const pageItems = React.useMemo(() => {
    const start = (page - 1) * pageSize
    return sortedFilteredTodos.slice(start, start + pageSize)
  }, [page, pageSize, sortedFilteredTodos])

  const groupedTodos = React.useMemo(() => {
    const groups: Array<{ date: string; items: typeof pageItems }> = []
    for (const t of pageItems) {
      const date = getDatePart(t.dueAt)
      const last = groups[groups.length - 1]
      if (!last || last.date !== date) groups.push({ date, items: [t] })
      else last.items.push(t)
    }
    return groups
  }, [pageItems])

  const completedCount = filteredTodos.filter((t) => t.completed).length

  async function addTodo(values: TodoFormValues) {
    const conflicts = todos.filter((t) => t.dueAt === values.dueAt)
    if (conflicts.length > 0) {
      setConflictDueAt(values.dueAt)
      if (clearConflictTimerRef.current) window.clearTimeout(clearConflictTimerRef.current)
      clearConflictTimerRef.current = window.setTimeout(() => {
        setConflictDueAt(null)
      }, 8000)

      // Make sure the user can see the conflicting tasks even if they were filtered out.
      const [d, time] = values.dueAt.split("T")
      setFilterMode("exact")
      setFilterExactDate(d ?? "")
      setFilterExactTime(time ?? "")
      setPage(1)

      toast.error("Time conflict", {
        description: `You already have ${conflicts.length} task(s) scheduled at ${formatLocalDateTime(
          values.dueAt
        )}.`,
      })
    }

    const { data, error } = await supabase
      .from("tasks")
      .insert(toDbTaskInsert(values, userId))
      .select("*")
      .single()
    if (error) {
      toast.error("Failed to add task", { description: error.message })
      return
    }

    setTodos((prev) => [fromDbTask(data as DbTaskRow), ...prev])
    form.reset()
  }

  async function toggleTodo(id: string, completed: boolean) {
    // optimistic
    setTodos((prev) =>
      prev.map((t) =>
        t.id === id ? { ...t, completed, attachments: t.attachments } : t
      )
    )
    if (completed) setInProgressTaskId((cur) => (cur === id ? null : cur))

    const update: { completed: boolean; in_progress?: boolean } = { completed }
    if (completed) update.in_progress = false

    const { error } = await supabase
      .from("tasks")
      .update(update)
      .eq("id", id)
      .eq("user_id", userId)
    if (error) {
      toast.error("Failed to update task", { description: error.message })
    }
  }

  function requestAttachmentsForTodo(todoId: string) {
    setAttachTargetTodoId(todoId)
    // Let state update before opening picker (some browsers are picky).
    queueMicrotask(() => fileInputRef.current?.click())
  }

  async function handleFilesPicked(e: React.ChangeEvent<HTMLInputElement>) {
    const files = Array.from(e.target.files ?? [])
    const targetId = attachTargetTodoId

    // reset input so picking the same file again triggers onChange
    e.target.value = ""
    setAttachTargetTodoId(null)

    if (!targetId || files.length === 0) return
    const targetTodo = todos.find((t) => t.id === targetId)
    if (!targetTodo) return

    const bucket = "task-attachments"
    const uploaded: Attachment[] = []

    for (const file of files) {
      const safeName = sanitizePathSegment(file.name)
      const path = `${userId}/${targetId}/${crypto.randomUUID()}-${safeName}`
      const { error } = await supabase.storage
        .from(bucket)
        .upload(path, file, { contentType: file.type, upsert: false })
      if (error) {
        toast.error("Upload failed", { description: error.message })
        continue
      }
      uploaded.push(buildAttachmentRecord(file, bucket, path))
    }

    if (uploaded.length === 0) return
    const nextAttachments = [...targetTodo.attachments, ...uploaded]

    // optimistic
    setTodos((prev) =>
      prev.map((t) => (t.id === targetId ? { ...t, attachments: nextAttachments } : t))
    )

    const { error } = await supabase
      .from("tasks")
      .update({ attachments: nextAttachments })
      .eq("id", targetId)
      .eq("user_id", userId)
    if (error) {
      toast.error("Failed to save attachments", { description: error.message })
    }
  }

  async function deleteTodo(id: string) {
    // optimistic
    setTodos((prev) => prev.filter((t) => t.id !== id))
    setInProgressTaskId((cur) => (cur === id ? null : cur))

    const { error } = await supabase.from("tasks").delete().eq("id", id).eq("user_id", userId)
    if (error) toast.error("Failed to delete task", { description: error.message })
  }

  async function setInProgress(taskId: string | null) {
    // optimistic
    setInProgressTaskId(taskId)

    // Clear any previous in-progress tasks first (enforces the single-task rule).
    const clearRes = await supabase
      .from("tasks")
      .update({ in_progress: false })
      .eq("user_id", userId)
      .eq("in_progress", true)
    if (clearRes.error) {
      toast.error("Failed to update in-progress", { description: clearRes.error.message })
      return
    }

    if (!taskId) return

    const setRes = await supabase
      .from("tasks")
      .update({ in_progress: true })
      .eq("id", taskId)
      .eq("user_id", userId)
    if (setRes.error) {
      toast.error("Failed to update in-progress", { description: setRes.error.message })
    }
  }

  async function downloadAttachment(a: Attachment) {
    const { data, error } = await supabase.storage.from(a.bucket).createSignedUrl(a.path, 60)
    if (error || !data?.signedUrl) {
      toast.error("Download failed", { description: error?.message ?? "Please try again." })
      return
    }
    window.open(data.signedUrl, "_blank", "noopener,noreferrer")
  }

  async function seedDemoTasks() {
    if (todos.length > 0) return
    const payload = initialTodos.map((t) => ({
      user_id: userId,
      title: t.title,
      description: t.description ?? null,
      due_at: t.dueAt,
      completed: t.completed,
      in_progress: false,
      attachments: [],
    }))
    const { data, error } = await supabase.from("tasks").insert(payload).select("*")
    if (error) {
      toast.error("Failed to seed demo tasks", { description: error.message })
      return
    }
    const rows = (data ?? []) as DbTaskRow[]
    setTodos(rows.map(fromDbTask))
  }

  async function clearCompleted() {
    const completedIds = new Set(todos.filter((t) => t.completed).map((t) => t.id))
    if (completedIds.size === 0) return

    // optimistic
    setTodos((prev) => prev.filter((t) => !completedIds.has(t.id)))

    const { error } = await supabase
      .from("tasks")
      .delete()
      .eq("user_id", userId)
      .eq("completed", true)
    if (error) toast.error("Failed to clear completed", { description: error.message })
  }

  return (
    <Card>
      <CardHeader className="flex flex-row items-center justify-between gap-4">
        <div className="space-y-1">
          <CardTitle className="text-2xl">To‑Do</CardTitle>
          <p className="text-muted-foreground text-sm">
            {completedCount}/{filteredTodos.length} completed
          </p>
        </div>
        <div className="flex items-center gap-2">
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <Button
                  type="button"
                  variant={focusMode ? "default" : "outline"}
                  size="sm"
                  onClick={() => {
                    setFocusMode((v) => !v)
                    setPage(1)
                  }}
                >
                  Focus Mode
                </Button>
              </TooltipTrigger>
              <TooltipContent>
                <p>Show tasks for the next 4 hours.</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
          <Button
            type="button"
            variant="outline"
            size="sm"
            onClick={async () => {
              await supabase.auth.signOut()
            }}
          >
            Sign out
          </Button>
          <ModeToggle />
        </div>
      </CardHeader>

      <CardContent className="space-y-6">
        {tasksLoading && (
          <p className="text-muted-foreground text-sm">Loading tasks…</p>
        )}

        {!tasksLoading && todos.length === 0 && (
          <div className="flex items-center justify-between gap-3 rounded-lg border bg-muted/20 px-3 py-2">
            <p className="text-muted-foreground text-sm">No tasks yet.</p>
            <Button type="button" variant="outline" size="sm" onClick={() => void seedDemoTasks()}>
              Seed demo tasks
            </Button>
          </div>
        )}

        <input
          ref={fileInputRef}
          type="file"
          multiple
          className="hidden"
          accept={[
            "image/*",
            "audio/*",
            "video/*",
            ".pdf",
            ".doc",
            ".docx",
            ".xls",
            ".xlsx",
            ".csv",
            ".txt",
            ".md",
            ".rtf",
          ].join(",")}
          onChange={handleFilesPicked}
        />

        {reminder && (
          <Alert className="border-primary/30 bg-primary/5">
            <Bell className="h-4 w-4" />
            <div className="flex flex-1 flex-col gap-1">
              <div className="flex flex-wrap items-center justify-between gap-2">
                <AlertTitle className="text-sm">
                  Next task starts in {reminder.mins} minute{reminder.mins === 1 ? "" : "s"}
                </AlertTitle>
                <Button
                  type="button"
                  variant="ghost"
                  size="sm"
                  onClick={() => setDismissedReminderTaskId(reminder.todo.id)}
                >
                  Dismiss
                </Button>
              </div>
              <AlertDescription className="text-sm">
                <span className="font-medium">{reminder.todo.title}</span> ·{" "}
                {formatDateTimeFromMs(reminder.dueMs)}
              </AlertDescription>
            </div>
          </Alert>
        )}

        <div className="rounded-xl border bg-card p-4">
          <div className="flex flex-wrap items-center justify-between gap-2">
            <p className="text-sm font-medium">
              Daily load{" "}
              <span className="text-muted-foreground font-normal">
                ({new Intl.DateTimeFormat(undefined, {
                  weekday: "short",
                  year: "numeric",
                  month: "short",
                  day: "2-digit",
                }).format(parseLocalDateOnly(loadDayKey))})
              </span>
            </p>
            <DailyLoadBadge load={dailyLoad.load} />
          </div>
          <p className="text-muted-foreground mt-2 text-sm">
            {dailyLoad.total} task(s) · busiest window {dailyLoad.busiestWindow} ({dailyLoad.peak})
          </p>
        </div>

        <div className="grid gap-3 sm:grid-cols-3">
          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Today’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">
              {summary.todayCompleted} completed
            </p>
            <p className="text-muted-foreground text-sm">{summary.todayPending} pending</p>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tomorrow’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">{summary.tomorrowTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.tomorrowBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tasks Until Next Week</p>
            <p className="mt-2 text-2xl font-semibold">{summary.upcomingTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.upcomingBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>
        </div>

        {focusMode && (
          <div className="flex flex-col gap-1 rounded-lg border bg-muted/20 px-3 py-2 sm:flex-row sm:items-center sm:justify-between">
            <p className="text-sm">
              <span className="font-medium">Focus Mode:</span>{" "}
              showing tasks due in the next 4 hours (until{" "}
              <span className="font-medium">
                {formatDateTimeFromMs(nowMs + 4 * 60 * 60 * 1000)}
              </span>
              )
            </p>
            <Button type="button" variant="ghost" size="sm" onClick={() => setFocusMode(false)}>
              Exit
            </Button>
          </div>
        )}

        <Form {...form}>
          <form
            onSubmit={form.handleSubmit(addTodo)}
            className="space-y-2"
            noValidate
          >
            <div className="flex flex-col gap-2 sm:flex-row">
              <FormField
                control={form.control}
                name="title"
                render={({ field }) => (
                  <FormItem className="flex-1">
                    <FormControl>
                      <Input
                        placeholder="Add a task…"
                        autoComplete="off"
                        {...field}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="dueAt"
                render={({ field }) => (
                  <FormItem className="sm:w-64">
                    <FormControl>
                      <Input type="datetime-local" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <Button type="submit">Add</Button>
            </div>

            <FormField
              control={form.control}
              name="description"
              render={({ field }) => (
                <FormItem>
                  <FormControl>
                    <Textarea
                      rows={3}
                      placeholder="Description (optional)…"
                      {...field}
                    />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />
          </form>
        </Form>

        <Separator />

        <div className="space-y-3">
          <div className="flex flex-wrap items-center justify-between gap-2">
            <p className="text-sm font-medium">Filter by date & time</p>
            <div className="flex items-center gap-2">
              <Button
                type="button"
                size="sm"
                variant={filterMode === "between" ? "default" : "outline"}
                onClick={() => setFilterMode("between")}
              >
                Between
              </Button>
              <Button
                type="button"
                size="sm"
                variant={filterMode === "exact" ? "default" : "outline"}
                onClick={() => setFilterMode("exact")}
              >
                Exact
              </Button>
              <Button
                type="button"
                size="sm"
                variant="ghost"
                onClick={() => {
                  setFilterFromDate("")
                  setFilterFromTime("")
                  setFilterToDate("")
                  setFilterToTime("")
                  setFilterExactDate("")
                  setFilterExactTime("")
                }}
              >
                Clear
              </Button>
            </div>
          </div>

          {filterMode === "between" ? (
            <div className="grid gap-2 sm:grid-cols-2">
              <div className="grid gap-2 sm:grid-cols-2">
                <Input
                  type="date"
                  value={filterFromDate}
                  onChange={(e) => setFilterFromDate(e.target.value)}
                />
                <Input
                  type="time"
                  value={filterFromTime}
                  onChange={(e) => setFilterFromTime(e.target.value)}
                />
              </div>
              <div className="grid gap-2 sm:grid-cols-2">
                <Input
                  type="date"
                  value={filterToDate}
                  onChange={(e) => setFilterToDate(e.target.value)}
                />
                <Input
                  type="time"
                  value={filterToTime}
                  onChange={(e) => setFilterToTime(e.target.value)}
                />
              </div>
            </div>
          ) : (
            <div className="grid gap-2 sm:grid-cols-2">
              <Input
                type="date"
                value={filterExactDate}
                onChange={(e) => setFilterExactDate(e.target.value)}
              />
              <Input
                type="time"
                value={filterExactTime}
                onChange={(e) => setFilterExactTime(e.target.value)}
              />
            </div>
          )}
        </div>

        <Separator />

        <div className="space-y-2">
          {groupedTodos.length === 0 ? (
            <p className="text-muted-foreground text-sm">No tasks yet.</p>
          ) : (
            groupedTodos.map((group) => (
              <div key={group.date} className="space-y-2">
                <div className="flex items-center gap-3 pt-2">
                  <Separator className="flex-1" />
                  <span className="text-muted-foreground whitespace-nowrap text-xs font-medium">
                    {new Intl.DateTimeFormat(undefined, {
                      weekday: "short",
                      year: "numeric",
                      month: "short",
                      day: "2-digit",
                    }).format(parseLocalDateOnly(group.date))}
                  </span>
                  <Separator className="flex-1" />
                </div>

                {group.items.map((todo) => {
                  const flags = getTaskFlags(todo, nowMs, inProgressTaskId)

                  return (
                    <div
                      key={todo.id}
                      className={cn(
                        "rounded-lg border px-3 py-2",
                        flags.completed && "opacity-75",
                        flags.overdue &&
                          "border-destructive/40 bg-destructive/5 text-muted-foreground",
                        flags.inProgress && "border-sky-500/40 bg-sky-500/10",
                        conflictDueAt &&
                          todo.dueAt === conflictDueAt &&
                          "border-destructive/60 bg-destructive/5 ring-1 ring-destructive/30"
                      )}
                    >
                      <div className="flex items-start justify-between gap-3">
                        <label className="flex cursor-pointer items-start gap-3">
                        <Checkbox
                          checked={todo.completed}
                          onCheckedChange={(v) => {
                            const next = Boolean(v)
                            toggleTodo(todo.id, next)
                            if (next && !todo.completed) {
                              requestAttachmentsForTodo(todo.id)
                            }
                          }}
                          aria-label={`Mark "${todo.title}" as ${
                            todo.completed ? "not completed" : "completed"
                          }`}
                          className="mt-0.5"
                        />
                        <span
                          className={cn(
                            "leading-6",
                            todo.completed && "text-muted-foreground line-through"
                          )}
                        >
                          <span className="flex flex-wrap items-center gap-2">
                            <span className="block">{todo.title}</span>
                              <span className="flex flex-wrap items-center gap-2">
                                <TaskBadges {...flags} />
                              </span>
                            {todo.description && (
                              <TooltipProvider>
                                <Tooltip>
                                  <TooltipTrigger asChild>
                                    <button
                                      type="button"
                                      className="text-muted-foreground hover:text-foreground inline-flex h-7 w-7 items-center justify-center rounded-md border bg-background"
                                      aria-label="View description"
                                    >
                                      <Info className="h-4 w-4" />
                                    </button>
                                  </TooltipTrigger>
                                  <TooltipContent className="max-w-xs">
                                    <p className="whitespace-pre-wrap text-sm">
                                      {todo.description}
                                    </p>
                                  </TooltipContent>
                                </Tooltip>
                              </TooltipProvider>
                            )}
                          </span>
                          <span className="text-muted-foreground block text-xs">
                            Due: {formatLocalDateTime(todo.dueAt)}
                          </span>
                        </span>
                      </label>

                      <div className="flex items-center gap-1">
                        {!todo.completed && (
                          <Button
                            type="button"
                            variant={flags.inProgress ? "default" : "outline"}
                            size="sm"
                            onClick={() => void setInProgress(flags.inProgress ? null : todo.id)}
                            className={cn(
                              flags.inProgress && "bg-sky-600 hover:bg-sky-600"
                            )}
                          >
                            {flags.inProgress ? (
                              <>
                                <CircleStop className="mr-1 h-4 w-4" />
                                Stop
                              </>
                            ) : (
                              <>
                                <CirclePlay className="mr-1 h-4 w-4" />
                                Start
                              </>
                            )}
                          </Button>
                        )}
                        {todo.completed && (
                          <Button
                            type="button"
                            variant="outline"
                            size="sm"
                            onClick={() => requestAttachmentsForTodo(todo.id)}
                          >
                            Add files
                          </Button>
                        )}
                        <Button
                          type="button"
                          variant="ghost"
                          size="icon"
                          aria-label={`Delete "${todo.title}"`}
                          onClick={() => deleteTodo(todo.id)}
                        >
                          <Trash2 className="h-4 w-4" />
                        </Button>
                      </div>
                    </div>

                    {todo.completed && todo.attachments.length > 0 && (
                      <div className="mt-3 space-y-2">
                        <p className="text-muted-foreground text-xs">Attachments</p>
                        <ul className="space-y-1">
                          {todo.attachments.map((a) => (
                            <li
                              key={a.id}
                              className="flex items-center justify-between gap-3 rounded-md bg-muted/30 px-2 py-1"
                            >
                              <div className="flex min-w-0 items-center gap-2">
                                <AttachmentIcon kind={a.kind} />
                                <span className="truncate text-sm">{a.name}</span>
                              </div>
                              <button
                                type="button"
                                onClick={() => void downloadAttachment(a)}
                                className="inline-flex items-center gap-1 text-sm font-medium underline underline-offset-4"
                              >
                                <Download className="h-4 w-4" />
                                Download
                              </button>
                            </li>
                          ))}
                        </ul>
                      </div>
                    )}
                  </div>
                  )
                })}
              </div>
            ))
          )}
        </div>

        {groupedTodos.length > 0 && (
          <div className="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
            <div className="flex items-center gap-2">
              <span className="text-muted-foreground text-sm">Items per page</span>
              <Select
                value={String(pageSize)}
                onValueChange={(v) => {
                  const next = Number(v)
                  setPageSize(next)
                  setPage(1)
                }}
              >
                <SelectTrigger className="w-[110px]">
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="5">5</SelectItem>
                  <SelectItem value="10">10</SelectItem>
                  <SelectItem value="15">15</SelectItem>
                  <SelectItem value="20">20</SelectItem>
                </SelectContent>
              </Select>
            </div>

            {showPagination && (
              <div className="flex items-center justify-between gap-3 sm:justify-end">
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={() => setPage((p) => Math.max(1, p - 1))}
                  disabled={page <= 1}
                >
                  Prev
                </Button>
                <span className="text-muted-foreground text-sm">
                  Page {page} of {totalPages}
                </span>
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={() => setPage((p) => Math.min(totalPages, p + 1))}
                  disabled={page >= totalPages}
                >
                  Next
                </Button>
              </div>
            )}
          </div>
        )}

        <div className="flex items-center justify-between gap-2">
          <Button
            type="button"
            variant="secondary"
            onClick={clearCompleted}
            disabled={completedCount === 0}
          >
            Clear completed
          </Button>
          <span className="text-muted-foreground text-sm">
            v 1.1.0
          </span>
    </div>
      </CardContent>
    </Card>
  )
}

```

```typescriptreact
"use client"

import { zodResolver } from "@hookform/resolvers/zod"
import {
  AlertTriangle,
  CirclePlay,
  CircleStop,
  CalendarClock,
  CheckCircle2,
  Download,
  File,
  FileSpreadsheet,
  FileText,
  Image as ImageIcon,
  Info,
  Music,
  Bell,
  Timer,
  Trash2,
  Video,
} from "lucide-react"
import * as React from "react"
import { useForm } from "react-hook-form"
import { toast } from "sonner"
import { z } from "zod"
// Supabase is accessed via Next.js API routes (see src/app/api/**). No direct client usage here.

import { ModeToggle } from "@/components/mode-toggle"
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert"
import { Badge } from "@/components/ui/badge"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Checkbox } from "@/components/ui/checkbox"
import { Form, FormControl, FormField, FormItem, FormMessage } from "@/components/ui/form"
import { Input } from "@/components/ui/input"
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select"
import { Separator } from "@/components/ui/separator"
import { Textarea } from "@/components/ui/textarea"
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip"
import { cn } from "@/lib/utils"
import { apiFetch, ApiError } from "@/lib/api-client"

type AttachmentKind =
  | "image"
  | "audio"
  | "video"
  | "pdf"
  | "spreadsheet"
  | "document"
  | "text"
  | "file"

type Attachment = {
  id: string
  name: string
  type: string
  size: number
  bucket: string
  path: string
  kind: AttachmentKind
}

type Todo = {
  id: string
  title: string
  description?: string
  completed: boolean
  // Stored as `datetime-local` string (YYYY-MM-DDTHH:mm) in local time.
  dueAt: string
  attachments: Attachment[]
}

type TaskState = "planned" | "in_progress" | "completed" | "overdue"
type DailyLoad = "light" | "balanced" | "heavy"

const todoSchema = z.object({
  title: z
    .string()
    .trim()
    .min(1, "Title is required.")
    .max(80, "Keep it under 80 characters."),
  description: z
    .string()
    .trim()
    .max(500, "Keep it under 500 characters.")
    .optional()
    .or(z.literal("")),
  dueAt: z
    .string()
    .min(1, "Due date & time is required.")
    .regex(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}$/, "Invalid date/time."),
})

type TodoFormValues = z.infer<typeof todoSchema>

const initialTodos: Todo[] = [
  {
    id: "1",
    title: "Create a Next.js app",
    description: "Scaffold with TypeScript + Tailwind and confirm it runs locally.",
    completed: true,
    dueAt: "2026-01-16T09:00",
    attachments: [],
  },
  {
    id: "2",
    title: "Add shadcn/ui + dark theme",
    description: "Initialize shadcn, set up theme provider, and verify dark mode.",
    completed: true,
    dueAt: "2026-01-16T10:30",
    attachments: [],
  },
  {
    id: "3",
    title: "Build a mock-data to-do list",
    completed: false,
    dueAt: "2026-01-16T15:00",
    attachments: [],
  },
  {
    id: "4",
    title: "Yesterday: review requirements",
    completed: true,
    dueAt: "2026-01-15T11:15",
    attachments: [],
  },
  {
    id: "5",
    title: "Yesterday: sketch UI layout",
    completed: true,
    dueAt: "2026-01-15T17:45",
    attachments: [],
  },
  {
    id: "6",
    title: "Today: add attachments support",
    completed: false,
    dueAt: "2026-01-16T18:20",
    attachments: [],
  },
  {
    id: "7",
    title: "Tomorrow: QA the filters",
    description: "Test date-only, time-only, exact, and between behaviors.",
    completed: false,
    dueAt: "2026-01-17T08:05",
    attachments: [],
  },
  {
    id: "8",
    title: "Tomorrow: polish summary cards",
    completed: false,
    dueAt: "2026-01-17T13:30",
    attachments: [],
  },
  {
    id: "9",
    title: "Tomorrow: write small UX notes",
    completed: false,
    dueAt: "2026-01-17T20:10",
    attachments: [],
  },
  {
    id: "10",
    title: "This weekend: add more mock tasks",
    completed: false,
    dueAt: "2026-01-18T10:00",
    attachments: [],
  },
  {
    id: "11",
    title: "This weekend: check time-only filter",
    completed: false,
    dueAt: "2026-01-18T22:15",
    attachments: [],
  },
  {
    id: "12",
    title: "Next week: sync with team",
    completed: false,
    dueAt: "2026-01-19T09:30",
    attachments: [],
  },
  {
    id: "13",
    title: "Next week: test date-only filter",
    completed: false,
    dueAt: "2026-01-20T14:05",
    attachments: [],
  },
  {
    id: "14",
    title: "Next week: test exact date+time filter",
    completed: false,
    dueAt: "2026-01-21T12:00",
    attachments: [],
  },
  {
    id: "15",
    title: "Next week: attach docs to completed tasks",
    completed: false,
    dueAt: "2026-01-22T16:40",
    attachments: [],
  },
  {
    id: "16",
    title: "Next week: final review",
    completed: false,
    dueAt: "2026-01-23T11:00",
    attachments: [],
  },
]

function parseLocalDateTime(value: string): number {
  // value: "YYYY-MM-DDTHH:mm"
  const [datePart, timePart] = value.split("T")
  const [y, m, d] = datePart.split("-").map(Number)
  const [hh, mm] = timePart.split(":").map(Number)
  return new Date(y, m - 1, d, hh, mm, 0, 0).getTime()
}

function pad2(n: number) {
  return String(n).padStart(2, "0")
}

function localDateKey(d: Date) {
  return `${d.getFullYear()}-${pad2(d.getMonth() + 1)}-${pad2(d.getDate())}`
}

function addDays(date: Date, days: number) {
  const d = new Date(date)
  d.setDate(d.getDate() + days)
  return d
}

function startOfDay(date: Date) {
  return new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0, 0)
}

function endOfDay(date: Date) {
  return new Date(
    date.getFullYear(),
    date.getMonth(),
    date.getDate(),
    23,
    59,
    59,
    999
  )
}

function getDatePart(dueAt: string) {
  return dueAt.split("T")[0] ?? ""
}

function getTimePart(dueAt: string) {
  return dueAt.split("T")[1] ?? ""
}

function parseLocalDateOnly(value: string): Date {
  // value: "YYYY-MM-DD"
  const [y, m, d] = value.split("-").map(Number)
  return new Date(y, m - 1, d, 0, 0, 0, 0)
}

function parseLocalTimeToMinutes(value: string): number {
  // value: "HH:mm"
  const [hh, mm] = value.split(":").map(Number)
  return hh * 60 + mm
}

function formatLocalDateTime(value: string): string {
  const ms = parseLocalDateTime(value)
  if (!Number.isFinite(ms)) return value
  return new Intl.DateTimeFormat(undefined, {
    year: "numeric",
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  }).format(new Date(ms))
}

function formatDateTimeFromMs(ms: number): string {
  return new Intl.DateTimeFormat(undefined, {
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  }).format(new Date(ms))
}

function minutesUntil(targetMs: number, nowMs: number) {
  return Math.ceil((targetMs - nowMs) / 60_000)
}

function getTaskFlags(todo: Todo, nowMs: number, inProgressTaskId: string | null) {
  const completed = todo.completed
  const dueMs = parseLocalDateTime(todo.dueAt)
  const overdue = !completed && dueMs < nowMs
  const inProgress = !completed && inProgressTaskId === todo.id
  const planned = !completed && !overdue && !inProgress
  return { completed, overdue, inProgress, planned }
}

function getDailyLoad(todosForDay: Todo[]) {
  // 4-hour windows across the day (local).
  const labels = [
    "00:00–04:00",
    "04:00–08:00",
    "08:00–12:00",
    "12:00–16:00",
    "16:00–20:00",
    "20:00–24:00",
  ]
  const buckets = Array.from({ length: 6 }, () => 0) as number[]
  for (const t of todosForDay) {
    const ms = parseLocalDateTime(t.dueAt)
    const hour = new Date(ms).getHours()
    const idx = Math.floor(hour / 4)
    buckets[idx] = (buckets[idx] ?? 0) + 1
  }

  const total = todosForDay.length
  const peak = Math.max(0, ...buckets)
  const spread = buckets.filter((c) => c > 0).length
  const busiestIdx = buckets.findIndex((c) => c === peak)
  const busiestWindow = busiestIdx >= 0 ? labels[busiestIdx] : labels[0]

  // Heuristic: more tasks + higher concentration in one window => heavier day.
  const score = total + peak * 1.5 + Math.max(0, spread - 1) * 0.5
  const load: DailyLoad = score <= 5 ? "light" : score <= 10 ? "balanced" : "heavy"

  return { load, total, peak, spread, busiestWindow }
}

function DailyLoadBadge({ load }: { load: DailyLoad }) {
  if (load === "heavy") return <Badge variant="destructive">Heavy</Badge>
  if (load === "balanced") return <Badge variant="secondary">Balanced</Badge>
  return <Badge variant="outline">Light</Badge>
}

function TaskBadges({
  completed,
  overdue,
  inProgress,
  planned,
}: {
  completed: boolean
  overdue: boolean
  inProgress: boolean
  planned: boolean
}) {
  if (completed) {
    return (
      <Badge className="gap-1 bg-emerald-600 text-white hover:bg-emerald-600">
        <CheckCircle2 className="h-3.5 w-3.5" />
        Completed
      </Badge>
    )
  }

  return (
    <>
      {inProgress && (
        <Badge className="gap-1 bg-sky-600 text-white hover:bg-sky-600">
          <Timer className="h-3.5 w-3.5 text-white" />
          In progress
        </Badge>
      )}
      {overdue && (
        <Badge variant="destructive" className="gap-1">
          <AlertTriangle className="h-3.5 w-3.5" />
          Overdue
        </Badge>
      )}
      {planned && (
        <Badge variant="outline" className="gap-1">
          <CalendarClock className="h-3.5 w-3.5" />
          Planned
        </Badge>
      )}
    </>
  )
}

function getAttachmentKind(file: File): AttachmentKind {
  const type = (file.type || "").toLowerCase()
  const name = file.name.toLowerCase()
  const ext = name.includes(".") ? name.split(".").pop() ?? "" : ""

  if (type.startsWith("image/")) return "image"
  if (type.startsWith("audio/")) return "audio"
  if (type.startsWith("video/")) return "video"

  if (ext === "pdf") return "pdf"
  if (["xls", "xlsx", "csv"].includes(ext)) return "spreadsheet"
  if (["doc", "docx"].includes(ext)) return "document"
  if (["txt", "md", "rtf"].includes(ext)) return "text"

  return "file"
}

function sanitizePathSegment(s: string) {
  return s.replace(/[^\w.\-]+/g, "_")
}

function buildAttachmentRecord(file: File, bucket: string, path: string): Attachment {
  return {
    id: crypto.randomUUID(),
    name: file.name,
    type: file.type,
    size: file.size,
    bucket,
    path,
    kind: getAttachmentKind(file),
  }
}

function AttachmentIcon({ kind }: { kind: AttachmentKind }) {
  const className = "h-4 w-4 text-muted-foreground"

  switch (kind) {
    case "image":
      return <ImageIcon className={className} />
    case "audio":
      return <Music className={className} />
    case "video":
      return <Video className={className} />
    case "spreadsheet":
      return <FileSpreadsheet className={className} />
    case "pdf":
    case "document":
    case "text":
      return <FileText className={className} />
    default:
      return <File className={className} />
  }
}

const authSchema = z.object({
  email: z.string().email("Enter a valid email."),
  password: z.string().min(6, "Password must be at least 6 characters."),
})
type AuthValues = z.infer<typeof authSchema>

function AuthCard({ onAuthed }: { onAuthed: () => void }) {
  const [mode, setMode] = React.useState<"sign_in" | "sign_up">("sign_in")
  const [busy, setBusy] = React.useState(false)

  const form = useForm<AuthValues>({
    resolver: zodResolver(authSchema),
    defaultValues: { email: "", password: "" },
  })

  async function onSubmit(values: AuthValues) {
    setBusy(true)
    try {
      if (mode === "sign_in") {
        await apiFetch("/api/auth/sign-in", {
          method: "POST",
          body: JSON.stringify(values),
        })
        onAuthed()
      } else {
        await apiFetch("/api/auth/sign-up", {
          method: "POST",
          body: JSON.stringify(values),
        })
        toast.success("Account created", {
          description: "You can now sign in (or confirm email if required).",
        })
        setMode("sign_in")
      }
    } catch (e) {
      toast.error("Authentication failed", {
        description: e instanceof Error ? e.message : "Please try again.",
      })
    } finally {
      setBusy(false)
    }
  }

  return (
    <div className="mx-auto flex min-h-screen max-w-md flex-col justify-center px-4 py-10">
      <Card>
        <CardHeader>
          <CardTitle className="text-2xl">Sign in</CardTitle>
          <p className="text-muted-foreground text-sm">
            {mode === "sign_in"
              ? "Use your email and password."
              : "Create an account with email and password."}
          </p>
        </CardHeader>
        <CardContent className="space-y-4">
          <Form {...form}>
            <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-3" noValidate>
              <FormField
                control={form.control}
                name="email"
                render={({ field }) => (
                  <FormItem>
                    <FormControl>
                      <Input placeholder="Email" autoComplete="email" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="password"
                render={({ field }) => (
                  <FormItem>
                    <FormControl>
                      <Input
                        type="password"
                        placeholder="Password"
                        autoComplete={
                          mode === "sign_in" ? "current-password" : "new-password"
                        }
                        {...field}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <Button type="submit" className="w-full" disabled={busy}>
                {mode === "sign_in" ? "Sign in" : "Sign up"}
              </Button>
            </form>
          </Form>

          <div className="flex items-center justify-between gap-3 text-sm">
            <span className="text-muted-foreground">
              {mode === "sign_in" ? "No account?" : "Already have an account?"}
            </span>
            <Button
              type="button"
              variant="link"
              className="px-0"
              onClick={() => setMode((m) => (m === "sign_in" ? "sign_up" : "sign_in"))}
            >
              {mode === "sign_in" ? "Sign up" : "Sign in"}
            </Button>
          </div>
        </CardContent>
      </Card>
    </div>
  )
}

export default function Home() {
  const [user, setUser] = React.useState<{ id: string; email?: string } | null>(null)
  const [authLoading, setAuthLoading] = React.useState(true)
  const [authError, setAuthError] = React.useState<string | null>(null)

  const refreshAuth = React.useCallback(async () => {
    setAuthLoading(true)
    try {
      const data = await apiFetch<{ user: { id: string; email?: string } | null }>("/api/auth/me")
      setUser(data.user)
      setAuthError(null)
    } catch (e) {
      setUser(null)
      setAuthError(e instanceof Error ? e.message : "Auth check failed.")
    } finally {
      setAuthLoading(false)
    }
  }, [])

  React.useEffect(() => {
    void refreshAuth()
  }, [refreshAuth])

  if (authLoading) {
    return (
      <div className="mx-auto flex min-h-screen max-w-2xl flex-col justify-center px-4 py-10">
        <p className="text-muted-foreground text-sm">Loading…</p>
      </div>
    )
  }

  if (authError) {
    return (
      <div className="mx-auto flex min-h-screen max-w-2xl flex-col justify-center gap-4 px-4 py-10">
        <Card>
          <CardHeader>
            <CardTitle>Auth unavailable</CardTitle>
          </CardHeader>
          <CardContent className="space-y-2">
            <p className="text-muted-foreground text-sm">{authError}</p>
            <p className="text-muted-foreground text-sm">
              Check <code>SUPABASE_SETUP.md</code> and set env vars from{" "}
              <code>supabase.env.example</code>.
            </p>
            <Button type="button" variant="outline" onClick={() => void refreshAuth()}>
              Retry
            </Button>
          </CardContent>
        </Card>
      </div>
    )
  }

  if (!user) return <AuthCard onAuthed={() => void refreshAuth()} />

  return (
    <div className="mx-auto flex min-h-screen max-w-2xl flex-col gap-6 px-4 py-10">
      <TodoApp userId={user.id} onSignedOut={() => void refreshAuth()} />
    </div>
  )
}

function TodoApp({ userId, onSignedOut }: { userId: string; onSignedOut: () => void }) {
  const [todos, setTodos] = React.useState<Todo[]>([])
  const [tasksLoading, setTasksLoading] = React.useState(true)
  const [tasksError, setTasksError] = React.useState<{ code?: string; message: string } | null>(
    null
  )
  const [attachTargetTodoId, setAttachTargetTodoId] = React.useState<string | null>(
    null
  )
  const [conflictDueAt, setConflictDueAt] = React.useState<string | null>(null)
  const clearConflictTimerRef = React.useRef<number | null>(null)
  const [focusMode, setFocusMode] = React.useState(false)
  const [nowMs, setNowMs] = React.useState(() => Date.now())
  const [inProgressTaskId, setInProgressTaskId] = React.useState<string | null>(null)
  const [dismissedReminderTaskId, setDismissedReminderTaskId] = React.useState<
    string | null
  >(null)
  const [filterMode, setFilterMode] = React.useState<"between" | "exact">("between")
  const [filterFromDate, setFilterFromDate] = React.useState<string>("")
  const [filterFromTime, setFilterFromTime] = React.useState<string>("")
  const [filterToDate, setFilterToDate] = React.useState<string>("")
  const [filterToTime, setFilterToTime] = React.useState<string>("")
  const [filterExactDate, setFilterExactDate] = React.useState<string>("")
  const [filterExactTime, setFilterExactTime] = React.useState<string>("")
  const fileInputRef = React.useRef<HTMLInputElement>(null)
  const [pageSize, setPageSize] = React.useState<number>(5)
  const [page, setPage] = React.useState<number>(1)

  React.useEffect(() => {
    let alive = true
    async function load() {
      setTasksLoading(true)
      if (!alive) return
      try {
        const data = await apiFetch<{ tasks: Todo[]; inProgressTaskId: string | null }>("/api/tasks")
        if (!alive) return
        setTodos(data.tasks)
        setInProgressTaskId(data.inProgressTaskId)
        setTasksError(null)
      } catch (e) {
        if (!alive) return
        if (e instanceof ApiError) setTasksError({ code: e.code, message: e.message })
        else setTasksError({ message: e instanceof Error ? e.message : "Failed to load tasks." })
        setTodos([])
        setInProgressTaskId(null)
      } finally {
        setTasksLoading(false)
      }
    }
    load()
    return () => {
      alive = false
    }
  }, [userId])

  // Keep "now" fresh so overdue/in-progress states stay accurate without user interaction.
  React.useEffect(() => {
    const id = window.setInterval(() => setNowMs(Date.now()), 30_000)
    return () => window.clearInterval(id)
  }, [])

  // Only one task can be "In Progress"; auto-clear if completed, deleted, or overdue.
  React.useEffect(() => {
    if (!inProgressTaskId) return
    const t = todos.find((x) => x.id === inProgressTaskId)
    if (!t || t.completed) {
      setInProgressTaskId(null)
      return
    }
  }, [inProgressTaskId, nowMs, todos])

  const nextUpcoming = React.useMemo(() => {
    const upcoming = todos
      .filter((t) => !t.completed)
      .map((t) => ({ todo: t, dueMs: parseLocalDateTime(t.dueAt) }))
      .filter((x) => x.dueMs >= nowMs)
      .sort((a, b) => a.dueMs - b.dueMs)[0]
    return upcoming ?? null
  }, [nowMs, todos])

  React.useEffect(() => {
    // If "next upcoming" changed, allow reminder again (dismiss is per-task).
    if (nextUpcoming && nextUpcoming.todo.id !== dismissedReminderTaskId) return
    if (!nextUpcoming) setDismissedReminderTaskId(null)
  }, [dismissedReminderTaskId, nextUpcoming])

  const reminder = React.useMemo(() => {
    const REMINDER_WINDOW_MIN = 15
    if (!nextUpcoming) return null
    if (dismissedReminderTaskId === nextUpcoming.todo.id) return null
    const mins = minutesUntil(nextUpcoming.dueMs, nowMs)
    if (mins < 0 || mins > REMINDER_WINDOW_MIN) return null
    return { ...nextUpcoming, mins }
  }, [dismissedReminderTaskId, nextUpcoming, nowMs])

  const form = useForm<TodoFormValues>({
    resolver: zodResolver(todoSchema),
    defaultValues: { title: "", description: "", dueAt: "" },
    mode: "onSubmit",
  })

  const summary = React.useMemo(() => {
    const now = new Date()
    const todayKey = localDateKey(now)
    const tomorrow = addDays(now, 1)
    const tomorrowKey = localDateKey(tomorrow)

    const todays = todos.filter((t) => t.dueAt.startsWith(todayKey))
    const todayCompleted = todays.filter((t) => t.completed).length
    const todayPending = todays.length - todayCompleted

    const labels = [
      "00:00–04:00",
      "04:00–08:00",
      "08:00–12:00",
      "12:00–16:00",
      "16:00–20:00",
      "20:00–24:00",
    ]

    // Tomorrow: same 4-hour windows breakdown
    const tomorrowTasks = todos.filter((t) => t.dueAt.startsWith(tomorrowKey))
    const tomorrowBuckets = Array.from({ length: 6 }, () => 0) as number[]
    for (const t of tomorrowTasks) {
      const ms = parseLocalDateTime(t.dueAt)
      const hour = new Date(ms).getHours()
      const idx = Math.floor(hour / 4)
      tomorrowBuckets[idx] = (tomorrowBuckets[idx] ?? 0) + 1
    }

    // Until next week = next 7 days starting tomorrow (local), grouped into 4-hour windows.
    const rangeStart = startOfDay(tomorrow).getTime()
    const rangeEnd = addDays(startOfDay(tomorrow), 7).getTime()
    const buckets = Array.from({ length: 6 }, () => 0) as number[]

    const upcoming = todos.filter((t) => {
      const ms = parseLocalDateTime(t.dueAt)
      return ms >= rangeStart && ms < rangeEnd
    })

    for (const t of upcoming) {
      const ms = parseLocalDateTime(t.dueAt)
      const hour = new Date(ms).getHours()
      const idx = Math.floor(hour / 4)
      buckets[idx] = (buckets[idx] ?? 0) + 1
    }

    return {
      todayCompleted,
      todayPending,
      tomorrowTotal: tomorrowTasks.length,
      tomorrowBuckets: labels.map((label, i) => ({ label, count: tomorrowBuckets[i] ?? 0 })),
      upcomingTotal: upcoming.length,
      upcomingBuckets: labels.map((label, i) => ({ label, count: buckets[i] ?? 0 })),
    }
  }, [todos])

  const loadDayKey = React.useMemo(() => {
    // Prefer an explicitly selected date from filters; otherwise use today.
    if (filterMode === "exact" && filterExactDate) return filterExactDate
    if (filterFromDate && !filterToDate) return filterFromDate
    if (filterFromDate && filterToDate && filterFromDate === filterToDate) return filterFromDate
    if (!filterFromDate && filterToDate) return filterToDate
    return localDateKey(new Date(nowMs))
  }, [filterExactDate, filterFromDate, filterMode, filterToDate, nowMs])

  const dailyLoad = React.useMemo(() => {
    const dayTodos = todos.filter((t) => getDatePart(t.dueAt) === loadDayKey)
    return getDailyLoad(dayTodos)
  }, [loadDayKey, todos])

  const filteredTodos = React.useMemo(() => {
    if (focusMode) {
      const endMs = nowMs + 4 * 60 * 60 * 1000
      const withMs = todos.map((t) => ({ ...t, _dueMs: parseLocalDateTime(t.dueAt) }))
      return withMs.filter((t) => t._dueMs >= nowMs && t._dueMs <= endMs)
    }

    const withMs = todos.map((t) => ({ ...t, _dueMs: parseLocalDateTime(t.dueAt) }))
    if (filterMode === "exact") {
      // If only date is selected -> show tasks for that date.
      // If time is selected too -> match exact date+time.
      // If only time is selected -> match time-of-day across all dates.
      if (!filterExactDate && !filterExactTime) return withMs

      if (filterExactDate && !filterExactTime) {
        return withMs.filter((t) => getDatePart(t.dueAt) === filterExactDate)
      }

      if (filterExactDate && filterExactTime) {
        const exactMs = parseLocalDateTime(`${filterExactDate}T${filterExactTime}`)
        return withMs.filter((t) => t._dueMs === exactMs)
      }

      // time only
      return withMs.filter((t) => getTimePart(t.dueAt) === filterExactTime)
    }
    // between
    const hasAnyDate = Boolean(filterFromDate || filterToDate)
    const hasAnyTime = Boolean(filterFromTime || filterToTime)

    // Date range (optional)
    const fromDateMs = filterFromDate
      ? startOfDay(parseLocalDateOnly(filterFromDate)).getTime()
      : Number.NEGATIVE_INFINITY
    const toDateMs = filterToDate
      ? endOfDay(parseLocalDateOnly(filterToDate)).getTime()
      : Number.POSITIVE_INFINITY

    // Time-of-day range (optional)
    const fromTimeMin = filterFromTime ? parseLocalTimeToMinutes(filterFromTime) : 0
    const toTimeMin = filterToTime ? parseLocalTimeToMinutes(filterToTime) : 24 * 60 - 1

    return withMs.filter((t) => {
      const ms = t._dueMs
      if (hasAnyDate && (ms < fromDateMs || ms > toDateMs)) return false

      if (hasAnyTime) {
        const time = getTimePart(t.dueAt)
        if (!time) return false
        const mins = parseLocalTimeToMinutes(time)
        // Simple (non-wrapping) range. If you want wrap-around (e.g. 22:00–02:00), tell me.
        if (mins < fromTimeMin || mins > toTimeMin) return false
      }

      // If neither date nor time selected, pass through (handled above anyway)
      return true
    })
  }, [
    todos,
    focusMode,
    nowMs,
    filterExactDate,
    filterExactTime,
    filterFromDate,
    filterFromTime,
    filterMode,
    filterToDate,
    filterToTime,
  ])

  const sortedFilteredTodos = React.useMemo(
    () =>
      filteredTodos
        .slice()
        .sort((a, b) => parseLocalDateTime(a.dueAt) - parseLocalDateTime(b.dueAt)),
    [filteredTodos]
  )

  // Clamp page when filters/pageSize change.
  React.useEffect(() => {
    const totalPages = Math.max(1, Math.ceil(sortedFilteredTodos.length / pageSize))
    setPage((p) => Math.min(Math.max(1, p), totalPages))
  }, [pageSize, sortedFilteredTodos.length])

  const totalItems = sortedFilteredTodos.length
  const totalPages = Math.max(1, Math.ceil(totalItems / pageSize))
  const showPagination = totalPages > 1

  const pageItems = React.useMemo(() => {
    const start = (page - 1) * pageSize
    return sortedFilteredTodos.slice(start, start + pageSize)
  }, [page, pageSize, sortedFilteredTodos])

  const groupedTodos = React.useMemo(() => {
    const groups: Array<{ date: string; items: typeof pageItems }> = []
    for (const t of pageItems) {
      const date = getDatePart(t.dueAt)
      const last = groups[groups.length - 1]
      if (!last || last.date !== date) groups.push({ date, items: [t] })
      else last.items.push(t)
    }
    return groups
  }, [pageItems])

  const completedCount = filteredTodos.filter((t) => t.completed).length

  async function addTodo(values: TodoFormValues) {
    const conflicts = todos.filter((t) => t.dueAt === values.dueAt)
    if (conflicts.length > 0) {
      setConflictDueAt(values.dueAt)
      if (clearConflictTimerRef.current) window.clearTimeout(clearConflictTimerRef.current)
      clearConflictTimerRef.current = window.setTimeout(() => {
        setConflictDueAt(null)
      }, 8000)

      // Make sure the user can see the conflicting tasks even if they were filtered out.
      const [d, time] = values.dueAt.split("T")
      setFilterMode("exact")
      setFilterExactDate(d ?? "")
      setFilterExactTime(time ?? "")
      setPage(1)

      toast.error("Time conflict", {
        description: `You already have ${conflicts.length} task(s) scheduled at ${formatLocalDateTime(
          values.dueAt
        )}.`,
      })
    }

    try {
      const data = await apiFetch<{ task: Todo }>("/api/tasks", {
        method: "POST",
        body: JSON.stringify(values),
      })
      setTodos((prev) => [data.task, ...prev])
    } catch (e) {
      toast.error("Failed to add task", { description: e instanceof Error ? e.message : "Failed." })
      return
    }
    form.reset()
  }

  async function toggleTodo(id: string, completed: boolean) {
    // optimistic
    setTodos((prev) =>
      prev.map((t) =>
        t.id === id ? { ...t, completed, attachments: t.attachments } : t
      )
    )
    if (completed) setInProgressTaskId((cur) => (cur === id ? null : cur))

    const update: { completed: boolean; in_progress?: boolean } = { completed }
    if (completed) update.in_progress = false

    try {
      await apiFetch("/api/tasks/" + id, {
        method: "PATCH",
        body: JSON.stringify({ completed }),
      })
    } catch (e) {
      toast.error("Failed to update task", { description: e instanceof Error ? e.message : "Failed." })
    }
  }

  function requestAttachmentsForTodo(todoId: string) {
    setAttachTargetTodoId(todoId)
    // Let state update before opening picker (some browsers are picky).
    queueMicrotask(() => fileInputRef.current?.click())
  }

  async function handleFilesPicked(e: React.ChangeEvent<HTMLInputElement>) {
    const files = Array.from(e.target.files ?? [])
    const targetId = attachTargetTodoId

    // reset input so picking the same file again triggers onChange
    e.target.value = ""
    setAttachTargetTodoId(null)

    if (!targetId || files.length === 0) return
    const form = new FormData()
    for (const f of files) form.append("files", f)
    try {
      const res = await fetch(`/api/tasks/${targetId}/attachments`, {
        method: "POST",
        credentials: "include",
        body: form,
      })
      const json = (await res.json().catch(() => null)) as
        | { ok: true; data: { task: Todo } }
        | { ok: false; error: { message: string } }
        | null
      if (!json || !json.ok) throw new Error(json?.error.message ?? "Upload failed.")
      setTodos((prev) => prev.map((t) => (t.id === targetId ? json.data.task : t)))
    } catch (e) {
      toast.error("Upload failed", { description: e instanceof Error ? e.message : "Failed." })
    }
  }

  async function deleteTodo(id: string) {
    // optimistic
    setTodos((prev) => prev.filter((t) => t.id !== id))
    setInProgressTaskId((cur) => (cur === id ? null : cur))

    try {
      await apiFetch("/api/tasks/" + id, { method: "DELETE" })
    } catch (e) {
      toast.error("Failed to delete task", { description: e instanceof Error ? e.message : "Failed." })
    }
  }

  async function setInProgress(taskId: string | null) {
    // optimistic
    setInProgressTaskId(taskId)

    try {
      const data = await apiFetch<{ inProgressTaskId: string | null }>("/api/tasks/in-progress", {
        method: "POST",
        body: JSON.stringify({ id: taskId }),
      })
      setInProgressTaskId(data.inProgressTaskId)
    } catch (e) {
      toast.error("Failed to update in-progress", {
        description: e instanceof Error ? e.message : "Failed.",
      })
    }
  }

  async function downloadAttachment(a: Attachment) {
    try {
      const data = await apiFetch<{ signedUrl: string }>("/api/attachments/signed-url", {
        method: "POST",
        body: JSON.stringify({ bucket: a.bucket, path: a.path }),
      })
      window.open(data.signedUrl, "_blank", "noopener,noreferrer")
    } catch (e) {
      toast.error("Download failed", { description: e instanceof Error ? e.message : "Failed." })
    }
  }

  async function seedDemoTasks() {
    if (todos.length > 0) return
    try {
      const data = await apiFetch<{ tasks: Todo[] }>("/api/tasks/seed", {
        method: "POST",
        body: JSON.stringify({ tasks: initialTodos }),
      })
      setTodos(data.tasks)
    } catch (e) {
      toast.error("Failed to seed demo tasks", { description: e instanceof Error ? e.message : "Failed." })
    }
  }

  async function clearCompleted() {
    const completedIds = new Set(todos.filter((t) => t.completed).map((t) => t.id))
    if (completedIds.size === 0) return

    // optimistic
    setTodos((prev) => prev.filter((t) => !completedIds.has(t.id)))

    try {
      await apiFetch("/api/tasks/clear-completed", { method: "POST" })
    } catch (e) {
      toast.error("Failed to clear completed", { description: e instanceof Error ? e.message : "Failed." })
    }
  }

  return (
    <Card>
      <CardHeader className="flex flex-row items-center justify-between gap-4">
        <div className="space-y-1">
          <CardTitle className="text-2xl">To‑Do</CardTitle>
          <p className="text-muted-foreground text-sm">
            {completedCount}/{filteredTodos.length} completed
          </p>
        </div>
        <div className="flex items-center gap-2">
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <Button
                  type="button"
                  variant={focusMode ? "default" : "outline"}
                  size="sm"
                  onClick={() => {
                    setFocusMode((v) => !v)
                    setPage(1)
                  }}
                >
                  Focus Mode
                </Button>
              </TooltipTrigger>
              <TooltipContent>
                <p>Show tasks for the next 4 hours.</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
          <Button
            type="button"
            variant="outline"
            size="sm"
            onClick={async () => {
              await supabase.auth.signOut()
            }}
          >
            Sign out
          </Button>
          <ModeToggle />
        </div>
      </CardHeader>

      <CardContent className="space-y-6">
        {tasksLoading && (
          <p className="text-muted-foreground text-sm">Loading tasks…</p>
        )}

        {!tasksLoading && todos.length === 0 && (
          <div className="flex items-center justify-between gap-3 rounded-lg border bg-muted/20 px-3 py-2">
            <p className="text-muted-foreground text-sm">No tasks yet.</p>
            <Button type="button" variant="outline" size="sm" onClick={() => void seedDemoTasks()}>
              Seed demo tasks
            </Button>
          </div>
        )}

        <input
          ref={fileInputRef}
          type="file"
          multiple
          className="hidden"
          accept={[
            "image/*",
            "audio/*",
            "video/*",
            ".pdf",
            ".doc",
            ".docx",
            ".xls",
            ".xlsx",
            ".csv",
            ".txt",
            ".md",
            ".rtf",
          ].join(",")}
          onChange={handleFilesPicked}
        />

        {reminder && (
          <Alert className="border-primary/30 bg-primary/5">
            <Bell className="h-4 w-4" />
            <div className="flex flex-1 flex-col gap-1">
              <div className="flex flex-wrap items-center justify-between gap-2">
                <AlertTitle className="text-sm">
                  Next task starts in {reminder.mins} minute{reminder.mins === 1 ? "" : "s"}
                </AlertTitle>
                <Button
                  type="button"
                  variant="ghost"
                  size="sm"
                  onClick={() => setDismissedReminderTaskId(reminder.todo.id)}
                >
                  Dismiss
                </Button>
              </div>
              <AlertDescription className="text-sm">
                <span className="font-medium">{reminder.todo.title}</span> ·{" "}
                {formatDateTimeFromMs(reminder.dueMs)}
              </AlertDescription>
            </div>
          </Alert>
        )}

        <div className="rounded-xl border bg-card p-4">
          <div className="flex flex-wrap items-center justify-between gap-2">
            <p className="text-sm font-medium">
              Daily load{" "}
              <span className="text-muted-foreground font-normal">
                ({new Intl.DateTimeFormat(undefined, {
                  weekday: "short",
                  year: "numeric",
                  month: "short",
                  day: "2-digit",
                }).format(parseLocalDateOnly(loadDayKey))})
              </span>
            </p>
            <DailyLoadBadge load={dailyLoad.load} />
          </div>
          <p className="text-muted-foreground mt-2 text-sm">
            {dailyLoad.total} task(s) · busiest window {dailyLoad.busiestWindow} ({dailyLoad.peak})
          </p>
        </div>

        <div className="grid gap-3 sm:grid-cols-3">
          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Today’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">
              {summary.todayCompleted} completed
            </p>
            <p className="text-muted-foreground text-sm">{summary.todayPending} pending</p>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tomorrow’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">{summary.tomorrowTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.tomorrowBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tasks Until Next Week</p>
            <p className="mt-2 text-2xl font-semibold">{summary.upcomingTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.upcomingBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>
        </div>

        {focusMode && (
          <div className="flex flex-col gap-1 rounded-lg border bg-muted/20 px-3 py-2 sm:flex-row sm:items-center sm:justify-between">
            <p className="text-sm">
              <span className="font-medium">Focus Mode:</span>{" "}
              showing tasks due in the next 4 hours (until{" "}
              <span className="font-medium">
                {formatDateTimeFromMs(nowMs + 4 * 60 * 60 * 1000)}
              </span>
              )
            </p>
            <Button type="button" variant="ghost" size="sm" onClick={() => setFocusMode(false)}>
              Exit
            </Button>
          </div>
        )}

        <Form {...form}>
          <form
            onSubmit={form.handleSubmit(addTodo)}
            className="space-y-2"
            noValidate
          >
            <div className="flex flex-col gap-2 sm:flex-row">
              <FormField
                control={form.control}
                name="title"
                render={({ field }) => (
                  <FormItem className="flex-1">
                    <FormControl>
                      <Input
                        placeholder="Add a task…"
                        autoComplete="off"
                        {...field}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="dueAt"
                render={({ field }) => (
                  <FormItem className="sm:w-64">
                    <FormControl>
                      <Input type="datetime-local" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <Button type="submit">Add</Button>
            </div>

            <FormField
              control={form.control}
              name="description"
              render={({ field }) => (
                <FormItem>
                  <FormControl>
                    <Textarea
                      rows={3}
                      placeholder="Description (optional)…"
                      {...field}
                    />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />
          </form>
        </Form>

        <Separator />

        <div className="space-y-3">
          <div className="flex flex-wrap items-center justify-between gap-2">
            <p className="text-sm font-medium">Filter by date & time</p>
            <div className="flex items-center gap-2">
              <Button
                type="button"
                size="sm"
                variant={filterMode === "between" ? "default" : "outline"}
                onClick={() => setFilterMode("between")}
              >
                Between
              </Button>
              <Button
                type="button"
                size="sm"
                variant={filterMode === "exact" ? "default" : "outline"}
                onClick={() => setFilterMode("exact")}
              >
                Exact
              </Button>
              <Button
                type="button"
                size="sm"
                variant="ghost"
                onClick={() => {
                  setFilterFromDate("")
                  setFilterFromTime("")
                  setFilterToDate("")
                  setFilterToTime("")
                  setFilterExactDate("")
                  setFilterExactTime("")
                }}
              >
                Clear
              </Button>
            </div>
          </div>

          {filterMode === "between" ? (
            <div className="grid gap-2 sm:grid-cols-2">
              <div className="grid gap-2 sm:grid-cols-2">
                <Input
                  type="date"
                  value={filterFromDate}
                  onChange={(e) => setFilterFromDate(e.target.value)}
                />
                <Input
                  type="time"
                  value={filterFromTime}
                  onChange={(e) => setFilterFromTime(e.target.value)}
                />
              </div>
              <div className="grid gap-2 sm:grid-cols-2">
                <Input
                  type="date"
                  value={filterToDate}
                  onChange={(e) => setFilterToDate(e.target.value)}
                />
                <Input
                  type="time"
                  value={filterToTime}
                  onChange={(e) => setFilterToTime(e.target.value)}
                />
              </div>
            </div>
          ) : (
            <div className="grid gap-2 sm:grid-cols-2">
              <Input
                type="date"
                value={filterExactDate}
                onChange={(e) => setFilterExactDate(e.target.value)}
              />
              <Input
                type="time"
                value={filterExactTime}
                onChange={(e) => setFilterExactTime(e.target.value)}
              />
            </div>
          )}
        </div>

        <Separator />

        <div className="space-y-2">
          {groupedTodos.length === 0 ? (
            <p className="text-muted-foreground text-sm">No tasks yet.</p>
          ) : (
            groupedTodos.map((group) => (
              <div key={group.date} className="space-y-2">
                <div className="flex items-center gap-3 pt-2">
                  <Separator className="flex-1" />
                  <span className="text-muted-foreground whitespace-nowrap text-xs font-medium">
                    {new Intl.DateTimeFormat(undefined, {
                      weekday: "short",
                      year: "numeric",
                      month: "short",
                      day: "2-digit",
                    }).format(parseLocalDateOnly(group.date))}
                  </span>
                  <Separator className="flex-1" />
                </div>

                {group.items.map((todo) => {
                  const flags = getTaskFlags(todo, nowMs, inProgressTaskId)

                  return (
                    <div
                      key={todo.id}
                      className={cn(
                        "rounded-lg border px-3 py-2",
                        flags.completed && "opacity-75",
                        flags.overdue &&
                          "border-destructive/40 bg-destructive/5 text-muted-foreground",
                        flags.inProgress && "border-sky-500/40 bg-sky-500/10",
                        conflictDueAt &&
                          todo.dueAt === conflictDueAt &&
                          "border-destructive/60 bg-destructive/5 ring-1 ring-destructive/30"
                      )}
                    >
                      <div className="flex items-start justify-between gap-3">
                        <label className="flex cursor-pointer items-start gap-3">
                        <Checkbox
                          checked={todo.completed}
                          onCheckedChange={(v) => {
                            const next = Boolean(v)
                            toggleTodo(todo.id, next)
                            if (next && !todo.completed) {
                              requestAttachmentsForTodo(todo.id)
                            }
                          }}
                          aria-label={`Mark "${todo.title}" as ${
                            todo.completed ? "not completed" : "completed"
                          }`}
                          className="mt-0.5"
                        />
                        <span
                          className={cn(
                            "leading-6",
                            todo.completed && "text-muted-foreground line-through"
                          )}
                        >
                          <span className="flex flex-wrap items-center gap-2">
                            <span className="block">{todo.title}</span>
                              <span className="flex flex-wrap items-center gap-2">
                                <TaskBadges {...flags} />
                              </span>
                            {todo.description && (
                              <TooltipProvider>
                                <Tooltip>
                                  <TooltipTrigger asChild>
                                    <button
                                      type="button"
                                      className="text-muted-foreground hover:text-foreground inline-flex h-7 w-7 items-center justify-center rounded-md border bg-background"
                                      aria-label="View description"
                                    >
                                      <Info className="h-4 w-4" />
                                    </button>
                                  </TooltipTrigger>
                                  <TooltipContent className="max-w-xs">
                                    <p className="whitespace-pre-wrap text-sm">
                                      {todo.description}
                                    </p>
                                  </TooltipContent>
                                </Tooltip>
                              </TooltipProvider>
                            )}
                          </span>
                          <span className="text-muted-foreground block text-xs">
                            Due: {formatLocalDateTime(todo.dueAt)}
                          </span>
                        </span>
                      </label>

                      <div className="flex items-center gap-1">
                        {!todo.completed && (
                          <Button
                            type="button"
                            variant={flags.inProgress ? "default" : "outline"}
                            size="sm"
                            onClick={() => void setInProgress(flags.inProgress ? null : todo.id)}
                            className={cn(
                              flags.inProgress && "bg-sky-600 hover:bg-sky-600"
                            )}
                          >
                            {flags.inProgress ? (
                              <>
                                <CircleStop className="mr-1 h-4 w-4" />
                                Stop
                              </>
                            ) : (
                              <>
                                <CirclePlay className="mr-1 h-4 w-4" />
                                Start
                              </>
                            )}
                          </Button>
                        )}
                        {todo.completed && (
                          <Button
                            type="button"
                            variant="outline"
                            size="sm"
                            onClick={() => requestAttachmentsForTodo(todo.id)}
                          >
                            Add files
                          </Button>
                        )}
                        <Button
                          type="button"
                          variant="ghost"
                          size="icon"
                          aria-label={`Delete "${todo.title}"`}
                          onClick={() => deleteTodo(todo.id)}
                        >
                          <Trash2 className="h-4 w-4" />
                        </Button>
                      </div>
                    </div>

                    {todo.completed && todo.attachments.length > 0 && (
                      <div className="mt-3 space-y-2">
                        <p className="text-muted-foreground text-xs">Attachments</p>
                        <ul className="space-y-1">
                          {todo.attachments.map((a) => (
                            <li
                              key={a.id}
                              className="flex items-center justify-between gap-3 rounded-md bg-muted/30 px-2 py-1"
                            >
                              <div className="flex min-w-0 items-center gap-2">
                                <AttachmentIcon kind={a.kind} />
                                <span className="truncate text-sm">{a.name}</span>
                              </div>
                              <button
                                type="button"
                                onClick={() => void downloadAttachment(a)}
                                className="inline-flex items-center gap-1 text-sm font-medium underline underline-offset-4"
                              >
                                <Download className="h-4 w-4" />
                                Download
                              </button>
                            </li>
                          ))}
                        </ul>
                      </div>
                    )}
                  </div>
                  )
                })}
              </div>
            ))
          )}
        </div>

        {groupedTodos.length > 0 && (
          <div className="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
            <div className="flex items-center gap-2">
              <span className="text-muted-foreground text-sm">Items per page</span>
              <Select
                value={String(pageSize)}
                onValueChange={(v) => {
                  const next = Number(v)
                  setPageSize(next)
                  setPage(1)
                }}
              >
                <SelectTrigger className="w-[110px]">
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="5">5</SelectItem>
                  <SelectItem value="10">10</SelectItem>
                  <SelectItem value="15">15</SelectItem>
                  <SelectItem value="20">20</SelectItem>
                </SelectContent>
              </Select>
            </div>

            {showPagination && (
              <div className="flex items-center justify-between gap-3 sm:justify-end">
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={() => setPage((p) => Math.max(1, p - 1))}
                  disabled={page <= 1}
                >
                  Prev
                </Button>
                <span className="text-muted-foreground text-sm">
                  Page {page} of {totalPages}
                </span>
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={() => setPage((p) => Math.min(totalPages, p + 1))}
                  disabled={page >= totalPages}
                >
                  Next
                </Button>
              </div>
            )}
          </div>
        )}

        <div className="flex items-center justify-between gap-2">
          <Button
            type="button"
            variant="secondary"
            onClick={clearCompleted}
            disabled={completedCount === 0}
          >
            Clear completed
          </Button>
          <span className="text-muted-foreground text-sm">
            v 1.1.0
          </span>
    </div>
      </CardContent>
    </Card>
  )
}

```

```typescriptreact
"use client"

import { zodResolver } from "@hookform/resolvers/zod"
import {
  AlertTriangle,
  CirclePlay,
  CircleStop,
  CalendarClock,
  CheckCircle2,
  Download,
  File,
  FileSpreadsheet,
  FileText,
  Image as ImageIcon,
  Info,
  Music,
  Bell,
  Timer,
  Trash2,
  Video,
} from "lucide-react"
import * as React from "react"
import { useForm } from "react-hook-form"
import { toast } from "sonner"
import { z } from "zod"
// Supabase is accessed via Next.js API routes (see src/app/api/**). No direct client usage here.

import { ModeToggle } from "@/components/mode-toggle"
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert"
import { Badge } from "@/components/ui/badge"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Checkbox } from "@/components/ui/checkbox"
import { Form, FormControl, FormField, FormItem, FormMessage } from "@/components/ui/form"
import { Input } from "@/components/ui/input"
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select"
import { Separator } from "@/components/ui/separator"
import { Textarea } from "@/components/ui/textarea"
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip"
import { cn } from "@/lib/utils"
import { apiFetch, ApiError } from "@/lib/api-client"

type AttachmentKind =
  | "image"
  | "audio"
  | "video"
  | "pdf"
  | "spreadsheet"
  | "document"
  | "text"
  | "file"

type Attachment = {
  id: string
  name: string
  type: string
  size: number
  bucket: string
  path: string
  kind: AttachmentKind
}

type Todo = {
  id: string
  title: string
  description?: string
  completed: boolean
  // Stored as `datetime-local` string (YYYY-MM-DDTHH:mm) in local time.
  dueAt: string
  attachments: Attachment[]
}

type TaskState = "planned" | "in_progress" | "completed" | "overdue"
type DailyLoad = "light" | "balanced" | "heavy"

const todoSchema = z.object({
  title: z
    .string()
    .trim()
    .min(1, "Title is required.")
    .max(80, "Keep it under 80 characters."),
  description: z
    .string()
    .trim()
    .max(500, "Keep it under 500 characters.")
    .optional()
    .or(z.literal("")),
  dueAt: z
    .string()
    .min(1, "Due date & time is required.")
    .regex(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}$/, "Invalid date/time."),
})

type TodoFormValues = z.infer<typeof todoSchema>

const initialTodos: Todo[] = [
  {
    id: "1",
    title: "Create a Next.js app",
    description: "Scaffold with TypeScript + Tailwind and confirm it runs locally.",
    completed: true,
    dueAt: "2026-01-16T09:00",
    attachments: [],
  },
  {
    id: "2",
    title: "Add shadcn/ui + dark theme",
    description: "Initialize shadcn, set up theme provider, and verify dark mode.",
    completed: true,
    dueAt: "2026-01-16T10:30",
    attachments: [],
  },
  {
    id: "3",
    title: "Build a mock-data to-do list",
    completed: false,
    dueAt: "2026-01-16T15:00",
    attachments: [],
  },
  {
    id: "4",
    title: "Yesterday: review requirements",
    completed: true,
    dueAt: "2026-01-15T11:15",
    attachments: [],
  },
  {
    id: "5",
    title: "Yesterday: sketch UI layout",
    completed: true,
    dueAt: "2026-01-15T17:45",
    attachments: [],
  },
  {
    id: "6",
    title: "Today: add attachments support",
    completed: false,
    dueAt: "2026-01-16T18:20",
    attachments: [],
  },
  {
    id: "7",
    title: "Tomorrow: QA the filters",
    description: "Test date-only, time-only, exact, and between behaviors.",
    completed: false,
    dueAt: "2026-01-17T08:05",
    attachments: [],
  },
  {
    id: "8",
    title: "Tomorrow: polish summary cards",
    completed: false,
    dueAt: "2026-01-17T13:30",
    attachments: [],
  },
  {
    id: "9",
    title: "Tomorrow: write small UX notes",
    completed: false,
    dueAt: "2026-01-17T20:10",
    attachments: [],
  },
  {
    id: "10",
    title: "This weekend: add more mock tasks",
    completed: false,
    dueAt: "2026-01-18T10:00",
    attachments: [],
  },
  {
    id: "11",
    title: "This weekend: check time-only filter",
    completed: false,
    dueAt: "2026-01-18T22:15",
    attachments: [],
  },
  {
    id: "12",
    title: "Next week: sync with team",
    completed: false,
    dueAt: "2026-01-19T09:30",
    attachments: [],
  },
  {
    id: "13",
    title: "Next week: test date-only filter",
    completed: false,
    dueAt: "2026-01-20T14:05",
    attachments: [],
  },
  {
    id: "14",
    title: "Next week: test exact date+time filter",
    completed: false,
    dueAt: "2026-01-21T12:00",
    attachments: [],
  },
  {
    id: "15",
    title: "Next week: attach docs to completed tasks",
    completed: false,
    dueAt: "2026-01-22T16:40",
    attachments: [],
  },
  {
    id: "16",
    title: "Next week: final review",
    completed: false,
    dueAt: "2026-01-23T11:00",
    attachments: [],
  },
]

function parseLocalDateTime(value: string): number {
  // value: "YYYY-MM-DDTHH:mm"
  const [datePart, timePart] = value.split("T")
  const [y, m, d] = datePart.split("-").map(Number)
  const [hh, mm] = timePart.split(":").map(Number)
  return new Date(y, m - 1, d, hh, mm, 0, 0).getTime()
}

function pad2(n: number) {
  return String(n).padStart(2, "0")
}

function localDateKey(d: Date) {
  return `${d.getFullYear()}-${pad2(d.getMonth() + 1)}-${pad2(d.getDate())}`
}

function addDays(date: Date, days: number) {
  const d = new Date(date)
  d.setDate(d.getDate() + days)
  return d
}

function startOfDay(date: Date) {
  return new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0, 0)
}

function endOfDay(date: Date) {
  return new Date(
    date.getFullYear(),
    date.getMonth(),
    date.getDate(),
    23,
    59,
    59,
    999
  )
}

function getDatePart(dueAt: string) {
  return dueAt.split("T")[0] ?? ""
}

function getTimePart(dueAt: string) {
  return dueAt.split("T")[1] ?? ""
}

function parseLocalDateOnly(value: string): Date {
  // value: "YYYY-MM-DD"
  const [y, m, d] = value.split("-").map(Number)
  return new Date(y, m - 1, d, 0, 0, 0, 0)
}

function parseLocalTimeToMinutes(value: string): number {
  // value: "HH:mm"
  const [hh, mm] = value.split(":").map(Number)
  return hh * 60 + mm
}

function formatLocalDateTime(value: string): string {
  const ms = parseLocalDateTime(value)
  if (!Number.isFinite(ms)) return value
  return new Intl.DateTimeFormat(undefined, {
    year: "numeric",
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  }).format(new Date(ms))
}

function formatDateTimeFromMs(ms: number): string {
  return new Intl.DateTimeFormat(undefined, {
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  }).format(new Date(ms))
}

function minutesUntil(targetMs: number, nowMs: number) {
  return Math.ceil((targetMs - nowMs) / 60_000)
}

function getTaskFlags(todo: Todo, nowMs: number, inProgressTaskId: string | null) {
  const completed = todo.completed
  const dueMs = parseLocalDateTime(todo.dueAt)
  const overdue = !completed && dueMs < nowMs
  const inProgress = !completed && inProgressTaskId === todo.id
  const planned = !completed && !overdue && !inProgress
  return { completed, overdue, inProgress, planned }
}

function getDailyLoad(todosForDay: Todo[]) {
  // 4-hour windows across the day (local).
  const labels = [
    "00:00–04:00",
    "04:00–08:00",
    "08:00–12:00",
    "12:00–16:00",
    "16:00–20:00",
    "20:00–24:00",
  ]
  const buckets = Array.from({ length: 6 }, () => 0) as number[]
  for (const t of todosForDay) {
    const ms = parseLocalDateTime(t.dueAt)
    const hour = new Date(ms).getHours()
    const idx = Math.floor(hour / 4)
    buckets[idx] = (buckets[idx] ?? 0) + 1
  }

  const total = todosForDay.length
  const peak = Math.max(0, ...buckets)
  const spread = buckets.filter((c) => c > 0).length
  const busiestIdx = buckets.findIndex((c) => c === peak)
  const busiestWindow = busiestIdx >= 0 ? labels[busiestIdx] : labels[0]

  // Heuristic: more tasks + higher concentration in one window => heavier day.
  const score = total + peak * 1.5 + Math.max(0, spread - 1) * 0.5
  const load: DailyLoad = score <= 5 ? "light" : score <= 10 ? "balanced" : "heavy"

  return { load, total, peak, spread, busiestWindow }
}

function DailyLoadBadge({ load }: { load: DailyLoad }) {
  if (load === "heavy") return <Badge variant="destructive">Heavy</Badge>
  if (load === "balanced") return <Badge variant="secondary">Balanced</Badge>
  return <Badge variant="outline">Light</Badge>
}

function TaskBadges({
  completed,
  overdue,
  inProgress,
  planned,
}: {
  completed: boolean
  overdue: boolean
  inProgress: boolean
  planned: boolean
}) {
  if (completed) {
    return (
      <Badge className="gap-1 bg-emerald-600 text-white hover:bg-emerald-600">
        <CheckCircle2 className="h-3.5 w-3.5" />
        Completed
      </Badge>
    )
  }

  return (
    <>
      {inProgress && (
        <Badge className="gap-1 bg-sky-600 text-white hover:bg-sky-600">
          <Timer className="h-3.5 w-3.5 text-white" />
          In progress
        </Badge>
      )}
      {overdue && (
        <Badge variant="destructive" className="gap-1">
          <AlertTriangle className="h-3.5 w-3.5" />
          Overdue
        </Badge>
      )}
      {planned && (
        <Badge variant="outline" className="gap-1">
          <CalendarClock className="h-3.5 w-3.5" />
          Planned
        </Badge>
      )}
    </>
  )
}

function getAttachmentKind(file: File): AttachmentKind {
  const type = (file.type || "").toLowerCase()
  const name = file.name.toLowerCase()
  const ext = name.includes(".") ? name.split(".").pop() ?? "" : ""

  if (type.startsWith("image/")) return "image"
  if (type.startsWith("audio/")) return "audio"
  if (type.startsWith("video/")) return "video"

  if (ext === "pdf") return "pdf"
  if (["xls", "xlsx", "csv"].includes(ext)) return "spreadsheet"
  if (["doc", "docx"].includes(ext)) return "document"
  if (["txt", "md", "rtf"].includes(ext)) return "text"

  return "file"
}

function sanitizePathSegment(s: string) {
  return s.replace(/[^\w.\-]+/g, "_")
}

function buildAttachmentRecord(file: File, bucket: string, path: string): Attachment {
  return {
    id: crypto.randomUUID(),
    name: file.name,
    type: file.type,
    size: file.size,
    bucket,
    path,
    kind: getAttachmentKind(file),
  }
}

function AttachmentIcon({ kind }: { kind: AttachmentKind }) {
  const className = "h-4 w-4 text-muted-foreground"

  switch (kind) {
    case "image":
      return <ImageIcon className={className} />
    case "audio":
      return <Music className={className} />
    case "video":
      return <Video className={className} />
    case "spreadsheet":
      return <FileSpreadsheet className={className} />
    case "pdf":
    case "document":
    case "text":
      return <FileText className={className} />
    default:
      return <File className={className} />
  }
}

const authSchema = z.object({
  email: z.string().email("Enter a valid email."),
  password: z.string().min(6, "Password must be at least 6 characters."),
})
type AuthValues = z.infer<typeof authSchema>

function AuthCard({ onAuthed }: { onAuthed: () => void }) {
  const [mode, setMode] = React.useState<"sign_in" | "sign_up">("sign_in")
  const [busy, setBusy] = React.useState(false)

  const form = useForm<AuthValues>({
    resolver: zodResolver(authSchema),
    defaultValues: { email: "", password: "" },
  })

  async function onSubmit(values: AuthValues) {
    setBusy(true)
    try {
      if (mode === "sign_in") {
        await apiFetch("/api/auth/sign-in", {
          method: "POST",
          body: JSON.stringify(values),
        })
        onAuthed()
      } else {
        await apiFetch("/api/auth/sign-up", {
          method: "POST",
          body: JSON.stringify(values),
        })
        toast.success("Account created", {
          description: "You can now sign in (or confirm email if required).",
        })
        setMode("sign_in")
      }
    } catch (e) {
      toast.error("Authentication failed", {
        description: e instanceof Error ? e.message : "Please try again.",
      })
    } finally {
      setBusy(false)
    }
  }

  return (
    <div className="mx-auto flex min-h-screen max-w-md flex-col justify-center px-4 py-10">
      <Card>
        <CardHeader>
          <CardTitle className="text-2xl">Sign in</CardTitle>
          <p className="text-muted-foreground text-sm">
            {mode === "sign_in"
              ? "Use your email and password."
              : "Create an account with email and password."}
          </p>
        </CardHeader>
        <CardContent className="space-y-4">
          <Form {...form}>
            <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-3" noValidate>
              <FormField
                control={form.control}
                name="email"
                render={({ field }) => (
                  <FormItem>
                    <FormControl>
                      <Input placeholder="Email" autoComplete="email" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="password"
                render={({ field }) => (
                  <FormItem>
                    <FormControl>
                      <Input
                        type="password"
                        placeholder="Password"
                        autoComplete={
                          mode === "sign_in" ? "current-password" : "new-password"
                        }
                        {...field}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <Button type="submit" className="w-full" disabled={busy}>
                {mode === "sign_in" ? "Sign in" : "Sign up"}
              </Button>
            </form>
          </Form>

          <div className="flex items-center justify-between gap-3 text-sm">
            <span className="text-muted-foreground">
              {mode === "sign_in" ? "No account?" : "Already have an account?"}
            </span>
            <Button
              type="button"
              variant="link"
              className="px-0"
              onClick={() => setMode((m) => (m === "sign_in" ? "sign_up" : "sign_in"))}
            >
              {mode === "sign_in" ? "Sign up" : "Sign in"}
            </Button>
          </div>
        </CardContent>
      </Card>
    </div>
  )
}

export default function Home() {
  const [user, setUser] = React.useState<{ id: string; email?: string } | null>(null)
  const [authLoading, setAuthLoading] = React.useState(true)
  const [authError, setAuthError] = React.useState<string | null>(null)

  const refreshAuth = React.useCallback(async () => {
    setAuthLoading(true)
    try {
      const data = await apiFetch<{ user: { id: string; email?: string } | null }>("/api/auth/me")
      setUser(data.user)
      setAuthError(null)
    } catch (e) {
      setUser(null)
      setAuthError(e instanceof Error ? e.message : "Auth check failed.")
    } finally {
      setAuthLoading(false)
    }
  }, [])

  React.useEffect(() => {
    void refreshAuth()
  }, [refreshAuth])

  if (authLoading) {
    return (
      <div className="mx-auto flex min-h-screen max-w-2xl flex-col justify-center px-4 py-10">
        <p className="text-muted-foreground text-sm">Loading…</p>
      </div>
    )
  }

  if (authError) {
    return (
      <div className="mx-auto flex min-h-screen max-w-2xl flex-col justify-center gap-4 px-4 py-10">
        <Card>
          <CardHeader>
            <CardTitle>Auth unavailable</CardTitle>
          </CardHeader>
          <CardContent className="space-y-2">
            <p className="text-muted-foreground text-sm">{authError}</p>
            <p className="text-muted-foreground text-sm">
              Check <code>SUPABASE_SETUP.md</code> and set env vars from{" "}
              <code>supabase.env.example</code>.
            </p>
            <Button type="button" variant="outline" onClick={() => void refreshAuth()}>
              Retry
            </Button>
          </CardContent>
        </Card>
      </div>
    )
  }

  if (!user) return <AuthCard onAuthed={() => void refreshAuth()} />

  return (
    <div className="mx-auto flex min-h-screen max-w-2xl flex-col gap-6 px-4 py-10">
      <TodoApp userId={user.id} onSignedOut={() => void refreshAuth()} />
    </div>
  )
}

function TodoApp({ userId, onSignedOut }: { userId: string; onSignedOut: () => void }) {
  const [todos, setTodos] = React.useState<Todo[]>([])
  const [tasksLoading, setTasksLoading] = React.useState(true)
  const [tasksError, setTasksError] = React.useState<{ code?: string; message: string } | null>(
    null
  )
  const [attachTargetTodoId, setAttachTargetTodoId] = React.useState<string | null>(
    null
  )
  const [conflictDueAt, setConflictDueAt] = React.useState<string | null>(null)
  const clearConflictTimerRef = React.useRef<number | null>(null)
  const [focusMode, setFocusMode] = React.useState(false)
  const [nowMs, setNowMs] = React.useState(() => Date.now())
  const [inProgressTaskId, setInProgressTaskId] = React.useState<string | null>(null)
  const [dismissedReminderTaskId, setDismissedReminderTaskId] = React.useState<
    string | null
  >(null)
  const [filterMode, setFilterMode] = React.useState<"between" | "exact">("between")
  const [filterFromDate, setFilterFromDate] = React.useState<string>("")
  const [filterFromTime, setFilterFromTime] = React.useState<string>("")
  const [filterToDate, setFilterToDate] = React.useState<string>("")
  const [filterToTime, setFilterToTime] = React.useState<string>("")
  const [filterExactDate, setFilterExactDate] = React.useState<string>("")
  const [filterExactTime, setFilterExactTime] = React.useState<string>("")
  const fileInputRef = React.useRef<HTMLInputElement>(null)
  const [pageSize, setPageSize] = React.useState<number>(5)
  const [page, setPage] = React.useState<number>(1)

  React.useEffect(() => {
    let alive = true
    async function load() {
      setTasksLoading(true)
      if (!alive) return
      try {
        const data = await apiFetch<{ tasks: Todo[]; inProgressTaskId: string | null }>("/api/tasks")
        if (!alive) return
        setTodos(data.tasks)
        setInProgressTaskId(data.inProgressTaskId)
        setTasksError(null)
      } catch (e) {
        if (!alive) return
        if (e instanceof ApiError) setTasksError({ code: e.code, message: e.message })
        else setTasksError({ message: e instanceof Error ? e.message : "Failed to load tasks." })
        setTodos([])
        setInProgressTaskId(null)
      } finally {
        setTasksLoading(false)
      }
    }
    load()
    return () => {
      alive = false
    }
  }, [userId])

  // Keep "now" fresh so overdue/in-progress states stay accurate without user interaction.
  React.useEffect(() => {
    const id = window.setInterval(() => setNowMs(Date.now()), 30_000)
    return () => window.clearInterval(id)
  }, [])

  // Only one task can be "In Progress"; auto-clear if completed, deleted, or overdue.
  React.useEffect(() => {
    if (!inProgressTaskId) return
    const t = todos.find((x) => x.id === inProgressTaskId)
    if (!t || t.completed) {
      setInProgressTaskId(null)
      return
    }
  }, [inProgressTaskId, nowMs, todos])

  const nextUpcoming = React.useMemo(() => {
    const upcoming = todos
      .filter((t) => !t.completed)
      .map((t) => ({ todo: t, dueMs: parseLocalDateTime(t.dueAt) }))
      .filter((x) => x.dueMs >= nowMs)
      .sort((a, b) => a.dueMs - b.dueMs)[0]
    return upcoming ?? null
  }, [nowMs, todos])

  React.useEffect(() => {
    // If "next upcoming" changed, allow reminder again (dismiss is per-task).
    if (nextUpcoming && nextUpcoming.todo.id !== dismissedReminderTaskId) return
    if (!nextUpcoming) setDismissedReminderTaskId(null)
  }, [dismissedReminderTaskId, nextUpcoming])

  const reminder = React.useMemo(() => {
    const REMINDER_WINDOW_MIN = 15
    if (!nextUpcoming) return null
    if (dismissedReminderTaskId === nextUpcoming.todo.id) return null
    const mins = minutesUntil(nextUpcoming.dueMs, nowMs)
    if (mins < 0 || mins > REMINDER_WINDOW_MIN) return null
    return { ...nextUpcoming, mins }
  }, [dismissedReminderTaskId, nextUpcoming, nowMs])

  const form = useForm<TodoFormValues>({
    resolver: zodResolver(todoSchema),
    defaultValues: { title: "", description: "", dueAt: "" },
    mode: "onSubmit",
  })

  const summary = React.useMemo(() => {
    const now = new Date()
    const todayKey = localDateKey(now)
    const tomorrow = addDays(now, 1)
    const tomorrowKey = localDateKey(tomorrow)

    const todays = todos.filter((t) => t.dueAt.startsWith(todayKey))
    const todayCompleted = todays.filter((t) => t.completed).length
    const todayPending = todays.length - todayCompleted

    const labels = [
      "00:00–04:00",
      "04:00–08:00",
      "08:00–12:00",
      "12:00–16:00",
      "16:00–20:00",
      "20:00–24:00",
    ]

    // Tomorrow: same 4-hour windows breakdown
    const tomorrowTasks = todos.filter((t) => t.dueAt.startsWith(tomorrowKey))
    const tomorrowBuckets = Array.from({ length: 6 }, () => 0) as number[]
    for (const t of tomorrowTasks) {
      const ms = parseLocalDateTime(t.dueAt)
      const hour = new Date(ms).getHours()
      const idx = Math.floor(hour / 4)
      tomorrowBuckets[idx] = (tomorrowBuckets[idx] ?? 0) + 1
    }

    // Until next week = next 7 days starting tomorrow (local), grouped into 4-hour windows.
    const rangeStart = startOfDay(tomorrow).getTime()
    const rangeEnd = addDays(startOfDay(tomorrow), 7).getTime()
    const buckets = Array.from({ length: 6 }, () => 0) as number[]

    const upcoming = todos.filter((t) => {
      const ms = parseLocalDateTime(t.dueAt)
      return ms >= rangeStart && ms < rangeEnd
    })

    for (const t of upcoming) {
      const ms = parseLocalDateTime(t.dueAt)
      const hour = new Date(ms).getHours()
      const idx = Math.floor(hour / 4)
      buckets[idx] = (buckets[idx] ?? 0) + 1
    }

    return {
      todayCompleted,
      todayPending,
      tomorrowTotal: tomorrowTasks.length,
      tomorrowBuckets: labels.map((label, i) => ({ label, count: tomorrowBuckets[i] ?? 0 })),
      upcomingTotal: upcoming.length,
      upcomingBuckets: labels.map((label, i) => ({ label, count: buckets[i] ?? 0 })),
    }
  }, [todos])

  const loadDayKey = React.useMemo(() => {
    // Prefer an explicitly selected date from filters; otherwise use today.
    if (filterMode === "exact" && filterExactDate) return filterExactDate
    if (filterFromDate && !filterToDate) return filterFromDate
    if (filterFromDate && filterToDate && filterFromDate === filterToDate) return filterFromDate
    if (!filterFromDate && filterToDate) return filterToDate
    return localDateKey(new Date(nowMs))
  }, [filterExactDate, filterFromDate, filterMode, filterToDate, nowMs])

  const dailyLoad = React.useMemo(() => {
    const dayTodos = todos.filter((t) => getDatePart(t.dueAt) === loadDayKey)
    return getDailyLoad(dayTodos)
  }, [loadDayKey, todos])

  const filteredTodos = React.useMemo(() => {
    if (focusMode) {
      const endMs = nowMs + 4 * 60 * 60 * 1000
      const withMs = todos.map((t) => ({ ...t, _dueMs: parseLocalDateTime(t.dueAt) }))
      return withMs.filter((t) => t._dueMs >= nowMs && t._dueMs <= endMs)
    }

    const withMs = todos.map((t) => ({ ...t, _dueMs: parseLocalDateTime(t.dueAt) }))
    if (filterMode === "exact") {
      // If only date is selected -> show tasks for that date.
      // If time is selected too -> match exact date+time.
      // If only time is selected -> match time-of-day across all dates.
      if (!filterExactDate && !filterExactTime) return withMs

      if (filterExactDate && !filterExactTime) {
        return withMs.filter((t) => getDatePart(t.dueAt) === filterExactDate)
      }

      if (filterExactDate && filterExactTime) {
        const exactMs = parseLocalDateTime(`${filterExactDate}T${filterExactTime}`)
        return withMs.filter((t) => t._dueMs === exactMs)
      }

      // time only
      return withMs.filter((t) => getTimePart(t.dueAt) === filterExactTime)
    }
    // between
    const hasAnyDate = Boolean(filterFromDate || filterToDate)
    const hasAnyTime = Boolean(filterFromTime || filterToTime)

    // Date range (optional)
    const fromDateMs = filterFromDate
      ? startOfDay(parseLocalDateOnly(filterFromDate)).getTime()
      : Number.NEGATIVE_INFINITY
    const toDateMs = filterToDate
      ? endOfDay(parseLocalDateOnly(filterToDate)).getTime()
      : Number.POSITIVE_INFINITY

    // Time-of-day range (optional)
    const fromTimeMin = filterFromTime ? parseLocalTimeToMinutes(filterFromTime) : 0
    const toTimeMin = filterToTime ? parseLocalTimeToMinutes(filterToTime) : 24 * 60 - 1

    return withMs.filter((t) => {
      const ms = t._dueMs
      if (hasAnyDate && (ms < fromDateMs || ms > toDateMs)) return false

      if (hasAnyTime) {
        const time = getTimePart(t.dueAt)
        if (!time) return false
        const mins = parseLocalTimeToMinutes(time)
        // Simple (non-wrapping) range. If you want wrap-around (e.g. 22:00–02:00), tell me.
        if (mins < fromTimeMin || mins > toTimeMin) return false
      }

      // If neither date nor time selected, pass through (handled above anyway)
      return true
    })
  }, [
    todos,
    focusMode,
    nowMs,
    filterExactDate,
    filterExactTime,
    filterFromDate,
    filterFromTime,
    filterMode,
    filterToDate,
    filterToTime,
  ])

  const sortedFilteredTodos = React.useMemo(
    () =>
      filteredTodos
        .slice()
        .sort((a, b) => parseLocalDateTime(a.dueAt) - parseLocalDateTime(b.dueAt)),
    [filteredTodos]
  )

  // Clamp page when filters/pageSize change.
  React.useEffect(() => {
    const totalPages = Math.max(1, Math.ceil(sortedFilteredTodos.length / pageSize))
    setPage((p) => Math.min(Math.max(1, p), totalPages))
  }, [pageSize, sortedFilteredTodos.length])

  const totalItems = sortedFilteredTodos.length
  const totalPages = Math.max(1, Math.ceil(totalItems / pageSize))
  const showPagination = totalPages > 1

  const pageItems = React.useMemo(() => {
    const start = (page - 1) * pageSize
    return sortedFilteredTodos.slice(start, start + pageSize)
  }, [page, pageSize, sortedFilteredTodos])

  const groupedTodos = React.useMemo(() => {
    const groups: Array<{ date: string; items: typeof pageItems }> = []
    for (const t of pageItems) {
      const date = getDatePart(t.dueAt)
      const last = groups[groups.length - 1]
      if (!last || last.date !== date) groups.push({ date, items: [t] })
      else last.items.push(t)
    }
    return groups
  }, [pageItems])

  const completedCount = filteredTodos.filter((t) => t.completed).length

  async function addTodo(values: TodoFormValues) {
    const conflicts = todos.filter((t) => t.dueAt === values.dueAt)
    if (conflicts.length > 0) {
      setConflictDueAt(values.dueAt)
      if (clearConflictTimerRef.current) window.clearTimeout(clearConflictTimerRef.current)
      clearConflictTimerRef.current = window.setTimeout(() => {
        setConflictDueAt(null)
      }, 8000)

      // Make sure the user can see the conflicting tasks even if they were filtered out.
      const [d, time] = values.dueAt.split("T")
      setFilterMode("exact")
      setFilterExactDate(d ?? "")
      setFilterExactTime(time ?? "")
      setPage(1)

      toast.error("Time conflict", {
        description: `You already have ${conflicts.length} task(s) scheduled at ${formatLocalDateTime(
          values.dueAt
        )}.`,
      })
    }

    try {
      const data = await apiFetch<{ task: Todo }>("/api/tasks", {
        method: "POST",
        body: JSON.stringify(values),
      })
      setTodos((prev) => [data.task, ...prev])
    } catch (e) {
      toast.error("Failed to add task", { description: e instanceof Error ? e.message : "Failed." })
      return
    }
    form.reset()
  }

  async function toggleTodo(id: string, completed: boolean) {
    // optimistic
    setTodos((prev) =>
      prev.map((t) =>
        t.id === id ? { ...t, completed, attachments: t.attachments } : t
      )
    )
    if (completed) setInProgressTaskId((cur) => (cur === id ? null : cur))

    const update: { completed: boolean; in_progress?: boolean } = { completed }
    if (completed) update.in_progress = false

    try {
      await apiFetch("/api/tasks/" + id, {
        method: "PATCH",
        body: JSON.stringify({ completed }),
      })
    } catch (e) {
      toast.error("Failed to update task", { description: e instanceof Error ? e.message : "Failed." })
    }
  }

  function requestAttachmentsForTodo(todoId: string) {
    setAttachTargetTodoId(todoId)
    // Let state update before opening picker (some browsers are picky).
    queueMicrotask(() => fileInputRef.current?.click())
  }

  async function handleFilesPicked(e: React.ChangeEvent<HTMLInputElement>) {
    const files = Array.from(e.target.files ?? [])
    const targetId = attachTargetTodoId

    // reset input so picking the same file again triggers onChange
    e.target.value = ""
    setAttachTargetTodoId(null)

    if (!targetId || files.length === 0) return
    const form = new FormData()
    for (const f of files) form.append("files", f)
    try {
      const res = await fetch(`/api/tasks/${targetId}/attachments`, {
        method: "POST",
        credentials: "include",
        body: form,
      })
      const json = (await res.json().catch(() => null)) as
        | { ok: true; data: { task: Todo } }
        | { ok: false; error: { message: string } }
        | null
      if (!json || !json.ok) throw new Error(json?.error.message ?? "Upload failed.")
      setTodos((prev) => prev.map((t) => (t.id === targetId ? json.data.task : t)))
    } catch (e) {
      toast.error("Upload failed", { description: e instanceof Error ? e.message : "Failed." })
    }
  }

  async function deleteTodo(id: string) {
    // optimistic
    setTodos((prev) => prev.filter((t) => t.id !== id))
    setInProgressTaskId((cur) => (cur === id ? null : cur))

    try {
      await apiFetch("/api/tasks/" + id, { method: "DELETE" })
    } catch (e) {
      toast.error("Failed to delete task", { description: e instanceof Error ? e.message : "Failed." })
    }
  }

  async function setInProgress(taskId: string | null) {
    // optimistic
    setInProgressTaskId(taskId)

    try {
      const data = await apiFetch<{ inProgressTaskId: string | null }>("/api/tasks/in-progress", {
        method: "POST",
        body: JSON.stringify({ id: taskId }),
      })
      setInProgressTaskId(data.inProgressTaskId)
    } catch (e) {
      toast.error("Failed to update in-progress", {
        description: e instanceof Error ? e.message : "Failed.",
      })
    }
  }

  async function downloadAttachment(a: Attachment) {
    try {
      const data = await apiFetch<{ signedUrl: string }>("/api/attachments/signed-url", {
        method: "POST",
        body: JSON.stringify({ bucket: a.bucket, path: a.path }),
      })
      window.open(data.signedUrl, "_blank", "noopener,noreferrer")
    } catch (e) {
      toast.error("Download failed", { description: e instanceof Error ? e.message : "Failed." })
    }
  }

  async function seedDemoTasks() {
    if (todos.length > 0) return
    try {
      const data = await apiFetch<{ tasks: Todo[] }>("/api/tasks/seed", {
        method: "POST",
        body: JSON.stringify({ tasks: initialTodos }),
      })
      setTodos(data.tasks)
    } catch (e) {
      toast.error("Failed to seed demo tasks", { description: e instanceof Error ? e.message : "Failed." })
    }
  }

  async function clearCompleted() {
    const completedIds = new Set(todos.filter((t) => t.completed).map((t) => t.id))
    if (completedIds.size === 0) return

    // optimistic
    setTodos((prev) => prev.filter((t) => !completedIds.has(t.id)))

    try {
      await apiFetch("/api/tasks/clear-completed", { method: "POST" })
    } catch (e) {
      toast.error("Failed to clear completed", { description: e instanceof Error ? e.message : "Failed." })
    }
  }

  return (
    <Card>
      <CardHeader className="flex flex-row items-center justify-between gap-4">
        <div className="space-y-1">
          <CardTitle className="text-2xl">To‑Do</CardTitle>
          <p className="text-muted-foreground text-sm">
            {completedCount}/{filteredTodos.length} completed
          </p>
        </div>
        <div className="flex items-center gap-2">
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <Button
                  type="button"
                  variant={focusMode ? "default" : "outline"}
                  size="sm"
                  onClick={() => {
                    setFocusMode((v) => !v)
                    setPage(1)
                  }}
                >
                  Focus Mode
                </Button>
              </TooltipTrigger>
              <TooltipContent>
                <p>Show tasks for the next 4 hours.</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
          <Button
            type="button"
            variant="outline"
            size="sm"
            onClick={async () => {
              await apiFetch("/api/auth/sign-out", { method: "POST" }).catch(() => {})
              onSignedOut()
            }}
          >
            Sign out
          </Button>
          <ModeToggle />
        </div>
      </CardHeader>

      <CardContent className="space-y-6">
        {tasksLoading && (
          <p className="text-muted-foreground text-sm">Loading tasks…</p>
        )}

        {!tasksLoading && todos.length === 0 && (
          <div className="flex items-center justify-between gap-3 rounded-lg border bg-muted/20 px-3 py-2">
            <p className="text-muted-foreground text-sm">No tasks yet.</p>
            <Button type="button" variant="outline" size="sm" onClick={() => void seedDemoTasks()}>
              Seed demo tasks
            </Button>
          </div>
        )}

        <input
          ref={fileInputRef}
          type="file"
          multiple
          className="hidden"
          accept={[
            "image/*",
            "audio/*",
            "video/*",
            ".pdf",
            ".doc",
            ".docx",
            ".xls",
            ".xlsx",
            ".csv",
            ".txt",
            ".md",
            ".rtf",
          ].join(",")}
          onChange={handleFilesPicked}
        />

        {reminder && (
          <Alert className="border-primary/30 bg-primary/5">
            <Bell className="h-4 w-4" />
            <div className="flex flex-1 flex-col gap-1">
              <div className="flex flex-wrap items-center justify-between gap-2">
                <AlertTitle className="text-sm">
                  Next task starts in {reminder.mins} minute{reminder.mins === 1 ? "" : "s"}
                </AlertTitle>
                <Button
                  type="button"
                  variant="ghost"
                  size="sm"
                  onClick={() => setDismissedReminderTaskId(reminder.todo.id)}
                >
                  Dismiss
                </Button>
              </div>
              <AlertDescription className="text-sm">
                <span className="font-medium">{reminder.todo.title}</span> ·{" "}
                {formatDateTimeFromMs(reminder.dueMs)}
              </AlertDescription>
            </div>
          </Alert>
        )}

        <div className="rounded-xl border bg-card p-4">
          <div className="flex flex-wrap items-center justify-between gap-2">
            <p className="text-sm font-medium">
              Daily load{" "}
              <span className="text-muted-foreground font-normal">
                ({new Intl.DateTimeFormat(undefined, {
                  weekday: "short",
                  year: "numeric",
                  month: "short",
                  day: "2-digit",
                }).format(parseLocalDateOnly(loadDayKey))})
              </span>
            </p>
            <DailyLoadBadge load={dailyLoad.load} />
          </div>
          <p className="text-muted-foreground mt-2 text-sm">
            {dailyLoad.total} task(s) · busiest window {dailyLoad.busiestWindow} ({dailyLoad.peak})
          </p>
        </div>

        <div className="grid gap-3 sm:grid-cols-3">
          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Today’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">
              {summary.todayCompleted} completed
            </p>
            <p className="text-muted-foreground text-sm">{summary.todayPending} pending</p>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tomorrow’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">{summary.tomorrowTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.tomorrowBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tasks Until Next Week</p>
            <p className="mt-2 text-2xl font-semibold">{summary.upcomingTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.upcomingBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>
        </div>

        {focusMode && (
          <div className="flex flex-col gap-1 rounded-lg border bg-muted/20 px-3 py-2 sm:flex-row sm:items-center sm:justify-between">
            <p className="text-sm">
              <span className="font-medium">Focus Mode:</span>{" "}
              showing tasks due in the next 4 hours (until{" "}
              <span className="font-medium">
                {formatDateTimeFromMs(nowMs + 4 * 60 * 60 * 1000)}
              </span>
              )
            </p>
            <Button type="button" variant="ghost" size="sm" onClick={() => setFocusMode(false)}>
              Exit
            </Button>
          </div>
        )}

        <Form {...form}>
          <form
            onSubmit={form.handleSubmit(addTodo)}
            className="space-y-2"
            noValidate
          >
            <div className="flex flex-col gap-2 sm:flex-row">
              <FormField
                control={form.control}
                name="title"
                render={({ field }) => (
                  <FormItem className="flex-1">
                    <FormControl>
                      <Input
                        placeholder="Add a task…"
                        autoComplete="off"
                        {...field}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="dueAt"
                render={({ field }) => (
                  <FormItem className="sm:w-64">
                    <FormControl>
                      <Input type="datetime-local" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <Button type="submit">Add</Button>
            </div>

            <FormField
              control={form.control}
              name="description"
              render={({ field }) => (
                <FormItem>
                  <FormControl>
                    <Textarea
                      rows={3}
                      placeholder="Description (optional)…"
                      {...field}
                    />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />
          </form>
        </Form>

        <Separator />

        <div className="space-y-3">
          <div className="flex flex-wrap items-center justify-between gap-2">
            <p className="text-sm font-medium">Filter by date & time</p>
            <div className="flex items-center gap-2">
              <Button
                type="button"
                size="sm"
                variant={filterMode === "between" ? "default" : "outline"}
                onClick={() => setFilterMode("between")}
              >
                Between
              </Button>
              <Button
                type="button"
                size="sm"
                variant={filterMode === "exact" ? "default" : "outline"}
                onClick={() => setFilterMode("exact")}
              >
                Exact
              </Button>
              <Button
                type="button"
                size="sm"
                variant="ghost"
                onClick={() => {
                  setFilterFromDate("")
                  setFilterFromTime("")
                  setFilterToDate("")
                  setFilterToTime("")
                  setFilterExactDate("")
                  setFilterExactTime("")
                }}
              >
                Clear
              </Button>
            </div>
          </div>

          {filterMode === "between" ? (
            <div className="grid gap-2 sm:grid-cols-2">
              <div className="grid gap-2 sm:grid-cols-2">
                <Input
                  type="date"
                  value={filterFromDate}
                  onChange={(e) => setFilterFromDate(e.target.value)}
                />
                <Input
                  type="time"
                  value={filterFromTime}
                  onChange={(e) => setFilterFromTime(e.target.value)}
                />
              </div>
              <div className="grid gap-2 sm:grid-cols-2">
                <Input
                  type="date"
                  value={filterToDate}
                  onChange={(e) => setFilterToDate(e.target.value)}
                />
                <Input
                  type="time"
                  value={filterToTime}
                  onChange={(e) => setFilterToTime(e.target.value)}
                />
              </div>
            </div>
          ) : (
            <div className="grid gap-2 sm:grid-cols-2">
              <Input
                type="date"
                value={filterExactDate}
                onChange={(e) => setFilterExactDate(e.target.value)}
              />
              <Input
                type="time"
                value={filterExactTime}
                onChange={(e) => setFilterExactTime(e.target.value)}
              />
            </div>
          )}
        </div>

        <Separator />

        <div className="space-y-2">
          {groupedTodos.length === 0 ? (
            <p className="text-muted-foreground text-sm">No tasks yet.</p>
          ) : (
            groupedTodos.map((group) => (
              <div key={group.date} className="space-y-2">
                <div className="flex items-center gap-3 pt-2">
                  <Separator className="flex-1" />
                  <span className="text-muted-foreground whitespace-nowrap text-xs font-medium">
                    {new Intl.DateTimeFormat(undefined, {
                      weekday: "short",
                      year: "numeric",
                      month: "short",
                      day: "2-digit",
                    }).format(parseLocalDateOnly(group.date))}
                  </span>
                  <Separator className="flex-1" />
                </div>

                {group.items.map((todo) => {
                  const flags = getTaskFlags(todo, nowMs, inProgressTaskId)

                  return (
                    <div
                      key={todo.id}
                      className={cn(
                        "rounded-lg border px-3 py-2",
                        flags.completed && "opacity-75",
                        flags.overdue &&
                          "border-destructive/40 bg-destructive/5 text-muted-foreground",
                        flags.inProgress && "border-sky-500/40 bg-sky-500/10",
                        conflictDueAt &&
                          todo.dueAt === conflictDueAt &&
                          "border-destructive/60 bg-destructive/5 ring-1 ring-destructive/30"
                      )}
                    >
                      <div className="flex items-start justify-between gap-3">
                        <label className="flex cursor-pointer items-start gap-3">
                        <Checkbox
                          checked={todo.completed}
                          onCheckedChange={(v) => {
                            const next = Boolean(v)
                            toggleTodo(todo.id, next)
                            if (next && !todo.completed) {
                              requestAttachmentsForTodo(todo.id)
                            }
                          }}
                          aria-label={`Mark "${todo.title}" as ${
                            todo.completed ? "not completed" : "completed"
                          }`}
                          className="mt-0.5"
                        />
                        <span
                          className={cn(
                            "leading-6",
                            todo.completed && "text-muted-foreground line-through"
                          )}
                        >
                          <span className="flex flex-wrap items-center gap-2">
                            <span className="block">{todo.title}</span>
                              <span className="flex flex-wrap items-center gap-2">
                                <TaskBadges {...flags} />
                              </span>
                            {todo.description && (
                              <TooltipProvider>
                                <Tooltip>
                                  <TooltipTrigger asChild>
                                    <button
                                      type="button"
                                      className="text-muted-foreground hover:text-foreground inline-flex h-7 w-7 items-center justify-center rounded-md border bg-background"
                                      aria-label="View description"
                                    >
                                      <Info className="h-4 w-4" />
                                    </button>
                                  </TooltipTrigger>
                                  <TooltipContent className="max-w-xs">
                                    <p className="whitespace-pre-wrap text-sm">
                                      {todo.description}
                                    </p>
                                  </TooltipContent>
                                </Tooltip>
                              </TooltipProvider>
                            )}
                          </span>
                          <span className="text-muted-foreground block text-xs">
                            Due: {formatLocalDateTime(todo.dueAt)}
                          </span>
                        </span>
                      </label>

                      <div className="flex items-center gap-1">
                        {!todo.completed && (
                          <Button
                            type="button"
                            variant={flags.inProgress ? "default" : "outline"}
                            size="sm"
                            onClick={() => void setInProgress(flags.inProgress ? null : todo.id)}
                            className={cn(
                              flags.inProgress && "bg-sky-600 hover:bg-sky-600"
                            )}
                          >
                            {flags.inProgress ? (
                              <>
                                <CircleStop className="mr-1 h-4 w-4" />
                                Stop
                              </>
                            ) : (
                              <>
                                <CirclePlay className="mr-1 h-4 w-4" />
                                Start
                              </>
                            )}
                          </Button>
                        )}
                        {todo.completed && (
                          <Button
                            type="button"
                            variant="outline"
                            size="sm"
                            onClick={() => requestAttachmentsForTodo(todo.id)}
                          >
                            Add files
                          </Button>
                        )}
                        <Button
                          type="button"
                          variant="ghost"
                          size="icon"
                          aria-label={`Delete "${todo.title}"`}
                          onClick={() => deleteTodo(todo.id)}
                        >
                          <Trash2 className="h-4 w-4" />
                        </Button>
                      </div>
                    </div>

                    {todo.completed && todo.attachments.length > 0 && (
                      <div className="mt-3 space-y-2">
                        <p className="text-muted-foreground text-xs">Attachments</p>
                        <ul className="space-y-1">
                          {todo.attachments.map((a) => (
                            <li
                              key={a.id}
                              className="flex items-center justify-between gap-3 rounded-md bg-muted/30 px-2 py-1"
                            >
                              <div className="flex min-w-0 items-center gap-2">
                                <AttachmentIcon kind={a.kind} />
                                <span className="truncate text-sm">{a.name}</span>
                              </div>
                              <button
                                type="button"
                                onClick={() => void downloadAttachment(a)}
                                className="inline-flex items-center gap-1 text-sm font-medium underline underline-offset-4"
                              >
                                <Download className="h-4 w-4" />
                                Download
                              </button>
                            </li>
                          ))}
                        </ul>
                      </div>
                    )}
                  </div>
                  )
                })}
              </div>
            ))
          )}
        </div>

        {groupedTodos.length > 0 && (
          <div className="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
            <div className="flex items-center gap-2">
              <span className="text-muted-foreground text-sm">Items per page</span>
              <Select
                value={String(pageSize)}
                onValueChange={(v) => {
                  const next = Number(v)
                  setPageSize(next)
                  setPage(1)
                }}
              >
                <SelectTrigger className="w-[110px]">
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="5">5</SelectItem>
                  <SelectItem value="10">10</SelectItem>
                  <SelectItem value="15">15</SelectItem>
                  <SelectItem value="20">20</SelectItem>
                </SelectContent>
              </Select>
            </div>

            {showPagination && (
              <div className="flex items-center justify-between gap-3 sm:justify-end">
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={() => setPage((p) => Math.max(1, p - 1))}
                  disabled={page <= 1}
                >
                  Prev
                </Button>
                <span className="text-muted-foreground text-sm">
                  Page {page} of {totalPages}
                </span>
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={() => setPage((p) => Math.min(totalPages, p + 1))}
                  disabled={page >= totalPages}
                >
                  Next
                </Button>
              </div>
            )}
          </div>
        )}

        <div className="flex items-center justify-between gap-2">
          <Button
            type="button"
            variant="secondary"
            onClick={clearCompleted}
            disabled={completedCount === 0}
          >
            Clear completed
          </Button>
          <span className="text-muted-foreground text-sm">
            v 1.1.0
          </span>
    </div>
      </CardContent>
    </Card>
  )
}

```

```typescriptreact
*** Begin Patch
*** Update File: src/app/page.tsx
@@
-function sanitizePathSegment(s: string) {
-  return s.replace(/[^\w.\-]+/g, "_")
-}
-
-function buildAttachmentRecord(file: File, bucket: string, path: string): Attachment {
-  return {
-    id: crypto.randomUUID(),
-    name: file.name,
-    type: file.type,
-    size: file.size,
-    bucket,
-    path,
-    kind: getAttachmentKind(file),
-  }
-}
-
 function revokeTodoAttachments(todo: Todo) {
   for (const a of todo.attachments) URL.revokeObjectURL(a.url)
 }
*** End Patch
```

```typescriptreact
"use client"

import { zodResolver } from "@hookform/resolvers/zod"
import {
  AlertTriangle,
  CirclePlay,
  CircleStop,
  CalendarClock,
  CheckCircle2,
  Download,
  File,
  FileSpreadsheet,
  FileText,
  Image as ImageIcon,
  Info,
  Music,
  Bell,
  Timer,
  Trash2,
  Video,
} from "lucide-react"
import * as React from "react"
import { useForm } from "react-hook-form"
import { toast } from "sonner"
import { z } from "zod"
// Supabase is accessed via Next.js API routes (see src/app/api/**). No direct client usage here.

import { ModeToggle } from "@/components/mode-toggle"
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert"
import { Badge } from "@/components/ui/badge"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Checkbox } from "@/components/ui/checkbox"
import { Form, FormControl, FormField, FormItem, FormMessage } from "@/components/ui/form"
import { Input } from "@/components/ui/input"
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select"
import { Separator } from "@/components/ui/separator"
import { Textarea } from "@/components/ui/textarea"
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip"
import { cn } from "@/lib/utils"
import { apiFetch, ApiError } from "@/lib/api-client"

type AttachmentKind =
  | "image"
  | "audio"
  | "video"
  | "pdf"
  | "spreadsheet"
  | "document"
  | "text"
  | "file"

type Attachment = {
  id: string
  name: string
  type: string
  size: number
  bucket: string
  path: string
  kind: AttachmentKind
}

type Todo = {
  id: string
  title: string
  description?: string
  completed: boolean
  // Stored as `datetime-local` string (YYYY-MM-DDTHH:mm) in local time.
  dueAt: string
  attachments: Attachment[]
}

type TaskState = "planned" | "in_progress" | "completed" | "overdue"
type DailyLoad = "light" | "balanced" | "heavy"

const todoSchema = z.object({
  title: z
    .string()
    .trim()
    .min(1, "Title is required.")
    .max(80, "Keep it under 80 characters."),
  description: z
    .string()
    .trim()
    .max(500, "Keep it under 500 characters.")
    .optional()
    .or(z.literal("")),
  dueAt: z
    .string()
    .min(1, "Due date & time is required.")
    .regex(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}$/, "Invalid date/time."),
})

type TodoFormValues = z.infer<typeof todoSchema>

const initialTodos: Todo[] = [
  {
    id: "1",
    title: "Create a Next.js app",
    description: "Scaffold with TypeScript + Tailwind and confirm it runs locally.",
    completed: true,
    dueAt: "2026-01-16T09:00",
    attachments: [],
  },
  {
    id: "2",
    title: "Add shadcn/ui + dark theme",
    description: "Initialize shadcn, set up theme provider, and verify dark mode.",
    completed: true,
    dueAt: "2026-01-16T10:30",
    attachments: [],
  },
  {
    id: "3",
    title: "Build a mock-data to-do list",
    completed: false,
    dueAt: "2026-01-16T15:00",
    attachments: [],
  },
  {
    id: "4",
    title: "Yesterday: review requirements",
    completed: true,
    dueAt: "2026-01-15T11:15",
    attachments: [],
  },
  {
    id: "5",
    title: "Yesterday: sketch UI layout",
    completed: true,
    dueAt: "2026-01-15T17:45",
    attachments: [],
  },
  {
    id: "6",
    title: "Today: add attachments support",
    completed: false,
    dueAt: "2026-01-16T18:20",
    attachments: [],
  },
  {
    id: "7",
    title: "Tomorrow: QA the filters",
    description: "Test date-only, time-only, exact, and between behaviors.",
    completed: false,
    dueAt: "2026-01-17T08:05",
    attachments: [],
  },
  {
    id: "8",
    title: "Tomorrow: polish summary cards",
    completed: false,
    dueAt: "2026-01-17T13:30",
    attachments: [],
  },
  {
    id: "9",
    title: "Tomorrow: write small UX notes",
    completed: false,
    dueAt: "2026-01-17T20:10",
    attachments: [],
  },
  {
    id: "10",
    title: "This weekend: add more mock tasks",
    completed: false,
    dueAt: "2026-01-18T10:00",
    attachments: [],
  },
  {
    id: "11",
    title: "This weekend: check time-only filter",
    completed: false,
    dueAt: "2026-01-18T22:15",
    attachments: [],
  },
  {
    id: "12",
    title: "Next week: sync with team",
    completed: false,
    dueAt: "2026-01-19T09:30",
    attachments: [],
  },
  {
    id: "13",
    title: "Next week: test date-only filter",
    completed: false,
    dueAt: "2026-01-20T14:05",
    attachments: [],
  },
  {
    id: "14",
    title: "Next week: test exact date+time filter",
    completed: false,
    dueAt: "2026-01-21T12:00",
    attachments: [],
  },
  {
    id: "15",
    title: "Next week: attach docs to completed tasks",
    completed: false,
    dueAt: "2026-01-22T16:40",
    attachments: [],
  },
  {
    id: "16",
    title: "Next week: final review",
    completed: false,
    dueAt: "2026-01-23T11:00",
    attachments: [],
  },
]

function parseLocalDateTime(value: string): number {
  // value: "YYYY-MM-DDTHH:mm"
  const [datePart, timePart] = value.split("T")
  const [y, m, d] = datePart.split("-").map(Number)
  const [hh, mm] = timePart.split(":").map(Number)
  return new Date(y, m - 1, d, hh, mm, 0, 0).getTime()
}

function pad2(n: number) {
  return String(n).padStart(2, "0")
}

function localDateKey(d: Date) {
  return `${d.getFullYear()}-${pad2(d.getMonth() + 1)}-${pad2(d.getDate())}`
}

function addDays(date: Date, days: number) {
  const d = new Date(date)
  d.setDate(d.getDate() + days)
  return d
}

function startOfDay(date: Date) {
  return new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0, 0)
}

function endOfDay(date: Date) {
  return new Date(
    date.getFullYear(),
    date.getMonth(),
    date.getDate(),
    23,
    59,
    59,
    999
  )
}

function getDatePart(dueAt: string) {
  return dueAt.split("T")[0] ?? ""
}

function getTimePart(dueAt: string) {
  return dueAt.split("T")[1] ?? ""
}

function parseLocalDateOnly(value: string): Date {
  // value: "YYYY-MM-DD"
  const [y, m, d] = value.split("-").map(Number)
  return new Date(y, m - 1, d, 0, 0, 0, 0)
}

function parseLocalTimeToMinutes(value: string): number {
  // value: "HH:mm"
  const [hh, mm] = value.split(":").map(Number)
  return hh * 60 + mm
}

function formatLocalDateTime(value: string): string {
  const ms = parseLocalDateTime(value)
  if (!Number.isFinite(ms)) return value
  return new Intl.DateTimeFormat(undefined, {
    year: "numeric",
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  }).format(new Date(ms))
}

function formatDateTimeFromMs(ms: number): string {
  return new Intl.DateTimeFormat(undefined, {
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  }).format(new Date(ms))
}

function minutesUntil(targetMs: number, nowMs: number) {
  return Math.ceil((targetMs - nowMs) / 60_000)
}

function getTaskFlags(todo: Todo, nowMs: number, inProgressTaskId: string | null) {
  const completed = todo.completed
  const dueMs = parseLocalDateTime(todo.dueAt)
  const overdue = !completed && dueMs < nowMs
  const inProgress = !completed && inProgressTaskId === todo.id
  const planned = !completed && !overdue && !inProgress
  return { completed, overdue, inProgress, planned }
}

function getDailyLoad(todosForDay: Todo[]) {
  // 4-hour windows across the day (local).
  const labels = [
    "00:00–04:00",
    "04:00–08:00",
    "08:00–12:00",
    "12:00–16:00",
    "16:00–20:00",
    "20:00–24:00",
  ]
  const buckets = Array.from({ length: 6 }, () => 0) as number[]
  for (const t of todosForDay) {
    const ms = parseLocalDateTime(t.dueAt)
    const hour = new Date(ms).getHours()
    const idx = Math.floor(hour / 4)
    buckets[idx] = (buckets[idx] ?? 0) + 1
  }

  const total = todosForDay.length
  const peak = Math.max(0, ...buckets)
  const spread = buckets.filter((c) => c > 0).length
  const busiestIdx = buckets.findIndex((c) => c === peak)
  const busiestWindow = busiestIdx >= 0 ? labels[busiestIdx] : labels[0]

  // Heuristic: more tasks + higher concentration in one window => heavier day.
  const score = total + peak * 1.5 + Math.max(0, spread - 1) * 0.5
  const load: DailyLoad = score <= 5 ? "light" : score <= 10 ? "balanced" : "heavy"

  return { load, total, peak, spread, busiestWindow }
}

function DailyLoadBadge({ load }: { load: DailyLoad }) {
  if (load === "heavy") return <Badge variant="destructive">Heavy</Badge>
  if (load === "balanced") return <Badge variant="secondary">Balanced</Badge>
  return <Badge variant="outline">Light</Badge>
}

function TaskBadges({
  completed,
  overdue,
  inProgress,
  planned,
}: {
  completed: boolean
  overdue: boolean
  inProgress: boolean
  planned: boolean
}) {
  if (completed) {
    return (
      <Badge className="gap-1 bg-emerald-600 text-white hover:bg-emerald-600">
        <CheckCircle2 className="h-3.5 w-3.5" />
        Completed
      </Badge>
    )
  }

  return (
    <>
      {inProgress && (
        <Badge className="gap-1 bg-sky-600 text-white hover:bg-sky-600">
          <Timer className="h-3.5 w-3.5 text-white" />
          In progress
        </Badge>
      )}
      {overdue && (
        <Badge variant="destructive" className="gap-1">
          <AlertTriangle className="h-3.5 w-3.5" />
          Overdue
        </Badge>
      )}
      {planned && (
        <Badge variant="outline" className="gap-1">
          <CalendarClock className="h-3.5 w-3.5" />
          Planned
        </Badge>
      )}
    </>
  )
}

function getAttachmentKind(file: File): AttachmentKind {
  const type = (file.type || "").toLowerCase()
  const name = file.name.toLowerCase()
  const ext = name.includes(".") ? name.split(".").pop() ?? "" : ""

  if (type.startsWith("image/")) return "image"
  if (type.startsWith("audio/")) return "audio"
  if (type.startsWith("video/")) return "video"

  if (ext === "pdf") return "pdf"
  if (["xls", "xlsx", "csv"].includes(ext)) return "spreadsheet"
  if (["doc", "docx"].includes(ext)) return "document"
  if (["txt", "md", "rtf"].includes(ext)) return "text"

  return "file"
}

function AttachmentIcon({ kind }: { kind: AttachmentKind }) {
  const className = "h-4 w-4 text-muted-foreground"

  switch (kind) {
    case "image":
      return <ImageIcon className={className} />
    case "audio":
      return <Music className={className} />
    case "video":
      return <Video className={className} />
    case "spreadsheet":
      return <FileSpreadsheet className={className} />
    case "pdf":
    case "document":
    case "text":
      return <FileText className={className} />
    default:
      return <File className={className} />
  }
}

const authSchema = z.object({
  email: z.string().email("Enter a valid email."),
  password: z.string().min(6, "Password must be at least 6 characters."),
})
type AuthValues = z.infer<typeof authSchema>

function AuthCard({ onAuthed }: { onAuthed: () => void }) {
  const [mode, setMode] = React.useState<"sign_in" | "sign_up">("sign_in")
  const [busy, setBusy] = React.useState(false)

  const form = useForm<AuthValues>({
    resolver: zodResolver(authSchema),
    defaultValues: { email: "", password: "" },
  })

  async function onSubmit(values: AuthValues) {
    setBusy(true)
    try {
      if (mode === "sign_in") {
        await apiFetch("/api/auth/sign-in", {
          method: "POST",
          body: JSON.stringify(values),
        })
        onAuthed()
      } else {
        await apiFetch("/api/auth/sign-up", {
          method: "POST",
          body: JSON.stringify(values),
        })
        toast.success("Account created", {
          description: "You can now sign in (or confirm email if required).",
        })
        setMode("sign_in")
      }
    } catch (e) {
      toast.error("Authentication failed", {
        description: e instanceof Error ? e.message : "Please try again.",
      })
    } finally {
      setBusy(false)
    }
  }

  return (
    <div className="mx-auto flex min-h-screen max-w-md flex-col justify-center px-4 py-10">
      <Card>
        <CardHeader>
          <CardTitle className="text-2xl">Sign in</CardTitle>
          <p className="text-muted-foreground text-sm">
            {mode === "sign_in"
              ? "Use your email and password."
              : "Create an account with email and password."}
          </p>
        </CardHeader>
        <CardContent className="space-y-4">
          <Form {...form}>
            <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-3" noValidate>
              <FormField
                control={form.control}
                name="email"
                render={({ field }) => (
                  <FormItem>
                    <FormControl>
                      <Input placeholder="Email" autoComplete="email" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="password"
                render={({ field }) => (
                  <FormItem>
                    <FormControl>
                      <Input
                        type="password"
                        placeholder="Password"
                        autoComplete={
                          mode === "sign_in" ? "current-password" : "new-password"
                        }
                        {...field}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <Button type="submit" className="w-full" disabled={busy}>
                {mode === "sign_in" ? "Sign in" : "Sign up"}
              </Button>
            </form>
          </Form>

          <div className="flex items-center justify-between gap-3 text-sm">
            <span className="text-muted-foreground">
              {mode === "sign_in" ? "No account?" : "Already have an account?"}
            </span>
            <Button
              type="button"
              variant="link"
              className="px-0"
              onClick={() => setMode((m) => (m === "sign_in" ? "sign_up" : "sign_in"))}
            >
              {mode === "sign_in" ? "Sign up" : "Sign in"}
            </Button>
          </div>
        </CardContent>
      </Card>
    </div>
  )
}

export default function Home() {
  const [user, setUser] = React.useState<{ id: string; email?: string } | null>(null)
  const [authLoading, setAuthLoading] = React.useState(true)
  const [authError, setAuthError] = React.useState<string | null>(null)

  const refreshAuth = React.useCallback(async () => {
    setAuthLoading(true)
    try {
      const data = await apiFetch<{ user: { id: string; email?: string } | null }>("/api/auth/me")
      setUser(data.user)
      setAuthError(null)
    } catch (e) {
      setUser(null)
      setAuthError(e instanceof Error ? e.message : "Auth check failed.")
    } finally {
      setAuthLoading(false)
    }
  }, [])

  React.useEffect(() => {
    void refreshAuth()
  }, [refreshAuth])

  if (authLoading) {
    return (
      <div className="mx-auto flex min-h-screen max-w-2xl flex-col justify-center px-4 py-10">
        <p className="text-muted-foreground text-sm">Loading…</p>
      </div>
    )
  }

  if (authError) {
    return (
      <div className="mx-auto flex min-h-screen max-w-2xl flex-col justify-center gap-4 px-4 py-10">
        <Card>
          <CardHeader>
            <CardTitle>Auth unavailable</CardTitle>
          </CardHeader>
          <CardContent className="space-y-2">
            <p className="text-muted-foreground text-sm">{authError}</p>
            <p className="text-muted-foreground text-sm">
              Check <code>SUPABASE_SETUP.md</code> and set env vars from{" "}
              <code>supabase.env.example</code>.
            </p>
            <Button type="button" variant="outline" onClick={() => void refreshAuth()}>
              Retry
            </Button>
          </CardContent>
        </Card>
      </div>
    )
  }

  if (!user) return <AuthCard onAuthed={() => void refreshAuth()} />

  return (
    <div className="mx-auto flex min-h-screen max-w-2xl flex-col gap-6 px-4 py-10">
      <TodoApp userId={user.id} onSignedOut={() => void refreshAuth()} />
    </div>
  )
}

function TodoApp({ userId, onSignedOut }: { userId: string; onSignedOut: () => void }) {
  const [todos, setTodos] = React.useState<Todo[]>([])
  const [tasksLoading, setTasksLoading] = React.useState(true)
  const [tasksError, setTasksError] = React.useState<{ code?: string; message: string } | null>(
    null
  )
  const [attachTargetTodoId, setAttachTargetTodoId] = React.useState<string | null>(
    null
  )
  const [conflictDueAt, setConflictDueAt] = React.useState<string | null>(null)
  const clearConflictTimerRef = React.useRef<number | null>(null)
  const [focusMode, setFocusMode] = React.useState(false)
  const [nowMs, setNowMs] = React.useState(() => Date.now())
  const [inProgressTaskId, setInProgressTaskId] = React.useState<string | null>(null)
  const [dismissedReminderTaskId, setDismissedReminderTaskId] = React.useState<
    string | null
  >(null)
  const [filterMode, setFilterMode] = React.useState<"between" | "exact">("between")
  const [filterFromDate, setFilterFromDate] = React.useState<string>("")
  const [filterFromTime, setFilterFromTime] = React.useState<string>("")
  const [filterToDate, setFilterToDate] = React.useState<string>("")
  const [filterToTime, setFilterToTime] = React.useState<string>("")
  const [filterExactDate, setFilterExactDate] = React.useState<string>("")
  const [filterExactTime, setFilterExactTime] = React.useState<string>("")
  const fileInputRef = React.useRef<HTMLInputElement>(null)
  const [pageSize, setPageSize] = React.useState<number>(5)
  const [page, setPage] = React.useState<number>(1)

  React.useEffect(() => {
    let alive = true
    async function load() {
      setTasksLoading(true)
      if (!alive) return
      try {
        const data = await apiFetch<{ tasks: Todo[]; inProgressTaskId: string | null }>("/api/tasks")
        if (!alive) return
        setTodos(data.tasks)
        setInProgressTaskId(data.inProgressTaskId)
        setTasksError(null)
      } catch (e) {
        if (!alive) return
        if (e instanceof ApiError) setTasksError({ code: e.code, message: e.message })
        else setTasksError({ message: e instanceof Error ? e.message : "Failed to load tasks." })
        setTodos([])
        setInProgressTaskId(null)
      } finally {
        setTasksLoading(false)
      }
    }
    load()
    return () => {
      alive = false
    }
  }, [userId])

  // Keep "now" fresh so overdue/in-progress states stay accurate without user interaction.
  React.useEffect(() => {
    const id = window.setInterval(() => setNowMs(Date.now()), 30_000)
    return () => window.clearInterval(id)
  }, [])

  // Only one task can be "In Progress"; auto-clear if completed, deleted, or overdue.
  React.useEffect(() => {
    if (!inProgressTaskId) return
    const t = todos.find((x) => x.id === inProgressTaskId)
    if (!t || t.completed) {
      setInProgressTaskId(null)
      return
    }
  }, [inProgressTaskId, nowMs, todos])

  const nextUpcoming = React.useMemo(() => {
    const upcoming = todos
      .filter((t) => !t.completed)
      .map((t) => ({ todo: t, dueMs: parseLocalDateTime(t.dueAt) }))
      .filter((x) => x.dueMs >= nowMs)
      .sort((a, b) => a.dueMs - b.dueMs)[0]
    return upcoming ?? null
  }, [nowMs, todos])

  React.useEffect(() => {
    // If "next upcoming" changed, allow reminder again (dismiss is per-task).
    if (nextUpcoming && nextUpcoming.todo.id !== dismissedReminderTaskId) return
    if (!nextUpcoming) setDismissedReminderTaskId(null)
  }, [dismissedReminderTaskId, nextUpcoming])

  const reminder = React.useMemo(() => {
    const REMINDER_WINDOW_MIN = 15
    if (!nextUpcoming) return null
    if (dismissedReminderTaskId === nextUpcoming.todo.id) return null
    const mins = minutesUntil(nextUpcoming.dueMs, nowMs)
    if (mins < 0 || mins > REMINDER_WINDOW_MIN) return null
    return { ...nextUpcoming, mins }
  }, [dismissedReminderTaskId, nextUpcoming, nowMs])

  const form = useForm<TodoFormValues>({
    resolver: zodResolver(todoSchema),
    defaultValues: { title: "", description: "", dueAt: "" },
    mode: "onSubmit",
  })

  const summary = React.useMemo(() => {
    const now = new Date()
    const todayKey = localDateKey(now)
    const tomorrow = addDays(now, 1)
    const tomorrowKey = localDateKey(tomorrow)

    const todays = todos.filter((t) => t.dueAt.startsWith(todayKey))
    const todayCompleted = todays.filter((t) => t.completed).length
    const todayPending = todays.length - todayCompleted

    const labels = [
      "00:00–04:00",
      "04:00–08:00",
      "08:00–12:00",
      "12:00–16:00",
      "16:00–20:00",
      "20:00–24:00",
    ]

    // Tomorrow: same 4-hour windows breakdown
    const tomorrowTasks = todos.filter((t) => t.dueAt.startsWith(tomorrowKey))
    const tomorrowBuckets = Array.from({ length: 6 }, () => 0) as number[]
    for (const t of tomorrowTasks) {
      const ms = parseLocalDateTime(t.dueAt)
      const hour = new Date(ms).getHours()
      const idx = Math.floor(hour / 4)
      tomorrowBuckets[idx] = (tomorrowBuckets[idx] ?? 0) + 1
    }

    // Until next week = next 7 days starting tomorrow (local), grouped into 4-hour windows.
    const rangeStart = startOfDay(tomorrow).getTime()
    const rangeEnd = addDays(startOfDay(tomorrow), 7).getTime()
    const buckets = Array.from({ length: 6 }, () => 0) as number[]

    const upcoming = todos.filter((t) => {
      const ms = parseLocalDateTime(t.dueAt)
      return ms >= rangeStart && ms < rangeEnd
    })

    for (const t of upcoming) {
      const ms = parseLocalDateTime(t.dueAt)
      const hour = new Date(ms).getHours()
      const idx = Math.floor(hour / 4)
      buckets[idx] = (buckets[idx] ?? 0) + 1
    }

    return {
      todayCompleted,
      todayPending,
      tomorrowTotal: tomorrowTasks.length,
      tomorrowBuckets: labels.map((label, i) => ({ label, count: tomorrowBuckets[i] ?? 0 })),
      upcomingTotal: upcoming.length,
      upcomingBuckets: labels.map((label, i) => ({ label, count: buckets[i] ?? 0 })),
    }
  }, [todos])

  const loadDayKey = React.useMemo(() => {
    // Prefer an explicitly selected date from filters; otherwise use today.
    if (filterMode === "exact" && filterExactDate) return filterExactDate
    if (filterFromDate && !filterToDate) return filterFromDate
    if (filterFromDate && filterToDate && filterFromDate === filterToDate) return filterFromDate
    if (!filterFromDate && filterToDate) return filterToDate
    return localDateKey(new Date(nowMs))
  }, [filterExactDate, filterFromDate, filterMode, filterToDate, nowMs])

  const dailyLoad = React.useMemo(() => {
    const dayTodos = todos.filter((t) => getDatePart(t.dueAt) === loadDayKey)
    return getDailyLoad(dayTodos)
  }, [loadDayKey, todos])

  const filteredTodos = React.useMemo(() => {
    if (focusMode) {
      const endMs = nowMs + 4 * 60 * 60 * 1000
      const withMs = todos.map((t) => ({ ...t, _dueMs: parseLocalDateTime(t.dueAt) }))
      return withMs.filter((t) => t._dueMs >= nowMs && t._dueMs <= endMs)
    }

    const withMs = todos.map((t) => ({ ...t, _dueMs: parseLocalDateTime(t.dueAt) }))
    if (filterMode === "exact") {
      // If only date is selected -> show tasks for that date.
      // If time is selected too -> match exact date+time.
      // If only time is selected -> match time-of-day across all dates.
      if (!filterExactDate && !filterExactTime) return withMs

      if (filterExactDate && !filterExactTime) {
        return withMs.filter((t) => getDatePart(t.dueAt) === filterExactDate)
      }

      if (filterExactDate && filterExactTime) {
        const exactMs = parseLocalDateTime(`${filterExactDate}T${filterExactTime}`)
        return withMs.filter((t) => t._dueMs === exactMs)
      }

      // time only
      return withMs.filter((t) => getTimePart(t.dueAt) === filterExactTime)
    }
    // between
    const hasAnyDate = Boolean(filterFromDate || filterToDate)
    const hasAnyTime = Boolean(filterFromTime || filterToTime)

    // Date range (optional)
    const fromDateMs = filterFromDate
      ? startOfDay(parseLocalDateOnly(filterFromDate)).getTime()
      : Number.NEGATIVE_INFINITY
    const toDateMs = filterToDate
      ? endOfDay(parseLocalDateOnly(filterToDate)).getTime()
      : Number.POSITIVE_INFINITY

    // Time-of-day range (optional)
    const fromTimeMin = filterFromTime ? parseLocalTimeToMinutes(filterFromTime) : 0
    const toTimeMin = filterToTime ? parseLocalTimeToMinutes(filterToTime) : 24 * 60 - 1

    return withMs.filter((t) => {
      const ms = t._dueMs
      if (hasAnyDate && (ms < fromDateMs || ms > toDateMs)) return false

      if (hasAnyTime) {
        const time = getTimePart(t.dueAt)
        if (!time) return false
        const mins = parseLocalTimeToMinutes(time)
        // Simple (non-wrapping) range. If you want wrap-around (e.g. 22:00–02:00), tell me.
        if (mins < fromTimeMin || mins > toTimeMin) return false
      }

      // If neither date nor time selected, pass through (handled above anyway)
      return true
    })
  }, [
    todos,
    focusMode,
    nowMs,
    filterExactDate,
    filterExactTime,
    filterFromDate,
    filterFromTime,
    filterMode,
    filterToDate,
    filterToTime,
  ])

  const sortedFilteredTodos = React.useMemo(
    () =>
      filteredTodos
        .slice()
        .sort((a, b) => parseLocalDateTime(a.dueAt) - parseLocalDateTime(b.dueAt)),
    [filteredTodos]
  )

  // Clamp page when filters/pageSize change.
  React.useEffect(() => {
    const totalPages = Math.max(1, Math.ceil(sortedFilteredTodos.length / pageSize))
    setPage((p) => Math.min(Math.max(1, p), totalPages))
  }, [pageSize, sortedFilteredTodos.length])

  const totalItems = sortedFilteredTodos.length
  const totalPages = Math.max(1, Math.ceil(totalItems / pageSize))
  const showPagination = totalPages > 1

  const pageItems = React.useMemo(() => {
    const start = (page - 1) * pageSize
    return sortedFilteredTodos.slice(start, start + pageSize)
  }, [page, pageSize, sortedFilteredTodos])

  const groupedTodos = React.useMemo(() => {
    const groups: Array<{ date: string; items: typeof pageItems }> = []
    for (const t of pageItems) {
      const date = getDatePart(t.dueAt)
      const last = groups[groups.length - 1]
      if (!last || last.date !== date) groups.push({ date, items: [t] })
      else last.items.push(t)
    }
    return groups
  }, [pageItems])

  const completedCount = filteredTodos.filter((t) => t.completed).length

  async function addTodo(values: TodoFormValues) {
    const conflicts = todos.filter((t) => t.dueAt === values.dueAt)
    if (conflicts.length > 0) {
      setConflictDueAt(values.dueAt)
      if (clearConflictTimerRef.current) window.clearTimeout(clearConflictTimerRef.current)
      clearConflictTimerRef.current = window.setTimeout(() => {
        setConflictDueAt(null)
      }, 8000)

      // Make sure the user can see the conflicting tasks even if they were filtered out.
      const [d, time] = values.dueAt.split("T")
      setFilterMode("exact")
      setFilterExactDate(d ?? "")
      setFilterExactTime(time ?? "")
      setPage(1)

      toast.error("Time conflict", {
        description: `You already have ${conflicts.length} task(s) scheduled at ${formatLocalDateTime(
          values.dueAt
        )}.`,
      })
    }

    try {
      const data = await apiFetch<{ task: Todo }>("/api/tasks", {
        method: "POST",
        body: JSON.stringify(values),
      })
      setTodos((prev) => [data.task, ...prev])
    } catch (e) {
      toast.error("Failed to add task", { description: e instanceof Error ? e.message : "Failed." })
      return
    }
    form.reset()
  }

  async function toggleTodo(id: string, completed: boolean) {
    // optimistic
    setTodos((prev) =>
      prev.map((t) =>
        t.id === id ? { ...t, completed, attachments: t.attachments } : t
      )
    )
    if (completed) setInProgressTaskId((cur) => (cur === id ? null : cur))

    const update: { completed: boolean; in_progress?: boolean } = { completed }
    if (completed) update.in_progress = false

    try {
      await apiFetch("/api/tasks/" + id, {
        method: "PATCH",
        body: JSON.stringify({ completed }),
      })
    } catch (e) {
      toast.error("Failed to update task", { description: e instanceof Error ? e.message : "Failed." })
    }
  }

  function requestAttachmentsForTodo(todoId: string) {
    setAttachTargetTodoId(todoId)
    // Let state update before opening picker (some browsers are picky).
    queueMicrotask(() => fileInputRef.current?.click())
  }

  async function handleFilesPicked(e: React.ChangeEvent<HTMLInputElement>) {
    const files = Array.from(e.target.files ?? [])
    const targetId = attachTargetTodoId

    // reset input so picking the same file again triggers onChange
    e.target.value = ""
    setAttachTargetTodoId(null)

    if (!targetId || files.length === 0) return
    const form = new FormData()
    for (const f of files) form.append("files", f)
    try {
      const res = await fetch(`/api/tasks/${targetId}/attachments`, {
        method: "POST",
        credentials: "include",
        body: form,
      })
      const json = (await res.json().catch(() => null)) as
        | { ok: true; data: { task: Todo } }
        | { ok: false; error: { message: string } }
        | null
      if (!json || !json.ok) throw new Error(json?.error.message ?? "Upload failed.")
      setTodos((prev) => prev.map((t) => (t.id === targetId ? json.data.task : t)))
    } catch (e) {
      toast.error("Upload failed", { description: e instanceof Error ? e.message : "Failed." })
    }
  }

  async function deleteTodo(id: string) {
    // optimistic
    setTodos((prev) => prev.filter((t) => t.id !== id))
    setInProgressTaskId((cur) => (cur === id ? null : cur))

    try {
      await apiFetch("/api/tasks/" + id, { method: "DELETE" })
    } catch (e) {
      toast.error("Failed to delete task", { description: e instanceof Error ? e.message : "Failed." })
    }
  }

  async function setInProgress(taskId: string | null) {
    // optimistic
    setInProgressTaskId(taskId)

    try {
      const data = await apiFetch<{ inProgressTaskId: string | null }>("/api/tasks/in-progress", {
        method: "POST",
        body: JSON.stringify({ id: taskId }),
      })
      setInProgressTaskId(data.inProgressTaskId)
    } catch (e) {
      toast.error("Failed to update in-progress", {
        description: e instanceof Error ? e.message : "Failed.",
      })
    }
  }

  async function downloadAttachment(a: Attachment) {
    try {
      const data = await apiFetch<{ signedUrl: string }>("/api/attachments/signed-url", {
        method: "POST",
        body: JSON.stringify({ bucket: a.bucket, path: a.path }),
      })
      window.open(data.signedUrl, "_blank", "noopener,noreferrer")
    } catch (e) {
      toast.error("Download failed", { description: e instanceof Error ? e.message : "Failed." })
    }
  }

  async function seedDemoTasks() {
    if (todos.length > 0) return
    try {
      const data = await apiFetch<{ tasks: Todo[] }>("/api/tasks/seed", {
        method: "POST",
        body: JSON.stringify({ tasks: initialTodos }),
      })
      setTodos(data.tasks)
    } catch (e) {
      toast.error("Failed to seed demo tasks", { description: e instanceof Error ? e.message : "Failed." })
    }
  }

  async function clearCompleted() {
    const completedIds = new Set(todos.filter((t) => t.completed).map((t) => t.id))
    if (completedIds.size === 0) return

    // optimistic
    setTodos((prev) => prev.filter((t) => !completedIds.has(t.id)))

    try {
      await apiFetch("/api/tasks/clear-completed", { method: "POST" })
    } catch (e) {
      toast.error("Failed to clear completed", { description: e instanceof Error ? e.message : "Failed." })
    }
  }

  return (
    <Card>
      <CardHeader className="flex flex-row items-center justify-between gap-4">
        <div className="space-y-1">
          <CardTitle className="text-2xl">To‑Do</CardTitle>
          <p className="text-muted-foreground text-sm">
            {completedCount}/{filteredTodos.length} completed
          </p>
        </div>
        <div className="flex items-center gap-2">
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <Button
                  type="button"
                  variant={focusMode ? "default" : "outline"}
                  size="sm"
                  onClick={() => {
                    setFocusMode((v) => !v)
                    setPage(1)
                  }}
                >
                  Focus Mode
                </Button>
              </TooltipTrigger>
              <TooltipContent>
                <p>Show tasks for the next 4 hours.</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
          <Button
            type="button"
            variant="outline"
            size="sm"
            onClick={async () => {
              await apiFetch("/api/auth/sign-out", { method: "POST" }).catch(() => {})
              onSignedOut()
            }}
          >
            Sign out
          </Button>
          <ModeToggle />
        </div>
      </CardHeader>

      <CardContent className="space-y-6">
        {tasksLoading && (
          <p className="text-muted-foreground text-sm">Loading tasks…</p>
        )}

        {!tasksLoading && todos.length === 0 && (
          <div className="flex items-center justify-between gap-3 rounded-lg border bg-muted/20 px-3 py-2">
            <p className="text-muted-foreground text-sm">No tasks yet.</p>
            <Button type="button" variant="outline" size="sm" onClick={() => void seedDemoTasks()}>
              Seed demo tasks
            </Button>
          </div>
        )}

        <input
          ref={fileInputRef}
          type="file"
          multiple
          className="hidden"
          accept={[
            "image/*",
            "audio/*",
            "video/*",
            ".pdf",
            ".doc",
            ".docx",
            ".xls",
            ".xlsx",
            ".csv",
            ".txt",
            ".md",
            ".rtf",
          ].join(",")}
          onChange={handleFilesPicked}
        />

        {reminder && (
          <Alert className="border-primary/30 bg-primary/5">
            <Bell className="h-4 w-4" />
            <div className="flex flex-1 flex-col gap-1">
              <div className="flex flex-wrap items-center justify-between gap-2">
                <AlertTitle className="text-sm">
                  Next task starts in {reminder.mins} minute{reminder.mins === 1 ? "" : "s"}
                </AlertTitle>
                <Button
                  type="button"
                  variant="ghost"
                  size="sm"
                  onClick={() => setDismissedReminderTaskId(reminder.todo.id)}
                >
                  Dismiss
                </Button>
              </div>
              <AlertDescription className="text-sm">
                <span className="font-medium">{reminder.todo.title}</span> ·{" "}
                {formatDateTimeFromMs(reminder.dueMs)}
              </AlertDescription>
            </div>
          </Alert>
        )}

        <div className="rounded-xl border bg-card p-4">
          <div className="flex flex-wrap items-center justify-between gap-2">
            <p className="text-sm font-medium">
              Daily load{" "}
              <span className="text-muted-foreground font-normal">
                ({new Intl.DateTimeFormat(undefined, {
                  weekday: "short",
                  year: "numeric",
                  month: "short",
                  day: "2-digit",
                }).format(parseLocalDateOnly(loadDayKey))})
              </span>
            </p>
            <DailyLoadBadge load={dailyLoad.load} />
          </div>
          <p className="text-muted-foreground mt-2 text-sm">
            {dailyLoad.total} task(s) · busiest window {dailyLoad.busiestWindow} ({dailyLoad.peak})
          </p>
        </div>

        <div className="grid gap-3 sm:grid-cols-3">
          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Today’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">
              {summary.todayCompleted} completed
            </p>
            <p className="text-muted-foreground text-sm">{summary.todayPending} pending</p>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tomorrow’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">{summary.tomorrowTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.tomorrowBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tasks Until Next Week</p>
            <p className="mt-2 text-2xl font-semibold">{summary.upcomingTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.upcomingBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>
        </div>

        {focusMode && (
          <div className="flex flex-col gap-1 rounded-lg border bg-muted/20 px-3 py-2 sm:flex-row sm:items-center sm:justify-between">
            <p className="text-sm">
              <span className="font-medium">Focus Mode:</span>{" "}
              showing tasks due in the next 4 hours (until{" "}
              <span className="font-medium">
                {formatDateTimeFromMs(nowMs + 4 * 60 * 60 * 1000)}
              </span>
              )
            </p>
            <Button type="button" variant="ghost" size="sm" onClick={() => setFocusMode(false)}>
              Exit
            </Button>
          </div>
        )}

        <Form {...form}>
          <form
            onSubmit={form.handleSubmit(addTodo)}
            className="space-y-2"
            noValidate
          >
            <div className="flex flex-col gap-2 sm:flex-row">
              <FormField
                control={form.control}
                name="title"
                render={({ field }) => (
                  <FormItem className="flex-1">
                    <FormControl>
                      <Input
                        placeholder="Add a task…"
                        autoComplete="off"
                        {...field}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="dueAt"
                render={({ field }) => (
                  <FormItem className="sm:w-64">
                    <FormControl>
                      <Input type="datetime-local" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <Button type="submit">Add</Button>
            </div>

            <FormField
              control={form.control}
              name="description"
              render={({ field }) => (
                <FormItem>
                  <FormControl>
                    <Textarea
                      rows={3}
                      placeholder="Description (optional)…"
                      {...field}
                    />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />
          </form>
        </Form>

        <Separator />

        <div className="space-y-3">
          <div className="flex flex-wrap items-center justify-between gap-2">
            <p className="text-sm font-medium">Filter by date & time</p>
            <div className="flex items-center gap-2">
              <Button
                type="button"
                size="sm"
                variant={filterMode === "between" ? "default" : "outline"}
                onClick={() => setFilterMode("between")}
              >
                Between
              </Button>
              <Button
                type="button"
                size="sm"
                variant={filterMode === "exact" ? "default" : "outline"}
                onClick={() => setFilterMode("exact")}
              >
                Exact
              </Button>
              <Button
                type="button"
                size="sm"
                variant="ghost"
                onClick={() => {
                  setFilterFromDate("")
                  setFilterFromTime("")
                  setFilterToDate("")
                  setFilterToTime("")
                  setFilterExactDate("")
                  setFilterExactTime("")
                }}
              >
                Clear
              </Button>
            </div>
          </div>

          {filterMode === "between" ? (
            <div className="grid gap-2 sm:grid-cols-2">
              <div className="grid gap-2 sm:grid-cols-2">
                <Input
                  type="date"
                  value={filterFromDate}
                  onChange={(e) => setFilterFromDate(e.target.value)}
                />
                <Input
                  type="time"
                  value={filterFromTime}
                  onChange={(e) => setFilterFromTime(e.target.value)}
                />
              </div>
              <div className="grid gap-2 sm:grid-cols-2">
                <Input
                  type="date"
                  value={filterToDate}
                  onChange={(e) => setFilterToDate(e.target.value)}
                />
                <Input
                  type="time"
                  value={filterToTime}
                  onChange={(e) => setFilterToTime(e.target.value)}
                />
              </div>
            </div>
          ) : (
            <div className="grid gap-2 sm:grid-cols-2">
              <Input
                type="date"
                value={filterExactDate}
                onChange={(e) => setFilterExactDate(e.target.value)}
              />
              <Input
                type="time"
                value={filterExactTime}
                onChange={(e) => setFilterExactTime(e.target.value)}
              />
            </div>
          )}
        </div>

        <Separator />

        <div className="space-y-2">
          {groupedTodos.length === 0 ? (
            <p className="text-muted-foreground text-sm">No tasks yet.</p>
          ) : (
            groupedTodos.map((group) => (
              <div key={group.date} className="space-y-2">
                <div className="flex items-center gap-3 pt-2">
                  <Separator className="flex-1" />
                  <span className="text-muted-foreground whitespace-nowrap text-xs font-medium">
                    {new Intl.DateTimeFormat(undefined, {
                      weekday: "short",
                      year: "numeric",
                      month: "short",
                      day: "2-digit",
                    }).format(parseLocalDateOnly(group.date))}
                  </span>
                  <Separator className="flex-1" />
                </div>

                {group.items.map((todo) => {
                  const flags = getTaskFlags(todo, nowMs, inProgressTaskId)

                  return (
                    <div
                      key={todo.id}
                      className={cn(
                        "rounded-lg border px-3 py-2",
                        flags.completed && "opacity-75",
                        flags.overdue &&
                          "border-destructive/40 bg-destructive/5 text-muted-foreground",
                        flags.inProgress && "border-sky-500/40 bg-sky-500/10",
                        conflictDueAt &&
                          todo.dueAt === conflictDueAt &&
                          "border-destructive/60 bg-destructive/5 ring-1 ring-destructive/30"
                      )}
                    >
                      <div className="flex items-start justify-between gap-3">
                        <label className="flex cursor-pointer items-start gap-3">
                        <Checkbox
                          checked={todo.completed}
                          onCheckedChange={(v) => {
                            const next = Boolean(v)
                            toggleTodo(todo.id, next)
                            if (next && !todo.completed) {
                              requestAttachmentsForTodo(todo.id)
                            }
                          }}
                          aria-label={`Mark "${todo.title}" as ${
                            todo.completed ? "not completed" : "completed"
                          }`}
                          className="mt-0.5"
                        />
                        <span
                          className={cn(
                            "leading-6",
                            todo.completed && "text-muted-foreground line-through"
                          )}
                        >
                          <span className="flex flex-wrap items-center gap-2">
                            <span className="block">{todo.title}</span>
                              <span className="flex flex-wrap items-center gap-2">
                                <TaskBadges {...flags} />
                              </span>
                            {todo.description && (
                              <TooltipProvider>
                                <Tooltip>
                                  <TooltipTrigger asChild>
                                    <button
                                      type="button"
                                      className="text-muted-foreground hover:text-foreground inline-flex h-7 w-7 items-center justify-center rounded-md border bg-background"
                                      aria-label="View description"
                                    >
                                      <Info className="h-4 w-4" />
                                    </button>
                                  </TooltipTrigger>
                                  <TooltipContent className="max-w-xs">
                                    <p className="whitespace-pre-wrap text-sm">
                                      {todo.description}
                                    </p>
                                  </TooltipContent>
                                </Tooltip>
                              </TooltipProvider>
                            )}
                          </span>
                          <span className="text-muted-foreground block text-xs">
                            Due: {formatLocalDateTime(todo.dueAt)}
                          </span>
                        </span>
                      </label>

                      <div className="flex items-center gap-1">
                        {!todo.completed && (
                          <Button
                            type="button"
                            variant={flags.inProgress ? "default" : "outline"}
                            size="sm"
                            onClick={() => void setInProgress(flags.inProgress ? null : todo.id)}
                            className={cn(
                              flags.inProgress && "bg-sky-600 hover:bg-sky-600"
                            )}
                          >
                            {flags.inProgress ? (
                              <>
                                <CircleStop className="mr-1 h-4 w-4" />
                                Stop
                              </>
                            ) : (
                              <>
                                <CirclePlay className="mr-1 h-4 w-4" />
                                Start
                              </>
                            )}
                          </Button>
                        )}
                        {todo.completed && (
                          <Button
                            type="button"
                            variant="outline"
                            size="sm"
                            onClick={() => requestAttachmentsForTodo(todo.id)}
                          >
                            Add files
                          </Button>
                        )}
                        <Button
                          type="button"
                          variant="ghost"
                          size="icon"
                          aria-label={`Delete "${todo.title}"`}
                          onClick={() => deleteTodo(todo.id)}
                        >
                          <Trash2 className="h-4 w-4" />
                        </Button>
                      </div>
                    </div>

                    {todo.completed && todo.attachments.length > 0 && (
                      <div className="mt-3 space-y-2">
                        <p className="text-muted-foreground text-xs">Attachments</p>
                        <ul className="space-y-1">
                          {todo.attachments.map((a) => (
                            <li
                              key={a.id}
                              className="flex items-center justify-between gap-3 rounded-md bg-muted/30 px-2 py-1"
                            >
                              <div className="flex min-w-0 items-center gap-2">
                                <AttachmentIcon kind={a.kind} />
                                <span className="truncate text-sm">{a.name}</span>
                              </div>
                              <button
                                type="button"
                                onClick={() => void downloadAttachment(a)}
                                className="inline-flex items-center gap-1 text-sm font-medium underline underline-offset-4"
                              >
                                <Download className="h-4 w-4" />
                                Download
                              </button>
                            </li>
                          ))}
                        </ul>
                      </div>
                    )}
                  </div>
                  )
                })}
              </div>
            ))
          )}
        </div>

        {groupedTodos.length > 0 && (
          <div className="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
            <div className="flex items-center gap-2">
              <span className="text-muted-foreground text-sm">Items per page</span>
              <Select
                value={String(pageSize)}
                onValueChange={(v) => {
                  const next = Number(v)
                  setPageSize(next)
                  setPage(1)
                }}
              >
                <SelectTrigger className="w-[110px]">
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="5">5</SelectItem>
                  <SelectItem value="10">10</SelectItem>
                  <SelectItem value="15">15</SelectItem>
                  <SelectItem value="20">20</SelectItem>
                </SelectContent>
              </Select>
            </div>

            {showPagination && (
              <div className="flex items-center justify-between gap-3 sm:justify-end">
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={() => setPage((p) => Math.max(1, p - 1))}
                  disabled={page <= 1}
                >
                  Prev
                </Button>
                <span className="text-muted-foreground text-sm">
                  Page {page} of {totalPages}
                </span>
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={() => setPage((p) => Math.min(totalPages, p + 1))}
                  disabled={page >= totalPages}
                >
                  Next
                </Button>
              </div>
            )}
          </div>
        )}

        <div className="flex items-center justify-between gap-2">
          <Button
            type="button"
            variant="secondary"
            onClick={clearCompleted}
            disabled={completedCount === 0}
          >
            Clear completed
          </Button>
          <span className="text-muted-foreground text-sm">
            v 1.1.0
          </span>
    </div>
      </CardContent>
    </Card>
  )
}

```

```typescriptreact
"use client"

import { zodResolver } from "@hookform/resolvers/zod"
import {
  AlertTriangle,
  CirclePlay,
  CircleStop,
  CalendarClock,
  CheckCircle2,
  Download,
  File,
  FileSpreadsheet,
  FileText,
  Image as ImageIcon,
  Info,
  Music,
  Bell,
  Timer,
  Trash2,
  Video,
} from "lucide-react"
import * as React from "react"
import { useForm } from "react-hook-form"
import { toast } from "sonner"
import { z } from "zod"
// Supabase is accessed via Next.js API routes (see src/app/api/**). No direct client usage here.

import { ModeToggle } from "@/components/mode-toggle"
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert"
import { Badge } from "@/components/ui/badge"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Checkbox } from "@/components/ui/checkbox"
import { Form, FormControl, FormField, FormItem, FormMessage } from "@/components/ui/form"
import { Input } from "@/components/ui/input"
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select"
import { Separator } from "@/components/ui/separator"
import { Textarea } from "@/components/ui/textarea"
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip"
import { cn } from "@/lib/utils"
import { apiFetch, ApiError } from "@/lib/api-client"

type AttachmentKind =
  | "image"
  | "audio"
  | "video"
  | "pdf"
  | "spreadsheet"
  | "document"
  | "text"
  | "file"

type Attachment = {
  id: string
  name: string
  type: string
  size: number
  bucket: string
  path: string
  kind: AttachmentKind
}

type Todo = {
  id: string
  title: string
  description?: string
  completed: boolean
  // Stored as `datetime-local` string (YYYY-MM-DDTHH:mm) in local time.
  dueAt: string
  attachments: Attachment[]
}

type TaskState = "planned" | "in_progress" | "completed" | "overdue"
type DailyLoad = "light" | "balanced" | "heavy"

const todoSchema = z.object({
  title: z
    .string()
    .trim()
    .min(1, "Title is required.")
    .max(80, "Keep it under 80 characters."),
  description: z
    .string()
    .trim()
    .max(500, "Keep it under 500 characters.")
    .optional()
    .or(z.literal("")),
  dueAt: z
    .string()
    .min(1, "Due date & time is required.")
    .regex(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}$/, "Invalid date/time."),
})

type TodoFormValues = z.infer<typeof todoSchema>

const initialTodos: Todo[] = [
  {
    id: "1",
    title: "Create a Next.js app",
    description: "Scaffold with TypeScript + Tailwind and confirm it runs locally.",
    completed: true,
    dueAt: "2026-01-16T09:00",
    attachments: [],
  },
  {
    id: "2",
    title: "Add shadcn/ui + dark theme",
    description: "Initialize shadcn, set up theme provider, and verify dark mode.",
    completed: true,
    dueAt: "2026-01-16T10:30",
    attachments: [],
  },
  {
    id: "3",
    title: "Build a mock-data to-do list",
    completed: false,
    dueAt: "2026-01-16T15:00",
    attachments: [],
  },
  {
    id: "4",
    title: "Yesterday: review requirements",
    completed: true,
    dueAt: "2026-01-15T11:15",
    attachments: [],
  },
  {
    id: "5",
    title: "Yesterday: sketch UI layout",
    completed: true,
    dueAt: "2026-01-15T17:45",
    attachments: [],
  },
  {
    id: "6",
    title: "Today: add attachments support",
    completed: false,
    dueAt: "2026-01-16T18:20",
    attachments: [],
  },
  {
    id: "7",
    title: "Tomorrow: QA the filters",
    description: "Test date-only, time-only, exact, and between behaviors.",
    completed: false,
    dueAt: "2026-01-17T08:05",
    attachments: [],
  },
  {
    id: "8",
    title: "Tomorrow: polish summary cards",
    completed: false,
    dueAt: "2026-01-17T13:30",
    attachments: [],
  },
  {
    id: "9",
    title: "Tomorrow: write small UX notes",
    completed: false,
    dueAt: "2026-01-17T20:10",
    attachments: [],
  },
  {
    id: "10",
    title: "This weekend: add more mock tasks",
    completed: false,
    dueAt: "2026-01-18T10:00",
    attachments: [],
  },
  {
    id: "11",
    title: "This weekend: check time-only filter",
    completed: false,
    dueAt: "2026-01-18T22:15",
    attachments: [],
  },
  {
    id: "12",
    title: "Next week: sync with team",
    completed: false,
    dueAt: "2026-01-19T09:30",
    attachments: [],
  },
  {
    id: "13",
    title: "Next week: test date-only filter",
    completed: false,
    dueAt: "2026-01-20T14:05",
    attachments: [],
  },
  {
    id: "14",
    title: "Next week: test exact date+time filter",
    completed: false,
    dueAt: "2026-01-21T12:00",
    attachments: [],
  },
  {
    id: "15",
    title: "Next week: attach docs to completed tasks",
    completed: false,
    dueAt: "2026-01-22T16:40",
    attachments: [],
  },
  {
    id: "16",
    title: "Next week: final review",
    completed: false,
    dueAt: "2026-01-23T11:00",
    attachments: [],
  },
]

function parseLocalDateTime(value: string): number {
  // value: "YYYY-MM-DDTHH:mm"
  const [datePart, timePart] = value.split("T")
  const [y, m, d] = datePart.split("-").map(Number)
  const [hh, mm] = timePart.split(":").map(Number)
  return new Date(y, m - 1, d, hh, mm, 0, 0).getTime()
}

function pad2(n: number) {
  return String(n).padStart(2, "0")
}

function localDateKey(d: Date) {
  return `${d.getFullYear()}-${pad2(d.getMonth() + 1)}-${pad2(d.getDate())}`
}

function addDays(date: Date, days: number) {
  const d = new Date(date)
  d.setDate(d.getDate() + days)
  return d
}

function startOfDay(date: Date) {
  return new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0, 0)
}

function endOfDay(date: Date) {
  return new Date(
    date.getFullYear(),
    date.getMonth(),
    date.getDate(),
    23,
    59,
    59,
    999
  )
}

function getDatePart(dueAt: string) {
  return dueAt.split("T")[0] ?? ""
}

function getTimePart(dueAt: string) {
  return dueAt.split("T")[1] ?? ""
}

function parseLocalDateOnly(value: string): Date {
  // value: "YYYY-MM-DD"
  const [y, m, d] = value.split("-").map(Number)
  return new Date(y, m - 1, d, 0, 0, 0, 0)
}

function parseLocalTimeToMinutes(value: string): number {
  // value: "HH:mm"
  const [hh, mm] = value.split(":").map(Number)
  return hh * 60 + mm
}

function formatLocalDateTime(value: string): string {
  const ms = parseLocalDateTime(value)
  if (!Number.isFinite(ms)) return value
  return new Intl.DateTimeFormat(undefined, {
    year: "numeric",
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  }).format(new Date(ms))
}

function formatDateTimeFromMs(ms: number): string {
  return new Intl.DateTimeFormat(undefined, {
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  }).format(new Date(ms))
}

function minutesUntil(targetMs: number, nowMs: number) {
  return Math.ceil((targetMs - nowMs) / 60_000)
}

function getTaskFlags(todo: Todo, nowMs: number, inProgressTaskId: string | null) {
  const completed = todo.completed
  const dueMs = parseLocalDateTime(todo.dueAt)
  const overdue = !completed && dueMs < nowMs
  const inProgress = !completed && inProgressTaskId === todo.id
  const planned = !completed && !overdue && !inProgress
  return { completed, overdue, inProgress, planned }
}

function getDailyLoad(todosForDay: Todo[]) {
  // 4-hour windows across the day (local).
  const labels = [
    "00:00–04:00",
    "04:00–08:00",
    "08:00–12:00",
    "12:00–16:00",
    "16:00–20:00",
    "20:00–24:00",
  ]
  const buckets = Array.from({ length: 6 }, () => 0) as number[]
  for (const t of todosForDay) {
    const ms = parseLocalDateTime(t.dueAt)
    const hour = new Date(ms).getHours()
    const idx = Math.floor(hour / 4)
    buckets[idx] = (buckets[idx] ?? 0) + 1
  }

  const total = todosForDay.length
  const peak = Math.max(0, ...buckets)
  const spread = buckets.filter((c) => c > 0).length
  const busiestIdx = buckets.findIndex((c) => c === peak)
  const busiestWindow = busiestIdx >= 0 ? labels[busiestIdx] : labels[0]

  // Heuristic: more tasks + higher concentration in one window => heavier day.
  const score = total + peak * 1.5 + Math.max(0, spread - 1) * 0.5
  const load: DailyLoad = score <= 5 ? "light" : score <= 10 ? "balanced" : "heavy"

  return { load, total, peak, spread, busiestWindow }
}

function DailyLoadBadge({ load }: { load: DailyLoad }) {
  if (load === "heavy") return <Badge variant="destructive">Heavy</Badge>
  if (load === "balanced") return <Badge variant="secondary">Balanced</Badge>
  return <Badge variant="outline">Light</Badge>
}

function TaskBadges({
  completed,
  overdue,
  inProgress,
  planned,
}: {
  completed: boolean
  overdue: boolean
  inProgress: boolean
  planned: boolean
}) {
  if (completed) {
    return (
      <Badge className="gap-1 bg-emerald-600 text-white hover:bg-emerald-600">
        <CheckCircle2 className="h-3.5 w-3.5" />
        Completed
      </Badge>
    )
  }

  return (
    <>
      {inProgress && (
        <Badge className="gap-1 bg-sky-600 text-white hover:bg-sky-600">
          <Timer className="h-3.5 w-3.5 text-white" />
          In progress
        </Badge>
      )}
      {overdue && (
        <Badge variant="destructive" className="gap-1">
          <AlertTriangle className="h-3.5 w-3.5" />
          Overdue
        </Badge>
      )}
      {planned && (
        <Badge variant="outline" className="gap-1">
          <CalendarClock className="h-3.5 w-3.5" />
          Planned
        </Badge>
      )}
    </>
  )
}

function getAttachmentKind(file: File): AttachmentKind {
  const type = (file.type || "").toLowerCase()
  const name = file.name.toLowerCase()
  const ext = name.includes(".") ? name.split(".").pop() ?? "" : ""

  if (type.startsWith("image/")) return "image"
  if (type.startsWith("audio/")) return "audio"
  if (type.startsWith("video/")) return "video"

  if (ext === "pdf") return "pdf"
  if (["xls", "xlsx", "csv"].includes(ext)) return "spreadsheet"
  if (["doc", "docx"].includes(ext)) return "document"
  if (["txt", "md", "rtf"].includes(ext)) return "text"

  return "file"
}

function AttachmentIcon({ kind }: { kind: AttachmentKind }) {
  const className = "h-4 w-4 text-muted-foreground"

  switch (kind) {
    case "image":
      return <ImageIcon className={className} />
    case "audio":
      return <Music className={className} />
    case "video":
      return <Video className={className} />
    case "spreadsheet":
      return <FileSpreadsheet className={className} />
    case "pdf":
    case "document":
    case "text":
      return <FileText className={className} />
    default:
      return <File className={className} />
  }
}

const authSchema = z.object({
  email: z.string().email("Enter a valid email."),
  password: z.string().min(6, "Password must be at least 6 characters."),
})
type AuthValues = z.infer<typeof authSchema>

function AuthCard({ onAuthed }: { onAuthed: () => void }) {
  const [mode, setMode] = React.useState<"sign_in" | "sign_up">("sign_in")
  const [busy, setBusy] = React.useState(false)

  const form = useForm<AuthValues>({
    resolver: zodResolver(authSchema),
    defaultValues: { email: "", password: "" },
  })

  async function onSubmit(values: AuthValues) {
    setBusy(true)
    try {
      if (mode === "sign_in") {
        await apiFetch("/api/auth/sign-in", {
          method: "POST",
          body: JSON.stringify(values),
        })
        onAuthed()
      } else {
        await apiFetch("/api/auth/sign-up", {
          method: "POST",
          body: JSON.stringify(values),
        })
        toast.success("Account created", {
          description: "You can now sign in (or confirm email if required).",
        })
        setMode("sign_in")
      }
    } catch (e) {
      toast.error("Authentication failed", {
        description: e instanceof Error ? e.message : "Please try again.",
      })
    } finally {
      setBusy(false)
    }
  }

  return (
    <div className="mx-auto flex min-h-screen max-w-md flex-col justify-center px-4 py-10">
      <Card>
        <CardHeader>
          <CardTitle className="text-2xl">Sign in</CardTitle>
          <p className="text-muted-foreground text-sm">
            {mode === "sign_in"
              ? "Use your email and password."
              : "Create an account with email and password."}
          </p>
        </CardHeader>
        <CardContent className="space-y-4">
          <Form {...form}>
            <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-3" noValidate>
              <FormField
                control={form.control}
                name="email"
                render={({ field }) => (
                  <FormItem>
                    <FormControl>
                      <Input placeholder="Email" autoComplete="email" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="password"
                render={({ field }) => (
                  <FormItem>
                    <FormControl>
                      <Input
                        type="password"
                        placeholder="Password"
                        autoComplete={
                          mode === "sign_in" ? "current-password" : "new-password"
                        }
                        {...field}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <Button type="submit" className="w-full" disabled={busy}>
                {mode === "sign_in" ? "Sign in" : "Sign up"}
              </Button>
            </form>
          </Form>

          <div className="flex items-center justify-between gap-3 text-sm">
            <span className="text-muted-foreground">
              {mode === "sign_in" ? "No account?" : "Already have an account?"}
            </span>
            <Button
              type="button"
              variant="link"
              className="px-0"
              onClick={() => setMode((m) => (m === "sign_in" ? "sign_up" : "sign_in"))}
            >
              {mode === "sign_in" ? "Sign up" : "Sign in"}
            </Button>
          </div>
        </CardContent>
      </Card>
    </div>
  )
}

export default function Home() {
  const [user, setUser] = React.useState<{ id: string; email?: string } | null>(null)
  const [authLoading, setAuthLoading] = React.useState(true)
  const [authError, setAuthError] = React.useState<string | null>(null)

  const refreshAuth = React.useCallback(async () => {
    setAuthLoading(true)
    try {
      const data = await apiFetch<{ user: { id: string; email?: string } | null }>("/api/auth/me")
      setUser(data.user)
      setAuthError(null)
    } catch (e) {
      setUser(null)
      setAuthError(e instanceof Error ? e.message : "Auth check failed.")
    } finally {
      setAuthLoading(false)
    }
  }, [])

  React.useEffect(() => {
    void refreshAuth()
  }, [refreshAuth])

  if (authLoading) {
    return (
      <div className="mx-auto flex min-h-screen max-w-2xl flex-col justify-center px-4 py-10">
        <p className="text-muted-foreground text-sm">Loading…</p>
      </div>
    )
  }

  if (authError) {
    return (
      <div className="mx-auto flex min-h-screen max-w-2xl flex-col justify-center gap-4 px-4 py-10">
        <Card>
          <CardHeader>
            <CardTitle>Auth unavailable</CardTitle>
          </CardHeader>
          <CardContent className="space-y-2">
            <p className="text-muted-foreground text-sm">{authError}</p>
            <p className="text-muted-foreground text-sm">
              Check <code>SUPABASE_SETUP.md</code> and set env vars from{" "}
              <code>supabase.env.example</code>.
            </p>
            <Button type="button" variant="outline" onClick={() => void refreshAuth()}>
              Retry
            </Button>
          </CardContent>
        </Card>
      </div>
    )
  }

  if (!user) return <AuthCard onAuthed={() => void refreshAuth()} />

  return (
    <div className="mx-auto flex min-h-screen max-w-2xl flex-col gap-6 px-4 py-10">
      <TodoApp userId={user.id} onSignedOut={() => void refreshAuth()} />
    </div>
  )
}

function TodoApp({ userId, onSignedOut }: { userId: string; onSignedOut: () => void }) {
  const [todos, setTodos] = React.useState<Todo[]>([])
  const [tasksLoading, setTasksLoading] = React.useState(true)
  const [tasksError, setTasksError] = React.useState<{ code?: string; message: string } | null>(
    null
  )
  const [attachTargetTodoId, setAttachTargetTodoId] = React.useState<string | null>(
    null
  )
  const [conflictDueAt, setConflictDueAt] = React.useState<string | null>(null)
  const clearConflictTimerRef = React.useRef<number | null>(null)
  const [focusMode, setFocusMode] = React.useState(false)
  const [nowMs, setNowMs] = React.useState(() => Date.now())
  const [inProgressTaskId, setInProgressTaskId] = React.useState<string | null>(null)
  const [dismissedReminderTaskId, setDismissedReminderTaskId] = React.useState<
    string | null
  >(null)
  const [filterMode, setFilterMode] = React.useState<"between" | "exact">("between")
  const [filterFromDate, setFilterFromDate] = React.useState<string>("")
  const [filterFromTime, setFilterFromTime] = React.useState<string>("")
  const [filterToDate, setFilterToDate] = React.useState<string>("")
  const [filterToTime, setFilterToTime] = React.useState<string>("")
  const [filterExactDate, setFilterExactDate] = React.useState<string>("")
  const [filterExactTime, setFilterExactTime] = React.useState<string>("")
  const fileInputRef = React.useRef<HTMLInputElement>(null)
  const [pageSize, setPageSize] = React.useState<number>(5)
  const [page, setPage] = React.useState<number>(1)

  React.useEffect(() => {
    let alive = true
    async function load() {
      setTasksLoading(true)
      if (!alive) return
      try {
        const data = await apiFetch<{ tasks: Todo[]; inProgressTaskId: string | null }>("/api/tasks")
        if (!alive) return
        setTodos(data.tasks)
        setInProgressTaskId(data.inProgressTaskId)
        setTasksError(null)
      } catch (e) {
        if (!alive) return
        if (e instanceof ApiError) setTasksError({ code: e.code, message: e.message })
        else setTasksError({ message: e instanceof Error ? e.message : "Failed to load tasks." })
        setTodos([])
        setInProgressTaskId(null)
      } finally {
        setTasksLoading(false)
      }
    }
    load()
    return () => {
      alive = false
    }
  }, [userId])

  // Keep "now" fresh so overdue/in-progress states stay accurate without user interaction.
  React.useEffect(() => {
    const id = window.setInterval(() => setNowMs(Date.now()), 30_000)
    return () => window.clearInterval(id)
  }, [])

  // Only one task can be "In Progress"; auto-clear if completed, deleted, or overdue.
  React.useEffect(() => {
    if (!inProgressTaskId) return
    const t = todos.find((x) => x.id === inProgressTaskId)
    if (!t || t.completed) {
      setInProgressTaskId(null)
      return
    }
  }, [inProgressTaskId, nowMs, todos])

  const nextUpcoming = React.useMemo(() => {
    const upcoming = todos
      .filter((t) => !t.completed)
      .map((t) => ({ todo: t, dueMs: parseLocalDateTime(t.dueAt) }))
      .filter((x) => x.dueMs >= nowMs)
      .sort((a, b) => a.dueMs - b.dueMs)[0]
    return upcoming ?? null
  }, [nowMs, todos])

  React.useEffect(() => {
    // If "next upcoming" changed, allow reminder again (dismiss is per-task).
    if (nextUpcoming && nextUpcoming.todo.id !== dismissedReminderTaskId) return
    if (!nextUpcoming) setDismissedReminderTaskId(null)
  }, [dismissedReminderTaskId, nextUpcoming])

  const reminder = React.useMemo(() => {
    const REMINDER_WINDOW_MIN = 15
    if (!nextUpcoming) return null
    if (dismissedReminderTaskId === nextUpcoming.todo.id) return null
    const mins = minutesUntil(nextUpcoming.dueMs, nowMs)
    if (mins < 0 || mins > REMINDER_WINDOW_MIN) return null
    return { ...nextUpcoming, mins }
  }, [dismissedReminderTaskId, nextUpcoming, nowMs])

  const form = useForm<TodoFormValues>({
    resolver: zodResolver(todoSchema),
    defaultValues: { title: "", description: "", dueAt: "" },
    mode: "onSubmit",
  })

  const summary = React.useMemo(() => {
    const now = new Date()
    const todayKey = localDateKey(now)
    const tomorrow = addDays(now, 1)
    const tomorrowKey = localDateKey(tomorrow)

    const todays = todos.filter((t) => t.dueAt.startsWith(todayKey))
    const todayCompleted = todays.filter((t) => t.completed).length
    const todayPending = todays.length - todayCompleted

    const labels = [
      "00:00–04:00",
      "04:00–08:00",
      "08:00–12:00",
      "12:00–16:00",
      "16:00–20:00",
      "20:00–24:00",
    ]

    // Tomorrow: same 4-hour windows breakdown
    const tomorrowTasks = todos.filter((t) => t.dueAt.startsWith(tomorrowKey))
    const tomorrowBuckets = Array.from({ length: 6 }, () => 0) as number[]
    for (const t of tomorrowTasks) {
      const ms = parseLocalDateTime(t.dueAt)
      const hour = new Date(ms).getHours()
      const idx = Math.floor(hour / 4)
      tomorrowBuckets[idx] = (tomorrowBuckets[idx] ?? 0) + 1
    }

    // Until next week = next 7 days starting tomorrow (local), grouped into 4-hour windows.
    const rangeStart = startOfDay(tomorrow).getTime()
    const rangeEnd = addDays(startOfDay(tomorrow), 7).getTime()
    const buckets = Array.from({ length: 6 }, () => 0) as number[]

    const upcoming = todos.filter((t) => {
      const ms = parseLocalDateTime(t.dueAt)
      return ms >= rangeStart && ms < rangeEnd
    })

    for (const t of upcoming) {
      const ms = parseLocalDateTime(t.dueAt)
      const hour = new Date(ms).getHours()
      const idx = Math.floor(hour / 4)
      buckets[idx] = (buckets[idx] ?? 0) + 1
    }

    return {
      todayCompleted,
      todayPending,
      tomorrowTotal: tomorrowTasks.length,
      tomorrowBuckets: labels.map((label, i) => ({ label, count: tomorrowBuckets[i] ?? 0 })),
      upcomingTotal: upcoming.length,
      upcomingBuckets: labels.map((label, i) => ({ label, count: buckets[i] ?? 0 })),
    }
  }, [todos])

  const loadDayKey = React.useMemo(() => {
    // Prefer an explicitly selected date from filters; otherwise use today.
    if (filterMode === "exact" && filterExactDate) return filterExactDate
    if (filterFromDate && !filterToDate) return filterFromDate
    if (filterFromDate && filterToDate && filterFromDate === filterToDate) return filterFromDate
    if (!filterFromDate && filterToDate) return filterToDate
    return localDateKey(new Date(nowMs))
  }, [filterExactDate, filterFromDate, filterMode, filterToDate, nowMs])

  const dailyLoad = React.useMemo(() => {
    const dayTodos = todos.filter((t) => getDatePart(t.dueAt) === loadDayKey)
    return getDailyLoad(dayTodos)
  }, [loadDayKey, todos])

  const filteredTodos = React.useMemo(() => {
    if (focusMode) {
      const endMs = nowMs + 4 * 60 * 60 * 1000
      const withMs = todos.map((t) => ({ ...t, _dueMs: parseLocalDateTime(t.dueAt) }))
      return withMs.filter((t) => t._dueMs >= nowMs && t._dueMs <= endMs)
    }

    const withMs = todos.map((t) => ({ ...t, _dueMs: parseLocalDateTime(t.dueAt) }))
    if (filterMode === "exact") {
      // If only date is selected -> show tasks for that date.
      // If time is selected too -> match exact date+time.
      // If only time is selected -> match time-of-day across all dates.
      if (!filterExactDate && !filterExactTime) return withMs

      if (filterExactDate && !filterExactTime) {
        return withMs.filter((t) => getDatePart(t.dueAt) === filterExactDate)
      }

      if (filterExactDate && filterExactTime) {
        const exactMs = parseLocalDateTime(`${filterExactDate}T${filterExactTime}`)
        return withMs.filter((t) => t._dueMs === exactMs)
      }

      // time only
      return withMs.filter((t) => getTimePart(t.dueAt) === filterExactTime)
    }
    // between
    const hasAnyDate = Boolean(filterFromDate || filterToDate)
    const hasAnyTime = Boolean(filterFromTime || filterToTime)

    // Date range (optional)
    const fromDateMs = filterFromDate
      ? startOfDay(parseLocalDateOnly(filterFromDate)).getTime()
      : Number.NEGATIVE_INFINITY
    const toDateMs = filterToDate
      ? endOfDay(parseLocalDateOnly(filterToDate)).getTime()
      : Number.POSITIVE_INFINITY

    // Time-of-day range (optional)
    const fromTimeMin = filterFromTime ? parseLocalTimeToMinutes(filterFromTime) : 0
    const toTimeMin = filterToTime ? parseLocalTimeToMinutes(filterToTime) : 24 * 60 - 1

    return withMs.filter((t) => {
      const ms = t._dueMs
      if (hasAnyDate && (ms < fromDateMs || ms > toDateMs)) return false

      if (hasAnyTime) {
        const time = getTimePart(t.dueAt)
        if (!time) return false
        const mins = parseLocalTimeToMinutes(time)
        // Simple (non-wrapping) range. If you want wrap-around (e.g. 22:00–02:00), tell me.
        if (mins < fromTimeMin || mins > toTimeMin) return false
      }

      // If neither date nor time selected, pass through (handled above anyway)
      return true
    })
  }, [
    todos,
    focusMode,
    nowMs,
    filterExactDate,
    filterExactTime,
    filterFromDate,
    filterFromTime,
    filterMode,
    filterToDate,
    filterToTime,
  ])

  const sortedFilteredTodos = React.useMemo(
    () =>
      filteredTodos
        .slice()
        .sort((a, b) => parseLocalDateTime(a.dueAt) - parseLocalDateTime(b.dueAt)),
    [filteredTodos]
  )

  // Clamp page when filters/pageSize change.
  React.useEffect(() => {
    const totalPages = Math.max(1, Math.ceil(sortedFilteredTodos.length / pageSize))
    setPage((p) => Math.min(Math.max(1, p), totalPages))
  }, [pageSize, sortedFilteredTodos.length])

  const totalItems = sortedFilteredTodos.length
  const totalPages = Math.max(1, Math.ceil(totalItems / pageSize))
  const showPagination = totalPages > 1

  const pageItems = React.useMemo(() => {
    const start = (page - 1) * pageSize
    return sortedFilteredTodos.slice(start, start + pageSize)
  }, [page, pageSize, sortedFilteredTodos])

  const groupedTodos = React.useMemo(() => {
    const groups: Array<{ date: string; items: typeof pageItems }> = []
    for (const t of pageItems) {
      const date = getDatePart(t.dueAt)
      const last = groups[groups.length - 1]
      if (!last || last.date !== date) groups.push({ date, items: [t] })
      else last.items.push(t)
    }
    return groups
  }, [pageItems])

  const completedCount = filteredTodos.filter((t) => t.completed).length

  async function addTodo(values: TodoFormValues) {
    const conflicts = todos.filter((t) => t.dueAt === values.dueAt)
    if (conflicts.length > 0) {
      setConflictDueAt(values.dueAt)
      if (clearConflictTimerRef.current) window.clearTimeout(clearConflictTimerRef.current)
      clearConflictTimerRef.current = window.setTimeout(() => {
        setConflictDueAt(null)
      }, 8000)

      // Make sure the user can see the conflicting tasks even if they were filtered out.
      const [d, time] = values.dueAt.split("T")
      setFilterMode("exact")
      setFilterExactDate(d ?? "")
      setFilterExactTime(time ?? "")
      setPage(1)

      toast.error("Time conflict", {
        description: `You already have ${conflicts.length} task(s) scheduled at ${formatLocalDateTime(
          values.dueAt
        )}.`,
      })
    }

    try {
      const data = await apiFetch<{ task: Todo }>("/api/tasks", {
        method: "POST",
        body: JSON.stringify(values),
      })
      setTodos((prev) => [data.task, ...prev])
    } catch (e) {
      toast.error("Failed to add task", { description: e instanceof Error ? e.message : "Failed." })
      return
    }
    form.reset()
  }

  async function toggleTodo(id: string, completed: boolean) {
    // optimistic
    setTodos((prev) =>
      prev.map((t) =>
        t.id === id ? { ...t, completed, attachments: t.attachments } : t
      )
    )
    if (completed) setInProgressTaskId((cur) => (cur === id ? null : cur))

    const update: { completed: boolean; in_progress?: boolean } = { completed }
    if (completed) update.in_progress = false

    try {
      await apiFetch("/api/tasks/" + id, {
        method: "PATCH",
        body: JSON.stringify({ completed }),
      })
    } catch (e) {
      toast.error("Failed to update task", { description: e instanceof Error ? e.message : "Failed." })
    }
  }

  function requestAttachmentsForTodo(todoId: string) {
    setAttachTargetTodoId(todoId)
    // Let state update before opening picker (some browsers are picky).
    queueMicrotask(() => fileInputRef.current?.click())
  }

  async function handleFilesPicked(e: React.ChangeEvent<HTMLInputElement>) {
    const files = Array.from(e.target.files ?? [])
    const targetId = attachTargetTodoId

    // reset input so picking the same file again triggers onChange
    e.target.value = ""
    setAttachTargetTodoId(null)

    if (!targetId || files.length === 0) return
    const form = new FormData()
    for (const f of files) form.append("files", f)
    try {
      const res = await fetch(`/api/tasks/${targetId}/attachments`, {
        method: "POST",
        credentials: "include",
        body: form,
      })
      const json = (await res.json().catch(() => null)) as
        | { ok: true; data: { task: Todo } }
        | { ok: false; error: { message: string } }
        | null
      if (!json || !json.ok) throw new Error(json?.error.message ?? "Upload failed.")
      setTodos((prev) => prev.map((t) => (t.id === targetId ? json.data.task : t)))
    } catch (e) {
      toast.error("Upload failed", { description: e instanceof Error ? e.message : "Failed." })
    }
  }

  async function deleteTodo(id: string) {
    // optimistic
    setTodos((prev) => prev.filter((t) => t.id !== id))
    setInProgressTaskId((cur) => (cur === id ? null : cur))

    try {
      await apiFetch("/api/tasks/" + id, { method: "DELETE" })
    } catch (e) {
      toast.error("Failed to delete task", { description: e instanceof Error ? e.message : "Failed." })
    }
  }

  async function setInProgress(taskId: string | null) {
    // optimistic
    setInProgressTaskId(taskId)

    try {
      const data = await apiFetch<{ inProgressTaskId: string | null }>("/api/tasks/in-progress", {
        method: "POST",
        body: JSON.stringify({ id: taskId }),
      })
      setInProgressTaskId(data.inProgressTaskId)
    } catch (e) {
      toast.error("Failed to update in-progress", {
        description: e instanceof Error ? e.message : "Failed.",
      })
    }
  }

  async function downloadAttachment(a: Attachment) {
    try {
      const data = await apiFetch<{ signedUrl: string }>("/api/attachments/signed-url", {
        method: "POST",
        body: JSON.stringify({ bucket: a.bucket, path: a.path }),
      })
      window.open(data.signedUrl, "_blank", "noopener,noreferrer")
    } catch (e) {
      toast.error("Download failed", { description: e instanceof Error ? e.message : "Failed." })
    }
  }

  async function seedDemoTasks() {
    if (todos.length > 0) return
    try {
      const data = await apiFetch<{ tasks: Todo[] }>("/api/tasks/seed", {
        method: "POST",
        body: JSON.stringify({ tasks: initialTodos }),
      })
      setTodos(data.tasks)
    } catch (e) {
      toast.error("Failed to seed demo tasks", { description: e instanceof Error ? e.message : "Failed." })
    }
  }

  async function clearCompleted() {
    const completedIds = new Set(todos.filter((t) => t.completed).map((t) => t.id))
    if (completedIds.size === 0) return

    // optimistic
    setTodos((prev) => prev.filter((t) => !completedIds.has(t.id)))

    try {
      await apiFetch("/api/tasks/clear-completed", { method: "POST" })
    } catch (e) {
      toast.error("Failed to clear completed", { description: e instanceof Error ? e.message : "Failed." })
    }
  }

  return (
    <Card>
      <CardHeader className="flex flex-row items-center justify-between gap-4">
        <div className="space-y-1">
          <CardTitle className="text-2xl">To‑Do</CardTitle>
          <p className="text-muted-foreground text-sm">
            {completedCount}/{filteredTodos.length} completed
          </p>
        </div>
        <div className="flex items-center gap-2">
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <Button
                  type="button"
                  variant={focusMode ? "default" : "outline"}
                  size="sm"
                  onClick={() => {
                    setFocusMode((v) => !v)
                    setPage(1)
                  }}
                >
                  Focus Mode
                </Button>
              </TooltipTrigger>
              <TooltipContent>
                <p>Show tasks for the next 4 hours.</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
          <Button
            type="button"
            variant="outline"
            size="sm"
            onClick={async () => {
              await apiFetch("/api/auth/sign-out", { method: "POST" }).catch(() => {})
              onSignedOut()
            }}
          >
            Sign out
          </Button>
          <ModeToggle />
        </div>
      </CardHeader>

      <CardContent className="space-y-6">
        {tasksLoading && (
          <p className="text-muted-foreground text-sm">Loading tasks…</p>
        )}

        {!tasksLoading && tasksError?.code === "MISSING_TABLE" && (
          <Alert variant="destructive">
            <AlertTitle>Database not initialized</AlertTitle>
            <AlertDescription>
              <div className="space-y-2">
                <p>
                  The Supabase table <code>public.tasks</code> was not found. Run the SQL in{" "}
                  <code>supabase/schema.sql</code> (Supabase Dashboard → SQL Editor), then refresh.
                </p>
                <p className="text-xs opacity-90">{tasksError.message}</p>
              </div>
            </AlertDescription>
          </Alert>
        )}

        {!tasksLoading && tasksError && tasksError.code !== "MISSING_TABLE" && (
          <Alert variant="destructive">
            <AlertTitle>Failed to load tasks</AlertTitle>
            <AlertDescription>{tasksError.message}</AlertDescription>
          </Alert>
        )}

        {!tasksLoading && todos.length === 0 && (
          <div className="flex items-center justify-between gap-3 rounded-lg border bg-muted/20 px-3 py-2">
            <p className="text-muted-foreground text-sm">No tasks yet.</p>
            <Button type="button" variant="outline" size="sm" onClick={() => void seedDemoTasks()}>
              Seed demo tasks
            </Button>
          </div>
        )}

        <input
          ref={fileInputRef}
          type="file"
          multiple
          className="hidden"
          accept={[
            "image/*",
            "audio/*",
            "video/*",
            ".pdf",
            ".doc",
            ".docx",
            ".xls",
            ".xlsx",
            ".csv",
            ".txt",
            ".md",
            ".rtf",
          ].join(",")}
          onChange={handleFilesPicked}
        />

        {reminder && (
          <Alert className="border-primary/30 bg-primary/5">
            <Bell className="h-4 w-4" />
            <div className="flex flex-1 flex-col gap-1">
              <div className="flex flex-wrap items-center justify-between gap-2">
                <AlertTitle className="text-sm">
                  Next task starts in {reminder.mins} minute{reminder.mins === 1 ? "" : "s"}
                </AlertTitle>
                <Button
                  type="button"
                  variant="ghost"
                  size="sm"
                  onClick={() => setDismissedReminderTaskId(reminder.todo.id)}
                >
                  Dismiss
                </Button>
              </div>
              <AlertDescription className="text-sm">
                <span className="font-medium">{reminder.todo.title}</span> ·{" "}
                {formatDateTimeFromMs(reminder.dueMs)}
              </AlertDescription>
            </div>
          </Alert>
        )}

        <div className="rounded-xl border bg-card p-4">
          <div className="flex flex-wrap items-center justify-between gap-2">
            <p className="text-sm font-medium">
              Daily load{" "}
              <span className="text-muted-foreground font-normal">
                ({new Intl.DateTimeFormat(undefined, {
                  weekday: "short",
                  year: "numeric",
                  month: "short",
                  day: "2-digit",
                }).format(parseLocalDateOnly(loadDayKey))})
              </span>
            </p>
            <DailyLoadBadge load={dailyLoad.load} />
          </div>
          <p className="text-muted-foreground mt-2 text-sm">
            {dailyLoad.total} task(s) · busiest window {dailyLoad.busiestWindow} ({dailyLoad.peak})
          </p>
        </div>

        <div className="grid gap-3 sm:grid-cols-3">
          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Today’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">
              {summary.todayCompleted} completed
            </p>
            <p className="text-muted-foreground text-sm">{summary.todayPending} pending</p>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tomorrow’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">{summary.tomorrowTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.tomorrowBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tasks Until Next Week</p>
            <p className="mt-2 text-2xl font-semibold">{summary.upcomingTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.upcomingBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>
        </div>

        {focusMode && (
          <div className="flex flex-col gap-1 rounded-lg border bg-muted/20 px-3 py-2 sm:flex-row sm:items-center sm:justify-between">
            <p className="text-sm">
              <span className="font-medium">Focus Mode:</span>{" "}
              showing tasks due in the next 4 hours (until{" "}
              <span className="font-medium">
                {formatDateTimeFromMs(nowMs + 4 * 60 * 60 * 1000)}
              </span>
              )
            </p>
            <Button type="button" variant="ghost" size="sm" onClick={() => setFocusMode(false)}>
              Exit
            </Button>
          </div>
        )}

        <Form {...form}>
          <form
            onSubmit={form.handleSubmit(addTodo)}
            className="space-y-2"
            noValidate
          >
            <div className="flex flex-col gap-2 sm:flex-row">
              <FormField
                control={form.control}
                name="title"
                render={({ field }) => (
                  <FormItem className="flex-1">
                    <FormControl>
                      <Input
                        placeholder="Add a task…"
                        autoComplete="off"
                        {...field}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="dueAt"
                render={({ field }) => (
                  <FormItem className="sm:w-64">
                    <FormControl>
                      <Input type="datetime-local" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <Button type="submit">Add</Button>
            </div>

            <FormField
              control={form.control}
              name="description"
              render={({ field }) => (
                <FormItem>
                  <FormControl>
                    <Textarea
                      rows={3}
                      placeholder="Description (optional)…"
                      {...field}
                    />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />
          </form>
        </Form>

        <Separator />

        <div className="space-y-3">
          <div className="flex flex-wrap items-center justify-between gap-2">
            <p className="text-sm font-medium">Filter by date & time</p>
            <div className="flex items-center gap-2">
              <Button
                type="button"
                size="sm"
                variant={filterMode === "between" ? "default" : "outline"}
                onClick={() => setFilterMode("between")}
              >
                Between
              </Button>
              <Button
                type="button"
                size="sm"
                variant={filterMode === "exact" ? "default" : "outline"}
                onClick={() => setFilterMode("exact")}
              >
                Exact
              </Button>
              <Button
                type="button"
                size="sm"
                variant="ghost"
                onClick={() => {
                  setFilterFromDate("")
                  setFilterFromTime("")
                  setFilterToDate("")
                  setFilterToTime("")
                  setFilterExactDate("")
                  setFilterExactTime("")
                }}
              >
                Clear
              </Button>
            </div>
          </div>

          {filterMode === "between" ? (
            <div className="grid gap-2 sm:grid-cols-2">
              <div className="grid gap-2 sm:grid-cols-2">
                <Input
                  type="date"
                  value={filterFromDate}
                  onChange={(e) => setFilterFromDate(e.target.value)}
                />
                <Input
                  type="time"
                  value={filterFromTime}
                  onChange={(e) => setFilterFromTime(e.target.value)}
                />
              </div>
              <div className="grid gap-2 sm:grid-cols-2">
                <Input
                  type="date"
                  value={filterToDate}
                  onChange={(e) => setFilterToDate(e.target.value)}
                />
                <Input
                  type="time"
                  value={filterToTime}
                  onChange={(e) => setFilterToTime(e.target.value)}
                />
              </div>
            </div>
          ) : (
            <div className="grid gap-2 sm:grid-cols-2">
              <Input
                type="date"
                value={filterExactDate}
                onChange={(e) => setFilterExactDate(e.target.value)}
              />
              <Input
                type="time"
                value={filterExactTime}
                onChange={(e) => setFilterExactTime(e.target.value)}
              />
            </div>
          )}
        </div>

        <Separator />

        <div className="space-y-2">
          {groupedTodos.length === 0 ? (
            <p className="text-muted-foreground text-sm">No tasks yet.</p>
          ) : (
            groupedTodos.map((group) => (
              <div key={group.date} className="space-y-2">
                <div className="flex items-center gap-3 pt-2">
                  <Separator className="flex-1" />
                  <span className="text-muted-foreground whitespace-nowrap text-xs font-medium">
                    {new Intl.DateTimeFormat(undefined, {
                      weekday: "short",
                      year: "numeric",
                      month: "short",
                      day: "2-digit",
                    }).format(parseLocalDateOnly(group.date))}
                  </span>
                  <Separator className="flex-1" />
                </div>

                {group.items.map((todo) => {
                  const flags = getTaskFlags(todo, nowMs, inProgressTaskId)

                  return (
                    <div
                      key={todo.id}
                      className={cn(
                        "rounded-lg border px-3 py-2",
                        flags.completed && "opacity-75",
                        flags.overdue &&
                          "border-destructive/40 bg-destructive/5 text-muted-foreground",
                        flags.inProgress && "border-sky-500/40 bg-sky-500/10",
                        conflictDueAt &&
                          todo.dueAt === conflictDueAt &&
                          "border-destructive/60 bg-destructive/5 ring-1 ring-destructive/30"
                      )}
                    >
                      <div className="flex items-start justify-between gap-3">
                        <label className="flex cursor-pointer items-start gap-3">
                        <Checkbox
                          checked={todo.completed}
                          onCheckedChange={(v) => {
                            const next = Boolean(v)
                            toggleTodo(todo.id, next)
                            if (next && !todo.completed) {
                              requestAttachmentsForTodo(todo.id)
                            }
                          }}
                          aria-label={`Mark "${todo.title}" as ${
                            todo.completed ? "not completed" : "completed"
                          }`}
                          className="mt-0.5"
                        />
                        <span
                          className={cn(
                            "leading-6",
                            todo.completed && "text-muted-foreground line-through"
                          )}
                        >
                          <span className="flex flex-wrap items-center gap-2">
                            <span className="block">{todo.title}</span>
                              <span className="flex flex-wrap items-center gap-2">
                                <TaskBadges {...flags} />
                              </span>
                            {todo.description && (
                              <TooltipProvider>
                                <Tooltip>
                                  <TooltipTrigger asChild>
                                    <button
                                      type="button"
                                      className="text-muted-foreground hover:text-foreground inline-flex h-7 w-7 items-center justify-center rounded-md border bg-background"
                                      aria-label="View description"
                                    >
                                      <Info className="h-4 w-4" />
                                    </button>
                                  </TooltipTrigger>
                                  <TooltipContent className="max-w-xs">
                                    <p className="whitespace-pre-wrap text-sm">
                                      {todo.description}
                                    </p>
                                  </TooltipContent>
                                </Tooltip>
                              </TooltipProvider>
                            )}
                          </span>
                          <span className="text-muted-foreground block text-xs">
                            Due: {formatLocalDateTime(todo.dueAt)}
                          </span>
                        </span>
                      </label>

                      <div className="flex items-center gap-1">
                        {!todo.completed && (
                          <Button
                            type="button"
                            variant={flags.inProgress ? "default" : "outline"}
                            size="sm"
                            onClick={() => void setInProgress(flags.inProgress ? null : todo.id)}
                            className={cn(
                              flags.inProgress && "bg-sky-600 hover:bg-sky-600"
                            )}
                          >
                            {flags.inProgress ? (
                              <>
                                <CircleStop className="mr-1 h-4 w-4" />
                                Stop
                              </>
                            ) : (
                              <>
                                <CirclePlay className="mr-1 h-4 w-4" />
                                Start
                              </>
                            )}
                          </Button>
                        )}
                        {todo.completed && (
                          <Button
                            type="button"
                            variant="outline"
                            size="sm"
                            onClick={() => requestAttachmentsForTodo(todo.id)}
                          >
                            Add files
                          </Button>
                        )}
                        <Button
                          type="button"
                          variant="ghost"
                          size="icon"
                          aria-label={`Delete "${todo.title}"`}
                          onClick={() => deleteTodo(todo.id)}
                        >
                          <Trash2 className="h-4 w-4" />
                        </Button>
                      </div>
                    </div>

                    {todo.completed && todo.attachments.length > 0 && (
                      <div className="mt-3 space-y-2">
                        <p className="text-muted-foreground text-xs">Attachments</p>
                        <ul className="space-y-1">
                          {todo.attachments.map((a) => (
                            <li
                              key={a.id}
                              className="flex items-center justify-between gap-3 rounded-md bg-muted/30 px-2 py-1"
                            >
                              <div className="flex min-w-0 items-center gap-2">
                                <AttachmentIcon kind={a.kind} />
                                <span className="truncate text-sm">{a.name}</span>
                              </div>
                              <button
                                type="button"
                                onClick={() => void downloadAttachment(a)}
                                className="inline-flex items-center gap-1 text-sm font-medium underline underline-offset-4"
                              >
                                <Download className="h-4 w-4" />
                                Download
                              </button>
                            </li>
                          ))}
                        </ul>
                      </div>
                    )}
                  </div>
                  )
                })}
              </div>
            ))
          )}
        </div>

        {groupedTodos.length > 0 && (
          <div className="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
            <div className="flex items-center gap-2">
              <span className="text-muted-foreground text-sm">Items per page</span>
              <Select
                value={String(pageSize)}
                onValueChange={(v) => {
                  const next = Number(v)
                  setPageSize(next)
                  setPage(1)
                }}
              >
                <SelectTrigger className="w-[110px]">
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="5">5</SelectItem>
                  <SelectItem value="10">10</SelectItem>
                  <SelectItem value="15">15</SelectItem>
                  <SelectItem value="20">20</SelectItem>
                </SelectContent>
              </Select>
            </div>

            {showPagination && (
              <div className="flex items-center justify-between gap-3 sm:justify-end">
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={() => setPage((p) => Math.max(1, p - 1))}
                  disabled={page <= 1}
                >
                  Prev
                </Button>
                <span className="text-muted-foreground text-sm">
                  Page {page} of {totalPages}
                </span>
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={() => setPage((p) => Math.min(totalPages, p + 1))}
                  disabled={page >= totalPages}
                >
                  Next
                </Button>
              </div>
            )}
          </div>
        )}

        <div className="flex items-center justify-between gap-2">
          <Button
            type="button"
            variant="secondary"
            onClick={clearCompleted}
            disabled={completedCount === 0}
          >
            Clear completed
          </Button>
          <span className="text-muted-foreground text-sm">
            v 1.1.0
          </span>
    </div>
      </CardContent>
    </Card>
  )
}

```

```typescript
import { cookies } from "next/headers"
import { NextResponse } from "next/server"

export const ACCESS_TOKEN_COOKIE = "sb-access-token"
export const REFRESH_TOKEN_COOKIE = "sb-refresh-token"

export async function getAccessTokenFromCookies() {
  return (await cookies()).get(ACCESS_TOKEN_COOKIE)?.value
}

export async function getRefreshTokenFromCookies() {
  return (await cookies()).get(REFRESH_TOKEN_COOKIE)?.value
}

export function setAuthCookies(res: NextResponse, accessToken: string, refreshToken: string) {
  const secure = process.env.NODE_ENV === "production"

  res.cookies.set(ACCESS_TOKEN_COOKIE, accessToken, {
    httpOnly: true,
    secure,
    sameSite: "lax",
    path: "/",
  })
  res.cookies.set(REFRESH_TOKEN_COOKIE, refreshToken, {
    httpOnly: true,
    secure,
    sameSite: "lax",
    path: "/",
  })
}

export function clearAuthCookies(res: NextResponse) {
  res.cookies.set(ACCESS_TOKEN_COOKIE, "", { httpOnly: true, path: "/", maxAge: 0 })
  res.cookies.set(REFRESH_TOKEN_COOKIE, "", { httpOnly: true, path: "/", maxAge: 0 })
}


```

```typescript
import { createServerSupabaseClient } from "@/lib/supabase/server"
import { getAccessTokenFromCookies, getRefreshTokenFromCookies, setAuthCookies } from "./auth"
import { NextResponse } from "next/server"

export async function requireUser() {
  const accessToken = await getAccessTokenFromCookies()
  const refreshToken = await getRefreshTokenFromCookies()

  if (!accessToken && !refreshToken)
    return { user: null as const, accessToken: null as const, res: null as const }

  const supabase = createServerSupabaseClient(accessToken)

  // Try current access token
  if (accessToken) {
    const { data } = await supabase.auth.getUser(accessToken)
    if (data.user) return { user: data.user, accessToken, res: null as const }
  }

  // Refresh if possible
  if (refreshToken) {
    const anon = createServerSupabaseClient()
    const { data, error } = await anon.auth.refreshSession({ refresh_token: refreshToken })
    if (error || !data.session?.access_token || !data.session.refresh_token) {
      return { user: null as const, accessToken: null as const, res: null as const }
    }

    const refreshed = createServerSupabaseClient(data.session.access_token)
    const userRes = await refreshed.auth.getUser(data.session.access_token)
    if (!userRes.data.user)
      return { user: null as const, accessToken: null as const, res: null as const }

    const res = NextResponse.next()
    setAuthCookies(res, data.session.access_token, data.session.refresh_token)
    return { user: userRes.data.user, accessToken: data.session.access_token, res }
  }

  return { user: null as const, accessToken: null as const, res: null as const }
}


```

```typescript
import { z } from "zod"
import { jsonError, jsonOk } from "@/app/api/_lib/response"
import { requireUser } from "@/app/api/_lib/supabase"
import { createServerSupabaseClient } from "@/lib/supabase/server"
import type { DbTaskRow } from "./types"
import { fromDbTask } from "./types"

const createSchema = z.object({
  title: z.string().min(1).max(80),
  description: z.string().max(500).optional().or(z.literal("")),
  dueAt: z.string().regex(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}$/),
})

export async function GET() {
  const { user, accessToken } = await requireUser()
  if (!user) return jsonError("Unauthorized", "UNAUTHORIZED", 401)

  const supabase = createServerSupabaseClient(accessToken ?? undefined)

  const { data, error } = await supabase
    .from("tasks")
    .select("*")
    .eq("user_id", user.id)
    .order("due_at", { ascending: true })

  if (error) {
    const msg = error.message ?? "Failed to load tasks."
    const code =
      msg.includes("Could not find the table") || msg.includes("schema cache")
        ? "MISSING_TABLE"
        : "DB"
    return jsonError(msg, code, 500)
  }

  const rows = (data ?? []) as DbTaskRow[]
  return jsonOk({
    tasks: rows.map(fromDbTask),
    inProgressTaskId: rows.find((r) => r.in_progress)?.id ?? null,
  })
}

export async function POST(req: Request) {
  const { user, accessToken } = await requireUser()
  if (!user) return jsonError("Unauthorized", "UNAUTHORIZED", 401)

  const body = await req.json().catch(() => null)
  const parsed = createSchema.safeParse(body)
  if (!parsed.success) return jsonError("Invalid request body.", "BAD_REQUEST", 400)

  const supabase = createServerSupabaseClient(accessToken ?? undefined)

  const { data, error } = await supabase
    .from("tasks")
    .insert({
      user_id: user.id,
      title: parsed.data.title.trim(),
      description: (parsed.data.description ?? "").trim() || null,
      due_at: parsed.data.dueAt,
      completed: false,
      in_progress: false,
      attachments: [],
    })
    .select("*")
    .single()

  if (error) return jsonError(error.message, "DB", 500)

  return jsonOk({ task: fromDbTask(data as DbTaskRow) })
}


```

```typescript
import { jsonError, jsonOk } from "@/app/api/_lib/response"
import { requireUser } from "@/app/api/_lib/supabase"
import { createServerSupabaseClient } from "@/lib/supabase/server"

export async function POST() {
  const { user, accessToken } = await requireUser()
  if (!user) return jsonError("Unauthorized", "UNAUTHORIZED", 401)

  const supabase = createServerSupabaseClient(accessToken ?? undefined)

  const { error } = await supabase
    .from("tasks")
    .delete()
    .eq("user_id", user.id)
    .eq("completed", true)

  if (error) return jsonError(error.message, "DB", 500)
  return jsonOk({ ok: true })
}


```

```typescript
import { z } from "zod"
import { jsonError, jsonOk } from "@/app/api/_lib/response"
import { requireUser } from "@/app/api/_lib/supabase"
import { createServerSupabaseClient } from "@/lib/supabase/server"

const schema = z.object({ id: z.string().uuid().nullable() })

export async function POST(req: Request) {
  const { user, accessToken } = await requireUser()
  if (!user) return jsonError("Unauthorized", "UNAUTHORIZED", 401)

  const body = await req.json().catch(() => null)
  const parsed = schema.safeParse(body)
  if (!parsed.success) return jsonError("Invalid request body.", "BAD_REQUEST", 400)

  const supabase = createServerSupabaseClient(accessToken ?? undefined)

  // Clear current in-progress
  const clearRes = await supabase
    .from("tasks")
    .update({ in_progress: false })
    .eq("user_id", user.id)
    .eq("in_progress", true)
  if (clearRes.error) return jsonError(clearRes.error.message, "DB", 500)

  if (!parsed.data.id) return jsonOk({ inProgressTaskId: null })

  const setRes = await supabase
    .from("tasks")
    .update({ in_progress: true })
    .eq("user_id", user.id)
    .eq("id", parsed.data.id)
  if (setRes.error) return jsonError(setRes.error.message, "DB", 500)

  return jsonOk({ inProgressTaskId: parsed.data.id })
}


```

```typescript
import { z } from "zod"
import { jsonError, jsonOk } from "@/app/api/_lib/response"
import { requireUser } from "@/app/api/_lib/supabase"
import { createServerSupabaseClient } from "@/lib/supabase/server"
import type { DbTaskRow } from "../types"
import { fromDbTask } from "../types"

const taskSchema = z.object({
  title: z.string().min(1).max(80),
  description: z.string().max(500).optional(),
  dueAt: z.string().regex(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}$/),
  completed: z.boolean().optional(),
})

const schema = z.object({ tasks: z.array(taskSchema).min(1) })

export async function POST(req: Request) {
  const { user, accessToken } = await requireUser()
  if (!user) return jsonError("Unauthorized", "UNAUTHORIZED", 401)

  const body = await req.json().catch(() => null)
  const parsed = schema.safeParse(body)
  if (!parsed.success) return jsonError("Invalid request body.", "BAD_REQUEST", 400)

  const supabase = createServerSupabaseClient(accessToken ?? undefined)

  const payload = parsed.data.tasks.map((t) => ({
    user_id: user.id,
    title: t.title.trim(),
    description: (t.description ?? "").trim() || null,
    due_at: t.dueAt,
    completed: t.completed ?? false,
    in_progress: false,
    attachments: [],
  }))

  const { data, error } = await supabase.from("tasks").insert(payload).select("*")
  if (error) return jsonError(error.message, "DB", 500)

  const rows = (data ?? []) as DbTaskRow[]
  return jsonOk({ tasks: rows.map(fromDbTask) })
}


```

```typescript
import { z } from "zod"
import { jsonError, jsonOk } from "@/app/api/_lib/response"
import { requireUser } from "@/app/api/_lib/supabase"
import { createServerSupabaseClient } from "@/lib/supabase/server"

const schema = z.object({
  bucket: z.string().min(1),
  path: z.string().min(1),
})

export async function POST(req: Request) {
  const { user, accessToken } = await requireUser()
  if (!user) return jsonError("Unauthorized", "UNAUTHORIZED", 401)

  const body = await req.json().catch(() => null)
  const parsed = schema.safeParse(body)
  if (!parsed.success) return jsonError("Invalid request body.", "BAD_REQUEST", 400)

  const supabase = createServerSupabaseClient(accessToken ?? undefined)

  const { data, error } = await supabase.storage
    .from(parsed.data.bucket)
    .createSignedUrl(parsed.data.path, 60)

  if (error || !data?.signedUrl) return jsonError(error?.message ?? "Failed.", "STORAGE", 500)
  return jsonOk({ signedUrl: data.signedUrl })
}


```

```typescript
import { z } from "zod"
import { jsonError, jsonOk } from "@/app/api/_lib/response"
import { requireUser } from "@/app/api/_lib/supabase"
import { createServerSupabaseClient } from "@/lib/supabase/server"

const patchSchema = z
  .object({
    completed: z.boolean().optional(),
    description: z.string().max(500).nullable().optional(),
    title: z.string().min(1).max(80).optional(),
    dueAt: z.string().regex(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}$/).optional(),
    attachments: z.any().optional(),
  })
  .strict()

export async function PATCH(req: Request, ctx: { params: Promise<{ id: string }> }) {
  const { user, accessToken } = await requireUser()
  if (!user) return jsonError("Unauthorized", "UNAUTHORIZED", 401)

  const { id } = await ctx.params
  const body = await req.json().catch(() => null)
  const parsed = patchSchema.safeParse(body)
  if (!parsed.success) return jsonError("Invalid request body.", "BAD_REQUEST", 400)

  const supabase = createServerSupabaseClient(accessToken ?? undefined)

  const update: Record<string, unknown> = {}
  if (typeof parsed.data.completed === "boolean") {
    update.completed = parsed.data.completed
    if (parsed.data.completed) update.in_progress = false
  }
  if (typeof parsed.data.title === "string") update.title = parsed.data.title.trim()
  if (typeof parsed.data.dueAt === "string") update.due_at = parsed.data.dueAt
  if (parsed.data.description !== undefined)
    update.description = parsed.data.description ? parsed.data.description.trim() : null
  if (parsed.data.attachments !== undefined) update.attachments = parsed.data.attachments

  const { error } = await supabase.from("tasks").update(update).eq("id", id).eq("user_id", user.id)
  if (error) return jsonError(error.message, "DB", 500)

  return jsonOk({ ok: true })
}

export async function DELETE(_req: Request, ctx: { params: Promise<{ id: string }> }) {
  const { user, accessToken } = await requireUser()
  if (!user) return jsonError("Unauthorized", "UNAUTHORIZED", 401)
  const { id } = await ctx.params

  const supabase = createServerSupabaseClient(accessToken ?? undefined)

  const { error } = await supabase.from("tasks").delete().eq("id", id).eq("user_id", user.id)
  if (error) return jsonError(error.message, "DB", 500)
  return jsonOk({ ok: true })
}


```

```typescript
import { jsonError, jsonOk } from "@/app/api/_lib/response"
import { requireUser } from "@/app/api/_lib/supabase"
import { createServerSupabaseClient } from "@/lib/supabase/server"
import type { Attachment, DbTaskRow } from "../../types"
import { coerceAttachments, fromDbTask } from "../../types"

function sanitizePathSegment(s: string) {
  return s.replace(/[^\w.\-]+/g, "_")
}

function getAttachmentKind(file: File) {
  const type = (file.type || "").toLowerCase()
  const name = file.name.toLowerCase()
  const ext = name.includes(".") ? name.split(".").pop() ?? "" : ""

  if (type.startsWith("image/")) return "image" as const
  if (type.startsWith("audio/")) return "audio" as const
  if (type.startsWith("video/")) return "video" as const

  if (ext === "pdf") return "pdf" as const
  if (["xls", "xlsx", "csv"].includes(ext)) return "spreadsheet" as const
  if (["doc", "docx"].includes(ext)) return "document" as const
  if (["txt", "md", "rtf"].includes(ext)) return "text" as const
  return "file" as const
}

export async function POST(req: Request, ctx: { params: Promise<{ id: string }> }) {
  const { user, accessToken } = await requireUser()
  if (!user) return jsonError("Unauthorized", "UNAUTHORIZED", 401)
  const { id } = await ctx.params

  const supabase = createServerSupabaseClient(accessToken ?? undefined)

  const form = await req.formData()
  const files = form.getAll("files").filter((x): x is File => x instanceof File)
  if (files.length === 0) return jsonError("No files provided.", "BAD_REQUEST", 400)

  const { data: taskRow, error: taskErr } = await supabase
    .from("tasks")
    .select("*")
    .eq("id", id)
    .eq("user_id", user.id)
    .single()

  if (taskErr || !taskRow) return jsonError(taskErr?.message ?? "Task not found.", "DB", 404)

  const bucket = "task-attachments"
  const current = coerceAttachments((taskRow as DbTaskRow).attachments)
  const uploaded: Attachment[] = []

  for (const file of files) {
    const safeName = sanitizePathSegment(file.name)
    const path = `${user.id}/${id}/${crypto.randomUUID()}-${safeName}`
    const { error } = await supabase.storage.from(bucket).upload(path, file, {
      contentType: file.type,
      upsert: false,
    })
    if (error) return jsonError(error.message, "STORAGE", 500)

    uploaded.push({
      id: crypto.randomUUID(),
      name: file.name,
      type: file.type,
      size: file.size,
      bucket,
      path,
      kind: getAttachmentKind(file),
    })
  }

  const nextAttachments = [...current, ...uploaded]
  const { error: updErr, data: updated } = await supabase
    .from("tasks")
    .update({ attachments: nextAttachments })
    .eq("id", id)
    .eq("user_id", user.id)
    .select("*")
    .single()

  if (updErr || !updated) return jsonError(updErr?.message ?? "Failed to update.", "DB", 500)
  return jsonOk({ task: fromDbTask(updated as DbTaskRow) })
}


```

```typescript
import { createServerSupabaseClient } from "@/lib/supabase/server"
import { getAccessTokenFromCookies, getRefreshTokenFromCookies, setAuthCookies } from "./auth"
import { NextResponse } from "next/server"

export async function requireUser() {
  const accessToken = await getAccessTokenFromCookies()
  const refreshToken = await getRefreshTokenFromCookies()

  if (!accessToken && !refreshToken) return { user: null, accessToken: null, res: null }

  const supabase = createServerSupabaseClient(accessToken)

  // Try current access token
  if (accessToken) {
    const { data } = await supabase.auth.getUser(accessToken)
    if (data.user) return { user: data.user, accessToken, res: null }
  }

  // Refresh if possible
  if (refreshToken) {
    const anon = createServerSupabaseClient()
    const { data, error } = await anon.auth.refreshSession({ refresh_token: refreshToken })
    if (error || !data.session?.access_token || !data.session.refresh_token) {
      return { user: null, accessToken: null, res: null }
    }

    const refreshed = createServerSupabaseClient(data.session.access_token)
    const userRes = await refreshed.auth.getUser(data.session.access_token)
    if (!userRes.data.user)
      return { user: null, accessToken: null, res: null }

    const res = NextResponse.next()
    setAuthCookies(res, data.session.access_token, data.session.refresh_token)
    return { user: userRes.data.user, accessToken: data.session.access_token, res }
  }

  return { user: null, accessToken: null, res: null }
}


```

### Refactor: all Supabase operations moved into `src/app/api/**`
- The page no longer calls Supabase directly. **Auth, tasks CRUD, in-progress updates, uploads, and signed downloads are handled by API routes**:
  - `src/app/api/auth/*`
  - `src/app/api/tasks/*`
  - `src/app/api/attachments/*`

### Fixed the error shown on the page (missing `public.tasks`)
- Instead of a toast, the UI now shows an **inline “Database not initialized” message** when Supabase returns the “table not found / schema cache” error.
- It tells you to run **`supabase/schema.sql`** in Supabase SQL Editor and refresh.

### Clean implementation pattern
- **UI**: calls `apiFetch(...)` only (`src/lib/api-client.ts`)
- **Server**: reads auth tokens from **httpOnly cookies**, uses `createServerSupabaseClient(...)` (`src/lib/supabase/server.ts`)
- **API**: returns consistent `{ ok, data } / { ok, error }` responses

### New/updated files
- **API helpers**: `src/app/api/_lib/*`
- **Auth routes**: `src/app/api/auth/*`
- **Tasks routes**: `src/app/api/tasks/*` (includes `seed`, `clear-completed`, `in-progress`, attachments upload)
- **Storage signed URL**: `src/app/api/attachments/signed-url/route.ts`
- **Client API wrapper**: `src/lib/api-client.ts`
- **UI refactor**: `src/app/page.tsx`

### Next steps for you
- Run `supabase/schema.sql` in Supabase Dashboard → **SQL Editor**
- Then refresh the app; the “missing table” message should disappear.

---

**User**

refactor the code to remove unused functions and redundant logic

---

**Cursor**

Plan: I’ll scan `src/app/page.tsx` for types/helpers that are no longer referenced after the API refactor (e.g. old Supabase helper types, attachment kind inference, etc.), delete them, and simplify a few duplicated UI wrappers. Then I’ll run `npm run build` to ensure nothing broke.

```typescriptreact
"use client"

import { zodResolver } from "@hookform/resolvers/zod"
import {
  AlertTriangle,
  CirclePlay,
  CircleStop,
  CalendarClock,
  CheckCircle2,
  Download,
  File,
  FileSpreadsheet,
  FileText,
  Image as ImageIcon,
  Info,
  Music,
  Bell,
  Timer,
  Trash2,
  Video,
} from "lucide-react"
import * as React from "react"
import { useForm } from "react-hook-form"
import { toast } from "sonner"
import { z } from "zod"
// Supabase is accessed via Next.js API routes (see src/app/api/**). No direct client usage here.

import { ModeToggle } from "@/components/mode-toggle"
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert"
import { Badge } from "@/components/ui/badge"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Checkbox } from "@/components/ui/checkbox"
import { Form, FormControl, FormField, FormItem, FormMessage } from "@/components/ui/form"
import { Input } from "@/components/ui/input"
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select"
import { Separator } from "@/components/ui/separator"
import { Textarea } from "@/components/ui/textarea"
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip"
import { cn } from "@/lib/utils"
import { apiFetch, ApiError } from "@/lib/api-client"

type AttachmentKind =
  | "image"
  | "audio"
  | "video"
  | "pdf"
  | "spreadsheet"
  | "document"
  | "text"
  | "file"

type Attachment = {
  id: string
  name: string
  type: string
  size: number
  bucket: string
  path: string
  kind: AttachmentKind
}

type Todo = {
  id: string
  title: string
  description?: string
  completed: boolean
  // Stored as `datetime-local` string (YYYY-MM-DDTHH:mm) in local time.
  dueAt: string
  attachments: Attachment[]
}

type DailyLoad = "light" | "balanced" | "heavy"

const todoSchema = z.object({
  title: z
    .string()
    .trim()
    .min(1, "Title is required.")
    .max(80, "Keep it under 80 characters."),
  description: z
    .string()
    .trim()
    .max(500, "Keep it under 500 characters.")
    .optional()
    .or(z.literal("")),
  dueAt: z
    .string()
    .min(1, "Due date & time is required.")
    .regex(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}$/, "Invalid date/time."),
})

type TodoFormValues = z.infer<typeof todoSchema>

const initialTodos: Todo[] = [
  {
    id: "1",
    title: "Create a Next.js app",
    description: "Scaffold with TypeScript + Tailwind and confirm it runs locally.",
    completed: true,
    dueAt: "2026-01-16T09:00",
    attachments: [],
  },
  {
    id: "2",
    title: "Add shadcn/ui + dark theme",
    description: "Initialize shadcn, set up theme provider, and verify dark mode.",
    completed: true,
    dueAt: "2026-01-16T10:30",
    attachments: [],
  },
  {
    id: "3",
    title: "Build a mock-data to-do list",
    completed: false,
    dueAt: "2026-01-16T15:00",
    attachments: [],
  },
  {
    id: "4",
    title: "Yesterday: review requirements",
    completed: true,
    dueAt: "2026-01-15T11:15",
    attachments: [],
  },
  {
    id: "5",
    title: "Yesterday: sketch UI layout",
    completed: true,
    dueAt: "2026-01-15T17:45",
    attachments: [],
  },
  {
    id: "6",
    title: "Today: add attachments support",
    completed: false,
    dueAt: "2026-01-16T18:20",
    attachments: [],
  },
  {
    id: "7",
    title: "Tomorrow: QA the filters",
    description: "Test date-only, time-only, exact, and between behaviors.",
    completed: false,
    dueAt: "2026-01-17T08:05",
    attachments: [],
  },
  {
    id: "8",
    title: "Tomorrow: polish summary cards",
    completed: false,
    dueAt: "2026-01-17T13:30",
    attachments: [],
  },
  {
    id: "9",
    title: "Tomorrow: write small UX notes",
    completed: false,
    dueAt: "2026-01-17T20:10",
    attachments: [],
  },
  {
    id: "10",
    title: "This weekend: add more mock tasks",
    completed: false,
    dueAt: "2026-01-18T10:00",
    attachments: [],
  },
  {
    id: "11",
    title: "This weekend: check time-only filter",
    completed: false,
    dueAt: "2026-01-18T22:15",
    attachments: [],
  },
  {
    id: "12",
    title: "Next week: sync with team",
    completed: false,
    dueAt: "2026-01-19T09:30",
    attachments: [],
  },
  {
    id: "13",
    title: "Next week: test date-only filter",
    completed: false,
    dueAt: "2026-01-20T14:05",
    attachments: [],
  },
  {
    id: "14",
    title: "Next week: test exact date+time filter",
    completed: false,
    dueAt: "2026-01-21T12:00",
    attachments: [],
  },
  {
    id: "15",
    title: "Next week: attach docs to completed tasks",
    completed: false,
    dueAt: "2026-01-22T16:40",
    attachments: [],
  },
  {
    id: "16",
    title: "Next week: final review",
    completed: false,
    dueAt: "2026-01-23T11:00",
    attachments: [],
  },
]

function parseLocalDateTime(value: string): number {
  // value: "YYYY-MM-DDTHH:mm"
  const [datePart, timePart] = value.split("T")
  const [y, m, d] = datePart.split("-").map(Number)
  const [hh, mm] = timePart.split(":").map(Number)
  return new Date(y, m - 1, d, hh, mm, 0, 0).getTime()
}

function pad2(n: number) {
  return String(n).padStart(2, "0")
}

function localDateKey(d: Date) {
  return `${d.getFullYear()}-${pad2(d.getMonth() + 1)}-${pad2(d.getDate())}`
}

function addDays(date: Date, days: number) {
  const d = new Date(date)
  d.setDate(d.getDate() + days)
  return d
}

function startOfDay(date: Date) {
  return new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0, 0)
}

function endOfDay(date: Date) {
  return new Date(
    date.getFullYear(),
    date.getMonth(),
    date.getDate(),
    23,
    59,
    59,
    999
  )
}

function getDatePart(dueAt: string) {
  return dueAt.split("T")[0] ?? ""
}

function getTimePart(dueAt: string) {
  return dueAt.split("T")[1] ?? ""
}

function parseLocalDateOnly(value: string): Date {
  // value: "YYYY-MM-DD"
  const [y, m, d] = value.split("-").map(Number)
  return new Date(y, m - 1, d, 0, 0, 0, 0)
}

function parseLocalTimeToMinutes(value: string): number {
  // value: "HH:mm"
  const [hh, mm] = value.split(":").map(Number)
  return hh * 60 + mm
}

function formatLocalDateTime(value: string): string {
  const ms = parseLocalDateTime(value)
  if (!Number.isFinite(ms)) return value
  return new Intl.DateTimeFormat(undefined, {
    year: "numeric",
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  }).format(new Date(ms))
}

function formatDateTimeFromMs(ms: number): string {
  return new Intl.DateTimeFormat(undefined, {
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  }).format(new Date(ms))
}

function minutesUntil(targetMs: number, nowMs: number) {
  return Math.ceil((targetMs - nowMs) / 60_000)
}

function getTaskFlags(todo: Todo, nowMs: number, inProgressTaskId: string | null) {
  const completed = todo.completed
  const dueMs = parseLocalDateTime(todo.dueAt)
  const overdue = !completed && dueMs < nowMs
  const inProgress = !completed && inProgressTaskId === todo.id
  const planned = !completed && !overdue && !inProgress
  return { completed, overdue, inProgress, planned }
}

function getDailyLoad(todosForDay: Todo[]) {
  // 4-hour windows across the day (local).
  const labels = [
    "00:00–04:00",
    "04:00–08:00",
    "08:00–12:00",
    "12:00–16:00",
    "16:00–20:00",
    "20:00–24:00",
  ]
  const buckets = Array.from({ length: 6 }, () => 0) as number[]
  for (const t of todosForDay) {
    const ms = parseLocalDateTime(t.dueAt)
    const hour = new Date(ms).getHours()
    const idx = Math.floor(hour / 4)
    buckets[idx] = (buckets[idx] ?? 0) + 1
  }

  const total = todosForDay.length
  const peak = Math.max(0, ...buckets)
  const spread = buckets.filter((c) => c > 0).length
  const busiestIdx = buckets.findIndex((c) => c === peak)
  const busiestWindow = busiestIdx >= 0 ? labels[busiestIdx] : labels[0]

  // Heuristic: more tasks + higher concentration in one window => heavier day.
  const score = total + peak * 1.5 + Math.max(0, spread - 1) * 0.5
  const load: DailyLoad = score <= 5 ? "light" : score <= 10 ? "balanced" : "heavy"

  return { load, total, peak, spread, busiestWindow }
}

function DailyLoadBadge({ load }: { load: DailyLoad }) {
  if (load === "heavy") return <Badge variant="destructive">Heavy</Badge>
  if (load === "balanced") return <Badge variant="secondary">Balanced</Badge>
  return <Badge variant="outline">Light</Badge>
}

function TaskBadges({
  completed,
  overdue,
  inProgress,
  planned,
}: {
  completed: boolean
  overdue: boolean
  inProgress: boolean
  planned: boolean
}) {
  if (completed) {
    return (
      <Badge className="gap-1 bg-emerald-600 text-white hover:bg-emerald-600">
        <CheckCircle2 className="h-3.5 w-3.5" />
        Completed
      </Badge>
    )
  }

  return (
    <>
      {inProgress && (
        <Badge className="gap-1 bg-sky-600 text-white hover:bg-sky-600">
          <Timer className="h-3.5 w-3.5 text-white" />
          In progress
        </Badge>
      )}
      {overdue && (
        <Badge variant="destructive" className="gap-1">
          <AlertTriangle className="h-3.5 w-3.5" />
          Overdue
        </Badge>
      )}
      {planned && (
        <Badge variant="outline" className="gap-1">
          <CalendarClock className="h-3.5 w-3.5" />
          Planned
        </Badge>
      )}
    </>
  )
}

function AttachmentIcon({ kind }: { kind: AttachmentKind }) {
  const className = "h-4 w-4 text-muted-foreground"

  switch (kind) {
    case "image":
      return <ImageIcon className={className} />
    case "audio":
      return <Music className={className} />
    case "video":
      return <Video className={className} />
    case "spreadsheet":
      return <FileSpreadsheet className={className} />
    case "pdf":
    case "document":
    case "text":
      return <FileText className={className} />
    default:
      return <File className={className} />
  }
}

const authSchema = z.object({
  email: z.string().email("Enter a valid email."),
  password: z.string().min(6, "Password must be at least 6 characters."),
})
type AuthValues = z.infer<typeof authSchema>

function AuthCard({ onAuthed }: { onAuthed: () => void }) {
  const [mode, setMode] = React.useState<"sign_in" | "sign_up">("sign_in")
  const [busy, setBusy] = React.useState(false)

  const form = useForm<AuthValues>({
    resolver: zodResolver(authSchema),
    defaultValues: { email: "", password: "" },
  })

  async function onSubmit(values: AuthValues) {
    setBusy(true)
    try {
      if (mode === "sign_in") {
        await apiFetch("/api/auth/sign-in", {
          method: "POST",
          body: JSON.stringify(values),
        })
        onAuthed()
      } else {
        await apiFetch("/api/auth/sign-up", {
          method: "POST",
          body: JSON.stringify(values),
        })
        toast.success("Account created", {
          description: "You can now sign in (or confirm email if required).",
        })
        setMode("sign_in")
      }
    } catch (e) {
      toast.error("Authentication failed", {
        description: e instanceof Error ? e.message : "Please try again.",
      })
    } finally {
      setBusy(false)
    }
  }

  return (
    <div className="mx-auto flex min-h-screen max-w-md flex-col justify-center px-4 py-10">
      <Card>
        <CardHeader>
          <CardTitle className="text-2xl">Sign in</CardTitle>
          <p className="text-muted-foreground text-sm">
            {mode === "sign_in"
              ? "Use your email and password."
              : "Create an account with email and password."}
          </p>
        </CardHeader>
        <CardContent className="space-y-4">
          <Form {...form}>
            <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-3" noValidate>
              <FormField
                control={form.control}
                name="email"
                render={({ field }) => (
                  <FormItem>
                    <FormControl>
                      <Input placeholder="Email" autoComplete="email" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="password"
                render={({ field }) => (
                  <FormItem>
                    <FormControl>
                      <Input
                        type="password"
                        placeholder="Password"
                        autoComplete={
                          mode === "sign_in" ? "current-password" : "new-password"
                        }
                        {...field}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <Button type="submit" className="w-full" disabled={busy}>
                {mode === "sign_in" ? "Sign in" : "Sign up"}
              </Button>
            </form>
          </Form>

          <div className="flex items-center justify-between gap-3 text-sm">
            <span className="text-muted-foreground">
              {mode === "sign_in" ? "No account?" : "Already have an account?"}
            </span>
            <Button
              type="button"
              variant="link"
              className="px-0"
              onClick={() => setMode((m) => (m === "sign_in" ? "sign_up" : "sign_in"))}
            >
              {mode === "sign_in" ? "Sign up" : "Sign in"}
            </Button>
          </div>
        </CardContent>
      </Card>
    </div>
  )
}

export default function Home() {
  const [user, setUser] = React.useState<{ id: string; email?: string } | null>(null)
  const [authLoading, setAuthLoading] = React.useState(true)
  const [authError, setAuthError] = React.useState<string | null>(null)

  const refreshAuth = React.useCallback(async () => {
    setAuthLoading(true)
    try {
      const data = await apiFetch<{ user: { id: string; email?: string } | null }>("/api/auth/me")
      setUser(data.user)
      setAuthError(null)
    } catch (e) {
      setUser(null)
      setAuthError(e instanceof Error ? e.message : "Auth check failed.")
    } finally {
      setAuthLoading(false)
    }
  }, [])

  React.useEffect(() => {
    void refreshAuth()
  }, [refreshAuth])

  if (authLoading) {
    return (
      <div className="mx-auto flex min-h-screen max-w-2xl flex-col justify-center px-4 py-10">
        <p className="text-muted-foreground text-sm">Loading…</p>
      </div>
    )
  }

  if (authError) {
    return (
      <div className="mx-auto flex min-h-screen max-w-2xl flex-col justify-center gap-4 px-4 py-10">
        <Card>
          <CardHeader>
            <CardTitle>Auth unavailable</CardTitle>
          </CardHeader>
          <CardContent className="space-y-2">
            <p className="text-muted-foreground text-sm">{authError}</p>
            <p className="text-muted-foreground text-sm">
              Check <code>SUPABASE_SETUP.md</code> and set env vars from{" "}
              <code>supabase.env.example</code>.
            </p>
            <Button type="button" variant="outline" onClick={() => void refreshAuth()}>
              Retry
            </Button>
          </CardContent>
        </Card>
      </div>
    )
  }

  if (!user) return <AuthCard onAuthed={() => void refreshAuth()} />

  return (
    <div className="mx-auto flex min-h-screen max-w-2xl flex-col gap-6 px-4 py-10">
      <TodoApp userId={user.id} onSignedOut={() => void refreshAuth()} />
    </div>
  )
}

function TodoApp({ userId, onSignedOut }: { userId: string; onSignedOut: () => void }) {
  const [todos, setTodos] = React.useState<Todo[]>([])
  const [tasksLoading, setTasksLoading] = React.useState(true)
  const [tasksError, setTasksError] = React.useState<{ code?: string; message: string } | null>(
    null
  )
  const [attachTargetTodoId, setAttachTargetTodoId] = React.useState<string | null>(
    null
  )
  const [conflictDueAt, setConflictDueAt] = React.useState<string | null>(null)
  const clearConflictTimerRef = React.useRef<number | null>(null)
  const [focusMode, setFocusMode] = React.useState(false)
  const [nowMs, setNowMs] = React.useState(() => Date.now())
  const [inProgressTaskId, setInProgressTaskId] = React.useState<string | null>(null)
  const [dismissedReminderTaskId, setDismissedReminderTaskId] = React.useState<
    string | null
  >(null)
  const [filterMode, setFilterMode] = React.useState<"between" | "exact">("between")
  const [filterFromDate, setFilterFromDate] = React.useState<string>("")
  const [filterFromTime, setFilterFromTime] = React.useState<string>("")
  const [filterToDate, setFilterToDate] = React.useState<string>("")
  const [filterToTime, setFilterToTime] = React.useState<string>("")
  const [filterExactDate, setFilterExactDate] = React.useState<string>("")
  const [filterExactTime, setFilterExactTime] = React.useState<string>("")
  const fileInputRef = React.useRef<HTMLInputElement>(null)
  const [pageSize, setPageSize] = React.useState<number>(5)
  const [page, setPage] = React.useState<number>(1)

  React.useEffect(() => {
    let alive = true
    async function load() {
      setTasksLoading(true)
      if (!alive) return
      try {
        const data = await apiFetch<{ tasks: Todo[]; inProgressTaskId: string | null }>("/api/tasks")
        if (!alive) return
        setTodos(data.tasks)
        setInProgressTaskId(data.inProgressTaskId)
        setTasksError(null)
      } catch (e) {
        if (!alive) return
        if (e instanceof ApiError) setTasksError({ code: e.code, message: e.message })
        else setTasksError({ message: e instanceof Error ? e.message : "Failed to load tasks." })
        setTodos([])
        setInProgressTaskId(null)
      } finally {
        setTasksLoading(false)
      }
    }
    load()
    return () => {
      alive = false
    }
  }, [userId])

  // Keep "now" fresh so overdue/in-progress states stay accurate without user interaction.
  React.useEffect(() => {
    const id = window.setInterval(() => setNowMs(Date.now()), 30_000)
    return () => window.clearInterval(id)
  }, [])

  // Only one task can be "In Progress"; auto-clear if completed, deleted, or overdue.
  React.useEffect(() => {
    if (!inProgressTaskId) return
    const t = todos.find((x) => x.id === inProgressTaskId)
    if (!t || t.completed) {
      setInProgressTaskId(null)
      return
    }
  }, [inProgressTaskId, nowMs, todos])

  const nextUpcoming = React.useMemo(() => {
    const upcoming = todos
      .filter((t) => !t.completed)
      .map((t) => ({ todo: t, dueMs: parseLocalDateTime(t.dueAt) }))
      .filter((x) => x.dueMs >= nowMs)
      .sort((a, b) => a.dueMs - b.dueMs)[0]
    return upcoming ?? null
  }, [nowMs, todos])

  React.useEffect(() => {
    // If "next upcoming" changed, allow reminder again (dismiss is per-task).
    if (nextUpcoming && nextUpcoming.todo.id !== dismissedReminderTaskId) return
    if (!nextUpcoming) setDismissedReminderTaskId(null)
  }, [dismissedReminderTaskId, nextUpcoming])

  const reminder = React.useMemo(() => {
    const REMINDER_WINDOW_MIN = 15
    if (!nextUpcoming) return null
    if (dismissedReminderTaskId === nextUpcoming.todo.id) return null
    const mins = minutesUntil(nextUpcoming.dueMs, nowMs)
    if (mins < 0 || mins > REMINDER_WINDOW_MIN) return null
    return { ...nextUpcoming, mins }
  }, [dismissedReminderTaskId, nextUpcoming, nowMs])

  const form = useForm<TodoFormValues>({
    resolver: zodResolver(todoSchema),
    defaultValues: { title: "", description: "", dueAt: "" },
    mode: "onSubmit",
  })

  const summary = React.useMemo(() => {
    const now = new Date()
    const todayKey = localDateKey(now)
    const tomorrow = addDays(now, 1)
    const tomorrowKey = localDateKey(tomorrow)

    const todays = todos.filter((t) => t.dueAt.startsWith(todayKey))
    const todayCompleted = todays.filter((t) => t.completed).length
    const todayPending = todays.length - todayCompleted

    const labels = [
      "00:00–04:00",
      "04:00–08:00",
      "08:00–12:00",
      "12:00–16:00",
      "16:00–20:00",
      "20:00–24:00",
    ]

    // Tomorrow: same 4-hour windows breakdown
    const tomorrowTasks = todos.filter((t) => t.dueAt.startsWith(tomorrowKey))
    const tomorrowBuckets = Array.from({ length: 6 }, () => 0) as number[]
    for (const t of tomorrowTasks) {
      const ms = parseLocalDateTime(t.dueAt)
      const hour = new Date(ms).getHours()
      const idx = Math.floor(hour / 4)
      tomorrowBuckets[idx] = (tomorrowBuckets[idx] ?? 0) + 1
    }

    // Until next week = next 7 days starting tomorrow (local), grouped into 4-hour windows.
    const rangeStart = startOfDay(tomorrow).getTime()
    const rangeEnd = addDays(startOfDay(tomorrow), 7).getTime()
    const buckets = Array.from({ length: 6 }, () => 0) as number[]

    const upcoming = todos.filter((t) => {
      const ms = parseLocalDateTime(t.dueAt)
      return ms >= rangeStart && ms < rangeEnd
    })

    for (const t of upcoming) {
      const ms = parseLocalDateTime(t.dueAt)
      const hour = new Date(ms).getHours()
      const idx = Math.floor(hour / 4)
      buckets[idx] = (buckets[idx] ?? 0) + 1
    }

    return {
      todayCompleted,
      todayPending,
      tomorrowTotal: tomorrowTasks.length,
      tomorrowBuckets: labels.map((label, i) => ({ label, count: tomorrowBuckets[i] ?? 0 })),
      upcomingTotal: upcoming.length,
      upcomingBuckets: labels.map((label, i) => ({ label, count: buckets[i] ?? 0 })),
    }
  }, [todos])

  const loadDayKey = React.useMemo(() => {
    // Prefer an explicitly selected date from filters; otherwise use today.
    if (filterMode === "exact" && filterExactDate) return filterExactDate
    if (filterFromDate && !filterToDate) return filterFromDate
    if (filterFromDate && filterToDate && filterFromDate === filterToDate) return filterFromDate
    if (!filterFromDate && filterToDate) return filterToDate
    return localDateKey(new Date(nowMs))
  }, [filterExactDate, filterFromDate, filterMode, filterToDate, nowMs])

  const dailyLoad = React.useMemo(() => {
    const dayTodos = todos.filter((t) => getDatePart(t.dueAt) === loadDayKey)
    return getDailyLoad(dayTodos)
  }, [loadDayKey, todos])

  const filteredTodos = React.useMemo(() => {
    if (focusMode) {
      const endMs = nowMs + 4 * 60 * 60 * 1000
      const withMs = todos.map((t) => ({ ...t, _dueMs: parseLocalDateTime(t.dueAt) }))
      return withMs.filter((t) => t._dueMs >= nowMs && t._dueMs <= endMs)
    }

    const withMs = todos.map((t) => ({ ...t, _dueMs: parseLocalDateTime(t.dueAt) }))
    if (filterMode === "exact") {
      // If only date is selected -> show tasks for that date.
      // If time is selected too -> match exact date+time.
      // If only time is selected -> match time-of-day across all dates.
      if (!filterExactDate && !filterExactTime) return withMs

      if (filterExactDate && !filterExactTime) {
        return withMs.filter((t) => getDatePart(t.dueAt) === filterExactDate)
      }

      if (filterExactDate && filterExactTime) {
        const exactMs = parseLocalDateTime(`${filterExactDate}T${filterExactTime}`)
        return withMs.filter((t) => t._dueMs === exactMs)
      }

      // time only
      return withMs.filter((t) => getTimePart(t.dueAt) === filterExactTime)
    }
    // between
    const hasAnyDate = Boolean(filterFromDate || filterToDate)
    const hasAnyTime = Boolean(filterFromTime || filterToTime)

    // Date range (optional)
    const fromDateMs = filterFromDate
      ? startOfDay(parseLocalDateOnly(filterFromDate)).getTime()
      : Number.NEGATIVE_INFINITY
    const toDateMs = filterToDate
      ? endOfDay(parseLocalDateOnly(filterToDate)).getTime()
      : Number.POSITIVE_INFINITY

    // Time-of-day range (optional)
    const fromTimeMin = filterFromTime ? parseLocalTimeToMinutes(filterFromTime) : 0
    const toTimeMin = filterToTime ? parseLocalTimeToMinutes(filterToTime) : 24 * 60 - 1

    return withMs.filter((t) => {
      const ms = t._dueMs
      if (hasAnyDate && (ms < fromDateMs || ms > toDateMs)) return false

      if (hasAnyTime) {
        const time = getTimePart(t.dueAt)
        if (!time) return false
        const mins = parseLocalTimeToMinutes(time)
        // Simple (non-wrapping) range. If you want wrap-around (e.g. 22:00–02:00), tell me.
        if (mins < fromTimeMin || mins > toTimeMin) return false
      }

      // If neither date nor time selected, pass through (handled above anyway)
      return true
    })
  }, [
    todos,
    focusMode,
    nowMs,
    filterExactDate,
    filterExactTime,
    filterFromDate,
    filterFromTime,
    filterMode,
    filterToDate,
    filterToTime,
  ])

  const sortedFilteredTodos = React.useMemo(
    () =>
      filteredTodos
        .slice()
        .sort((a, b) => parseLocalDateTime(a.dueAt) - parseLocalDateTime(b.dueAt)),
    [filteredTodos]
  )

  // Clamp page when filters/pageSize change.
  React.useEffect(() => {
    const totalPages = Math.max(1, Math.ceil(sortedFilteredTodos.length / pageSize))
    setPage((p) => Math.min(Math.max(1, p), totalPages))
  }, [pageSize, sortedFilteredTodos.length])

  const totalItems = sortedFilteredTodos.length
  const totalPages = Math.max(1, Math.ceil(totalItems / pageSize))
  const showPagination = totalPages > 1

  const pageItems = React.useMemo(() => {
    const start = (page - 1) * pageSize
    return sortedFilteredTodos.slice(start, start + pageSize)
  }, [page, pageSize, sortedFilteredTodos])

  const groupedTodos = React.useMemo(() => {
    const groups: Array<{ date: string; items: typeof pageItems }> = []
    for (const t of pageItems) {
      const date = getDatePart(t.dueAt)
      const last = groups[groups.length - 1]
      if (!last || last.date !== date) groups.push({ date, items: [t] })
      else last.items.push(t)
    }
    return groups
  }, [pageItems])

  const completedCount = filteredTodos.filter((t) => t.completed).length

  async function addTodo(values: TodoFormValues) {
    const conflicts = todos.filter((t) => t.dueAt === values.dueAt)
    if (conflicts.length > 0) {
      setConflictDueAt(values.dueAt)
      if (clearConflictTimerRef.current) window.clearTimeout(clearConflictTimerRef.current)
      clearConflictTimerRef.current = window.setTimeout(() => {
        setConflictDueAt(null)
      }, 8000)

      // Make sure the user can see the conflicting tasks even if they were filtered out.
      const [d, time] = values.dueAt.split("T")
      setFilterMode("exact")
      setFilterExactDate(d ?? "")
      setFilterExactTime(time ?? "")
      setPage(1)

      toast.error("Time conflict", {
        description: `You already have ${conflicts.length} task(s) scheduled at ${formatLocalDateTime(
          values.dueAt
        )}.`,
      })
    }

    try {
      const data = await apiFetch<{ task: Todo }>("/api/tasks", {
        method: "POST",
        body: JSON.stringify(values),
      })
      setTodos((prev) => [data.task, ...prev])
    } catch (e) {
      toast.error("Failed to add task", { description: e instanceof Error ? e.message : "Failed." })
      return
    }
    form.reset()
  }

  async function toggleTodo(id: string, completed: boolean) {
    // optimistic
    setTodos((prev) =>
      prev.map((t) =>
        t.id === id ? { ...t, completed, attachments: t.attachments } : t
      )
    )
    if (completed) setInProgressTaskId((cur) => (cur === id ? null : cur))

    const update: { completed: boolean; in_progress?: boolean } = { completed }
    if (completed) update.in_progress = false

    try {
      await apiFetch("/api/tasks/" + id, {
        method: "PATCH",
        body: JSON.stringify({ completed }),
      })
    } catch (e) {
      toast.error("Failed to update task", { description: e instanceof Error ? e.message : "Failed." })
    }
  }

  function requestAttachmentsForTodo(todoId: string) {
    setAttachTargetTodoId(todoId)
    // Let state update before opening picker (some browsers are picky).
    queueMicrotask(() => fileInputRef.current?.click())
  }

  async function handleFilesPicked(e: React.ChangeEvent<HTMLInputElement>) {
    const files = Array.from(e.target.files ?? [])
    const targetId = attachTargetTodoId

    // reset input so picking the same file again triggers onChange
    e.target.value = ""
    setAttachTargetTodoId(null)

    if (!targetId || files.length === 0) return
    const form = new FormData()
    for (const f of files) form.append("files", f)
    try {
      const res = await fetch(`/api/tasks/${targetId}/attachments`, {
        method: "POST",
        credentials: "include",
        body: form,
      })
      const json = (await res.json().catch(() => null)) as
        | { ok: true; data: { task: Todo } }
        | { ok: false; error: { message: string } }
        | null
      if (!json || !json.ok) throw new Error(json?.error.message ?? "Upload failed.")
      setTodos((prev) => prev.map((t) => (t.id === targetId ? json.data.task : t)))
    } catch (e) {
      toast.error("Upload failed", { description: e instanceof Error ? e.message : "Failed." })
    }
  }

  async function deleteTodo(id: string) {
    // optimistic
    setTodos((prev) => prev.filter((t) => t.id !== id))
    setInProgressTaskId((cur) => (cur === id ? null : cur))

    try {
      await apiFetch("/api/tasks/" + id, { method: "DELETE" })
    } catch (e) {
      toast.error("Failed to delete task", { description: e instanceof Error ? e.message : "Failed." })
    }
  }

  async function setInProgress(taskId: string | null) {
    // optimistic
    setInProgressTaskId(taskId)

    try {
      const data = await apiFetch<{ inProgressTaskId: string | null }>("/api/tasks/in-progress", {
        method: "POST",
        body: JSON.stringify({ id: taskId }),
      })
      setInProgressTaskId(data.inProgressTaskId)
    } catch (e) {
      toast.error("Failed to update in-progress", {
        description: e instanceof Error ? e.message : "Failed.",
      })
    }
  }

  async function downloadAttachment(a: Attachment) {
    try {
      const data = await apiFetch<{ signedUrl: string }>("/api/attachments/signed-url", {
        method: "POST",
        body: JSON.stringify({ bucket: a.bucket, path: a.path }),
      })
      window.open(data.signedUrl, "_blank", "noopener,noreferrer")
    } catch (e) {
      toast.error("Download failed", { description: e instanceof Error ? e.message : "Failed." })
    }
  }

  async function seedDemoTasks() {
    if (todos.length > 0) return
    try {
      const data = await apiFetch<{ tasks: Todo[] }>("/api/tasks/seed", {
        method: "POST",
        body: JSON.stringify({ tasks: initialTodos }),
      })
      setTodos(data.tasks)
    } catch (e) {
      toast.error("Failed to seed demo tasks", { description: e instanceof Error ? e.message : "Failed." })
    }
  }

  async function clearCompleted() {
    const completedIds = new Set(todos.filter((t) => t.completed).map((t) => t.id))
    if (completedIds.size === 0) return

    // optimistic
    setTodos((prev) => prev.filter((t) => !completedIds.has(t.id)))

    try {
      await apiFetch("/api/tasks/clear-completed", { method: "POST" })
    } catch (e) {
      toast.error("Failed to clear completed", { description: e instanceof Error ? e.message : "Failed." })
    }
  }

  return (
    <Card>
      <CardHeader className="flex flex-row items-center justify-between gap-4">
        <div className="space-y-1">
          <CardTitle className="text-2xl">To‑Do</CardTitle>
          <p className="text-muted-foreground text-sm">
            {completedCount}/{filteredTodos.length} completed
          </p>
        </div>
        <div className="flex items-center gap-2">
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <Button
                  type="button"
                  variant={focusMode ? "default" : "outline"}
                  size="sm"
                  onClick={() => {
                    setFocusMode((v) => !v)
                    setPage(1)
                  }}
                >
                  Focus Mode
                </Button>
              </TooltipTrigger>
              <TooltipContent>
                <p>Show tasks for the next 4 hours.</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
          <Button
            type="button"
            variant="outline"
            size="sm"
            onClick={async () => {
              await apiFetch("/api/auth/sign-out", { method: "POST" }).catch(() => {})
              onSignedOut()
            }}
          >
            Sign out
          </Button>
          <ModeToggle />
        </div>
      </CardHeader>

      <CardContent className="space-y-6">
        {tasksLoading && (
          <p className="text-muted-foreground text-sm">Loading tasks…</p>
        )}

        {!tasksLoading && tasksError?.code === "MISSING_TABLE" && (
          <Alert variant="destructive">
            <AlertTitle>Database not initialized</AlertTitle>
            <AlertDescription>
              <div className="space-y-2">
                <p>
                  The Supabase table <code>public.tasks</code> was not found. Run the SQL in{" "}
                  <code>supabase/schema.sql</code> (Supabase Dashboard → SQL Editor), then refresh.
                </p>
                <p className="text-xs opacity-90">{tasksError.message}</p>
              </div>
            </AlertDescription>
          </Alert>
        )}

        {!tasksLoading && tasksError && tasksError.code !== "MISSING_TABLE" && (
          <Alert variant="destructive">
            <AlertTitle>Failed to load tasks</AlertTitle>
            <AlertDescription>{tasksError.message}</AlertDescription>
          </Alert>
        )}

        {!tasksLoading && todos.length === 0 && (
          <div className="flex items-center justify-between gap-3 rounded-lg border bg-muted/20 px-3 py-2">
            <p className="text-muted-foreground text-sm">No tasks yet.</p>
            <Button type="button" variant="outline" size="sm" onClick={() => void seedDemoTasks()}>
              Seed demo tasks
            </Button>
          </div>
        )}

        <input
          ref={fileInputRef}
          type="file"
          multiple
          className="hidden"
          accept={[
            "image/*",
            "audio/*",
            "video/*",
            ".pdf",
            ".doc",
            ".docx",
            ".xls",
            ".xlsx",
            ".csv",
            ".txt",
            ".md",
            ".rtf",
          ].join(",")}
          onChange={handleFilesPicked}
        />

        {reminder && (
          <Alert className="border-primary/30 bg-primary/5">
            <Bell className="h-4 w-4" />
            <div className="flex flex-1 flex-col gap-1">
              <div className="flex flex-wrap items-center justify-between gap-2">
                <AlertTitle className="text-sm">
                  Next task starts in {reminder.mins} minute{reminder.mins === 1 ? "" : "s"}
                </AlertTitle>
                <Button
                  type="button"
                  variant="ghost"
                  size="sm"
                  onClick={() => setDismissedReminderTaskId(reminder.todo.id)}
                >
                  Dismiss
                </Button>
              </div>
              <AlertDescription className="text-sm">
                <span className="font-medium">{reminder.todo.title}</span> ·{" "}
                {formatDateTimeFromMs(reminder.dueMs)}
              </AlertDescription>
            </div>
          </Alert>
        )}

        <div className="rounded-xl border bg-card p-4">
          <div className="flex flex-wrap items-center justify-between gap-2">
            <p className="text-sm font-medium">
              Daily load{" "}
              <span className="text-muted-foreground font-normal">
                ({new Intl.DateTimeFormat(undefined, {
                  weekday: "short",
                  year: "numeric",
                  month: "short",
                  day: "2-digit",
                }).format(parseLocalDateOnly(loadDayKey))})
              </span>
            </p>
            <DailyLoadBadge load={dailyLoad.load} />
          </div>
          <p className="text-muted-foreground mt-2 text-sm">
            {dailyLoad.total} task(s) · busiest window {dailyLoad.busiestWindow} ({dailyLoad.peak})
          </p>
        </div>

        <div className="grid gap-3 sm:grid-cols-3">
          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Today’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">
              {summary.todayCompleted} completed
            </p>
            <p className="text-muted-foreground text-sm">{summary.todayPending} pending</p>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tomorrow’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">{summary.tomorrowTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.tomorrowBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tasks Until Next Week</p>
            <p className="mt-2 text-2xl font-semibold">{summary.upcomingTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.upcomingBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>
        </div>

        {focusMode && (
          <div className="flex flex-col gap-1 rounded-lg border bg-muted/20 px-3 py-2 sm:flex-row sm:items-center sm:justify-between">
            <p className="text-sm">
              <span className="font-medium">Focus Mode:</span>{" "}
              showing tasks due in the next 4 hours (until{" "}
              <span className="font-medium">
                {formatDateTimeFromMs(nowMs + 4 * 60 * 60 * 1000)}
              </span>
              )
            </p>
            <Button type="button" variant="ghost" size="sm" onClick={() => setFocusMode(false)}>
              Exit
            </Button>
          </div>
        )}

        <Form {...form}>
          <form
            onSubmit={form.handleSubmit(addTodo)}
            className="space-y-2"
            noValidate
          >
            <div className="flex flex-col gap-2 sm:flex-row">
              <FormField
                control={form.control}
                name="title"
                render={({ field }) => (
                  <FormItem className="flex-1">
                    <FormControl>
                      <Input
                        placeholder="Add a task…"
                        autoComplete="off"
                        {...field}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="dueAt"
                render={({ field }) => (
                  <FormItem className="sm:w-64">
                    <FormControl>
                      <Input type="datetime-local" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <Button type="submit">Add</Button>
            </div>

            <FormField
              control={form.control}
              name="description"
              render={({ field }) => (
                <FormItem>
                  <FormControl>
                    <Textarea
                      rows={3}
                      placeholder="Description (optional)…"
                      {...field}
                    />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />
          </form>
        </Form>

        <Separator />

        <div className="space-y-3">
          <div className="flex flex-wrap items-center justify-between gap-2">
            <p className="text-sm font-medium">Filter by date & time</p>
            <div className="flex items-center gap-2">
              <Button
                type="button"
                size="sm"
                variant={filterMode === "between" ? "default" : "outline"}
                onClick={() => setFilterMode("between")}
              >
                Between
              </Button>
              <Button
                type="button"
                size="sm"
                variant={filterMode === "exact" ? "default" : "outline"}
                onClick={() => setFilterMode("exact")}
              >
                Exact
              </Button>
              <Button
                type="button"
                size="sm"
                variant="ghost"
                onClick={() => {
                  setFilterFromDate("")
                  setFilterFromTime("")
                  setFilterToDate("")
                  setFilterToTime("")
                  setFilterExactDate("")
                  setFilterExactTime("")
                }}
              >
                Clear
              </Button>
            </div>
          </div>

          {filterMode === "between" ? (
            <div className="grid gap-2 sm:grid-cols-2">
              <div className="grid gap-2 sm:grid-cols-2">
                <Input
                  type="date"
                  value={filterFromDate}
                  onChange={(e) => setFilterFromDate(e.target.value)}
                />
                <Input
                  type="time"
                  value={filterFromTime}
                  onChange={(e) => setFilterFromTime(e.target.value)}
                />
              </div>
              <div className="grid gap-2 sm:grid-cols-2">
                <Input
                  type="date"
                  value={filterToDate}
                  onChange={(e) => setFilterToDate(e.target.value)}
                />
                <Input
                  type="time"
                  value={filterToTime}
                  onChange={(e) => setFilterToTime(e.target.value)}
                />
              </div>
            </div>
          ) : (
            <div className="grid gap-2 sm:grid-cols-2">
              <Input
                type="date"
                value={filterExactDate}
                onChange={(e) => setFilterExactDate(e.target.value)}
              />
              <Input
                type="time"
                value={filterExactTime}
                onChange={(e) => setFilterExactTime(e.target.value)}
              />
            </div>
          )}
        </div>

        <Separator />

        <div className="space-y-2">
          {groupedTodos.length === 0 ? (
            <p className="text-muted-foreground text-sm">No tasks yet.</p>
          ) : (
            groupedTodos.map((group) => (
              <div key={group.date} className="space-y-2">
                <div className="flex items-center gap-3 pt-2">
                  <Separator className="flex-1" />
                  <span className="text-muted-foreground whitespace-nowrap text-xs font-medium">
                    {new Intl.DateTimeFormat(undefined, {
                      weekday: "short",
                      year: "numeric",
                      month: "short",
                      day: "2-digit",
                    }).format(parseLocalDateOnly(group.date))}
                  </span>
                  <Separator className="flex-1" />
                </div>

                {group.items.map((todo) => {
                  const flags = getTaskFlags(todo, nowMs, inProgressTaskId)

                  return (
                    <div
                      key={todo.id}
                      className={cn(
                        "rounded-lg border px-3 py-2",
                        flags.completed && "opacity-75",
                        flags.overdue &&
                          "border-destructive/40 bg-destructive/5 text-muted-foreground",
                        flags.inProgress && "border-sky-500/40 bg-sky-500/10",
                        conflictDueAt &&
                          todo.dueAt === conflictDueAt &&
                          "border-destructive/60 bg-destructive/5 ring-1 ring-destructive/30"
                      )}
                    >
                      <div className="flex items-start justify-between gap-3">
                        <label className="flex cursor-pointer items-start gap-3">
                        <Checkbox
                          checked={todo.completed}
                          onCheckedChange={(v) => {
                            const next = Boolean(v)
                            toggleTodo(todo.id, next)
                            if (next && !todo.completed) {
                              requestAttachmentsForTodo(todo.id)
                            }
                          }}
                          aria-label={`Mark "${todo.title}" as ${
                            todo.completed ? "not completed" : "completed"
                          }`}
                          className="mt-0.5"
                        />
                        <span
                          className={cn(
                            "leading-6",
                            todo.completed && "text-muted-foreground line-through"
                          )}
                        >
                          <span className="flex flex-wrap items-center gap-2">
                            <span className="block">{todo.title}</span>
                              <span className="flex flex-wrap items-center gap-2">
                                <TaskBadges {...flags} />
                              </span>
                            {todo.description && (
                              <TooltipProvider>
                                <Tooltip>
                                  <TooltipTrigger asChild>
                                    <button
                                      type="button"
                                      className="text-muted-foreground hover:text-foreground inline-flex h-7 w-7 items-center justify-center rounded-md border bg-background"
                                      aria-label="View description"
                                    >
                                      <Info className="h-4 w-4" />
                                    </button>
                                  </TooltipTrigger>
                                  <TooltipContent className="max-w-xs">
                                    <p className="whitespace-pre-wrap text-sm">
                                      {todo.description}
                                    </p>
                                  </TooltipContent>
                                </Tooltip>
                              </TooltipProvider>
                            )}
                          </span>
                          <span className="text-muted-foreground block text-xs">
                            Due: {formatLocalDateTime(todo.dueAt)}
                          </span>
                        </span>
                      </label>

                      <div className="flex items-center gap-1">
                        {!todo.completed && (
                          <Button
                            type="button"
                            variant={flags.inProgress ? "default" : "outline"}
                            size="sm"
                            onClick={() => void setInProgress(flags.inProgress ? null : todo.id)}
                            className={cn(
                              flags.inProgress && "bg-sky-600 hover:bg-sky-600"
                            )}
                          >
                            {flags.inProgress ? (
                              <>
                                <CircleStop className="mr-1 h-4 w-4" />
                                Stop
                              </>
                            ) : (
                              <>
                                <CirclePlay className="mr-1 h-4 w-4" />
                                Start
                              </>
                            )}
                          </Button>
                        )}
                        {todo.completed && (
                          <Button
                            type="button"
                            variant="outline"
                            size="sm"
                            onClick={() => requestAttachmentsForTodo(todo.id)}
                          >
                            Add files
                          </Button>
                        )}
                        <Button
                          type="button"
                          variant="ghost"
                          size="icon"
                          aria-label={`Delete "${todo.title}"`}
                          onClick={() => deleteTodo(todo.id)}
                        >
                          <Trash2 className="h-4 w-4" />
                        </Button>
                      </div>
                    </div>

                    {todo.completed && todo.attachments.length > 0 && (
                      <div className="mt-3 space-y-2">
                        <p className="text-muted-foreground text-xs">Attachments</p>
                        <ul className="space-y-1">
                          {todo.attachments.map((a) => (
                            <li
                              key={a.id}
                              className="flex items-center justify-between gap-3 rounded-md bg-muted/30 px-2 py-1"
                            >
                              <div className="flex min-w-0 items-center gap-2">
                                <AttachmentIcon kind={a.kind} />
                                <span className="truncate text-sm">{a.name}</span>
                              </div>
                              <button
                                type="button"
                                onClick={() => void downloadAttachment(a)}
                                className="inline-flex items-center gap-1 text-sm font-medium underline underline-offset-4"
                              >
                                <Download className="h-4 w-4" />
                                Download
                              </button>
                            </li>
                          ))}
                        </ul>
                      </div>
                    )}
                  </div>
                  )
                })}
              </div>
            ))
          )}
        </div>

        {groupedTodos.length > 0 && (
          <div className="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
            <div className="flex items-center gap-2">
              <span className="text-muted-foreground text-sm">Items per page</span>
              <Select
                value={String(pageSize)}
                onValueChange={(v) => {
                  const next = Number(v)
                  setPageSize(next)
                  setPage(1)
                }}
              >
                <SelectTrigger className="w-[110px]">
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="5">5</SelectItem>
                  <SelectItem value="10">10</SelectItem>
                  <SelectItem value="15">15</SelectItem>
                  <SelectItem value="20">20</SelectItem>
                </SelectContent>
              </Select>
            </div>

            {showPagination && (
              <div className="flex items-center justify-between gap-3 sm:justify-end">
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={() => setPage((p) => Math.max(1, p - 1))}
                  disabled={page <= 1}
                >
                  Prev
                </Button>
                <span className="text-muted-foreground text-sm">
                  Page {page} of {totalPages}
                </span>
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={() => setPage((p) => Math.min(totalPages, p + 1))}
                  disabled={page >= totalPages}
                >
                  Next
                </Button>
              </div>
            )}
          </div>
        )}

        <div className="flex items-center justify-between gap-2">
          <Button
            type="button"
            variant="secondary"
            onClick={clearCompleted}
            disabled={completedCount === 0}
          >
            Clear completed
          </Button>
          <span className="text-muted-foreground text-sm">
            v 1.1.0
          </span>
    </div>
      </CardContent>
    </Card>
  )
}

```

```typescriptreact
"use client"

import { zodResolver } from "@hookform/resolvers/zod"
import {
  AlertTriangle,
  CirclePlay,
  CircleStop,
  CalendarClock,
  CheckCircle2,
  Download,
  File,
  FileSpreadsheet,
  FileText,
  Image as ImageIcon,
  Info,
  Music,
  Bell,
  Timer,
  Trash2,
  Video,
} from "lucide-react"
import * as React from "react"
import { useForm } from "react-hook-form"
import { toast } from "sonner"
import { z } from "zod"
// Supabase is accessed via Next.js API routes (see src/app/api/**). No direct client usage here.

import { ModeToggle } from "@/components/mode-toggle"
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert"
import { Badge } from "@/components/ui/badge"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Checkbox } from "@/components/ui/checkbox"
import { Form, FormControl, FormField, FormItem, FormMessage } from "@/components/ui/form"
import { Input } from "@/components/ui/input"
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select"
import { Separator } from "@/components/ui/separator"
import { Textarea } from "@/components/ui/textarea"
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip"
import { cn } from "@/lib/utils"
import { apiFetch, ApiError } from "@/lib/api-client"

type AttachmentKind =
  | "image"
  | "audio"
  | "video"
  | "pdf"
  | "spreadsheet"
  | "document"
  | "text"
  | "file"

type Attachment = {
  id: string
  name: string
  type: string
  size: number
  bucket: string
  path: string
  kind: AttachmentKind
}

type Todo = {
  id: string
  title: string
  description?: string
  completed: boolean
  // Stored as `datetime-local` string (YYYY-MM-DDTHH:mm) in local time.
  dueAt: string
  attachments: Attachment[]
}

type DailyLoad = "light" | "balanced" | "heavy"

const todoSchema = z.object({
  title: z
    .string()
    .trim()
    .min(1, "Title is required.")
    .max(80, "Keep it under 80 characters."),
  description: z
    .string()
    .trim()
    .max(500, "Keep it under 500 characters.")
    .optional()
    .or(z.literal("")),
  dueAt: z
    .string()
    .min(1, "Due date & time is required.")
    .regex(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}$/, "Invalid date/time."),
})

type TodoFormValues = z.infer<typeof todoSchema>

const initialTodos: Todo[] = [
  {
    id: "1",
    title: "Create a Next.js app",
    description: "Scaffold with TypeScript + Tailwind and confirm it runs locally.",
    completed: true,
    dueAt: "2026-01-16T09:00",
    attachments: [],
  },
  {
    id: "2",
    title: "Add shadcn/ui + dark theme",
    description: "Initialize shadcn, set up theme provider, and verify dark mode.",
    completed: true,
    dueAt: "2026-01-16T10:30",
    attachments: [],
  },
  {
    id: "3",
    title: "Build a mock-data to-do list",
    completed: false,
    dueAt: "2026-01-16T15:00",
    attachments: [],
  },
  {
    id: "4",
    title: "Yesterday: review requirements",
    completed: true,
    dueAt: "2026-01-15T11:15",
    attachments: [],
  },
  {
    id: "5",
    title: "Yesterday: sketch UI layout",
    completed: true,
    dueAt: "2026-01-15T17:45",
    attachments: [],
  },
  {
    id: "6",
    title: "Today: add attachments support",
    completed: false,
    dueAt: "2026-01-16T18:20",
    attachments: [],
  },
  {
    id: "7",
    title: "Tomorrow: QA the filters",
    description: "Test date-only, time-only, exact, and between behaviors.",
    completed: false,
    dueAt: "2026-01-17T08:05",
    attachments: [],
  },
  {
    id: "8",
    title: "Tomorrow: polish summary cards",
    completed: false,
    dueAt: "2026-01-17T13:30",
    attachments: [],
  },
  {
    id: "9",
    title: "Tomorrow: write small UX notes",
    completed: false,
    dueAt: "2026-01-17T20:10",
    attachments: [],
  },
  {
    id: "10",
    title: "This weekend: add more mock tasks",
    completed: false,
    dueAt: "2026-01-18T10:00",
    attachments: [],
  },
  {
    id: "11",
    title: "This weekend: check time-only filter",
    completed: false,
    dueAt: "2026-01-18T22:15",
    attachments: [],
  },
  {
    id: "12",
    title: "Next week: sync with team",
    completed: false,
    dueAt: "2026-01-19T09:30",
    attachments: [],
  },
  {
    id: "13",
    title: "Next week: test date-only filter",
    completed: false,
    dueAt: "2026-01-20T14:05",
    attachments: [],
  },
  {
    id: "14",
    title: "Next week: test exact date+time filter",
    completed: false,
    dueAt: "2026-01-21T12:00",
    attachments: [],
  },
  {
    id: "15",
    title: "Next week: attach docs to completed tasks",
    completed: false,
    dueAt: "2026-01-22T16:40",
    attachments: [],
  },
  {
    id: "16",
    title: "Next week: final review",
    completed: false,
    dueAt: "2026-01-23T11:00",
    attachments: [],
  },
]

function parseLocalDateTime(value: string): number {
  // value: "YYYY-MM-DDTHH:mm"
  const [datePart, timePart] = value.split("T")
  const [y, m, d] = datePart.split("-").map(Number)
  const [hh, mm] = timePart.split(":").map(Number)
  return new Date(y, m - 1, d, hh, mm, 0, 0).getTime()
}

function pad2(n: number) {
  return String(n).padStart(2, "0")
}

function localDateKey(d: Date) {
  return `${d.getFullYear()}-${pad2(d.getMonth() + 1)}-${pad2(d.getDate())}`
}

function addDays(date: Date, days: number) {
  const d = new Date(date)
  d.setDate(d.getDate() + days)
  return d
}

function startOfDay(date: Date) {
  return new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0, 0)
}

function endOfDay(date: Date) {
  return new Date(
    date.getFullYear(),
    date.getMonth(),
    date.getDate(),
    23,
    59,
    59,
    999
  )
}

function getDatePart(dueAt: string) {
  return dueAt.split("T")[0] ?? ""
}

function getTimePart(dueAt: string) {
  return dueAt.split("T")[1] ?? ""
}

function parseLocalDateOnly(value: string): Date {
  // value: "YYYY-MM-DD"
  const [y, m, d] = value.split("-").map(Number)
  return new Date(y, m - 1, d, 0, 0, 0, 0)
}

function parseLocalTimeToMinutes(value: string): number {
  // value: "HH:mm"
  const [hh, mm] = value.split(":").map(Number)
  return hh * 60 + mm
}

function formatLocalDateTime(value: string): string {
  const ms = parseLocalDateTime(value)
  if (!Number.isFinite(ms)) return value
  return new Intl.DateTimeFormat(undefined, {
    year: "numeric",
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  }).format(new Date(ms))
}

function formatDateTimeFromMs(ms: number): string {
  return new Intl.DateTimeFormat(undefined, {
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  }).format(new Date(ms))
}

function minutesUntil(targetMs: number, nowMs: number) {
  return Math.ceil((targetMs - nowMs) / 60_000)
}

function getTaskFlags(todo: Todo, nowMs: number, inProgressTaskId: string | null) {
  const completed = todo.completed
  const dueMs = parseLocalDateTime(todo.dueAt)
  const overdue = !completed && dueMs < nowMs
  const inProgress = !completed && inProgressTaskId === todo.id
  const planned = !completed && !overdue && !inProgress
  return { completed, overdue, inProgress, planned }
}

function getDailyLoad(todosForDay: Todo[]) {
  // 4-hour windows across the day (local).
  const labels = [
    "00:00–04:00",
    "04:00–08:00",
    "08:00–12:00",
    "12:00–16:00",
    "16:00–20:00",
    "20:00–24:00",
  ]
  const buckets = Array.from({ length: 6 }, () => 0) as number[]
  for (const t of todosForDay) {
    const ms = parseLocalDateTime(t.dueAt)
    const hour = new Date(ms).getHours()
    const idx = Math.floor(hour / 4)
    buckets[idx] = (buckets[idx] ?? 0) + 1
  }

  const total = todosForDay.length
  const peak = Math.max(0, ...buckets)
  const spread = buckets.filter((c) => c > 0).length
  const busiestIdx = buckets.findIndex((c) => c === peak)
  const busiestWindow = busiestIdx >= 0 ? labels[busiestIdx] : labels[0]

  // Heuristic: more tasks + higher concentration in one window => heavier day.
  const score = total + peak * 1.5 + Math.max(0, spread - 1) * 0.5
  const load: DailyLoad = score <= 5 ? "light" : score <= 10 ? "balanced" : "heavy"

  return { load, total, peak, spread, busiestWindow }
}

function DailyLoadBadge({ load }: { load: DailyLoad }) {
  if (load === "heavy") return <Badge variant="destructive">Heavy</Badge>
  if (load === "balanced") return <Badge variant="secondary">Balanced</Badge>
  return <Badge variant="outline">Light</Badge>
}

function TaskBadges({
  completed,
  overdue,
  inProgress,
  planned,
}: {
  completed: boolean
  overdue: boolean
  inProgress: boolean
  planned: boolean
}) {
  if (completed) {
    return (
      <Badge className="gap-1 bg-emerald-600 text-white hover:bg-emerald-600">
        <CheckCircle2 className="h-3.5 w-3.5" />
        Completed
      </Badge>
    )
  }

  return (
    <>
      {inProgress && (
        <Badge className="gap-1 bg-sky-600 text-white hover:bg-sky-600">
          <Timer className="h-3.5 w-3.5 text-white" />
          In progress
        </Badge>
      )}
      {overdue && (
        <Badge variant="destructive" className="gap-1">
          <AlertTriangle className="h-3.5 w-3.5" />
          Overdue
        </Badge>
      )}
      {planned && (
        <Badge variant="outline" className="gap-1">
          <CalendarClock className="h-3.5 w-3.5" />
          Planned
        </Badge>
      )}
    </>
  )
}

function AttachmentIcon({ kind }: { kind: AttachmentKind }) {
  const className = "h-4 w-4 text-muted-foreground"

  switch (kind) {
    case "image":
      return <ImageIcon className={className} />
    case "audio":
      return <Music className={className} />
    case "video":
      return <Video className={className} />
    case "spreadsheet":
      return <FileSpreadsheet className={className} />
    case "pdf":
    case "document":
    case "text":
      return <FileText className={className} />
    default:
      return <File className={className} />
  }
}

const authSchema = z.object({
  email: z.string().email("Enter a valid email."),
  password: z.string().min(6, "Password must be at least 6 characters."),
})
type AuthValues = z.infer<typeof authSchema>

function AuthCard({ onAuthed }: { onAuthed: () => void }) {
  const [mode, setMode] = React.useState<"sign_in" | "sign_up">("sign_in")
  const [busy, setBusy] = React.useState(false)

  const form = useForm<AuthValues>({
    resolver: zodResolver(authSchema),
    defaultValues: { email: "", password: "" },
  })

  async function onSubmit(values: AuthValues) {
    setBusy(true)
    try {
      if (mode === "sign_in") {
        await apiFetch("/api/auth/sign-in", {
          method: "POST",
          body: JSON.stringify(values),
        })
        onAuthed()
      } else {
        await apiFetch("/api/auth/sign-up", {
          method: "POST",
          body: JSON.stringify(values),
        })
        toast.success("Account created", {
          description: "You can now sign in (or confirm email if required).",
        })
        setMode("sign_in")
      }
    } catch (e) {
      toast.error("Authentication failed", {
        description: e instanceof Error ? e.message : "Please try again.",
      })
    } finally {
      setBusy(false)
    }
  }

  return (
    <div className="mx-auto flex min-h-screen max-w-md flex-col justify-center px-4 py-10">
      <Card>
        <CardHeader>
          <CardTitle className="text-2xl">Sign in</CardTitle>
          <p className="text-muted-foreground text-sm">
            {mode === "sign_in"
              ? "Use your email and password."
              : "Create an account with email and password."}
          </p>
        </CardHeader>
        <CardContent className="space-y-4">
          <Form {...form}>
            <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-3" noValidate>
              <FormField
                control={form.control}
                name="email"
                render={({ field }) => (
                  <FormItem>
                    <FormControl>
                      <Input placeholder="Email" autoComplete="email" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="password"
                render={({ field }) => (
                  <FormItem>
                    <FormControl>
                      <Input
                        type="password"
                        placeholder="Password"
                        autoComplete={
                          mode === "sign_in" ? "current-password" : "new-password"
                        }
                        {...field}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <Button type="submit" className="w-full" disabled={busy}>
                {mode === "sign_in" ? "Sign in" : "Sign up"}
              </Button>
            </form>
          </Form>

          <div className="flex items-center justify-between gap-3 text-sm">
            <span className="text-muted-foreground">
              {mode === "sign_in" ? "No account?" : "Already have an account?"}
            </span>
            <Button
              type="button"
              variant="link"
              className="px-0"
              onClick={() => setMode((m) => (m === "sign_in" ? "sign_up" : "sign_in"))}
            >
              {mode === "sign_in" ? "Sign up" : "Sign in"}
            </Button>
          </div>
        </CardContent>
      </Card>
    </div>
  )
}

export default function Home() {
  const [user, setUser] = React.useState<{ id: string; email?: string } | null>(null)
  const [authLoading, setAuthLoading] = React.useState(true)
  const [authError, setAuthError] = React.useState<string | null>(null)

  const refreshAuth = React.useCallback(async () => {
    setAuthLoading(true)
    try {
      const data = await apiFetch<{ user: { id: string; email?: string } | null }>("/api/auth/me")
      setUser(data.user)
      setAuthError(null)
    } catch (e) {
      setUser(null)
      setAuthError(e instanceof Error ? e.message : "Auth check failed.")
    } finally {
      setAuthLoading(false)
    }
  }, [])

  React.useEffect(() => {
    void refreshAuth()
  }, [refreshAuth])

  if (authLoading) {
    return (
      <div className="mx-auto flex min-h-screen max-w-2xl flex-col justify-center px-4 py-10">
        <p className="text-muted-foreground text-sm">Loading…</p>
      </div>
    )
  }

  if (authError) {
    return (
      <div className="mx-auto flex min-h-screen max-w-2xl flex-col justify-center gap-4 px-4 py-10">
        <Card>
          <CardHeader>
            <CardTitle>Auth unavailable</CardTitle>
          </CardHeader>
          <CardContent className="space-y-2">
            <p className="text-muted-foreground text-sm">{authError}</p>
            <p className="text-muted-foreground text-sm">
              Check <code>SUPABASE_SETUP.md</code> and set env vars from{" "}
              <code>supabase.env.example</code>.
            </p>
            <Button type="button" variant="outline" onClick={() => void refreshAuth()}>
              Retry
            </Button>
          </CardContent>
        </Card>
      </div>
    )
  }

  if (!user) return <AuthCard onAuthed={() => void refreshAuth()} />

  return (
    <div className="mx-auto flex min-h-screen max-w-2xl flex-col gap-6 px-4 py-10">
      <TodoApp userId={user.id} onSignedOut={() => void refreshAuth()} />
    </div>
  )
}

function TodoApp({ userId, onSignedOut }: { userId: string; onSignedOut: () => void }) {
  const [todos, setTodos] = React.useState<Todo[]>([])
  const [tasksLoading, setTasksLoading] = React.useState(true)
  const [tasksError, setTasksError] = React.useState<{ code?: string; message: string } | null>(
    null
  )
  const [attachTargetTodoId, setAttachTargetTodoId] = React.useState<string | null>(
    null
  )
  const [conflictDueAt, setConflictDueAt] = React.useState<string | null>(null)
  const clearConflictTimerRef = React.useRef<number | null>(null)
  const [focusMode, setFocusMode] = React.useState(false)
  const [nowMs, setNowMs] = React.useState(() => Date.now())
  const [inProgressTaskId, setInProgressTaskId] = React.useState<string | null>(null)
  const [dismissedReminderTaskId, setDismissedReminderTaskId] = React.useState<
    string | null
  >(null)
  const [filterMode, setFilterMode] = React.useState<"between" | "exact">("between")
  const [filterFromDate, setFilterFromDate] = React.useState<string>("")
  const [filterFromTime, setFilterFromTime] = React.useState<string>("")
  const [filterToDate, setFilterToDate] = React.useState<string>("")
  const [filterToTime, setFilterToTime] = React.useState<string>("")
  const [filterExactDate, setFilterExactDate] = React.useState<string>("")
  const [filterExactTime, setFilterExactTime] = React.useState<string>("")
  const fileInputRef = React.useRef<HTMLInputElement>(null)
  const [pageSize, setPageSize] = React.useState<number>(5)
  const [page, setPage] = React.useState<number>(1)

  React.useEffect(() => {
    let alive = true
    async function load() {
      setTasksLoading(true)
      if (!alive) return
      try {
        const data = await apiFetch<{ tasks: Todo[]; inProgressTaskId: string | null }>("/api/tasks")
        if (!alive) return
        setTodos(data.tasks)
        setInProgressTaskId(data.inProgressTaskId)
        setTasksError(null)
      } catch (e) {
        if (!alive) return
        if (e instanceof ApiError) setTasksError({ code: e.code, message: e.message })
        else setTasksError({ message: e instanceof Error ? e.message : "Failed to load tasks." })
        setTodos([])
        setInProgressTaskId(null)
      } finally {
        setTasksLoading(false)
      }
    }
    load()
    return () => {
      alive = false
    }
  }, [userId])

  // Keep "now" fresh so overdue/in-progress states stay accurate without user interaction.
  React.useEffect(() => {
    const id = window.setInterval(() => setNowMs(Date.now()), 30_000)
    return () => window.clearInterval(id)
  }, [])

  // Only one task can be "In Progress"; auto-clear if completed, deleted, or overdue.
  React.useEffect(() => {
    if (!inProgressTaskId) return
    const t = todos.find((x) => x.id === inProgressTaskId)
    if (!t || t.completed) {
      setInProgressTaskId(null)
      return
    }
  }, [inProgressTaskId, nowMs, todos])

  const nextUpcoming = React.useMemo(() => {
    const upcoming = todos
      .filter((t) => !t.completed)
      .map((t) => ({ todo: t, dueMs: parseLocalDateTime(t.dueAt) }))
      .filter((x) => x.dueMs >= nowMs)
      .sort((a, b) => a.dueMs - b.dueMs)[0]
    return upcoming ?? null
  }, [nowMs, todos])

  React.useEffect(() => {
    // If "next upcoming" changed, allow reminder again (dismiss is per-task).
    if (nextUpcoming && nextUpcoming.todo.id !== dismissedReminderTaskId) return
    if (!nextUpcoming) setDismissedReminderTaskId(null)
  }, [dismissedReminderTaskId, nextUpcoming])

  const reminder = React.useMemo(() => {
    const REMINDER_WINDOW_MIN = 15
    if (!nextUpcoming) return null
    if (dismissedReminderTaskId === nextUpcoming.todo.id) return null
    const mins = minutesUntil(nextUpcoming.dueMs, nowMs)
    if (mins < 0 || mins > REMINDER_WINDOW_MIN) return null
    return { ...nextUpcoming, mins }
  }, [dismissedReminderTaskId, nextUpcoming, nowMs])

  const form = useForm<TodoFormValues>({
    resolver: zodResolver(todoSchema),
    defaultValues: { title: "", description: "", dueAt: "" },
    mode: "onSubmit",
  })

  const summary = React.useMemo(() => {
    const now = new Date()
    const todayKey = localDateKey(now)
    const tomorrow = addDays(now, 1)
    const tomorrowKey = localDateKey(tomorrow)

    const todays = todos.filter((t) => t.dueAt.startsWith(todayKey))
    const todayCompleted = todays.filter((t) => t.completed).length
    const todayPending = todays.length - todayCompleted

    const labels = [
      "00:00–04:00",
      "04:00–08:00",
      "08:00–12:00",
      "12:00–16:00",
      "16:00–20:00",
      "20:00–24:00",
    ]

    // Tomorrow: same 4-hour windows breakdown
    const tomorrowTasks = todos.filter((t) => t.dueAt.startsWith(tomorrowKey))
    const tomorrowBuckets = Array.from({ length: 6 }, () => 0) as number[]
    for (const t of tomorrowTasks) {
      const ms = parseLocalDateTime(t.dueAt)
      const hour = new Date(ms).getHours()
      const idx = Math.floor(hour / 4)
      tomorrowBuckets[idx] = (tomorrowBuckets[idx] ?? 0) + 1
    }

    // Until next week = next 7 days starting tomorrow (local), grouped into 4-hour windows.
    const rangeStart = startOfDay(tomorrow).getTime()
    const rangeEnd = addDays(startOfDay(tomorrow), 7).getTime()
    const buckets = Array.from({ length: 6 }, () => 0) as number[]

    const upcoming = todos.filter((t) => {
      const ms = parseLocalDateTime(t.dueAt)
      return ms >= rangeStart && ms < rangeEnd
    })

    for (const t of upcoming) {
      const ms = parseLocalDateTime(t.dueAt)
      const hour = new Date(ms).getHours()
      const idx = Math.floor(hour / 4)
      buckets[idx] = (buckets[idx] ?? 0) + 1
    }

    return {
      todayCompleted,
      todayPending,
      tomorrowTotal: tomorrowTasks.length,
      tomorrowBuckets: labels.map((label, i) => ({ label, count: tomorrowBuckets[i] ?? 0 })),
      upcomingTotal: upcoming.length,
      upcomingBuckets: labels.map((label, i) => ({ label, count: buckets[i] ?? 0 })),
    }
  }, [todos])

  const loadDayKey = React.useMemo(() => {
    // Prefer an explicitly selected date from filters; otherwise use today.
    if (filterMode === "exact" && filterExactDate) return filterExactDate
    if (filterFromDate && !filterToDate) return filterFromDate
    if (filterFromDate && filterToDate && filterFromDate === filterToDate) return filterFromDate
    if (!filterFromDate && filterToDate) return filterToDate
    return localDateKey(new Date(nowMs))
  }, [filterExactDate, filterFromDate, filterMode, filterToDate, nowMs])

  const dailyLoad = React.useMemo(() => {
    const dayTodos = todos.filter((t) => getDatePart(t.dueAt) === loadDayKey)
    return getDailyLoad(dayTodos)
  }, [loadDayKey, todos])

  const filteredTodos = React.useMemo(() => {
    if (focusMode) {
      const endMs = nowMs + 4 * 60 * 60 * 1000
      const withMs = todos.map((t) => ({ ...t, _dueMs: parseLocalDateTime(t.dueAt) }))
      return withMs.filter((t) => t._dueMs >= nowMs && t._dueMs <= endMs)
    }

    const withMs = todos.map((t) => ({ ...t, _dueMs: parseLocalDateTime(t.dueAt) }))
    if (filterMode === "exact") {
      // If only date is selected -> show tasks for that date.
      // If time is selected too -> match exact date+time.
      // If only time is selected -> match time-of-day across all dates.
      if (!filterExactDate && !filterExactTime) return withMs

      if (filterExactDate && !filterExactTime) {
        return withMs.filter((t) => getDatePart(t.dueAt) === filterExactDate)
      }

      if (filterExactDate && filterExactTime) {
        const exactMs = parseLocalDateTime(`${filterExactDate}T${filterExactTime}`)
        return withMs.filter((t) => t._dueMs === exactMs)
      }

      // time only
      return withMs.filter((t) => getTimePart(t.dueAt) === filterExactTime)
    }
    // between
    const hasAnyDate = Boolean(filterFromDate || filterToDate)
    const hasAnyTime = Boolean(filterFromTime || filterToTime)

    // Date range (optional)
    const fromDateMs = filterFromDate
      ? startOfDay(parseLocalDateOnly(filterFromDate)).getTime()
      : Number.NEGATIVE_INFINITY
    const toDateMs = filterToDate
      ? endOfDay(parseLocalDateOnly(filterToDate)).getTime()
      : Number.POSITIVE_INFINITY

    // Time-of-day range (optional)
    const fromTimeMin = filterFromTime ? parseLocalTimeToMinutes(filterFromTime) : 0
    const toTimeMin = filterToTime ? parseLocalTimeToMinutes(filterToTime) : 24 * 60 - 1

    return withMs.filter((t) => {
      const ms = t._dueMs
      if (hasAnyDate && (ms < fromDateMs || ms > toDateMs)) return false

      if (hasAnyTime) {
        const time = getTimePart(t.dueAt)
        if (!time) return false
        const mins = parseLocalTimeToMinutes(time)
        // Simple (non-wrapping) range. If you want wrap-around (e.g. 22:00–02:00), tell me.
        if (mins < fromTimeMin || mins > toTimeMin) return false
      }

      // If neither date nor time selected, pass through (handled above anyway)
      return true
    })
  }, [
    todos,
    focusMode,
    nowMs,
    filterExactDate,
    filterExactTime,
    filterFromDate,
    filterFromTime,
    filterMode,
    filterToDate,
    filterToTime,
  ])

  const sortedFilteredTodos = React.useMemo(
    () =>
      filteredTodos
        .slice()
        .sort((a, b) => parseLocalDateTime(a.dueAt) - parseLocalDateTime(b.dueAt)),
    [filteredTodos]
  )

  // Clamp page when filters/pageSize change.
  React.useEffect(() => {
    const totalPages = Math.max(1, Math.ceil(sortedFilteredTodos.length / pageSize))
    setPage((p) => Math.min(Math.max(1, p), totalPages))
  }, [pageSize, sortedFilteredTodos.length])

  const totalItems = sortedFilteredTodos.length
  const totalPages = Math.max(1, Math.ceil(totalItems / pageSize))
  const showPagination = totalPages > 1

  const pageItems = React.useMemo(() => {
    const start = (page - 1) * pageSize
    return sortedFilteredTodos.slice(start, start + pageSize)
  }, [page, pageSize, sortedFilteredTodos])

  const groupedTodos = React.useMemo(() => {
    const groups: Array<{ date: string; items: typeof pageItems }> = []
    for (const t of pageItems) {
      const date = getDatePart(t.dueAt)
      const last = groups[groups.length - 1]
      if (!last || last.date !== date) groups.push({ date, items: [t] })
      else last.items.push(t)
    }
    return groups
  }, [pageItems])

  const completedCount = filteredTodos.filter((t) => t.completed).length

  async function addTodo(values: TodoFormValues) {
    const conflicts = todos.filter((t) => t.dueAt === values.dueAt)
    if (conflicts.length > 0) {
      setConflictDueAt(values.dueAt)
      if (clearConflictTimerRef.current) window.clearTimeout(clearConflictTimerRef.current)
      clearConflictTimerRef.current = window.setTimeout(() => {
        setConflictDueAt(null)
      }, 8000)

      // Make sure the user can see the conflicting tasks even if they were filtered out.
      const [d, time] = values.dueAt.split("T")
      setFilterMode("exact")
      setFilterExactDate(d ?? "")
      setFilterExactTime(time ?? "")
      setPage(1)

      toast.error("Time conflict", {
        description: `You already have ${conflicts.length} task(s) scheduled at ${formatLocalDateTime(
          values.dueAt
        )}.`,
      })
    }

    try {
      const data = await apiFetch<{ task: Todo }>("/api/tasks", {
        method: "POST",
        body: JSON.stringify(values),
      })
      setTodos((prev) => [data.task, ...prev])
    } catch (e) {
      toast.error("Failed to add task", { description: e instanceof Error ? e.message : "Failed." })
      return
    }
    form.reset()
  }

  async function toggleTodo(id: string, completed: boolean) {
    // optimistic
    setTodos((prev) =>
      prev.map((t) =>
        t.id === id ? { ...t, completed, attachments: t.attachments } : t
      )
    )
    if (completed) setInProgressTaskId((cur) => (cur === id ? null : cur))

    const update: { completed: boolean; in_progress?: boolean } = { completed }
    if (completed) update.in_progress = false

    try {
      await apiFetch("/api/tasks/" + id, {
        method: "PATCH",
        body: JSON.stringify({ completed }),
      })
    } catch (e) {
      toast.error("Failed to update task", { description: e instanceof Error ? e.message : "Failed." })
    }
  }

  function requestAttachmentsForTodo(todoId: string) {
    setAttachTargetTodoId(todoId)
    // Let state update before opening picker (some browsers are picky).
    queueMicrotask(() => fileInputRef.current?.click())
  }

  async function handleFilesPicked(e: React.ChangeEvent<HTMLInputElement>) {
    const files = Array.from(e.target.files ?? [])
    const targetId = attachTargetTodoId

    // reset input so picking the same file again triggers onChange
    e.target.value = ""
    setAttachTargetTodoId(null)

    if (!targetId || files.length === 0) return
    const form = new FormData()
    for (const f of files) form.append("files", f)
    try {
      const res = await fetch(`/api/tasks/${targetId}/attachments`, {
        method: "POST",
        credentials: "include",
        body: form,
      })
      const json = (await res.json().catch(() => null)) as
        | { ok: true; data: { task: Todo } }
        | { ok: false; error: { message: string } }
        | null
      if (!json || !json.ok) throw new Error(json?.error.message ?? "Upload failed.")
      setTodos((prev) => prev.map((t) => (t.id === targetId ? json.data.task : t)))
    } catch (e) {
      toast.error("Upload failed", { description: e instanceof Error ? e.message : "Failed." })
    }
  }

  async function deleteTodo(id: string) {
    // optimistic
    setTodos((prev) => prev.filter((t) => t.id !== id))
    setInProgressTaskId((cur) => (cur === id ? null : cur))

    try {
      await apiFetch("/api/tasks/" + id, { method: "DELETE" })
    } catch (e) {
      toast.error("Failed to delete task", { description: e instanceof Error ? e.message : "Failed." })
    }
  }

  async function setInProgress(taskId: string | null) {
    // optimistic
    setInProgressTaskId(taskId)

    try {
      const data = await apiFetch<{ inProgressTaskId: string | null }>("/api/tasks/in-progress", {
        method: "POST",
        body: JSON.stringify({ id: taskId }),
      })
      setInProgressTaskId(data.inProgressTaskId)
    } catch (e) {
      toast.error("Failed to update in-progress", {
        description: e instanceof Error ? e.message : "Failed.",
      })
    }
  }

  async function downloadAttachment(a: Attachment) {
    try {
      const data = await apiFetch<{ signedUrl: string }>("/api/attachments/signed-url", {
        method: "POST",
        body: JSON.stringify({ bucket: a.bucket, path: a.path }),
      })
      window.open(data.signedUrl, "_blank", "noopener,noreferrer")
    } catch (e) {
      toast.error("Download failed", { description: e instanceof Error ? e.message : "Failed." })
    }
  }

  async function seedDemoTasks() {
    if (todos.length > 0) return
    try {
      const data = await apiFetch<{ tasks: Todo[] }>("/api/tasks/seed", {
        method: "POST",
        body: JSON.stringify({ tasks: initialTodos }),
      })
      setTodos(data.tasks)
    } catch (e) {
      toast.error("Failed to seed demo tasks", { description: e instanceof Error ? e.message : "Failed." })
    }
  }

  async function clearCompleted() {
    const completedIds = new Set(todos.filter((t) => t.completed).map((t) => t.id))
    if (completedIds.size === 0) return

    // optimistic
    setTodos((prev) => prev.filter((t) => !completedIds.has(t.id)))

    try {
      await apiFetch("/api/tasks/clear-completed", { method: "POST" })
    } catch (e) {
      toast.error("Failed to clear completed", { description: e instanceof Error ? e.message : "Failed." })
    }
  }

  return (
    <Card>
      <CardHeader className="flex flex-row items-center justify-between gap-4">
        <div className="space-y-1">
          <CardTitle className="text-2xl">To‑Do</CardTitle>
          <p className="text-muted-foreground text-sm">
            {completedCount}/{filteredTodos.length} completed
          </p>
        </div>
        <div className="flex items-center gap-2">
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <Button
                  type="button"
                  variant={focusMode ? "default" : "outline"}
                  size="sm"
                  onClick={() => {
                    setFocusMode((v) => !v)
                    setPage(1)
                  }}
                >
                  Focus Mode
                </Button>
              </TooltipTrigger>
              <TooltipContent>
                <p>Show tasks for the next 4 hours.</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
          <Button
            type="button"
            variant="outline"
            size="sm"
            onClick={async () => {
              await apiFetch("/api/auth/sign-out", { method: "POST" }).catch(() => {})
              onSignedOut()
            }}
          >
            Sign out
          </Button>
          <ModeToggle />
        </div>
      </CardHeader>

      <CardContent className="space-y-6">
        {tasksLoading && (
          <p className="text-muted-foreground text-sm">Loading tasks…</p>
        )}

        {!tasksLoading && tasksError?.code === "MISSING_TABLE" && (
          <Alert variant="destructive">
            <AlertTitle>Database not initialized</AlertTitle>
            <AlertDescription>
              <div className="space-y-2">
                <p>
                  The Supabase table <code>public.tasks</code> was not found. Run the SQL in{" "}
                  <code>supabase/schema.sql</code> (Supabase Dashboard → SQL Editor), then refresh.
                </p>
                <p className="text-xs opacity-90">{tasksError.message}</p>
              </div>
            </AlertDescription>
          </Alert>
        )}

        {!tasksLoading && tasksError && tasksError.code !== "MISSING_TABLE" && (
          <Alert variant="destructive">
            <AlertTitle>Failed to load tasks</AlertTitle>
            <AlertDescription>{tasksError.message}</AlertDescription>
          </Alert>
        )}

        {!tasksLoading && todos.length === 0 && (
          <div className="flex items-center justify-between gap-3 rounded-lg border bg-muted/20 px-3 py-2">
            <p className="text-muted-foreground text-sm">No tasks yet.</p>
            <Button type="button" variant="outline" size="sm" onClick={() => void seedDemoTasks()}>
              Seed demo tasks
            </Button>
          </div>
        )}

        <input
          ref={fileInputRef}
          type="file"
          multiple
          className="hidden"
          accept={[
            "image/*",
            "audio/*",
            "video/*",
            ".pdf",
            ".doc",
            ".docx",
            ".xls",
            ".xlsx",
            ".csv",
            ".txt",
            ".md",
            ".rtf",
          ].join(",")}
          onChange={handleFilesPicked}
        />

        {reminder && (
          <Alert className="border-primary/30 bg-primary/5">
            <Bell className="h-4 w-4" />
            <div className="flex flex-1 flex-col gap-1">
              <div className="flex flex-wrap items-center justify-between gap-2">
                <AlertTitle className="text-sm">
                  Next task starts in {reminder.mins} minute{reminder.mins === 1 ? "" : "s"}
                </AlertTitle>
                <Button
                  type="button"
                  variant="ghost"
                  size="sm"
                  onClick={() => setDismissedReminderTaskId(reminder.todo.id)}
                >
                  Dismiss
                </Button>
              </div>
              <AlertDescription className="text-sm">
                <span className="font-medium">{reminder.todo.title}</span> ·{" "}
                {formatDateTimeFromMs(reminder.dueMs)}
              </AlertDescription>
            </div>
          </Alert>
        )}

        <div className="rounded-xl border bg-card p-4">
          <div className="flex flex-wrap items-center justify-between gap-2">
            <p className="text-sm font-medium">
              Daily load{" "}
              <span className="text-muted-foreground font-normal">
                ({new Intl.DateTimeFormat(undefined, {
                  weekday: "short",
                  year: "numeric",
                  month: "short",
                  day: "2-digit",
                }).format(parseLocalDateOnly(loadDayKey))})
              </span>
            </p>
            <DailyLoadBadge load={dailyLoad.load} />
          </div>
          <p className="text-muted-foreground mt-2 text-sm">
            {dailyLoad.total} task(s) · busiest window {dailyLoad.busiestWindow} ({dailyLoad.peak})
          </p>
        </div>

        <div className="grid gap-3 sm:grid-cols-3">
          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Today’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">
              {summary.todayCompleted} completed
            </p>
            <p className="text-muted-foreground text-sm">{summary.todayPending} pending</p>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tomorrow’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">{summary.tomorrowTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.tomorrowBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tasks Until Next Week</p>
            <p className="mt-2 text-2xl font-semibold">{summary.upcomingTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.upcomingBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>
        </div>

        {focusMode && (
          <div className="flex flex-col gap-1 rounded-lg border bg-muted/20 px-3 py-2 sm:flex-row sm:items-center sm:justify-between">
            <p className="text-sm">
              <span className="font-medium">Focus Mode:</span>{" "}
              showing tasks due in the next 4 hours (until{" "}
              <span className="font-medium">
                {formatDateTimeFromMs(nowMs + 4 * 60 * 60 * 1000)}
              </span>
              )
            </p>
            <Button type="button" variant="ghost" size="sm" onClick={() => setFocusMode(false)}>
              Exit
            </Button>
          </div>
        )}

        <Form {...form}>
          <form
            onSubmit={form.handleSubmit(addTodo)}
            className="space-y-2"
            noValidate
          >
            <div className="flex flex-col gap-2 sm:flex-row">
              <FormField
                control={form.control}
                name="title"
                render={({ field }) => (
                  <FormItem className="flex-1">
                    <FormControl>
                      <Input
                        placeholder="Add a task…"
                        autoComplete="off"
                        {...field}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="dueAt"
                render={({ field }) => (
                  <FormItem className="sm:w-64">
                    <FormControl>
                      <Input type="datetime-local" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <Button type="submit">Add</Button>
            </div>

            <FormField
              control={form.control}
              name="description"
              render={({ field }) => (
                <FormItem>
                  <FormControl>
                    <Textarea
                      rows={3}
                      placeholder="Description (optional)…"
                      {...field}
                    />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />
          </form>
        </Form>

        <Separator />

        <div className="space-y-3">
          <div className="flex flex-wrap items-center justify-between gap-2">
            <p className="text-sm font-medium">Filter by date & time</p>
            <div className="flex items-center gap-2">
              <Button
                type="button"
                size="sm"
                variant={filterMode === "between" ? "default" : "outline"}
                onClick={() => setFilterMode("between")}
              >
                Between
              </Button>
              <Button
                type="button"
                size="sm"
                variant={filterMode === "exact" ? "default" : "outline"}
                onClick={() => setFilterMode("exact")}
              >
                Exact
              </Button>
              <Button
                type="button"
                size="sm"
                variant="ghost"
                onClick={() => {
                  setFilterFromDate("")
                  setFilterFromTime("")
                  setFilterToDate("")
                  setFilterToTime("")
                  setFilterExactDate("")
                  setFilterExactTime("")
                }}
              >
                Clear
              </Button>
            </div>
          </div>

          {filterMode === "between" ? (
            <div className="grid gap-2 sm:grid-cols-2">
              <div className="grid gap-2 sm:grid-cols-2">
                <Input
                  type="date"
                  value={filterFromDate}
                  onChange={(e) => setFilterFromDate(e.target.value)}
                />
                <Input
                  type="time"
                  value={filterFromTime}
                  onChange={(e) => setFilterFromTime(e.target.value)}
                />
              </div>
              <div className="grid gap-2 sm:grid-cols-2">
                <Input
                  type="date"
                  value={filterToDate}
                  onChange={(e) => setFilterToDate(e.target.value)}
                />
                <Input
                  type="time"
                  value={filterToTime}
                  onChange={(e) => setFilterToTime(e.target.value)}
                />
              </div>
            </div>
          ) : (
            <div className="grid gap-2 sm:grid-cols-2">
              <Input
                type="date"
                value={filterExactDate}
                onChange={(e) => setFilterExactDate(e.target.value)}
              />
              <Input
                type="time"
                value={filterExactTime}
                onChange={(e) => setFilterExactTime(e.target.value)}
              />
            </div>
          )}
        </div>

        <Separator />

        <div className="space-y-2">
          {groupedTodos.length === 0 ? (
            <p className="text-muted-foreground text-sm">No tasks yet.</p>
          ) : (
            groupedTodos.map((group) => (
              <div key={group.date} className="space-y-2">
                <div className="flex items-center gap-3 pt-2">
                  <Separator className="flex-1" />
                  <span className="text-muted-foreground whitespace-nowrap text-xs font-medium">
                    {new Intl.DateTimeFormat(undefined, {
                      weekday: "short",
                      year: "numeric",
                      month: "short",
                      day: "2-digit",
                    }).format(parseLocalDateOnly(group.date))}
                  </span>
                  <Separator className="flex-1" />
                </div>

                {group.items.map((todo) => {
                  const flags = getTaskFlags(todo, nowMs, inProgressTaskId)

                  return (
                    <div
                      key={todo.id}
                      className={cn(
                        "rounded-lg border px-3 py-2",
                        flags.completed && "opacity-75",
                        flags.overdue &&
                          "border-destructive/40 bg-destructive/5 text-muted-foreground",
                        flags.inProgress && "border-sky-500/40 bg-sky-500/10",
                        conflictDueAt &&
                          todo.dueAt === conflictDueAt &&
                          "border-destructive/60 bg-destructive/5 ring-1 ring-destructive/30"
                      )}
                    >
                      <div className="flex items-start justify-between gap-3">
                        <label className="flex cursor-pointer items-start gap-3">
                        <Checkbox
                          checked={todo.completed}
                          onCheckedChange={(v) => {
                            const next = Boolean(v)
                            toggleTodo(todo.id, next)
                            if (next && !todo.completed) {
                              requestAttachmentsForTodo(todo.id)
                            }
                          }}
                          aria-label={`Mark "${todo.title}" as ${
                            todo.completed ? "not completed" : "completed"
                          }`}
                          className="mt-0.5"
                        />
                        <span
                          className={cn(
                            "leading-6",
                            todo.completed && "text-muted-foreground line-through"
                          )}
                        >
                          <span className="flex flex-wrap items-center gap-2">
                            <span className="block">{todo.title}</span>
                              <TaskBadges {...flags} />
                            {todo.description && (
                              <TooltipProvider>
                                <Tooltip>
                                  <TooltipTrigger asChild>
                                    <button
                                      type="button"
                                      className="text-muted-foreground hover:text-foreground inline-flex h-7 w-7 items-center justify-center rounded-md border bg-background"
                                      aria-label="View description"
                                    >
                                      <Info className="h-4 w-4" />
                                    </button>
                                  </TooltipTrigger>
                                  <TooltipContent className="max-w-xs">
                                    <p className="whitespace-pre-wrap text-sm">
                                      {todo.description}
                                    </p>
                                  </TooltipContent>
                                </Tooltip>
                              </TooltipProvider>
                            )}
                          </span>
                          <span className="text-muted-foreground block text-xs">
                            Due: {formatLocalDateTime(todo.dueAt)}
                          </span>
                        </span>
                      </label>

                      <div className="flex items-center gap-1">
                        {!todo.completed && (
                          <Button
                            type="button"
                            variant={flags.inProgress ? "default" : "outline"}
                            size="sm"
                            onClick={() => void setInProgress(flags.inProgress ? null : todo.id)}
                            className={cn(
                              flags.inProgress && "bg-sky-600 hover:bg-sky-600"
                            )}
                          >
                            {flags.inProgress ? (
                              <>
                                <CircleStop className="mr-1 h-4 w-4" />
                                Stop
                              </>
                            ) : (
                              <>
                                <CirclePlay className="mr-1 h-4 w-4" />
                                Start
                              </>
                            )}
                          </Button>
                        )}
                        {todo.completed && (
                          <Button
                            type="button"
                            variant="outline"
                            size="sm"
                            onClick={() => requestAttachmentsForTodo(todo.id)}
                          >
                            Add files
                          </Button>
                        )}
                        <Button
                          type="button"
                          variant="ghost"
                          size="icon"
                          aria-label={`Delete "${todo.title}"`}
                          onClick={() => deleteTodo(todo.id)}
                        >
                          <Trash2 className="h-4 w-4" />
                        </Button>
                      </div>
                    </div>

                    {todo.completed && todo.attachments.length > 0 && (
                      <div className="mt-3 space-y-2">
                        <p className="text-muted-foreground text-xs">Attachments</p>
                        <ul className="space-y-1">
                          {todo.attachments.map((a) => (
                            <li
                              key={a.id}
                              className="flex items-center justify-between gap-3 rounded-md bg-muted/30 px-2 py-1"
                            >
                              <div className="flex min-w-0 items-center gap-2">
                                <AttachmentIcon kind={a.kind} />
                                <span className="truncate text-sm">{a.name}</span>
                              </div>
                              <button
                                type="button"
                                onClick={() => void downloadAttachment(a)}
                                className="inline-flex items-center gap-1 text-sm font-medium underline underline-offset-4"
                              >
                                <Download className="h-4 w-4" />
                                Download
                              </button>
                            </li>
                          ))}
                        </ul>
                      </div>
                    )}
                  </div>
                  )
                })}
              </div>
            ))
          )}
        </div>

        {groupedTodos.length > 0 && (
          <div className="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
            <div className="flex items-center gap-2">
              <span className="text-muted-foreground text-sm">Items per page</span>
              <Select
                value={String(pageSize)}
                onValueChange={(v) => {
                  const next = Number(v)
                  setPageSize(next)
                  setPage(1)
                }}
              >
                <SelectTrigger className="w-[110px]">
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="5">5</SelectItem>
                  <SelectItem value="10">10</SelectItem>
                  <SelectItem value="15">15</SelectItem>
                  <SelectItem value="20">20</SelectItem>
                </SelectContent>
              </Select>
            </div>

            {showPagination && (
              <div className="flex items-center justify-between gap-3 sm:justify-end">
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={() => setPage((p) => Math.max(1, p - 1))}
                  disabled={page <= 1}
                >
                  Prev
                </Button>
                <span className="text-muted-foreground text-sm">
                  Page {page} of {totalPages}
                </span>
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={() => setPage((p) => Math.min(totalPages, p + 1))}
                  disabled={page >= totalPages}
                >
                  Next
                </Button>
              </div>
            )}
          </div>
        )}

        <div className="flex items-center justify-between gap-2">
          <Button
            type="button"
            variant="secondary"
            onClick={clearCompleted}
            disabled={completedCount === 0}
          >
            Clear completed
          </Button>
          <span className="text-muted-foreground text-sm">
            v 1.1.0
          </span>
    </div>
      </CardContent>
    </Card>
  )
}

```

### Refactor cleanup done
- **Removed unused code** from `src/app/page.tsx`:
  - **`TaskState` type** (no longer referenced)
  - **`getAttachmentKind()`** (attachment `kind` is now set server-side during upload)
- **Removed redundant JSX wrapper** around `<TaskBadges />` to simplify the task row markup.

### Verified
- `npm run build` passes successfully.

---

**User**

remove a sign out button and Add a user avatar with a dropdown menu that includes a compact Logout button with an icon.

---

**Cursor**

Plan: add shadcn `avatar` + `dropdown-menu`, replace the header “Sign out” button with a small user avatar trigger, and put a compact **Logout** menu item (with icon) inside the dropdown that calls `/api/auth/sign-out`. Then I’ll run a build to confirm.

```typescriptreact
"use client"

import { zodResolver } from "@hookform/resolvers/zod"
import {
  AlertTriangle,
  CirclePlay,
  CircleStop,
  CalendarClock,
  CheckCircle2,
  Download,
  File,
  FileSpreadsheet,
  FileText,
  Image as ImageIcon,
  Info,
  LogOut,
  Music,
  Bell,
  Timer,
  Trash2,
  Video,
} from "lucide-react"
import * as React from "react"
import { useForm } from "react-hook-form"
import { toast } from "sonner"
import { z } from "zod"
// Supabase is accessed via Next.js API routes (see src/app/api/**). No direct client usage here.

import { ModeToggle } from "@/components/mode-toggle"
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert"
import { Avatar, AvatarFallback } from "@/components/ui/avatar"
import { Badge } from "@/components/ui/badge"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Checkbox } from "@/components/ui/checkbox"
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu"
import { Form, FormControl, FormField, FormItem, FormMessage } from "@/components/ui/form"
import { Input } from "@/components/ui/input"
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select"
import { Separator } from "@/components/ui/separator"
import { Textarea } from "@/components/ui/textarea"
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip"
import { cn } from "@/lib/utils"
import { apiFetch, ApiError } from "@/lib/api-client"

type AttachmentKind =
  | "image"
  | "audio"
  | "video"
  | "pdf"
  | "spreadsheet"
  | "document"
  | "text"
  | "file"

type Attachment = {
  id: string
  name: string
  type: string
  size: number
  bucket: string
  path: string
  kind: AttachmentKind
}

type Todo = {
  id: string
  title: string
  description?: string
  completed: boolean
  // Stored as `datetime-local` string (YYYY-MM-DDTHH:mm) in local time.
  dueAt: string
  attachments: Attachment[]
}

type DailyLoad = "light" | "balanced" | "heavy"

const todoSchema = z.object({
  title: z
    .string()
    .trim()
    .min(1, "Title is required.")
    .max(80, "Keep it under 80 characters."),
  description: z
    .string()
    .trim()
    .max(500, "Keep it under 500 characters.")
    .optional()
    .or(z.literal("")),
  dueAt: z
    .string()
    .min(1, "Due date & time is required.")
    .regex(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}$/, "Invalid date/time."),
})

type TodoFormValues = z.infer<typeof todoSchema>

const initialTodos: Todo[] = [
  {
    id: "1",
    title: "Create a Next.js app",
    description: "Scaffold with TypeScript + Tailwind and confirm it runs locally.",
    completed: true,
    dueAt: "2026-01-16T09:00",
    attachments: [],
  },
  {
    id: "2",
    title: "Add shadcn/ui + dark theme",
    description: "Initialize shadcn, set up theme provider, and verify dark mode.",
    completed: true,
    dueAt: "2026-01-16T10:30",
    attachments: [],
  },
  {
    id: "3",
    title: "Build a mock-data to-do list",
    completed: false,
    dueAt: "2026-01-16T15:00",
    attachments: [],
  },
  {
    id: "4",
    title: "Yesterday: review requirements",
    completed: true,
    dueAt: "2026-01-15T11:15",
    attachments: [],
  },
  {
    id: "5",
    title: "Yesterday: sketch UI layout",
    completed: true,
    dueAt: "2026-01-15T17:45",
    attachments: [],
  },
  {
    id: "6",
    title: "Today: add attachments support",
    completed: false,
    dueAt: "2026-01-16T18:20",
    attachments: [],
  },
  {
    id: "7",
    title: "Tomorrow: QA the filters",
    description: "Test date-only, time-only, exact, and between behaviors.",
    completed: false,
    dueAt: "2026-01-17T08:05",
    attachments: [],
  },
  {
    id: "8",
    title: "Tomorrow: polish summary cards",
    completed: false,
    dueAt: "2026-01-17T13:30",
    attachments: [],
  },
  {
    id: "9",
    title: "Tomorrow: write small UX notes",
    completed: false,
    dueAt: "2026-01-17T20:10",
    attachments: [],
  },
  {
    id: "10",
    title: "This weekend: add more mock tasks",
    completed: false,
    dueAt: "2026-01-18T10:00",
    attachments: [],
  },
  {
    id: "11",
    title: "This weekend: check time-only filter",
    completed: false,
    dueAt: "2026-01-18T22:15",
    attachments: [],
  },
  {
    id: "12",
    title: "Next week: sync with team",
    completed: false,
    dueAt: "2026-01-19T09:30",
    attachments: [],
  },
  {
    id: "13",
    title: "Next week: test date-only filter",
    completed: false,
    dueAt: "2026-01-20T14:05",
    attachments: [],
  },
  {
    id: "14",
    title: "Next week: test exact date+time filter",
    completed: false,
    dueAt: "2026-01-21T12:00",
    attachments: [],
  },
  {
    id: "15",
    title: "Next week: attach docs to completed tasks",
    completed: false,
    dueAt: "2026-01-22T16:40",
    attachments: [],
  },
  {
    id: "16",
    title: "Next week: final review",
    completed: false,
    dueAt: "2026-01-23T11:00",
    attachments: [],
  },
]

function parseLocalDateTime(value: string): number {
  // value: "YYYY-MM-DDTHH:mm"
  const [datePart, timePart] = value.split("T")
  const [y, m, d] = datePart.split("-").map(Number)
  const [hh, mm] = timePart.split(":").map(Number)
  return new Date(y, m - 1, d, hh, mm, 0, 0).getTime()
}

function pad2(n: number) {
  return String(n).padStart(2, "0")
}

function localDateKey(d: Date) {
  return `${d.getFullYear()}-${pad2(d.getMonth() + 1)}-${pad2(d.getDate())}`
}

function addDays(date: Date, days: number) {
  const d = new Date(date)
  d.setDate(d.getDate() + days)
  return d
}

function startOfDay(date: Date) {
  return new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0, 0)
}

function endOfDay(date: Date) {
  return new Date(
    date.getFullYear(),
    date.getMonth(),
    date.getDate(),
    23,
    59,
    59,
    999
  )
}

function getDatePart(dueAt: string) {
  return dueAt.split("T")[0] ?? ""
}

function getTimePart(dueAt: string) {
  return dueAt.split("T")[1] ?? ""
}

function parseLocalDateOnly(value: string): Date {
  // value: "YYYY-MM-DD"
  const [y, m, d] = value.split("-").map(Number)
  return new Date(y, m - 1, d, 0, 0, 0, 0)
}

function parseLocalTimeToMinutes(value: string): number {
  // value: "HH:mm"
  const [hh, mm] = value.split(":").map(Number)
  return hh * 60 + mm
}

function formatLocalDateTime(value: string): string {
  const ms = parseLocalDateTime(value)
  if (!Number.isFinite(ms)) return value
  return new Intl.DateTimeFormat(undefined, {
    year: "numeric",
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  }).format(new Date(ms))
}

function formatDateTimeFromMs(ms: number): string {
  return new Intl.DateTimeFormat(undefined, {
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  }).format(new Date(ms))
}

function minutesUntil(targetMs: number, nowMs: number) {
  return Math.ceil((targetMs - nowMs) / 60_000)
}

function getTaskFlags(todo: Todo, nowMs: number, inProgressTaskId: string | null) {
  const completed = todo.completed
  const dueMs = parseLocalDateTime(todo.dueAt)
  const overdue = !completed && dueMs < nowMs
  const inProgress = !completed && inProgressTaskId === todo.id
  const planned = !completed && !overdue && !inProgress
  return { completed, overdue, inProgress, planned }
}

function getDailyLoad(todosForDay: Todo[]) {
  // 4-hour windows across the day (local).
  const labels = [
    "00:00–04:00",
    "04:00–08:00",
    "08:00–12:00",
    "12:00–16:00",
    "16:00–20:00",
    "20:00–24:00",
  ]
  const buckets = Array.from({ length: 6 }, () => 0) as number[]
  for (const t of todosForDay) {
    const ms = parseLocalDateTime(t.dueAt)
    const hour = new Date(ms).getHours()
    const idx = Math.floor(hour / 4)
    buckets[idx] = (buckets[idx] ?? 0) + 1
  }

  const total = todosForDay.length
  const peak = Math.max(0, ...buckets)
  const spread = buckets.filter((c) => c > 0).length
  const busiestIdx = buckets.findIndex((c) => c === peak)
  const busiestWindow = busiestIdx >= 0 ? labels[busiestIdx] : labels[0]

  // Heuristic: more tasks + higher concentration in one window => heavier day.
  const score = total + peak * 1.5 + Math.max(0, spread - 1) * 0.5
  const load: DailyLoad = score <= 5 ? "light" : score <= 10 ? "balanced" : "heavy"

  return { load, total, peak, spread, busiestWindow }
}

function DailyLoadBadge({ load }: { load: DailyLoad }) {
  if (load === "heavy") return <Badge variant="destructive">Heavy</Badge>
  if (load === "balanced") return <Badge variant="secondary">Balanced</Badge>
  return <Badge variant="outline">Light</Badge>
}

function TaskBadges({
  completed,
  overdue,
  inProgress,
  planned,
}: {
  completed: boolean
  overdue: boolean
  inProgress: boolean
  planned: boolean
}) {
  if (completed) {
    return (
      <Badge className="gap-1 bg-emerald-600 text-white hover:bg-emerald-600">
        <CheckCircle2 className="h-3.5 w-3.5" />
        Completed
      </Badge>
    )
  }

  return (
    <>
      {inProgress && (
        <Badge className="gap-1 bg-sky-600 text-white hover:bg-sky-600">
          <Timer className="h-3.5 w-3.5 text-white" />
          In progress
        </Badge>
      )}
      {overdue && (
        <Badge variant="destructive" className="gap-1">
          <AlertTriangle className="h-3.5 w-3.5" />
          Overdue
        </Badge>
      )}
      {planned && (
        <Badge variant="outline" className="gap-1">
          <CalendarClock className="h-3.5 w-3.5" />
          Planned
        </Badge>
      )}
    </>
  )
}

function AttachmentIcon({ kind }: { kind: AttachmentKind }) {
  const className = "h-4 w-4 text-muted-foreground"

  switch (kind) {
    case "image":
      return <ImageIcon className={className} />
    case "audio":
      return <Music className={className} />
    case "video":
      return <Video className={className} />
    case "spreadsheet":
      return <FileSpreadsheet className={className} />
    case "pdf":
    case "document":
    case "text":
      return <FileText className={className} />
    default:
      return <File className={className} />
  }
}

const authSchema = z.object({
  email: z.string().email("Enter a valid email."),
  password: z.string().min(6, "Password must be at least 6 characters."),
})
type AuthValues = z.infer<typeof authSchema>

function AuthCard({ onAuthed }: { onAuthed: () => void }) {
  const [mode, setMode] = React.useState<"sign_in" | "sign_up">("sign_in")
  const [busy, setBusy] = React.useState(false)

  const form = useForm<AuthValues>({
    resolver: zodResolver(authSchema),
    defaultValues: { email: "", password: "" },
  })

  async function onSubmit(values: AuthValues) {
    setBusy(true)
    try {
      if (mode === "sign_in") {
        await apiFetch("/api/auth/sign-in", {
          method: "POST",
          body: JSON.stringify(values),
        })
        onAuthed()
      } else {
        await apiFetch("/api/auth/sign-up", {
          method: "POST",
          body: JSON.stringify(values),
        })
        toast.success("Account created", {
          description: "You can now sign in (or confirm email if required).",
        })
        setMode("sign_in")
      }
    } catch (e) {
      toast.error("Authentication failed", {
        description: e instanceof Error ? e.message : "Please try again.",
      })
    } finally {
      setBusy(false)
    }
  }

  return (
    <div className="mx-auto flex min-h-screen max-w-md flex-col justify-center px-4 py-10">
      <Card>
        <CardHeader>
          <CardTitle className="text-2xl">Sign in</CardTitle>
          <p className="text-muted-foreground text-sm">
            {mode === "sign_in"
              ? "Use your email and password."
              : "Create an account with email and password."}
          </p>
        </CardHeader>
        <CardContent className="space-y-4">
          <Form {...form}>
            <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-3" noValidate>
              <FormField
                control={form.control}
                name="email"
                render={({ field }) => (
                  <FormItem>
                    <FormControl>
                      <Input placeholder="Email" autoComplete="email" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="password"
                render={({ field }) => (
                  <FormItem>
                    <FormControl>
                      <Input
                        type="password"
                        placeholder="Password"
                        autoComplete={
                          mode === "sign_in" ? "current-password" : "new-password"
                        }
                        {...field}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <Button type="submit" className="w-full" disabled={busy}>
                {mode === "sign_in" ? "Sign in" : "Sign up"}
              </Button>
            </form>
          </Form>

          <div className="flex items-center justify-between gap-3 text-sm">
            <span className="text-muted-foreground">
              {mode === "sign_in" ? "No account?" : "Already have an account?"}
            </span>
            <Button
              type="button"
              variant="link"
              className="px-0"
              onClick={() => setMode((m) => (m === "sign_in" ? "sign_up" : "sign_in"))}
            >
              {mode === "sign_in" ? "Sign up" : "Sign in"}
            </Button>
          </div>
        </CardContent>
      </Card>
    </div>
  )
}

export default function Home() {
  const [user, setUser] = React.useState<{ id: string; email?: string } | null>(null)
  const [authLoading, setAuthLoading] = React.useState(true)
  const [authError, setAuthError] = React.useState<string | null>(null)

  const refreshAuth = React.useCallback(async () => {
    setAuthLoading(true)
    try {
      const data = await apiFetch<{ user: { id: string; email?: string } | null }>("/api/auth/me")
      setUser(data.user)
      setAuthError(null)
    } catch (e) {
      setUser(null)
      setAuthError(e instanceof Error ? e.message : "Auth check failed.")
    } finally {
      setAuthLoading(false)
    }
  }, [])

  React.useEffect(() => {
    void refreshAuth()
  }, [refreshAuth])

  if (authLoading) {
    return (
      <div className="mx-auto flex min-h-screen max-w-2xl flex-col justify-center px-4 py-10">
        <p className="text-muted-foreground text-sm">Loading…</p>
      </div>
    )
  }

  if (authError) {
    return (
      <div className="mx-auto flex min-h-screen max-w-2xl flex-col justify-center gap-4 px-4 py-10">
        <Card>
          <CardHeader>
            <CardTitle>Auth unavailable</CardTitle>
          </CardHeader>
          <CardContent className="space-y-2">
            <p className="text-muted-foreground text-sm">{authError}</p>
            <p className="text-muted-foreground text-sm">
              Check <code>SUPABASE_SETUP.md</code> and set env vars from{" "}
              <code>supabase.env.example</code>.
            </p>
            <Button type="button" variant="outline" onClick={() => void refreshAuth()}>
              Retry
            </Button>
          </CardContent>
        </Card>
      </div>
    )
  }

  if (!user) return <AuthCard onAuthed={() => void refreshAuth()} />

  return (
    <div className="mx-auto flex min-h-screen max-w-2xl flex-col gap-6 px-4 py-10">
      <TodoApp userId={user.id} onSignedOut={() => void refreshAuth()} />
    </div>
  )
}

function TodoApp({ userId, onSignedOut }: { userId: string; onSignedOut: () => void }) {
  const [todos, setTodos] = React.useState<Todo[]>([])
  const [tasksLoading, setTasksLoading] = React.useState(true)
  const [tasksError, setTasksError] = React.useState<{ code?: string; message: string } | null>(
    null
  )
  const [attachTargetTodoId, setAttachTargetTodoId] = React.useState<string | null>(
    null
  )
  const [conflictDueAt, setConflictDueAt] = React.useState<string | null>(null)
  const clearConflictTimerRef = React.useRef<number | null>(null)
  const [focusMode, setFocusMode] = React.useState(false)
  const [nowMs, setNowMs] = React.useState(() => Date.now())
  const [inProgressTaskId, setInProgressTaskId] = React.useState<string | null>(null)
  const [dismissedReminderTaskId, setDismissedReminderTaskId] = React.useState<
    string | null
  >(null)
  const [filterMode, setFilterMode] = React.useState<"between" | "exact">("between")
  const [filterFromDate, setFilterFromDate] = React.useState<string>("")
  const [filterFromTime, setFilterFromTime] = React.useState<string>("")
  const [filterToDate, setFilterToDate] = React.useState<string>("")
  const [filterToTime, setFilterToTime] = React.useState<string>("")
  const [filterExactDate, setFilterExactDate] = React.useState<string>("")
  const [filterExactTime, setFilterExactTime] = React.useState<string>("")
  const fileInputRef = React.useRef<HTMLInputElement>(null)
  const [pageSize, setPageSize] = React.useState<number>(5)
  const [page, setPage] = React.useState<number>(1)

  React.useEffect(() => {
    let alive = true
    async function load() {
      setTasksLoading(true)
      if (!alive) return
      try {
        const data = await apiFetch<{ tasks: Todo[]; inProgressTaskId: string | null }>("/api/tasks")
        if (!alive) return
        setTodos(data.tasks)
        setInProgressTaskId(data.inProgressTaskId)
        setTasksError(null)
      } catch (e) {
        if (!alive) return
        if (e instanceof ApiError) setTasksError({ code: e.code, message: e.message })
        else setTasksError({ message: e instanceof Error ? e.message : "Failed to load tasks." })
        setTodos([])
        setInProgressTaskId(null)
      } finally {
        setTasksLoading(false)
      }
    }
    load()
    return () => {
      alive = false
    }
  }, [userId])

  // Keep "now" fresh so overdue/in-progress states stay accurate without user interaction.
  React.useEffect(() => {
    const id = window.setInterval(() => setNowMs(Date.now()), 30_000)
    return () => window.clearInterval(id)
  }, [])

  // Only one task can be "In Progress"; auto-clear if completed, deleted, or overdue.
  React.useEffect(() => {
    if (!inProgressTaskId) return
    const t = todos.find((x) => x.id === inProgressTaskId)
    if (!t || t.completed) {
      setInProgressTaskId(null)
      return
    }
  }, [inProgressTaskId, nowMs, todos])

  const nextUpcoming = React.useMemo(() => {
    const upcoming = todos
      .filter((t) => !t.completed)
      .map((t) => ({ todo: t, dueMs: parseLocalDateTime(t.dueAt) }))
      .filter((x) => x.dueMs >= nowMs)
      .sort((a, b) => a.dueMs - b.dueMs)[0]
    return upcoming ?? null
  }, [nowMs, todos])

  React.useEffect(() => {
    // If "next upcoming" changed, allow reminder again (dismiss is per-task).
    if (nextUpcoming && nextUpcoming.todo.id !== dismissedReminderTaskId) return
    if (!nextUpcoming) setDismissedReminderTaskId(null)
  }, [dismissedReminderTaskId, nextUpcoming])

  const reminder = React.useMemo(() => {
    const REMINDER_WINDOW_MIN = 15
    if (!nextUpcoming) return null
    if (dismissedReminderTaskId === nextUpcoming.todo.id) return null
    const mins = minutesUntil(nextUpcoming.dueMs, nowMs)
    if (mins < 0 || mins > REMINDER_WINDOW_MIN) return null
    return { ...nextUpcoming, mins }
  }, [dismissedReminderTaskId, nextUpcoming, nowMs])

  const form = useForm<TodoFormValues>({
    resolver: zodResolver(todoSchema),
    defaultValues: { title: "", description: "", dueAt: "" },
    mode: "onSubmit",
  })

  const summary = React.useMemo(() => {
    const now = new Date()
    const todayKey = localDateKey(now)
    const tomorrow = addDays(now, 1)
    const tomorrowKey = localDateKey(tomorrow)

    const todays = todos.filter((t) => t.dueAt.startsWith(todayKey))
    const todayCompleted = todays.filter((t) => t.completed).length
    const todayPending = todays.length - todayCompleted

    const labels = [
      "00:00–04:00",
      "04:00–08:00",
      "08:00–12:00",
      "12:00–16:00",
      "16:00–20:00",
      "20:00–24:00",
    ]

    // Tomorrow: same 4-hour windows breakdown
    const tomorrowTasks = todos.filter((t) => t.dueAt.startsWith(tomorrowKey))
    const tomorrowBuckets = Array.from({ length: 6 }, () => 0) as number[]
    for (const t of tomorrowTasks) {
      const ms = parseLocalDateTime(t.dueAt)
      const hour = new Date(ms).getHours()
      const idx = Math.floor(hour / 4)
      tomorrowBuckets[idx] = (tomorrowBuckets[idx] ?? 0) + 1
    }

    // Until next week = next 7 days starting tomorrow (local), grouped into 4-hour windows.
    const rangeStart = startOfDay(tomorrow).getTime()
    const rangeEnd = addDays(startOfDay(tomorrow), 7).getTime()
    const buckets = Array.from({ length: 6 }, () => 0) as number[]

    const upcoming = todos.filter((t) => {
      const ms = parseLocalDateTime(t.dueAt)
      return ms >= rangeStart && ms < rangeEnd
    })

    for (const t of upcoming) {
      const ms = parseLocalDateTime(t.dueAt)
      const hour = new Date(ms).getHours()
      const idx = Math.floor(hour / 4)
      buckets[idx] = (buckets[idx] ?? 0) + 1
    }

    return {
      todayCompleted,
      todayPending,
      tomorrowTotal: tomorrowTasks.length,
      tomorrowBuckets: labels.map((label, i) => ({ label, count: tomorrowBuckets[i] ?? 0 })),
      upcomingTotal: upcoming.length,
      upcomingBuckets: labels.map((label, i) => ({ label, count: buckets[i] ?? 0 })),
    }
  }, [todos])

  const loadDayKey = React.useMemo(() => {
    // Prefer an explicitly selected date from filters; otherwise use today.
    if (filterMode === "exact" && filterExactDate) return filterExactDate
    if (filterFromDate && !filterToDate) return filterFromDate
    if (filterFromDate && filterToDate && filterFromDate === filterToDate) return filterFromDate
    if (!filterFromDate && filterToDate) return filterToDate
    return localDateKey(new Date(nowMs))
  }, [filterExactDate, filterFromDate, filterMode, filterToDate, nowMs])

  const dailyLoad = React.useMemo(() => {
    const dayTodos = todos.filter((t) => getDatePart(t.dueAt) === loadDayKey)
    return getDailyLoad(dayTodos)
  }, [loadDayKey, todos])

  const filteredTodos = React.useMemo(() => {
    if (focusMode) {
      const endMs = nowMs + 4 * 60 * 60 * 1000
      const withMs = todos.map((t) => ({ ...t, _dueMs: parseLocalDateTime(t.dueAt) }))
      return withMs.filter((t) => t._dueMs >= nowMs && t._dueMs <= endMs)
    }

    const withMs = todos.map((t) => ({ ...t, _dueMs: parseLocalDateTime(t.dueAt) }))
    if (filterMode === "exact") {
      // If only date is selected -> show tasks for that date.
      // If time is selected too -> match exact date+time.
      // If only time is selected -> match time-of-day across all dates.
      if (!filterExactDate && !filterExactTime) return withMs

      if (filterExactDate && !filterExactTime) {
        return withMs.filter((t) => getDatePart(t.dueAt) === filterExactDate)
      }

      if (filterExactDate && filterExactTime) {
        const exactMs = parseLocalDateTime(`${filterExactDate}T${filterExactTime}`)
        return withMs.filter((t) => t._dueMs === exactMs)
      }

      // time only
      return withMs.filter((t) => getTimePart(t.dueAt) === filterExactTime)
    }
    // between
    const hasAnyDate = Boolean(filterFromDate || filterToDate)
    const hasAnyTime = Boolean(filterFromTime || filterToTime)

    // Date range (optional)
    const fromDateMs = filterFromDate
      ? startOfDay(parseLocalDateOnly(filterFromDate)).getTime()
      : Number.NEGATIVE_INFINITY
    const toDateMs = filterToDate
      ? endOfDay(parseLocalDateOnly(filterToDate)).getTime()
      : Number.POSITIVE_INFINITY

    // Time-of-day range (optional)
    const fromTimeMin = filterFromTime ? parseLocalTimeToMinutes(filterFromTime) : 0
    const toTimeMin = filterToTime ? parseLocalTimeToMinutes(filterToTime) : 24 * 60 - 1

    return withMs.filter((t) => {
      const ms = t._dueMs
      if (hasAnyDate && (ms < fromDateMs || ms > toDateMs)) return false

      if (hasAnyTime) {
        const time = getTimePart(t.dueAt)
        if (!time) return false
        const mins = parseLocalTimeToMinutes(time)
        // Simple (non-wrapping) range. If you want wrap-around (e.g. 22:00–02:00), tell me.
        if (mins < fromTimeMin || mins > toTimeMin) return false
      }

      // If neither date nor time selected, pass through (handled above anyway)
      return true
    })
  }, [
    todos,
    focusMode,
    nowMs,
    filterExactDate,
    filterExactTime,
    filterFromDate,
    filterFromTime,
    filterMode,
    filterToDate,
    filterToTime,
  ])

  const sortedFilteredTodos = React.useMemo(
    () =>
      filteredTodos
        .slice()
        .sort((a, b) => parseLocalDateTime(a.dueAt) - parseLocalDateTime(b.dueAt)),
    [filteredTodos]
  )

  // Clamp page when filters/pageSize change.
  React.useEffect(() => {
    const totalPages = Math.max(1, Math.ceil(sortedFilteredTodos.length / pageSize))
    setPage((p) => Math.min(Math.max(1, p), totalPages))
  }, [pageSize, sortedFilteredTodos.length])

  const totalItems = sortedFilteredTodos.length
  const totalPages = Math.max(1, Math.ceil(totalItems / pageSize))
  const showPagination = totalPages > 1

  const pageItems = React.useMemo(() => {
    const start = (page - 1) * pageSize
    return sortedFilteredTodos.slice(start, start + pageSize)
  }, [page, pageSize, sortedFilteredTodos])

  const groupedTodos = React.useMemo(() => {
    const groups: Array<{ date: string; items: typeof pageItems }> = []
    for (const t of pageItems) {
      const date = getDatePart(t.dueAt)
      const last = groups[groups.length - 1]
      if (!last || last.date !== date) groups.push({ date, items: [t] })
      else last.items.push(t)
    }
    return groups
  }, [pageItems])

  const completedCount = filteredTodos.filter((t) => t.completed).length

  async function addTodo(values: TodoFormValues) {
    const conflicts = todos.filter((t) => t.dueAt === values.dueAt)
    if (conflicts.length > 0) {
      setConflictDueAt(values.dueAt)
      if (clearConflictTimerRef.current) window.clearTimeout(clearConflictTimerRef.current)
      clearConflictTimerRef.current = window.setTimeout(() => {
        setConflictDueAt(null)
      }, 8000)

      // Make sure the user can see the conflicting tasks even if they were filtered out.
      const [d, time] = values.dueAt.split("T")
      setFilterMode("exact")
      setFilterExactDate(d ?? "")
      setFilterExactTime(time ?? "")
      setPage(1)

      toast.error("Time conflict", {
        description: `You already have ${conflicts.length} task(s) scheduled at ${formatLocalDateTime(
          values.dueAt
        )}.`,
      })
    }

    try {
      const data = await apiFetch<{ task: Todo }>("/api/tasks", {
        method: "POST",
        body: JSON.stringify(values),
      })
      setTodos((prev) => [data.task, ...prev])
    } catch (e) {
      toast.error("Failed to add task", { description: e instanceof Error ? e.message : "Failed." })
      return
    }
    form.reset()
  }

  async function toggleTodo(id: string, completed: boolean) {
    // optimistic
    setTodos((prev) =>
      prev.map((t) =>
        t.id === id ? { ...t, completed, attachments: t.attachments } : t
      )
    )
    if (completed) setInProgressTaskId((cur) => (cur === id ? null : cur))

    const update: { completed: boolean; in_progress?: boolean } = { completed }
    if (completed) update.in_progress = false

    try {
      await apiFetch("/api/tasks/" + id, {
        method: "PATCH",
        body: JSON.stringify({ completed }),
      })
    } catch (e) {
      toast.error("Failed to update task", { description: e instanceof Error ? e.message : "Failed." })
    }
  }

  function requestAttachmentsForTodo(todoId: string) {
    setAttachTargetTodoId(todoId)
    // Let state update before opening picker (some browsers are picky).
    queueMicrotask(() => fileInputRef.current?.click())
  }

  async function handleFilesPicked(e: React.ChangeEvent<HTMLInputElement>) {
    const files = Array.from(e.target.files ?? [])
    const targetId = attachTargetTodoId

    // reset input so picking the same file again triggers onChange
    e.target.value = ""
    setAttachTargetTodoId(null)

    if (!targetId || files.length === 0) return
    const form = new FormData()
    for (const f of files) form.append("files", f)
    try {
      const res = await fetch(`/api/tasks/${targetId}/attachments`, {
        method: "POST",
        credentials: "include",
        body: form,
      })
      const json = (await res.json().catch(() => null)) as
        | { ok: true; data: { task: Todo } }
        | { ok: false; error: { message: string } }
        | null
      if (!json || !json.ok) throw new Error(json?.error.message ?? "Upload failed.")
      setTodos((prev) => prev.map((t) => (t.id === targetId ? json.data.task : t)))
    } catch (e) {
      toast.error("Upload failed", { description: e instanceof Error ? e.message : "Failed." })
    }
  }

  async function deleteTodo(id: string) {
    // optimistic
    setTodos((prev) => prev.filter((t) => t.id !== id))
    setInProgressTaskId((cur) => (cur === id ? null : cur))

    try {
      await apiFetch("/api/tasks/" + id, { method: "DELETE" })
    } catch (e) {
      toast.error("Failed to delete task", { description: e instanceof Error ? e.message : "Failed." })
    }
  }

  async function setInProgress(taskId: string | null) {
    // optimistic
    setInProgressTaskId(taskId)

    try {
      const data = await apiFetch<{ inProgressTaskId: string | null }>("/api/tasks/in-progress", {
        method: "POST",
        body: JSON.stringify({ id: taskId }),
      })
      setInProgressTaskId(data.inProgressTaskId)
    } catch (e) {
      toast.error("Failed to update in-progress", {
        description: e instanceof Error ? e.message : "Failed.",
      })
    }
  }

  async function downloadAttachment(a: Attachment) {
    try {
      const data = await apiFetch<{ signedUrl: string }>("/api/attachments/signed-url", {
        method: "POST",
        body: JSON.stringify({ bucket: a.bucket, path: a.path }),
      })
      window.open(data.signedUrl, "_blank", "noopener,noreferrer")
    } catch (e) {
      toast.error("Download failed", { description: e instanceof Error ? e.message : "Failed." })
    }
  }

  async function seedDemoTasks() {
    if (todos.length > 0) return
    try {
      const data = await apiFetch<{ tasks: Todo[] }>("/api/tasks/seed", {
        method: "POST",
        body: JSON.stringify({ tasks: initialTodos }),
      })
      setTodos(data.tasks)
    } catch (e) {
      toast.error("Failed to seed demo tasks", { description: e instanceof Error ? e.message : "Failed." })
    }
  }

  async function clearCompleted() {
    const completedIds = new Set(todos.filter((t) => t.completed).map((t) => t.id))
    if (completedIds.size === 0) return

    // optimistic
    setTodos((prev) => prev.filter((t) => !completedIds.has(t.id)))

    try {
      await apiFetch("/api/tasks/clear-completed", { method: "POST" })
    } catch (e) {
      toast.error("Failed to clear completed", { description: e instanceof Error ? e.message : "Failed." })
    }
  }

  return (
    <Card>
      <CardHeader className="flex flex-row items-center justify-between gap-4">
        <div className="space-y-1">
          <CardTitle className="text-2xl">To‑Do</CardTitle>
          <p className="text-muted-foreground text-sm">
            {completedCount}/{filteredTodos.length} completed
          </p>
        </div>
        <div className="flex items-center gap-2">
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <Button
                  type="button"
                  variant={focusMode ? "default" : "outline"}
                  size="sm"
                  onClick={() => {
                    setFocusMode((v) => !v)
                    setPage(1)
                  }}
                >
                  Focus Mode
                </Button>
              </TooltipTrigger>
              <TooltipContent>
                <p>Show tasks for the next 4 hours.</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>

          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <button
                type="button"
                className="rounded-full border bg-background p-0.5"
                aria-label="User menu"
              >
                <Avatar className="h-8 w-8">
                  <AvatarFallback>{userId.slice(0, 2).toUpperCase()}</AvatarFallback>
                </Avatar>
              </button>
            </DropdownMenuTrigger>
            <DropdownMenuContent align="end" className="w-48">
              <DropdownMenuLabel className="text-xs">Account</DropdownMenuLabel>
              <DropdownMenuSeparator />
              <DropdownMenuItem
                onSelect={(e) => {
                  e.preventDefault()
                  void apiFetch("/api/auth/sign-out", { method: "POST" })
                    .catch(() => {})
                    .finally(() => onSignedOut())
                }}
              >
                <LogOut className="mr-2 h-4 w-4" />
                Logout
              </DropdownMenuItem>
            </DropdownMenuContent>
          </DropdownMenu>

          <ModeToggle />
        </div>
      </CardHeader>

      <CardContent className="space-y-6">
        {tasksLoading && (
          <p className="text-muted-foreground text-sm">Loading tasks…</p>
        )}

        {!tasksLoading && tasksError?.code === "MISSING_TABLE" && (
          <Alert variant="destructive">
            <AlertTitle>Database not initialized</AlertTitle>
            <AlertDescription>
              <div className="space-y-2">
                <p>
                  The Supabase table <code>public.tasks</code> was not found. Run the SQL in{" "}
                  <code>supabase/schema.sql</code> (Supabase Dashboard → SQL Editor), then refresh.
                </p>
                <p className="text-xs opacity-90">{tasksError.message}</p>
              </div>
            </AlertDescription>
          </Alert>
        )}

        {!tasksLoading && tasksError && tasksError.code !== "MISSING_TABLE" && (
          <Alert variant="destructive">
            <AlertTitle>Failed to load tasks</AlertTitle>
            <AlertDescription>{tasksError.message}</AlertDescription>
          </Alert>
        )}

        {!tasksLoading && todos.length === 0 && (
          <div className="flex items-center justify-between gap-3 rounded-lg border bg-muted/20 px-3 py-2">
            <p className="text-muted-foreground text-sm">No tasks yet.</p>
            <Button type="button" variant="outline" size="sm" onClick={() => void seedDemoTasks()}>
              Seed demo tasks
            </Button>
          </div>
        )}

        <input
          ref={fileInputRef}
          type="file"
          multiple
          className="hidden"
          accept={[
            "image/*",
            "audio/*",
            "video/*",
            ".pdf",
            ".doc",
            ".docx",
            ".xls",
            ".xlsx",
            ".csv",
            ".txt",
            ".md",
            ".rtf",
          ].join(",")}
          onChange={handleFilesPicked}
        />

        {reminder && (
          <Alert className="border-primary/30 bg-primary/5">
            <Bell className="h-4 w-4" />
            <div className="flex flex-1 flex-col gap-1">
              <div className="flex flex-wrap items-center justify-between gap-2">
                <AlertTitle className="text-sm">
                  Next task starts in {reminder.mins} minute{reminder.mins === 1 ? "" : "s"}
                </AlertTitle>
                <Button
                  type="button"
                  variant="ghost"
                  size="sm"
                  onClick={() => setDismissedReminderTaskId(reminder.todo.id)}
                >
                  Dismiss
                </Button>
              </div>
              <AlertDescription className="text-sm">
                <span className="font-medium">{reminder.todo.title}</span> ·{" "}
                {formatDateTimeFromMs(reminder.dueMs)}
              </AlertDescription>
            </div>
          </Alert>
        )}

        <div className="rounded-xl border bg-card p-4">
          <div className="flex flex-wrap items-center justify-between gap-2">
            <p className="text-sm font-medium">
              Daily load{" "}
              <span className="text-muted-foreground font-normal">
                ({new Intl.DateTimeFormat(undefined, {
                  weekday: "short",
                  year: "numeric",
                  month: "short",
                  day: "2-digit",
                }).format(parseLocalDateOnly(loadDayKey))})
              </span>
            </p>
            <DailyLoadBadge load={dailyLoad.load} />
          </div>
          <p className="text-muted-foreground mt-2 text-sm">
            {dailyLoad.total} task(s) · busiest window {dailyLoad.busiestWindow} ({dailyLoad.peak})
          </p>
        </div>

        <div className="grid gap-3 sm:grid-cols-3">
          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Today’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">
              {summary.todayCompleted} completed
            </p>
            <p className="text-muted-foreground text-sm">{summary.todayPending} pending</p>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tomorrow’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">{summary.tomorrowTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.tomorrowBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tasks Until Next Week</p>
            <p className="mt-2 text-2xl font-semibold">{summary.upcomingTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.upcomingBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>
        </div>

        {focusMode && (
          <div className="flex flex-col gap-1 rounded-lg border bg-muted/20 px-3 py-2 sm:flex-row sm:items-center sm:justify-between">
            <p className="text-sm">
              <span className="font-medium">Focus Mode:</span>{" "}
              showing tasks due in the next 4 hours (until{" "}
              <span className="font-medium">
                {formatDateTimeFromMs(nowMs + 4 * 60 * 60 * 1000)}
              </span>
              )
            </p>
            <Button type="button" variant="ghost" size="sm" onClick={() => setFocusMode(false)}>
              Exit
            </Button>
          </div>
        )}

        <Form {...form}>
          <form
            onSubmit={form.handleSubmit(addTodo)}
            className="space-y-2"
            noValidate
          >
            <div className="flex flex-col gap-2 sm:flex-row">
              <FormField
                control={form.control}
                name="title"
                render={({ field }) => (
                  <FormItem className="flex-1">
                    <FormControl>
                      <Input
                        placeholder="Add a task…"
                        autoComplete="off"
                        {...field}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="dueAt"
                render={({ field }) => (
                  <FormItem className="sm:w-64">
                    <FormControl>
                      <Input type="datetime-local" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <Button type="submit">Add</Button>
            </div>

            <FormField
              control={form.control}
              name="description"
              render={({ field }) => (
                <FormItem>
                  <FormControl>
                    <Textarea
                      rows={3}
                      placeholder="Description (optional)…"
                      {...field}
                    />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />
          </form>
        </Form>

        <Separator />

        <div className="space-y-3">
          <div className="flex flex-wrap items-center justify-between gap-2">
            <p className="text-sm font-medium">Filter by date & time</p>
            <div className="flex items-center gap-2">
              <Button
                type="button"
                size="sm"
                variant={filterMode === "between" ? "default" : "outline"}
                onClick={() => setFilterMode("between")}
              >
                Between
              </Button>
              <Button
                type="button"
                size="sm"
                variant={filterMode === "exact" ? "default" : "outline"}
                onClick={() => setFilterMode("exact")}
              >
                Exact
              </Button>
              <Button
                type="button"
                size="sm"
                variant="ghost"
                onClick={() => {
                  setFilterFromDate("")
                  setFilterFromTime("")
                  setFilterToDate("")
                  setFilterToTime("")
                  setFilterExactDate("")
                  setFilterExactTime("")
                }}
              >
                Clear
              </Button>
            </div>
          </div>

          {filterMode === "between" ? (
            <div className="grid gap-2 sm:grid-cols-2">
              <div className="grid gap-2 sm:grid-cols-2">
                <Input
                  type="date"
                  value={filterFromDate}
                  onChange={(e) => setFilterFromDate(e.target.value)}
                />
                <Input
                  type="time"
                  value={filterFromTime}
                  onChange={(e) => setFilterFromTime(e.target.value)}
                />
              </div>
              <div className="grid gap-2 sm:grid-cols-2">
                <Input
                  type="date"
                  value={filterToDate}
                  onChange={(e) => setFilterToDate(e.target.value)}
                />
                <Input
                  type="time"
                  value={filterToTime}
                  onChange={(e) => setFilterToTime(e.target.value)}
                />
              </div>
            </div>
          ) : (
            <div className="grid gap-2 sm:grid-cols-2">
              <Input
                type="date"
                value={filterExactDate}
                onChange={(e) => setFilterExactDate(e.target.value)}
              />
              <Input
                type="time"
                value={filterExactTime}
                onChange={(e) => setFilterExactTime(e.target.value)}
              />
            </div>
          )}
        </div>

        <Separator />

        <div className="space-y-2">
          {groupedTodos.length === 0 ? (
            <p className="text-muted-foreground text-sm">No tasks yet.</p>
          ) : (
            groupedTodos.map((group) => (
              <div key={group.date} className="space-y-2">
                <div className="flex items-center gap-3 pt-2">
                  <Separator className="flex-1" />
                  <span className="text-muted-foreground whitespace-nowrap text-xs font-medium">
                    {new Intl.DateTimeFormat(undefined, {
                      weekday: "short",
                      year: "numeric",
                      month: "short",
                      day: "2-digit",
                    }).format(parseLocalDateOnly(group.date))}
                  </span>
                  <Separator className="flex-1" />
                </div>

                {group.items.map((todo) => {
                  const flags = getTaskFlags(todo, nowMs, inProgressTaskId)

                  return (
                    <div
                      key={todo.id}
                      className={cn(
                        "rounded-lg border px-3 py-2",
                        flags.completed && "opacity-75",
                        flags.overdue &&
                          "border-destructive/40 bg-destructive/5 text-muted-foreground",
                        flags.inProgress && "border-sky-500/40 bg-sky-500/10",
                        conflictDueAt &&
                          todo.dueAt === conflictDueAt &&
                          "border-destructive/60 bg-destructive/5 ring-1 ring-destructive/30"
                      )}
                    >
                      <div className="flex items-start justify-between gap-3">
                        <label className="flex cursor-pointer items-start gap-3">
                        <Checkbox
                          checked={todo.completed}
                          onCheckedChange={(v) => {
                            const next = Boolean(v)
                            toggleTodo(todo.id, next)
                            if (next && !todo.completed) {
                              requestAttachmentsForTodo(todo.id)
                            }
                          }}
                          aria-label={`Mark "${todo.title}" as ${
                            todo.completed ? "not completed" : "completed"
                          }`}
                          className="mt-0.5"
                        />
                        <span
                          className={cn(
                            "leading-6",
                            todo.completed && "text-muted-foreground line-through"
                          )}
                        >
                          <span className="flex flex-wrap items-center gap-2">
                            <span className="block">{todo.title}</span>
                              <TaskBadges {...flags} />
                            {todo.description && (
                              <TooltipProvider>
                                <Tooltip>
                                  <TooltipTrigger asChild>
                                    <button
                                      type="button"
                                      className="text-muted-foreground hover:text-foreground inline-flex h-7 w-7 items-center justify-center rounded-md border bg-background"
                                      aria-label="View description"
                                    >
                                      <Info className="h-4 w-4" />
                                    </button>
                                  </TooltipTrigger>
                                  <TooltipContent className="max-w-xs">
                                    <p className="whitespace-pre-wrap text-sm">
                                      {todo.description}
                                    </p>
                                  </TooltipContent>
                                </Tooltip>
                              </TooltipProvider>
                            )}
                          </span>
                          <span className="text-muted-foreground block text-xs">
                            Due: {formatLocalDateTime(todo.dueAt)}
                          </span>
                        </span>
                      </label>

                      <div className="flex items-center gap-1">
                        {!todo.completed && (
                          <Button
                            type="button"
                            variant={flags.inProgress ? "default" : "outline"}
                            size="sm"
                            onClick={() => void setInProgress(flags.inProgress ? null : todo.id)}
                            className={cn(
                              flags.inProgress && "bg-sky-600 hover:bg-sky-600"
                            )}
                          >
                            {flags.inProgress ? (
                              <>
                                <CircleStop className="mr-1 h-4 w-4" />
                                Stop
                              </>
                            ) : (
                              <>
                                <CirclePlay className="mr-1 h-4 w-4" />
                                Start
                              </>
                            )}
                          </Button>
                        )}
                        {todo.completed && (
                          <Button
                            type="button"
                            variant="outline"
                            size="sm"
                            onClick={() => requestAttachmentsForTodo(todo.id)}
                          >
                            Add files
                          </Button>
                        )}
                        <Button
                          type="button"
                          variant="ghost"
                          size="icon"
                          aria-label={`Delete "${todo.title}"`}
                          onClick={() => deleteTodo(todo.id)}
                        >
                          <Trash2 className="h-4 w-4" />
                        </Button>
                      </div>
                    </div>

                    {todo.completed && todo.attachments.length > 0 && (
                      <div className="mt-3 space-y-2">
                        <p className="text-muted-foreground text-xs">Attachments</p>
                        <ul className="space-y-1">
                          {todo.attachments.map((a) => (
                            <li
                              key={a.id}
                              className="flex items-center justify-between gap-3 rounded-md bg-muted/30 px-2 py-1"
                            >
                              <div className="flex min-w-0 items-center gap-2">
                                <AttachmentIcon kind={a.kind} />
                                <span className="truncate text-sm">{a.name}</span>
                              </div>
                              <button
                                type="button"
                                onClick={() => void downloadAttachment(a)}
                                className="inline-flex items-center gap-1 text-sm font-medium underline underline-offset-4"
                              >
                                <Download className="h-4 w-4" />
                                Download
                              </button>
                            </li>
                          ))}
                        </ul>
                      </div>
                    )}
                  </div>
                  )
                })}
              </div>
            ))
          )}
        </div>

        {groupedTodos.length > 0 && (
          <div className="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
            <div className="flex items-center gap-2">
              <span className="text-muted-foreground text-sm">Items per page</span>
              <Select
                value={String(pageSize)}
                onValueChange={(v) => {
                  const next = Number(v)
                  setPageSize(next)
                  setPage(1)
                }}
              >
                <SelectTrigger className="w-[110px]">
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="5">5</SelectItem>
                  <SelectItem value="10">10</SelectItem>
                  <SelectItem value="15">15</SelectItem>
                  <SelectItem value="20">20</SelectItem>
                </SelectContent>
              </Select>
            </div>

            {showPagination && (
              <div className="flex items-center justify-between gap-3 sm:justify-end">
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={() => setPage((p) => Math.max(1, p - 1))}
                  disabled={page <= 1}
                >
                  Prev
                </Button>
                <span className="text-muted-foreground text-sm">
                  Page {page} of {totalPages}
                </span>
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={() => setPage((p) => Math.min(totalPages, p + 1))}
                  disabled={page >= totalPages}
                >
                  Next
                </Button>
              </div>
            )}
          </div>
        )}

        <div className="flex items-center justify-between gap-2">
          <Button
            type="button"
            variant="secondary"
            onClick={clearCompleted}
            disabled={completedCount === 0}
          >
            Clear completed
          </Button>
          <span className="text-muted-foreground text-sm">
            v 1.1.0
          </span>
    </div>
      </CardContent>
    </Card>
  )
}

```

### Updated header auth UI
- **Removed** the standalone **Sign out** button.
- **Added** a **user avatar** button with a **dropdown menu**.
  - Includes a compact **Logout** item with a **LogOut icon**.

### Files changed
- **Updated**: `src/app/page.tsx`
- **Added**: `src/components/ui/avatar.tsx`, `src/components/ui/dropdown-menu.tsx`

---

**User**

The page.tsx is getting too cluttered. For better code organization and maintainability, please refactor it into smaller, reusable components.

---

**Cursor**

Plan: I’ll extract the big UI chunks in `src/app/page.tsx` into focused components (Auth, header/user menu, reminders/summary cards, task form, task list + pagination). I’ll keep the state + API calls in a single container component (`TodoApp`) to avoid prop-drilling, then run a build to confirm nothing breaks.

```typescript
export type AttachmentKind =
  | "image"
  | "audio"
  | "video"
  | "pdf"
  | "spreadsheet"
  | "document"
  | "text"
  | "file"

export type Attachment = {
  id: string
  name: string
  type: string
  size: number
  bucket: string
  path: string
  kind: AttachmentKind
}

export type Todo = {
  id: string
  title: string
  description?: string
  completed: boolean
  // Stored as `datetime-local` string (YYYY-MM-DDTHH:mm) in local time.
  dueAt: string
  attachments: Attachment[]
}

export type DailyLoad = "light" | "balanced" | "heavy"


```

```typescript
"use client"

import { z } from "zod"

export const todoSchema = z.object({
  title: z.string().trim().min(1, "Title is required.").max(80, "Keep it under 80 characters."),
  description: z
    .string()
    .trim()
    .max(500, "Keep it under 500 characters.")
    .optional()
    .or(z.literal("")),
  dueAt: z
    .string()
    .min(1, "Due date & time is required.")
    .regex(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}$/, "Invalid date/time."),
})

export type TodoFormValues = z.infer<typeof todoSchema>

export const authSchema = z.object({
  email: z.string().email("Enter a valid email."),
  password: z.string().min(6, "Password must be at least 6 characters."),
})

export type AuthValues = z.infer<typeof authSchema>


```

```typescript
"use client"

import type { Todo } from "./types"

export const initialTodos: Todo[] = [
  {
    id: "1",
    title: "Create a Next.js app",
    description: "Scaffold with TypeScript + Tailwind and confirm it runs locally.",
    completed: true,
    dueAt: "2026-01-16T09:00",
    attachments: [],
  },
  {
    id: "2",
    title: "Add shadcn/ui + dark theme",
    description: "Initialize shadcn, set up theme provider, and verify dark mode.",
    completed: true,
    dueAt: "2026-01-16T10:30",
    attachments: [],
  },
  {
    id: "3",
    title: "Build a mock-data to-do list",
    completed: false,
    dueAt: "2026-01-16T15:00",
    attachments: [],
  },
  {
    id: "4",
    title: "Yesterday: review requirements",
    completed: true,
    dueAt: "2026-01-15T11:15",
    attachments: [],
  },
  {
    id: "5",
    title: "Yesterday: sketch UI layout",
    completed: true,
    dueAt: "2026-01-15T17:45",
    attachments: [],
  },
  {
    id: "6",
    title: "Today: add attachments support",
    completed: false,
    dueAt: "2026-01-16T18:20",
    attachments: [],
  },
  {
    id: "7",
    title: "Tomorrow: QA the filters",
    description: "Test date-only, time-only, exact, and between behaviors.",
    completed: false,
    dueAt: "2026-01-17T08:05",
    attachments: [],
  },
  {
    id: "8",
    title: "Tomorrow: polish summary cards",
    completed: false,
    dueAt: "2026-01-17T13:30",
    attachments: [],
  },
  {
    id: "9",
    title: "Tomorrow: write small UX notes",
    completed: false,
    dueAt: "2026-01-17T20:10",
    attachments: [],
  },
  {
    id: "10",
    title: "This weekend: add more mock tasks",
    completed: false,
    dueAt: "2026-01-18T10:00",
    attachments: [],
  },
  {
    id: "11",
    title: "This weekend: check time-only filter",
    completed: false,
    dueAt: "2026-01-18T22:15",
    attachments: [],
  },
  {
    id: "12",
    title: "Next week: sync with team",
    completed: false,
    dueAt: "2026-01-19T09:30",
    attachments: [],
  },
  {
    id: "13",
    title: "Next week: test date-only filter",
    completed: false,
    dueAt: "2026-01-20T14:05",
    attachments: [],
  },
  {
    id: "14",
    title: "Next week: test exact date+time filter",
    completed: false,
    dueAt: "2026-01-21T12:00",
    attachments: [],
  },
  {
    id: "15",
    title: "Next week: attach docs to completed tasks",
    completed: false,
    dueAt: "2026-01-22T16:40",
    attachments: [],
  },
  {
    id: "16",
    title: "Next week: final review",
    completed: false,
    dueAt: "2026-01-23T11:00",
    attachments: [],
  },
]


```

```typescriptreact
"use client"

import * as React from "react"
import { useForm } from "react-hook-form"
import { toast } from "sonner"

import { apiFetch } from "@/lib/api-client"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Form, FormControl, FormField, FormItem, FormMessage } from "@/components/ui/form"
import { Input } from "@/components/ui/input"
import { zodResolver } from "@hookform/resolvers/zod"

import { authSchema, type AuthValues } from "./schemas"

export function AuthCard({ onAuthed }: { onAuthed: () => void }) {
  const [mode, setMode] = React.useState<"sign_in" | "sign_up">("sign_in")
  const [busy, setBusy] = React.useState(false)

  const form = useForm<AuthValues>({
    resolver: zodResolver(authSchema),
    defaultValues: { email: "", password: "" },
  })

  async function onSubmit(values: AuthValues) {
    setBusy(true)
    try {
      if (mode === "sign_in") {
        await apiFetch("/api/auth/sign-in", {
          method: "POST",
          body: JSON.stringify(values),
        })
        onAuthed()
      } else {
        await apiFetch("/api/auth/sign-up", {
          method: "POST",
          body: JSON.stringify(values),
        })
        toast.success("Account created", {
          description: "You can now sign in (or confirm email if required).",
        })
        setMode("sign_in")
      }
    } catch (e) {
      toast.error("Authentication failed", {
        description: e instanceof Error ? e.message : "Please try again.",
      })
    } finally {
      setBusy(false)
    }
  }

  return (
    <div className="mx-auto flex min-h-screen max-w-md flex-col justify-center px-4 py-10">
      <Card>
        <CardHeader>
          <CardTitle className="text-2xl">{mode === "sign_in" ? "Sign in" : "Sign up"}</CardTitle>
          <p className="text-muted-foreground text-sm">
            {mode === "sign_in"
              ? "Use your email and password."
              : "Create an account with email and password."}
          </p>
        </CardHeader>
        <CardContent className="space-y-4">
          <Form {...form}>
            <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-3" noValidate>
              <FormField
                control={form.control}
                name="email"
                render={({ field }) => (
                  <FormItem>
                    <FormControl>
                      <Input placeholder="Email" autoComplete="email" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="password"
                render={({ field }) => (
                  <FormItem>
                    <FormControl>
                      <Input
                        type="password"
                        placeholder="Password"
                        autoComplete={mode === "sign_in" ? "current-password" : "new-password"}
                        {...field}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <Button type="submit" className="w-full" disabled={busy}>
                {mode === "sign_in" ? "Sign in" : "Sign up"}
              </Button>
            </form>
          </Form>

          <div className="flex items-center justify-between gap-3 text-sm">
            <span className="text-muted-foreground">
              {mode === "sign_in" ? "No account?" : "Already have an account?"}
            </span>
            <Button
              type="button"
              variant="link"
              className="px-0"
              onClick={() => setMode((m) => (m === "sign_in" ? "sign_up" : "sign_in"))}
            >
              {mode === "sign_in" ? "Sign up" : "Sign in"}
            </Button>
          </div>
        </CardContent>
      </Card>
    </div>
  )
}


```

```typescriptreact
"use client"

import * as React from "react"
import { LogOut } from "lucide-react"

import { apiFetch } from "@/lib/api-client"
import { Avatar, AvatarFallback } from "@/components/ui/avatar"
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu"

export function UserMenu({ userId, onSignedOut }: { userId: string; onSignedOut: () => void }) {
  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <button
          type="button"
          className="rounded-full border bg-background p-0.5"
          aria-label="User menu"
        >
          <Avatar className="h-8 w-8">
            <AvatarFallback>{userId.slice(0, 2).toUpperCase()}</AvatarFallback>
          </Avatar>
        </button>
      </DropdownMenuTrigger>
      <DropdownMenuContent align="end" className="w-48">
        <DropdownMenuLabel className="text-xs">Account</DropdownMenuLabel>
        <DropdownMenuSeparator />
        <DropdownMenuItem
          onSelect={(e) => {
            e.preventDefault()
            void apiFetch("/api/auth/sign-out", { method: "POST" })
              .catch(() => {})
              .finally(() => onSignedOut())
          }}
        >
          <LogOut className="mr-2 h-4 w-4" />
          Logout
        </DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  )
}


```

```typescriptreact
"use client"

import * as React from "react"
import { zodResolver } from "@hookform/resolvers/zod"
import { useForm } from "react-hook-form"

import { Button } from "@/components/ui/button"
import { Form, FormControl, FormField, FormItem, FormMessage } from "@/components/ui/form"
import { Input } from "@/components/ui/input"
import { Textarea } from "@/components/ui/textarea"

import { todoSchema, type TodoFormValues } from "./schemas"

export function TaskForm({ onAdd }: { onAdd: (values: TodoFormValues) => Promise<void> }) {
  const form = useForm<TodoFormValues>({
    resolver: zodResolver(todoSchema),
    defaultValues: { title: "", description: "", dueAt: "" },
    mode: "onSubmit",
  })

  return (
    <Form {...form}>
      <form
        onSubmit={form.handleSubmit(async (values) => {
          await onAdd(values)
          form.reset()
        })}
        className="space-y-2"
        noValidate
      >
        <div className="flex flex-col gap-2 sm:flex-row">
          <FormField
            control={form.control}
            name="title"
            render={({ field }) => (
              <FormItem className="flex-1">
                <FormControl>
                  <Input placeholder="Add a task…" autoComplete="off" {...field} />
                </FormControl>
                <FormMessage />
              </FormItem>
            )}
          />
          <FormField
            control={form.control}
            name="dueAt"
            render={({ field }) => (
              <FormItem className="sm:w-64">
                <FormControl>
                  <Input type="datetime-local" {...field} />
                </FormControl>
                <FormMessage />
              </FormItem>
            )}
          />
          <Button type="submit">Add</Button>
        </div>

        <FormField
          control={form.control}
          name="description"
          render={({ field }) => (
            <FormItem>
              <FormControl>
                <Textarea rows={3} placeholder="Description (optional)…" {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
      </form>
    </Form>
  )
}


```

```typescript
"use client"

import type { DailyLoad, Todo } from "./types"

export function pad2(n: number) {
  return String(n).padStart(2, "0")
}

export function localDateKey(d: Date) {
  return `${d.getFullYear()}-${pad2(d.getMonth() + 1)}-${pad2(d.getDate())}`
}

export function addDays(date: Date, days: number) {
  const d = new Date(date)
  d.setDate(d.getDate() + days)
  return d
}

export function startOfDay(date: Date) {
  return new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0, 0)
}

export function endOfDay(date: Date) {
  return new Date(date.getFullYear(), date.getMonth(), date.getDate(), 23, 59, 59, 999)
}

export function getDatePart(dueAt: string) {
  return dueAt.split("T")[0] ?? ""
}

export function getTimePart(dueAt: string) {
  return dueAt.split("T")[1] ?? ""
}

export function parseLocalDateTime(value: string): number {
  const [datePart, timePart] = value.split("T")
  const [y, m, d] = datePart.split("-").map(Number)
  const [hh, mm] = timePart.split(":").map(Number)
  return new Date(y, m - 1, d, hh, mm, 0, 0).getTime()
}

export function parseLocalDateOnly(value: string): Date {
  const [y, m, d] = value.split("-").map(Number)
  return new Date(y, m - 1, d, 0, 0, 0, 0)
}

export function parseLocalTimeToMinutes(value: string): number {
  const [hh, mm] = value.split(":").map(Number)
  return hh * 60 + mm
}

export function formatLocalDateTime(value: string): string {
  const ms = parseLocalDateTime(value)
  if (!Number.isFinite(ms)) return value
  return new Intl.DateTimeFormat(undefined, {
    year: "numeric",
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  }).format(new Date(ms))
}

export function formatDateTimeFromMs(ms: number): string {
  return new Intl.DateTimeFormat(undefined, {
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  }).format(new Date(ms))
}

export function minutesUntil(targetMs: number, nowMs: number) {
  return Math.ceil((targetMs - nowMs) / 60_000)
}

export function getDailyLoad(todosForDay: Todo[]) {
  const labels = [
    "00:00–04:00",
    "04:00–08:00",
    "08:00–12:00",
    "12:00–16:00",
    "16:00–20:00",
    "20:00–24:00",
  ]
  const buckets = Array.from({ length: 6 }, () => 0) as number[]
  for (const t of todosForDay) {
    const ms = parseLocalDateTime(t.dueAt)
    const hour = new Date(ms).getHours()
    const idx = Math.floor(hour / 4)
    buckets[idx] = (buckets[idx] ?? 0) + 1
  }

  const total = todosForDay.length
  const peak = Math.max(0, ...buckets)
  const spread = buckets.filter((c) => c > 0).length
  const busiestIdx = buckets.findIndex((c) => c === peak)
  const busiestWindow = busiestIdx >= 0 ? labels[busiestIdx] : labels[0]

  const score = total + peak * 1.5 + Math.max(0, spread - 1) * 0.5
  const load: DailyLoad = score <= 5 ? "light" : score <= 10 ? "balanced" : "heavy"

  return { load, total, peak, spread, busiestWindow, labels, buckets }
}

export function getTaskFlags(todo: Todo, nowMs: number, inProgressTaskId: string | null) {
  const completed = todo.completed
  const dueMs = parseLocalDateTime(todo.dueAt)
  const overdue = !completed && dueMs < nowMs
  const inProgress = !completed && inProgressTaskId === todo.id
  const planned = !completed && !overdue && !inProgress
  return { completed, overdue, inProgress, planned }
}


```

```typescriptreact
"use client"

import * as React from "react"
import {
  CirclePlay,
  CircleStop,
  Download,
  File,
  FileSpreadsheet,
  FileText,
  Image as ImageIcon,
  Info,
  Music,
  Trash2,
  Video,
} from "lucide-react"

import type { AttachmentKind, Todo } from "./types"
import { cn } from "@/lib/utils"
import { formatLocalDateTime, parseLocalDateOnly, parseLocalDateTime } from "./utils"
import { getTaskFlags } from "./utils"

import { Button } from "@/components/ui/button"
import { Checkbox } from "@/components/ui/checkbox"
import { Separator } from "@/components/ui/separator"
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip"
import { Badge } from "@/components/ui/badge"

function AttachmentIcon({ kind }: { kind: AttachmentKind }) {
  const className = "h-4 w-4 text-muted-foreground"
  switch (kind) {
    case "image":
      return <ImageIcon className={className} />
    case "audio":
      return <Music className={className} />
    case "video":
      return <Video className={className} />
    case "spreadsheet":
      return <FileSpreadsheet className={className} />
    case "pdf":
    case "document":
    case "text":
      return <FileText className={className} />
    default:
      return <File className={className} />
  }
}

function TaskBadges({
  completed,
  overdue,
  inProgress,
  planned,
}: {
  completed: boolean
  overdue: boolean
  inProgress: boolean
  planned: boolean
}) {
  if (completed) {
    return (
      <Badge className="gap-1 bg-emerald-600 text-white hover:bg-emerald-600">Completed</Badge>
    )
  }
  return (
    <span className="flex flex-wrap items-center gap-2">
      {inProgress && <Badge className="bg-sky-600 text-white hover:bg-sky-600">In progress</Badge>}
      {overdue && <Badge variant="destructive">Overdue</Badge>}
      {planned && <Badge variant="outline">Planned</Badge>}
    </span>
  )
}

export function TaskList({
  groups,
  nowMs,
  inProgressTaskId,
  conflictDueAt,
  onToggleCompleted,
  onToggleInProgress,
  onDelete,
  onAddFiles,
  onDownloadAttachment,
}: {
  groups: Array<{ date: string; items: Todo[] }>
  nowMs: number
  inProgressTaskId: string | null
  conflictDueAt: string | null
  onToggleCompleted: (id: string, completed: boolean) => void
  onToggleInProgress: (todoId: string, isInProgress: boolean) => void
  onDelete: (id: string) => void
  onAddFiles: (todoId: string) => void
  onDownloadAttachment: (a: Todo["attachments"][number]) => void
}) {
  if (groups.length === 0) {
    return <p className="text-muted-foreground text-sm">No tasks yet.</p>
  }

  return (
    <div className="space-y-2">
      {groups.map((group) => (
        <div key={group.date} className="space-y-2">
          <div className="flex items-center gap-3 pt-2">
            <Separator className="flex-1" />
            <span className="text-muted-foreground whitespace-nowrap text-xs font-medium">
              {new Intl.DateTimeFormat(undefined, {
                weekday: "short",
                year: "numeric",
                month: "short",
                day: "2-digit",
              }).format(parseLocalDateOnly(group.date))}
            </span>
            <Separator className="flex-1" />
          </div>

          {group.items.map((todo) => {
            const flags = getTaskFlags(todo, nowMs, inProgressTaskId)

            return (
              <div
                key={todo.id}
                className={cn(
                  "rounded-lg border px-3 py-2",
                  flags.completed && "opacity-75",
                  flags.overdue && "border-destructive/40 bg-destructive/5 text-muted-foreground",
                  flags.inProgress && "border-sky-500/40 bg-sky-500/10",
                  conflictDueAt &&
                    todo.dueAt === conflictDueAt &&
                    "border-destructive/60 bg-destructive/5 ring-1 ring-destructive/30"
                )}
              >
                <div className="flex items-start justify-between gap-3">
                  <label className="flex cursor-pointer items-start gap-3">
                    <Checkbox
                      checked={todo.completed}
                      onCheckedChange={(v) => onToggleCompleted(todo.id, Boolean(v))}
                      aria-label={`Mark "${todo.title}" as ${
                        todo.completed ? "not completed" : "completed"
                      }`}
                      className="mt-0.5"
                    />
                    <span
                      className={cn(
                        "leading-6",
                        todo.completed && "text-muted-foreground line-through"
                      )}
                    >
                      <span className="flex flex-wrap items-center gap-2">
                        <span className="block">{todo.title}</span>
                        <TaskBadges {...flags} />
                        {todo.description && (
                          <TooltipProvider>
                            <Tooltip>
                              <TooltipTrigger asChild>
                                <button
                                  type="button"
                                  className="text-muted-foreground hover:text-foreground inline-flex h-7 w-7 items-center justify-center rounded-md border bg-background"
                                  aria-label="View description"
                                >
                                  <Info className="h-4 w-4" />
                                </button>
                              </TooltipTrigger>
                              <TooltipContent className="max-w-xs">
                                <p className="whitespace-pre-wrap text-sm">{todo.description}</p>
                              </TooltipContent>
                            </Tooltip>
                          </TooltipProvider>
                        )}
                      </span>
                      <span className="text-muted-foreground block text-xs">
                        Due: {formatLocalDateTime(todo.dueAt)}
                      </span>
                    </span>
                  </label>

                  <div className="flex items-center gap-1">
                    {!todo.completed && (
                      <Button
                        type="button"
                        variant={flags.inProgress ? "default" : "outline"}
                        size="sm"
                        onClick={() => onToggleInProgress(todo.id, flags.inProgress)}
                        className={cn(flags.inProgress && "bg-sky-600 hover:bg-sky-600")}
                      >
                        {flags.inProgress ? (
                          <>
                            <CircleStop className="mr-1 h-4 w-4" />
                            Stop
                          </>
                        ) : (
                          <>
                            <CirclePlay className="mr-1 h-4 w-4" />
                            Start
                          </>
                        )}
                      </Button>
                    )}

                    {todo.completed && (
                      <Button
                        type="button"
                        variant="outline"
                        size="sm"
                        onClick={() => onAddFiles(todo.id)}
                      >
                        Add files
                      </Button>
                    )}

                    <Button
                      type="button"
                      variant="ghost"
                      size="icon"
                      aria-label={`Delete "${todo.title}"`}
                      onClick={() => onDelete(todo.id)}
                    >
                      <Trash2 className="h-4 w-4" />
                    </Button>
                  </div>
                </div>

                {todo.completed && todo.attachments.length > 0 && (
                  <div className="mt-3 space-y-2">
                    <p className="text-muted-foreground text-xs">Attachments</p>
                    <ul className="space-y-1">
                      {todo.attachments.map((a) => (
                        <li
                          key={a.id}
                          className="flex items-center justify-between gap-3 rounded-md bg-muted/30 px-2 py-1"
                        >
                          <div className="flex min-w-0 items-center gap-2">
                            <AttachmentIcon kind={a.kind} />
                            <span className="truncate text-sm">{a.name}</span>
                          </div>
                          <button
                            type="button"
                            onClick={() => onDownloadAttachment(a)}
                            className="inline-flex items-center gap-1 text-sm font-medium underline underline-offset-4"
                          >
                            <Download className="h-4 w-4" />
                            Download
                          </button>
                        </li>
                      ))}
                    </ul>
                  </div>
                )}
              </div>
            )
          })}
        </div>
      ))}
    </div>
  )
}


```

Nice—this refactor will dramatically slim `src/app/page.tsx`: it’ll just render a `TodoPage` component, while the task UI is composed from `AuthCard`, `UserMenu`, `TaskForm`, and `TaskList`, plus a single `TodoApp` container that holds state + API calls. Next I’ll add `src/components/todo/TodoApp.tsx` + `TodoPage.tsx`, then replace `src/app/page.tsx` with a tiny wrapper and run a build.

```typescriptreact
"use client"

import * as React from "react"
import { Bell } from "lucide-react"
import { toast } from "sonner"

import type { DailyLoad, Todo } from "./types"
import { initialTodos } from "./mock-data"
import { TaskForm } from "./TaskForm"
import { TaskList } from "./TaskList"
import { UserMenu } from "./UserMenu"

import { apiFetch, ApiError } from "@/lib/api-client"
import { ModeToggle } from "@/components/mode-toggle"
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert"
import { Badge } from "@/components/ui/badge"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Input } from "@/components/ui/input"
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select"
import { Separator } from "@/components/ui/separator"
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip"

import type { TodoFormValues } from "./schemas"
import {
  addDays,
  endOfDay,
  formatDateTimeFromMs,
  formatLocalDateTime,
  getDailyLoad,
  getDatePart,
  getTimePart,
  localDateKey,
  minutesUntil,
  parseLocalDateOnly,
  parseLocalDateTime,
  parseLocalTimeToMinutes,
  startOfDay,
} from "./utils"

function DailyLoadBadge({ load }: { load: DailyLoad }) {
  if (load === "heavy") return <Badge variant="destructive">Heavy</Badge>
  if (load === "balanced") return <Badge variant="secondary">Balanced</Badge>
  return <Badge variant="outline">Light</Badge>
}

export function TodoApp({ userId, onSignedOut }: { userId: string; onSignedOut: () => void }) {
  const [todos, setTodos] = React.useState<Todo[]>([])
  const [tasksLoading, setTasksLoading] = React.useState(true)
  const [tasksError, setTasksError] = React.useState<{ code?: string; message: string } | null>(
    null
  )

  const [attachTargetTodoId, setAttachTargetTodoId] = React.useState<string | null>(null)
  const fileInputRef = React.useRef<HTMLInputElement>(null)

  const [conflictDueAt, setConflictDueAt] = React.useState<string | null>(null)
  const clearConflictTimerRef = React.useRef<number | null>(null)

  const [focusMode, setFocusMode] = React.useState(false)
  const [nowMs, setNowMs] = React.useState(() => Date.now())
  const [inProgressTaskId, setInProgressTaskId] = React.useState<string | null>(null)

  const [dismissedReminderTaskId, setDismissedReminderTaskId] = React.useState<string | null>(null)

  const [filterMode, setFilterMode] = React.useState<"between" | "exact">("between")
  const [filterFromDate, setFilterFromDate] = React.useState<string>("")
  const [filterFromTime, setFilterFromTime] = React.useState<string>("")
  const [filterToDate, setFilterToDate] = React.useState<string>("")
  const [filterToTime, setFilterToTime] = React.useState<string>("")
  const [filterExactDate, setFilterExactDate] = React.useState<string>("")
  const [filterExactTime, setFilterExactTime] = React.useState<string>("")

  const [pageSize, setPageSize] = React.useState<number>(5)
  const [page, setPage] = React.useState<number>(1)

  React.useEffect(() => {
    const id = window.setInterval(() => setNowMs(Date.now()), 30_000)
    return () => window.clearInterval(id)
  }, [])

  React.useEffect(() => {
    if (!inProgressTaskId) return
    const t = todos.find((x) => x.id === inProgressTaskId)
    if (!t || t.completed) setInProgressTaskId(null)
  }, [inProgressTaskId, todos])

  React.useEffect(() => {
    let alive = true
    async function load() {
      setTasksLoading(true)
      try {
        const data = await apiFetch<{ tasks: Todo[]; inProgressTaskId: string | null }>("/api/tasks")
        if (!alive) return
        setTodos(data.tasks)
        setInProgressTaskId(data.inProgressTaskId)
        setTasksError(null)
      } catch (e) {
        if (!alive) return
        if (e instanceof ApiError) setTasksError({ code: e.code, message: e.message })
        else setTasksError({ message: e instanceof Error ? e.message : "Failed to load tasks." })
        setTodos([])
        setInProgressTaskId(null)
      } finally {
        if (!alive) return
        setTasksLoading(false)
      }
    }
    void load()
    return () => {
      alive = false
    }
  }, [])

  const nextUpcoming = React.useMemo(() => {
    const upcoming = todos
      .filter((t) => !t.completed)
      .map((t) => ({ todo: t, dueMs: parseLocalDateTime(t.dueAt) }))
      .filter((x) => x.dueMs >= nowMs)
      .sort((a, b) => a.dueMs - b.dueMs)[0]
    return upcoming ?? null
  }, [nowMs, todos])

  React.useEffect(() => {
    if (nextUpcoming && nextUpcoming.todo.id !== dismissedReminderTaskId) return
    if (!nextUpcoming) setDismissedReminderTaskId(null)
  }, [dismissedReminderTaskId, nextUpcoming])

  const reminder = React.useMemo(() => {
    const REMINDER_WINDOW_MIN = 15
    if (!nextUpcoming) return null
    if (dismissedReminderTaskId === nextUpcoming.todo.id) return null
    const mins = minutesUntil(nextUpcoming.dueMs, nowMs)
    if (mins < 0 || mins > REMINDER_WINDOW_MIN) return null
    return { ...nextUpcoming, mins }
  }, [dismissedReminderTaskId, nextUpcoming, nowMs])

  const filteredTodos = React.useMemo(() => {
    if (focusMode) {
      const endMs = nowMs + 4 * 60 * 60 * 1000
      return todos.filter((t) => {
        const ms = parseLocalDateTime(t.dueAt)
        return ms >= nowMs && ms <= endMs
      })
    }

    if (filterMode === "exact") {
      if (!filterExactDate && !filterExactTime) return todos
      if (filterExactDate && !filterExactTime) {
        return todos.filter((t) => getDatePart(t.dueAt) === filterExactDate)
      }
      if (filterExactDate && filterExactTime) {
        const exactMs = parseLocalDateTime(`${filterExactDate}T${filterExactTime}`)
        return todos.filter((t) => parseLocalDateTime(t.dueAt) === exactMs)
      }
      return todos.filter((t) => getTimePart(t.dueAt) === filterExactTime)
    }

    const hasAnyDate = Boolean(filterFromDate || filterToDate)
    const hasAnyTime = Boolean(filterFromTime || filterToTime)

    const fromDateMs = filterFromDate
      ? startOfDay(parseLocalDateOnly(filterFromDate)).getTime()
      : Number.NEGATIVE_INFINITY
    const toDateMs = filterToDate
      ? endOfDay(parseLocalDateOnly(filterToDate)).getTime()
      : Number.POSITIVE_INFINITY

    const fromTimeMin = filterFromTime ? parseLocalTimeToMinutes(filterFromTime) : 0
    const toTimeMin = filterToTime ? parseLocalTimeToMinutes(filterToTime) : 24 * 60 - 1

    return todos.filter((t) => {
      const ms = parseLocalDateTime(t.dueAt)
      if (hasAnyDate && (ms < fromDateMs || ms > toDateMs)) return false
      if (hasAnyTime) {
        const time = getTimePart(t.dueAt)
        if (!time) return false
        const mins = parseLocalTimeToMinutes(time)
        if (mins < fromTimeMin || mins > toTimeMin) return false
      }
      return true
    })
  }, [
    todos,
    focusMode,
    nowMs,
    filterMode,
    filterExactDate,
    filterExactTime,
    filterFromDate,
    filterFromTime,
    filterToDate,
    filterToTime,
  ])

  const sortedFilteredTodos = React.useMemo(
    () =>
      filteredTodos
        .slice()
        .sort((a, b) => parseLocalDateTime(a.dueAt) - parseLocalDateTime(b.dueAt)),
    [filteredTodos]
  )

  React.useEffect(() => {
    const totalPages = Math.max(1, Math.ceil(sortedFilteredTodos.length / pageSize))
    setPage((p) => Math.min(Math.max(1, p), totalPages))
  }, [pageSize, sortedFilteredTodos.length])

  const totalItems = sortedFilteredTodos.length
  const totalPages = Math.max(1, Math.ceil(totalItems / pageSize))
  const showPagination = totalPages > 1

  const pageItems = React.useMemo(() => {
    const start = (page - 1) * pageSize
    return sortedFilteredTodos.slice(start, start + pageSize)
  }, [page, pageSize, sortedFilteredTodos])

  const groupedTodos = React.useMemo(() => {
    const groups: Array<{ date: string; items: Todo[] }> = []
    for (const t of pageItems) {
      const date = getDatePart(t.dueAt)
      const last = groups[groups.length - 1]
      if (!last || last.date !== date) groups.push({ date, items: [t] })
      else last.items.push(t)
    }
    return groups
  }, [pageItems])

  const completedCount = filteredTodos.filter((t) => t.completed).length

  async function requestAttachmentsForTodo(todoId: string) {
    setAttachTargetTodoId(todoId)
    queueMicrotask(() => fileInputRef.current?.click())
  }

  async function handleFilesPicked(e: React.ChangeEvent<HTMLInputElement>) {
    const files = Array.from(e.target.files ?? [])
    const targetId = attachTargetTodoId
    e.target.value = ""
    setAttachTargetTodoId(null)
    if (!targetId || files.length === 0) return

    const form = new FormData()
    for (const f of files) form.append("files", f)

    try {
      const res = await fetch(`/api/tasks/${targetId}/attachments`, {
        method: "POST",
        credentials: "include",
        body: form,
      })
      const json = (await res.json().catch(() => null)) as
        | { ok: true; data: { task: Todo } }
        | { ok: false; error: { message: string } }
        | null
      if (!json || !json.ok) throw new Error(json?.error.message ?? "Upload failed.")
      setTodos((prev) => prev.map((t) => (t.id === targetId ? json.data.task : t)))
    } catch (err) {
      toast.error("Upload failed", { description: err instanceof Error ? err.message : "Failed." })
    }
  }

  async function addTodo(values: TodoFormValues) {
    const conflicts = todos.filter((t) => t.dueAt === values.dueAt)
    if (conflicts.length > 0) {
      setConflictDueAt(values.dueAt)
      if (clearConflictTimerRef.current) window.clearTimeout(clearConflictTimerRef.current)
      clearConflictTimerRef.current = window.setTimeout(() => setConflictDueAt(null), 8000)

      const [d, time] = values.dueAt.split("T")
      setFilterMode("exact")
      setFilterExactDate(d ?? "")
      setFilterExactTime(time ?? "")
      setPage(1)

      toast.error("Time conflict", {
        description: `You already have ${conflicts.length} task(s) scheduled at ${formatLocalDateTime(
          values.dueAt
        )}.`,
      })
    }

    const data = await apiFetch<{ task: Todo }>("/api/tasks", {
      method: "POST",
      body: JSON.stringify(values),
    })
    setTodos((prev) => [data.task, ...prev])
  }

  async function toggleTodo(id: string, completed: boolean) {
    const before = todos.find((t) => t.id === id)
    setTodos((prev) => prev.map((t) => (t.id === id ? { ...t, completed } : t)))
    if (completed) setInProgressTaskId((cur) => (cur === id ? null : cur))

    try {
      await apiFetch("/api/tasks/" + id, { method: "PATCH", body: JSON.stringify({ completed }) })
    } catch (e) {
      toast.error("Failed to update task", { description: e instanceof Error ? e.message : "Failed." })
    }

    if (completed && before && !before.completed) {
      await requestAttachmentsForTodo(id)
    }
  }

  async function deleteTodo(id: string) {
    setTodos((prev) => prev.filter((t) => t.id !== id))
    setInProgressTaskId((cur) => (cur === id ? null : cur))
    try {
      await apiFetch("/api/tasks/" + id, { method: "DELETE" })
    } catch (e) {
      toast.error("Failed to delete task", { description: e instanceof Error ? e.message : "Failed." })
    }
  }

  async function clearCompleted() {
    const completedIds = new Set(todos.filter((t) => t.completed).map((t) => t.id))
    if (completedIds.size === 0) return
    setTodos((prev) => prev.filter((t) => !completedIds.has(t.id)))
    try {
      await apiFetch("/api/tasks/clear-completed", { method: "POST" })
    } catch (e) {
      toast.error("Failed to clear completed", { description: e instanceof Error ? e.message : "Failed." })
    }
  }

  async function setInProgress(taskId: string | null) {
    setInProgressTaskId(taskId)
    try {
      const data = await apiFetch<{ inProgressTaskId: string | null }>("/api/tasks/in-progress", {
        method: "POST",
        body: JSON.stringify({ id: taskId }),
      })
      setInProgressTaskId(data.inProgressTaskId)
    } catch (e) {
      toast.error("Failed to update in-progress", { description: e instanceof Error ? e.message : "Failed." })
    }
  }

  async function downloadAttachment(a: Todo["attachments"][number]) {
    const data = await apiFetch<{ signedUrl: string }>("/api/attachments/signed-url", {
      method: "POST",
      body: JSON.stringify({ bucket: a.bucket, path: a.path }),
    })
    window.open(data.signedUrl, "_blank", "noopener,noreferrer")
  }

  async function seedDemoTasks() {
    if (todos.length > 0) return
    const data = await apiFetch<{ tasks: Todo[] }>("/api/tasks/seed", {
      method: "POST",
      body: JSON.stringify({ tasks: initialTodos }),
    })
    setTodos(data.tasks)
  }

  const loadDayKey = React.useMemo(() => {
    if (filterMode === "exact" && filterExactDate) return filterExactDate
    if (filterFromDate && !filterToDate) return filterFromDate
    if (filterFromDate && filterToDate && filterFromDate === filterToDate) return filterFromDate
    if (!filterFromDate && filterToDate) return filterToDate
    return localDateKey(new Date(nowMs))
  }, [filterExactDate, filterFromDate, filterMode, filterToDate, nowMs])

  const dailyLoad = React.useMemo(() => {
    const dayTodos = todos.filter((t) => getDatePart(t.dueAt) === loadDayKey)
    return getDailyLoad(dayTodos)
  }, [loadDayKey, todos])

  const summary = React.useMemo(() => {
    const now = new Date(nowMs)
    const todayKey = localDateKey(now)
    const tomorrow = addDays(now, 1)
    const tomorrowKey = localDateKey(tomorrow)
    const labels = dailyLoad.labels

    const todays = todos.filter((t) => t.dueAt.startsWith(todayKey))
    const todayCompleted = todays.filter((t) => t.completed).length
    const todayPending = todays.length - todayCompleted

    const tomorrowTasks = todos.filter((t) => t.dueAt.startsWith(tomorrowKey))
    const tomorrowBuckets = Array.from({ length: 6 }, () => 0) as number[]
    for (const t of tomorrowTasks) {
      const hour = new Date(parseLocalDateTime(t.dueAt)).getHours()
      tomorrowBuckets[Math.floor(hour / 4)]++
    }

    const rangeStart = startOfDay(tomorrow).getTime()
    const rangeEnd = addDays(startOfDay(tomorrow), 7).getTime()
    const buckets = Array.from({ length: 6 }, () => 0) as number[]
    const upcoming = todos.filter((t) => {
      const ms = parseLocalDateTime(t.dueAt)
      return ms >= rangeStart && ms < rangeEnd
    })
    for (const t of upcoming) {
      const hour = new Date(parseLocalDateTime(t.dueAt)).getHours()
      buckets[Math.floor(hour / 4)]++
    }

    return {
      todayCompleted,
      todayPending,
      tomorrowTotal: tomorrowTasks.length,
      tomorrowBuckets: labels.map((label, i) => ({ label, count: tomorrowBuckets[i] ?? 0 })),
      upcomingTotal: upcoming.length,
      upcomingBuckets: labels.map((label, i) => ({ label, count: buckets[i] ?? 0 })),
    }
  }, [dailyLoad.labels, nowMs, todos])

  return (
    <Card>
      <CardHeader className="flex flex-row items-center justify-between gap-4">
        <div className="space-y-1">
          <CardTitle className="text-2xl">To‑Do</CardTitle>
          <p className="text-muted-foreground text-sm">
            {completedCount}/{filteredTodos.length} completed
          </p>
        </div>

        <div className="flex items-center gap-2">
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <Button
                  type="button"
                  variant={focusMode ? "default" : "outline"}
                  size="sm"
                  onClick={() => {
                    setFocusMode((v) => !v)
                    setPage(1)
                  }}
                >
                  Focus Mode
                </Button>
              </TooltipTrigger>
              <TooltipContent>
                <p>Show tasks for the next 4 hours.</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>

          <UserMenu userId={userId} onSignedOut={onSignedOut} />
          <ModeToggle />
        </div>
      </CardHeader>

      <CardContent className="space-y-6">
        {tasksLoading && <p className="text-muted-foreground text-sm">Loading tasks…</p>}

        {!tasksLoading && tasksError?.code === "MISSING_TABLE" && (
          <Alert variant="destructive">
            <AlertTitle>Database not initialized</AlertTitle>
            <AlertDescription>
              <div className="space-y-2">
                <p>
                  The Supabase table <code>public.tasks</code> was not found. Run the SQL in{" "}
                  <code>supabase/schema.sql</code> (Supabase Dashboard → SQL Editor), then refresh.
                </p>
                <p className="text-xs opacity-90">{tasksError.message}</p>
              </div>
            </AlertDescription>
          </Alert>
        )}

        {!tasksLoading && tasksError && tasksError.code !== "MISSING_TABLE" && (
          <Alert variant="destructive">
            <AlertTitle>Failed to load tasks</AlertTitle>
            <AlertDescription>{tasksError.message}</AlertDescription>
          </Alert>
        )}

        {!tasksLoading && todos.length === 0 && (
          <div className="flex items-center justify-between gap-3 rounded-lg border bg-muted/20 px-3 py-2">
            <p className="text-muted-foreground text-sm">No tasks yet.</p>
            <Button type="button" variant="outline" size="sm" onClick={() => void seedDemoTasks()}>
              Seed demo tasks
            </Button>
          </div>
        )}

        <input
          ref={fileInputRef}
          type="file"
          multiple
          className="hidden"
          accept={[
            "image/*",
            "audio/*",
            "video/*",
            ".pdf",
            ".doc",
            ".docx",
            ".xls",
            ".xlsx",
            ".csv",
            ".txt",
            ".md",
            ".rtf",
          ].join(",")}
          onChange={handleFilesPicked}
        />

        {reminder && (
          <Alert className="border-primary/30 bg-primary/5">
            <Bell className="h-4 w-4" />
            <div className="flex flex-1 flex-col gap-1">
              <div className="flex flex-wrap items-center justify-between gap-2">
                <AlertTitle className="text-sm">
                  Next task starts in {reminder.mins} minute{reminder.mins === 1 ? "" : "s"}
                </AlertTitle>
                <Button
                  type="button"
                  variant="ghost"
                  size="sm"
                  onClick={() => setDismissedReminderTaskId(reminder.todo.id)}
                >
                  Dismiss
                </Button>
              </div>
              <AlertDescription className="text-sm">
                <span className="font-medium">{reminder.todo.title}</span> ·{" "}
                {formatDateTimeFromMs(reminder.dueMs)}
              </AlertDescription>
            </div>
          </Alert>
        )}

        <div className="rounded-xl border bg-card p-4">
          <div className="flex flex-wrap items-center justify-between gap-2">
            <p className="text-sm font-medium">
              Daily load{" "}
              <span className="text-muted-foreground font-normal">
                ({new Intl.DateTimeFormat(undefined, {
                  weekday: "short",
                  year: "numeric",
                  month: "short",
                  day: "2-digit",
                }).format(parseLocalDateOnly(loadDayKey))})
              </span>
            </p>
            <DailyLoadBadge load={dailyLoad.load} />
          </div>
          <p className="text-muted-foreground mt-2 text-sm">
            {dailyLoad.total} task(s) · busiest window {dailyLoad.busiestWindow} ({dailyLoad.peak})
          </p>
        </div>

        <div className="grid gap-3 sm:grid-cols-3">
          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Today’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">{summary.todayCompleted} completed</p>
            <p className="text-muted-foreground text-sm">{summary.todayPending} pending</p>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tomorrow’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">{summary.tomorrowTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.tomorrowBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tasks Until Next Week</p>
            <p className="mt-2 text-2xl font-semibold">{summary.upcomingTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.upcomingBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>
        </div>

        {focusMode && (
          <div className="flex flex-col gap-1 rounded-lg border bg-muted/20 px-3 py-2 sm:flex-row sm:items-center sm:justify-between">
            <p className="text-sm">
              <span className="font-medium">Focus Mode:</span> showing tasks due in the next 4 hours
              (until <span className="font-medium">{formatDateTimeFromMs(nowMs + 4 * 60 * 60 * 1000)}</span>)
            </p>
            <Button type="button" variant="ghost" size="sm" onClick={() => setFocusMode(false)}>
              Exit
            </Button>
          </div>
        )}

        <TaskForm onAdd={addTodo} />

        <Separator />

        <div className="space-y-3">
          <div className="flex flex-wrap items-center justify-between gap-2">
            <p className="text-sm font-medium">Filter by date & time</p>
            <div className="flex items-center gap-2">
              <Button
                type="button"
                size="sm"
                variant={filterMode === "between" ? "default" : "outline"}
                onClick={() => setFilterMode("between")}
              >
                Between
              </Button>
              <Button
                type="button"
                size="sm"
                variant={filterMode === "exact" ? "default" : "outline"}
                onClick={() => setFilterMode("exact")}
              >
                Exact
              </Button>
              <Button
                type="button"
                size="sm"
                variant="ghost"
                onClick={() => {
                  setFilterFromDate("")
                  setFilterFromTime("")
                  setFilterToDate("")
                  setFilterToTime("")
                  setFilterExactDate("")
                  setFilterExactTime("")
                }}
              >
                Clear
              </Button>
            </div>
          </div>

          {filterMode === "between" ? (
            <div className="grid gap-2 sm:grid-cols-2">
              <div className="grid gap-2 sm:grid-cols-2">
                <Input type="date" value={filterFromDate} onChange={(e) => setFilterFromDate(e.target.value)} />
                <Input type="time" value={filterFromTime} onChange={(e) => setFilterFromTime(e.target.value)} />
              </div>
              <div className="grid gap-2 sm:grid-cols-2">
                <Input type="date" value={filterToDate} onChange={(e) => setFilterToDate(e.target.value)} />
                <Input type="time" value={filterToTime} onChange={(e) => setFilterToTime(e.target.value)} />
              </div>
            </div>
          ) : (
            <div className="grid gap-2 sm:grid-cols-2">
              <Input type="date" value={filterExactDate} onChange={(e) => setFilterExactDate(e.target.value)} />
              <Input type="time" value={filterExactTime} onChange={(e) => setFilterExactTime(e.target.value)} />
            </div>
          )}
        </div>

        <Separator />

        <TaskList
          groups={groupedTodos}
          nowMs={nowMs}
          inProgressTaskId={inProgressTaskId}
          conflictDueAt={conflictDueAt}
          onToggleCompleted={(id, completed) => void toggleTodo(id, completed)}
          onToggleInProgress={(id, isInProgress) => void setInProgress(isInProgress ? null : id)}
          onDelete={(id) => void deleteTodo(id)}
          onAddFiles={(id) => void requestAttachmentsForTodo(id)}
          onDownloadAttachment={(a) => void downloadAttachment(a)}
        />

        <div className="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
          <div className="flex items-center gap-2">
            <span className="text-muted-foreground text-sm">Items per page</span>
            <Select
              value={String(pageSize)}
              onValueChange={(v) => {
                const next = Number(v)
                setPageSize(next)
                setPage(1)
              }}
            >
              <SelectTrigger className="w-[110px]">
                <SelectValue />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="5">5</SelectItem>
                <SelectItem value="10">10</SelectItem>
                <SelectItem value="15">15</SelectItem>
                <SelectItem value="20">20</SelectItem>
              </SelectContent>
            </Select>
          </div>

          {showPagination && (
            <div className="flex items-center justify-between gap-3 sm:justify-end">
              <Button
                type="button"
                variant="outline"
                size="sm"
                onClick={() => setPage((p) => Math.max(1, p - 1))}
                disabled={page <= 1}
              >
                Prev
              </Button>
              <span className="text-muted-foreground text-sm">
                Page {page} of {totalPages}
              </span>
              <Button
                type="button"
                variant="outline"
                size="sm"
                onClick={() => setPage((p) => Math.min(totalPages, p + 1))}
                disabled={page >= totalPages}
              >
                Next
              </Button>
            </div>
          )}
        </div>

        <div className="flex items-center justify-between gap-2">
          <Button
            type="button"
            variant="secondary"
            onClick={() => void clearCompleted()}
            disabled={completedCount === 0}
          >
            Clear completed
          </Button>
          <span className="text-muted-foreground text-sm">Supabase-backed</span>
        </div>
      </CardContent>
    </Card>
  )
}


```

```typescriptreact
"use client"

import * as React from "react"

import { apiFetch } from "@/lib/api-client"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"

import { AuthCard } from "./AuthCard"
import { TodoApp } from "./TodoApp"

export function TodoPage() {
  const [user, setUser] = React.useState<{ id: string; email?: string } | null>(null)
  const [authLoading, setAuthLoading] = React.useState(true)
  const [authError, setAuthError] = React.useState<string | null>(null)

  const refreshAuth = React.useCallback(async () => {
    setAuthLoading(true)
    try {
      const data = await apiFetch<{ user: { id: string; email?: string } | null }>("/api/auth/me")
      setUser(data.user)
      setAuthError(null)
    } catch (e) {
      setUser(null)
      setAuthError(e instanceof Error ? e.message : "Auth check failed.")
    } finally {
      setAuthLoading(false)
    }
  }, [])

  React.useEffect(() => {
    void refreshAuth()
  }, [refreshAuth])

  if (authLoading) {
    return (
      <div className="mx-auto flex min-h-screen max-w-2xl flex-col justify-center px-4 py-10">
        <p className="text-muted-foreground text-sm">Loading…</p>
      </div>
    )
  }

  if (authError) {
    return (
      <div className="mx-auto flex min-h-screen max-w-2xl flex-col justify-center gap-4 px-4 py-10">
        <Card>
          <CardHeader>
            <CardTitle>Auth unavailable</CardTitle>
          </CardHeader>
          <CardContent className="space-y-2">
            <p className="text-muted-foreground text-sm">{authError}</p>
            <p className="text-muted-foreground text-sm">
              Check <code>SUPABASE_SETUP.md</code> and set env vars from{" "}
              <code>supabase.env.example</code>.
            </p>
            <Button type="button" variant="outline" onClick={() => void refreshAuth()}>
              Retry
            </Button>
          </CardContent>
        </Card>
      </div>
    )
  }

  if (!user) return <AuthCard onAuthed={() => void refreshAuth()} />

  return (
    <div className="mx-auto flex min-h-screen max-w-2xl flex-col gap-6 px-4 py-10">
      <TodoApp userId={user.id} onSignedOut={() => void refreshAuth()} />
    </div>
  )
}


```

```typescriptreact
import { TodoPage } from "@/components/todo/TodoPage"

function parseLocalDateTime(value: string): number {
  // value: "YYYY-MM-DDTHH:mm"
  const [datePart, timePart] = value.split("T")
  const [y, m, d] = datePart.split("-").map(Number)
  const [hh, mm] = timePart.split(":").map(Number)
  return new Date(y, m - 1, d, hh, mm, 0, 0).getTime()
}

function pad2(n: number) {
  return String(n).padStart(2, "0")
}

function localDateKey(d: Date) {
  return `${d.getFullYear()}-${pad2(d.getMonth() + 1)}-${pad2(d.getDate())}`
}

function addDays(date: Date, days: number) {
  const d = new Date(date)
  d.setDate(d.getDate() + days)
  return d
}

function startOfDay(date: Date) {
  return new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0, 0)
}

function endOfDay(date: Date) {
  return new Date(
    date.getFullYear(),
    date.getMonth(),
    date.getDate(),
    23,
    59,
    59,
    999
  )
}

function getDatePart(dueAt: string) {
  return dueAt.split("T")[0] ?? ""
}

function getTimePart(dueAt: string) {
  return dueAt.split("T")[1] ?? ""
}

function parseLocalDateOnly(value: string): Date {
  // value: "YYYY-MM-DD"
  const [y, m, d] = value.split("-").map(Number)
  return new Date(y, m - 1, d, 0, 0, 0, 0)
}

function parseLocalTimeToMinutes(value: string): number {
  // value: "HH:mm"
  const [hh, mm] = value.split(":").map(Number)
  return hh * 60 + mm
}

function formatLocalDateTime(value: string): string {
  const ms = parseLocalDateTime(value)
  if (!Number.isFinite(ms)) return value
  return new Intl.DateTimeFormat(undefined, {
    year: "numeric",
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  }).format(new Date(ms))
}

function formatDateTimeFromMs(ms: number): string {
  return new Intl.DateTimeFormat(undefined, {
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  }).format(new Date(ms))
}

function minutesUntil(targetMs: number, nowMs: number) {
  return Math.ceil((targetMs - nowMs) / 60_000)
}

function getTaskFlags(todo: Todo, nowMs: number, inProgressTaskId: string | null) {
  const completed = todo.completed
  const dueMs = parseLocalDateTime(todo.dueAt)
  const overdue = !completed && dueMs < nowMs
  const inProgress = !completed && inProgressTaskId === todo.id
  const planned = !completed && !overdue && !inProgress
  return { completed, overdue, inProgress, planned }
}

function getDailyLoad(todosForDay: Todo[]) {
  // 4-hour windows across the day (local).
  const labels = [
    "00:00–04:00",
    "04:00–08:00",
    "08:00–12:00",
    "12:00–16:00",
    "16:00–20:00",
    "20:00–24:00",
  ]
  const buckets = Array.from({ length: 6 }, () => 0) as number[]
  for (const t of todosForDay) {
    const ms = parseLocalDateTime(t.dueAt)
    const hour = new Date(ms).getHours()
    const idx = Math.floor(hour / 4)
    buckets[idx] = (buckets[idx] ?? 0) + 1
  }

  const total = todosForDay.length
  const peak = Math.max(0, ...buckets)
  const spread = buckets.filter((c) => c > 0).length
  const busiestIdx = buckets.findIndex((c) => c === peak)
  const busiestWindow = busiestIdx >= 0 ? labels[busiestIdx] : labels[0]

  // Heuristic: more tasks + higher concentration in one window => heavier day.
  const score = total + peak * 1.5 + Math.max(0, spread - 1) * 0.5
  const load: DailyLoad = score <= 5 ? "light" : score <= 10 ? "balanced" : "heavy"

  return { load, total, peak, spread, busiestWindow }
}

function DailyLoadBadge({ load }: { load: DailyLoad }) {
  if (load === "heavy") return <Badge variant="destructive">Heavy</Badge>
  if (load === "balanced") return <Badge variant="secondary">Balanced</Badge>
  return <Badge variant="outline">Light</Badge>
}

function TaskBadges({
  completed,
  overdue,
  inProgress,
  planned,
}: {
  completed: boolean
  overdue: boolean
  inProgress: boolean
  planned: boolean
}) {
  if (completed) {
    return (
      <Badge className="gap-1 bg-emerald-600 text-white hover:bg-emerald-600">
        <CheckCircle2 className="h-3.5 w-3.5" />
        Completed
      </Badge>
    )
  }

  return (
    <>
      {inProgress && (
        <Badge className="gap-1 bg-sky-600 text-white hover:bg-sky-600">
          <Timer className="h-3.5 w-3.5 text-white" />
          In progress
        </Badge>
      )}
      {overdue && (
        <Badge variant="destructive" className="gap-1">
          <AlertTriangle className="h-3.5 w-3.5" />
          Overdue
        </Badge>
      )}
      {planned && (
        <Badge variant="outline" className="gap-1">
          <CalendarClock className="h-3.5 w-3.5" />
          Planned
        </Badge>
      )}
    </>
  )
}

function AttachmentIcon({ kind }: { kind: AttachmentKind }) {
  const className = "h-4 w-4 text-muted-foreground"

  switch (kind) {
    case "image":
      return <ImageIcon className={className} />
    case "audio":
      return <Music className={className} />
    case "video":
      return <Video className={className} />
    case "spreadsheet":
      return <FileSpreadsheet className={className} />
    case "pdf":
    case "document":
    case "text":
      return <FileText className={className} />
    default:
      return <File className={className} />
  }
}

const authSchema = z.object({
  email: z.string().email("Enter a valid email."),
  password: z.string().min(6, "Password must be at least 6 characters."),
})
type AuthValues = z.infer<typeof authSchema>

function AuthCard({ onAuthed }: { onAuthed: () => void }) {
  const [mode, setMode] = React.useState<"sign_in" | "sign_up">("sign_in")
  const [busy, setBusy] = React.useState(false)

  const form = useForm<AuthValues>({
    resolver: zodResolver(authSchema),
    defaultValues: { email: "", password: "" },
  })

  async function onSubmit(values: AuthValues) {
    setBusy(true)
    try {
      if (mode === "sign_in") {
        await apiFetch("/api/auth/sign-in", {
          method: "POST",
          body: JSON.stringify(values),
        })
        onAuthed()
      } else {
        await apiFetch("/api/auth/sign-up", {
          method: "POST",
          body: JSON.stringify(values),
        })
        toast.success("Account created", {
          description: "You can now sign in (or confirm email if required).",
        })
        setMode("sign_in")
      }
    } catch (e) {
      toast.error("Authentication failed", {
        description: e instanceof Error ? e.message : "Please try again.",
      })
    } finally {
      setBusy(false)
    }
  }

  return (
    <div className="mx-auto flex min-h-screen max-w-md flex-col justify-center px-4 py-10">
      <Card>
        <CardHeader>
          <CardTitle className="text-2xl">Sign in</CardTitle>
          <p className="text-muted-foreground text-sm">
            {mode === "sign_in"
              ? "Use your email and password."
              : "Create an account with email and password."}
          </p>
        </CardHeader>
        <CardContent className="space-y-4">
          <Form {...form}>
            <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-3" noValidate>
              <FormField
                control={form.control}
                name="email"
                render={({ field }) => (
                  <FormItem>
                    <FormControl>
                      <Input placeholder="Email" autoComplete="email" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="password"
                render={({ field }) => (
                  <FormItem>
                    <FormControl>
                      <Input
                        type="password"
                        placeholder="Password"
                        autoComplete={
                          mode === "sign_in" ? "current-password" : "new-password"
                        }
                        {...field}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <Button type="submit" className="w-full" disabled={busy}>
                {mode === "sign_in" ? "Sign in" : "Sign up"}
              </Button>
            </form>
          </Form>

          <div className="flex items-center justify-between gap-3 text-sm">
            <span className="text-muted-foreground">
              {mode === "sign_in" ? "No account?" : "Already have an account?"}
            </span>
            <Button
              type="button"
              variant="link"
              className="px-0"
              onClick={() => setMode((m) => (m === "sign_in" ? "sign_up" : "sign_in"))}
            >
              {mode === "sign_in" ? "Sign up" : "Sign in"}
            </Button>
          </div>
        </CardContent>
      </Card>
    </div>
  )
}

export default function Home() {
  return <TodoPage />
}

function TodoApp({ userId, onSignedOut }: { userId: string; onSignedOut: () => void }) {
  const [todos, setTodos] = React.useState<Todo[]>([])
  const [tasksLoading, setTasksLoading] = React.useState(true)
  const [tasksError, setTasksError] = React.useState<{ code?: string; message: string } | null>(
    null
  )
  const [attachTargetTodoId, setAttachTargetTodoId] = React.useState<string | null>(
    null
  )
  const [conflictDueAt, setConflictDueAt] = React.useState<string | null>(null)
  const clearConflictTimerRef = React.useRef<number | null>(null)
  const [focusMode, setFocusMode] = React.useState(false)
  const [nowMs, setNowMs] = React.useState(() => Date.now())
  const [inProgressTaskId, setInProgressTaskId] = React.useState<string | null>(null)
  const [dismissedReminderTaskId, setDismissedReminderTaskId] = React.useState<
    string | null
  >(null)
  const [filterMode, setFilterMode] = React.useState<"between" | "exact">("between")
  const [filterFromDate, setFilterFromDate] = React.useState<string>("")
  const [filterFromTime, setFilterFromTime] = React.useState<string>("")
  const [filterToDate, setFilterToDate] = React.useState<string>("")
  const [filterToTime, setFilterToTime] = React.useState<string>("")
  const [filterExactDate, setFilterExactDate] = React.useState<string>("")
  const [filterExactTime, setFilterExactTime] = React.useState<string>("")
  const fileInputRef = React.useRef<HTMLInputElement>(null)
  const [pageSize, setPageSize] = React.useState<number>(5)
  const [page, setPage] = React.useState<number>(1)

  React.useEffect(() => {
    let alive = true
    async function load() {
      setTasksLoading(true)
      if (!alive) return
      try {
        const data = await apiFetch<{ tasks: Todo[]; inProgressTaskId: string | null }>("/api/tasks")
        if (!alive) return
        setTodos(data.tasks)
        setInProgressTaskId(data.inProgressTaskId)
        setTasksError(null)
      } catch (e) {
        if (!alive) return
        if (e instanceof ApiError) setTasksError({ code: e.code, message: e.message })
        else setTasksError({ message: e instanceof Error ? e.message : "Failed to load tasks." })
        setTodos([])
        setInProgressTaskId(null)
      } finally {
        setTasksLoading(false)
      }
    }
    load()
    return () => {
      alive = false
    }
  }, [userId])

  // Keep "now" fresh so overdue/in-progress states stay accurate without user interaction.
  React.useEffect(() => {
    const id = window.setInterval(() => setNowMs(Date.now()), 30_000)
    return () => window.clearInterval(id)
  }, [])

  // Only one task can be "In Progress"; auto-clear if completed, deleted, or overdue.
  React.useEffect(() => {
    if (!inProgressTaskId) return
    const t = todos.find((x) => x.id === inProgressTaskId)
    if (!t || t.completed) {
      setInProgressTaskId(null)
      return
    }
  }, [inProgressTaskId, nowMs, todos])

  const nextUpcoming = React.useMemo(() => {
    const upcoming = todos
      .filter((t) => !t.completed)
      .map((t) => ({ todo: t, dueMs: parseLocalDateTime(t.dueAt) }))
      .filter((x) => x.dueMs >= nowMs)
      .sort((a, b) => a.dueMs - b.dueMs)[0]
    return upcoming ?? null
  }, [nowMs, todos])

  React.useEffect(() => {
    // If "next upcoming" changed, allow reminder again (dismiss is per-task).
    if (nextUpcoming && nextUpcoming.todo.id !== dismissedReminderTaskId) return
    if (!nextUpcoming) setDismissedReminderTaskId(null)
  }, [dismissedReminderTaskId, nextUpcoming])

  const reminder = React.useMemo(() => {
    const REMINDER_WINDOW_MIN = 15
    if (!nextUpcoming) return null
    if (dismissedReminderTaskId === nextUpcoming.todo.id) return null
    const mins = minutesUntil(nextUpcoming.dueMs, nowMs)
    if (mins < 0 || mins > REMINDER_WINDOW_MIN) return null
    return { ...nextUpcoming, mins }
  }, [dismissedReminderTaskId, nextUpcoming, nowMs])

  const form = useForm<TodoFormValues>({
    resolver: zodResolver(todoSchema),
    defaultValues: { title: "", description: "", dueAt: "" },
    mode: "onSubmit",
  })

  const summary = React.useMemo(() => {
    const now = new Date()
    const todayKey = localDateKey(now)
    const tomorrow = addDays(now, 1)
    const tomorrowKey = localDateKey(tomorrow)

    const todays = todos.filter((t) => t.dueAt.startsWith(todayKey))
    const todayCompleted = todays.filter((t) => t.completed).length
    const todayPending = todays.length - todayCompleted

    const labels = [
      "00:00–04:00",
      "04:00–08:00",
      "08:00–12:00",
      "12:00–16:00",
      "16:00–20:00",
      "20:00–24:00",
    ]

    // Tomorrow: same 4-hour windows breakdown
    const tomorrowTasks = todos.filter((t) => t.dueAt.startsWith(tomorrowKey))
    const tomorrowBuckets = Array.from({ length: 6 }, () => 0) as number[]
    for (const t of tomorrowTasks) {
      const ms = parseLocalDateTime(t.dueAt)
      const hour = new Date(ms).getHours()
      const idx = Math.floor(hour / 4)
      tomorrowBuckets[idx] = (tomorrowBuckets[idx] ?? 0) + 1
    }

    // Until next week = next 7 days starting tomorrow (local), grouped into 4-hour windows.
    const rangeStart = startOfDay(tomorrow).getTime()
    const rangeEnd = addDays(startOfDay(tomorrow), 7).getTime()
    const buckets = Array.from({ length: 6 }, () => 0) as number[]

    const upcoming = todos.filter((t) => {
      const ms = parseLocalDateTime(t.dueAt)
      return ms >= rangeStart && ms < rangeEnd
    })

    for (const t of upcoming) {
      const ms = parseLocalDateTime(t.dueAt)
      const hour = new Date(ms).getHours()
      const idx = Math.floor(hour / 4)
      buckets[idx] = (buckets[idx] ?? 0) + 1
    }

    return {
      todayCompleted,
      todayPending,
      tomorrowTotal: tomorrowTasks.length,
      tomorrowBuckets: labels.map((label, i) => ({ label, count: tomorrowBuckets[i] ?? 0 })),
      upcomingTotal: upcoming.length,
      upcomingBuckets: labels.map((label, i) => ({ label, count: buckets[i] ?? 0 })),
    }
  }, [todos])

  const loadDayKey = React.useMemo(() => {
    // Prefer an explicitly selected date from filters; otherwise use today.
    if (filterMode === "exact" && filterExactDate) return filterExactDate
    if (filterFromDate && !filterToDate) return filterFromDate
    if (filterFromDate && filterToDate && filterFromDate === filterToDate) return filterFromDate
    if (!filterFromDate && filterToDate) return filterToDate
    return localDateKey(new Date(nowMs))
  }, [filterExactDate, filterFromDate, filterMode, filterToDate, nowMs])

  const dailyLoad = React.useMemo(() => {
    const dayTodos = todos.filter((t) => getDatePart(t.dueAt) === loadDayKey)
    return getDailyLoad(dayTodos)
  }, [loadDayKey, todos])

  const filteredTodos = React.useMemo(() => {
    if (focusMode) {
      const endMs = nowMs + 4 * 60 * 60 * 1000
      const withMs = todos.map((t) => ({ ...t, _dueMs: parseLocalDateTime(t.dueAt) }))
      return withMs.filter((t) => t._dueMs >= nowMs && t._dueMs <= endMs)
    }

    const withMs = todos.map((t) => ({ ...t, _dueMs: parseLocalDateTime(t.dueAt) }))
    if (filterMode === "exact") {
      // If only date is selected -> show tasks for that date.
      // If time is selected too -> match exact date+time.
      // If only time is selected -> match time-of-day across all dates.
      if (!filterExactDate && !filterExactTime) return withMs

      if (filterExactDate && !filterExactTime) {
        return withMs.filter((t) => getDatePart(t.dueAt) === filterExactDate)
      }

      if (filterExactDate && filterExactTime) {
        const exactMs = parseLocalDateTime(`${filterExactDate}T${filterExactTime}`)
        return withMs.filter((t) => t._dueMs === exactMs)
      }

      // time only
      return withMs.filter((t) => getTimePart(t.dueAt) === filterExactTime)
    }
    // between
    const hasAnyDate = Boolean(filterFromDate || filterToDate)
    const hasAnyTime = Boolean(filterFromTime || filterToTime)

    // Date range (optional)
    const fromDateMs = filterFromDate
      ? startOfDay(parseLocalDateOnly(filterFromDate)).getTime()
      : Number.NEGATIVE_INFINITY
    const toDateMs = filterToDate
      ? endOfDay(parseLocalDateOnly(filterToDate)).getTime()
      : Number.POSITIVE_INFINITY

    // Time-of-day range (optional)
    const fromTimeMin = filterFromTime ? parseLocalTimeToMinutes(filterFromTime) : 0
    const toTimeMin = filterToTime ? parseLocalTimeToMinutes(filterToTime) : 24 * 60 - 1

    return withMs.filter((t) => {
      const ms = t._dueMs
      if (hasAnyDate && (ms < fromDateMs || ms > toDateMs)) return false

      if (hasAnyTime) {
        const time = getTimePart(t.dueAt)
        if (!time) return false
        const mins = parseLocalTimeToMinutes(time)
        // Simple (non-wrapping) range. If you want wrap-around (e.g. 22:00–02:00), tell me.
        if (mins < fromTimeMin || mins > toTimeMin) return false
      }

      // If neither date nor time selected, pass through (handled above anyway)
      return true
    })
  }, [
    todos,
    focusMode,
    nowMs,
    filterExactDate,
    filterExactTime,
    filterFromDate,
    filterFromTime,
    filterMode,
    filterToDate,
    filterToTime,
  ])

  const sortedFilteredTodos = React.useMemo(
    () =>
      filteredTodos
        .slice()
        .sort((a, b) => parseLocalDateTime(a.dueAt) - parseLocalDateTime(b.dueAt)),
    [filteredTodos]
  )

  // Clamp page when filters/pageSize change.
  React.useEffect(() => {
    const totalPages = Math.max(1, Math.ceil(sortedFilteredTodos.length / pageSize))
    setPage((p) => Math.min(Math.max(1, p), totalPages))
  }, [pageSize, sortedFilteredTodos.length])

  const totalItems = sortedFilteredTodos.length
  const totalPages = Math.max(1, Math.ceil(totalItems / pageSize))
  const showPagination = totalPages > 1

  const pageItems = React.useMemo(() => {
    const start = (page - 1) * pageSize
    return sortedFilteredTodos.slice(start, start + pageSize)
  }, [page, pageSize, sortedFilteredTodos])

  const groupedTodos = React.useMemo(() => {
    const groups: Array<{ date: string; items: typeof pageItems }> = []
    for (const t of pageItems) {
      const date = getDatePart(t.dueAt)
      const last = groups[groups.length - 1]
      if (!last || last.date !== date) groups.push({ date, items: [t] })
      else last.items.push(t)
    }
    return groups
  }, [pageItems])

  const completedCount = filteredTodos.filter((t) => t.completed).length

  async function addTodo(values: TodoFormValues) {
    const conflicts = todos.filter((t) => t.dueAt === values.dueAt)
    if (conflicts.length > 0) {
      setConflictDueAt(values.dueAt)
      if (clearConflictTimerRef.current) window.clearTimeout(clearConflictTimerRef.current)
      clearConflictTimerRef.current = window.setTimeout(() => {
        setConflictDueAt(null)
      }, 8000)

      // Make sure the user can see the conflicting tasks even if they were filtered out.
      const [d, time] = values.dueAt.split("T")
      setFilterMode("exact")
      setFilterExactDate(d ?? "")
      setFilterExactTime(time ?? "")
      setPage(1)

      toast.error("Time conflict", {
        description: `You already have ${conflicts.length} task(s) scheduled at ${formatLocalDateTime(
          values.dueAt
        )}.`,
      })
    }

    try {
      const data = await apiFetch<{ task: Todo }>("/api/tasks", {
        method: "POST",
        body: JSON.stringify(values),
      })
      setTodos((prev) => [data.task, ...prev])
    } catch (e) {
      toast.error("Failed to add task", { description: e instanceof Error ? e.message : "Failed." })
      return
    }
    form.reset()
  }

  async function toggleTodo(id: string, completed: boolean) {
    // optimistic
    setTodos((prev) =>
      prev.map((t) =>
        t.id === id ? { ...t, completed, attachments: t.attachments } : t
      )
    )
    if (completed) setInProgressTaskId((cur) => (cur === id ? null : cur))

    const update: { completed: boolean; in_progress?: boolean } = { completed }
    if (completed) update.in_progress = false

    try {
      await apiFetch("/api/tasks/" + id, {
        method: "PATCH",
        body: JSON.stringify({ completed }),
      })
    } catch (e) {
      toast.error("Failed to update task", { description: e instanceof Error ? e.message : "Failed." })
    }
  }

  function requestAttachmentsForTodo(todoId: string) {
    setAttachTargetTodoId(todoId)
    // Let state update before opening picker (some browsers are picky).
    queueMicrotask(() => fileInputRef.current?.click())
  }

  async function handleFilesPicked(e: React.ChangeEvent<HTMLInputElement>) {
    const files = Array.from(e.target.files ?? [])
    const targetId = attachTargetTodoId

    // reset input so picking the same file again triggers onChange
    e.target.value = ""
    setAttachTargetTodoId(null)

    if (!targetId || files.length === 0) return
    const form = new FormData()
    for (const f of files) form.append("files", f)
    try {
      const res = await fetch(`/api/tasks/${targetId}/attachments`, {
        method: "POST",
        credentials: "include",
        body: form,
      })
      const json = (await res.json().catch(() => null)) as
        | { ok: true; data: { task: Todo } }
        | { ok: false; error: { message: string } }
        | null
      if (!json || !json.ok) throw new Error(json?.error.message ?? "Upload failed.")
      setTodos((prev) => prev.map((t) => (t.id === targetId ? json.data.task : t)))
    } catch (e) {
      toast.error("Upload failed", { description: e instanceof Error ? e.message : "Failed." })
    }
  }

  async function deleteTodo(id: string) {
    // optimistic
    setTodos((prev) => prev.filter((t) => t.id !== id))
    setInProgressTaskId((cur) => (cur === id ? null : cur))

    try {
      await apiFetch("/api/tasks/" + id, { method: "DELETE" })
    } catch (e) {
      toast.error("Failed to delete task", { description: e instanceof Error ? e.message : "Failed." })
    }
  }

  async function setInProgress(taskId: string | null) {
    // optimistic
    setInProgressTaskId(taskId)

    try {
      const data = await apiFetch<{ inProgressTaskId: string | null }>("/api/tasks/in-progress", {
        method: "POST",
        body: JSON.stringify({ id: taskId }),
      })
      setInProgressTaskId(data.inProgressTaskId)
    } catch (e) {
      toast.error("Failed to update in-progress", {
        description: e instanceof Error ? e.message : "Failed.",
      })
    }
  }

  async function downloadAttachment(a: Attachment) {
    try {
      const data = await apiFetch<{ signedUrl: string }>("/api/attachments/signed-url", {
        method: "POST",
        body: JSON.stringify({ bucket: a.bucket, path: a.path }),
      })
      window.open(data.signedUrl, "_blank", "noopener,noreferrer")
    } catch (e) {
      toast.error("Download failed", { description: e instanceof Error ? e.message : "Failed." })
    }
  }

  async function seedDemoTasks() {
    if (todos.length > 0) return
    try {
      const data = await apiFetch<{ tasks: Todo[] }>("/api/tasks/seed", {
        method: "POST",
        body: JSON.stringify({ tasks: initialTodos }),
      })
      setTodos(data.tasks)
    } catch (e) {
      toast.error("Failed to seed demo tasks", { description: e instanceof Error ? e.message : "Failed." })
    }
  }

  async function clearCompleted() {
    const completedIds = new Set(todos.filter((t) => t.completed).map((t) => t.id))
    if (completedIds.size === 0) return

    // optimistic
    setTodos((prev) => prev.filter((t) => !completedIds.has(t.id)))

    try {
      await apiFetch("/api/tasks/clear-completed", { method: "POST" })
    } catch (e) {
      toast.error("Failed to clear completed", { description: e instanceof Error ? e.message : "Failed." })
    }
  }

  return (
    <Card>
      <CardHeader className="flex flex-row items-center justify-between gap-4">
        <div className="space-y-1">
          <CardTitle className="text-2xl">To‑Do</CardTitle>
          <p className="text-muted-foreground text-sm">
            {completedCount}/{filteredTodos.length} completed
          </p>
        </div>
        <div className="flex items-center gap-2">
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <Button
                  type="button"
                  variant={focusMode ? "default" : "outline"}
                  size="sm"
                  onClick={() => {
                    setFocusMode((v) => !v)
                    setPage(1)
                  }}
                >
                  Focus Mode
                </Button>
              </TooltipTrigger>
              <TooltipContent>
                <p>Show tasks for the next 4 hours.</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>

          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <button
                type="button"
                className="rounded-full border bg-background p-0.5"
                aria-label="User menu"
              >
                <Avatar className="h-8 w-8">
                  <AvatarFallback>{userId.slice(0, 2).toUpperCase()}</AvatarFallback>
                </Avatar>
              </button>
            </DropdownMenuTrigger>
            <DropdownMenuContent align="end" className="w-48">
              <DropdownMenuLabel className="text-xs">Account</DropdownMenuLabel>
              <DropdownMenuSeparator />
              <DropdownMenuItem
                onSelect={(e) => {
                  e.preventDefault()
                  void apiFetch("/api/auth/sign-out", { method: "POST" })
                    .catch(() => {})
                    .finally(() => onSignedOut())
                }}
              >
                <LogOut className="mr-2 h-4 w-4" />
                Logout
              </DropdownMenuItem>
            </DropdownMenuContent>
          </DropdownMenu>

          <ModeToggle />
        </div>
      </CardHeader>

      <CardContent className="space-y-6">
        {tasksLoading && (
          <p className="text-muted-foreground text-sm">Loading tasks…</p>
        )}

        {!tasksLoading && tasksError?.code === "MISSING_TABLE" && (
          <Alert variant="destructive">
            <AlertTitle>Database not initialized</AlertTitle>
            <AlertDescription>
              <div className="space-y-2">
                <p>
                  The Supabase table <code>public.tasks</code> was not found. Run the SQL in{" "}
                  <code>supabase/schema.sql</code> (Supabase Dashboard → SQL Editor), then refresh.
                </p>
                <p className="text-xs opacity-90">{tasksError.message}</p>
              </div>
            </AlertDescription>
          </Alert>
        )}

        {!tasksLoading && tasksError && tasksError.code !== "MISSING_TABLE" && (
          <Alert variant="destructive">
            <AlertTitle>Failed to load tasks</AlertTitle>
            <AlertDescription>{tasksError.message}</AlertDescription>
          </Alert>
        )}

        {!tasksLoading && todos.length === 0 && (
          <div className="flex items-center justify-between gap-3 rounded-lg border bg-muted/20 px-3 py-2">
            <p className="text-muted-foreground text-sm">No tasks yet.</p>
            <Button type="button" variant="outline" size="sm" onClick={() => void seedDemoTasks()}>
              Seed demo tasks
            </Button>
          </div>
        )}

        <input
          ref={fileInputRef}
          type="file"
          multiple
          className="hidden"
          accept={[
            "image/*",
            "audio/*",
            "video/*",
            ".pdf",
            ".doc",
            ".docx",
            ".xls",
            ".xlsx",
            ".csv",
            ".txt",
            ".md",
            ".rtf",
          ].join(",")}
          onChange={handleFilesPicked}
        />

        {reminder && (
          <Alert className="border-primary/30 bg-primary/5">
            <Bell className="h-4 w-4" />
            <div className="flex flex-1 flex-col gap-1">
              <div className="flex flex-wrap items-center justify-between gap-2">
                <AlertTitle className="text-sm">
                  Next task starts in {reminder.mins} minute{reminder.mins === 1 ? "" : "s"}
                </AlertTitle>
                <Button
                  type="button"
                  variant="ghost"
                  size="sm"
                  onClick={() => setDismissedReminderTaskId(reminder.todo.id)}
                >
                  Dismiss
                </Button>
              </div>
              <AlertDescription className="text-sm">
                <span className="font-medium">{reminder.todo.title}</span> ·{" "}
                {formatDateTimeFromMs(reminder.dueMs)}
              </AlertDescription>
            </div>
          </Alert>
        )}

        <div className="rounded-xl border bg-card p-4">
          <div className="flex flex-wrap items-center justify-between gap-2">
            <p className="text-sm font-medium">
              Daily load{" "}
              <span className="text-muted-foreground font-normal">
                ({new Intl.DateTimeFormat(undefined, {
                  weekday: "short",
                  year: "numeric",
                  month: "short",
                  day: "2-digit",
                }).format(parseLocalDateOnly(loadDayKey))})
              </span>
            </p>
            <DailyLoadBadge load={dailyLoad.load} />
          </div>
          <p className="text-muted-foreground mt-2 text-sm">
            {dailyLoad.total} task(s) · busiest window {dailyLoad.busiestWindow} ({dailyLoad.peak})
          </p>
        </div>

        <div className="grid gap-3 sm:grid-cols-3">
          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Today’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">
              {summary.todayCompleted} completed
            </p>
            <p className="text-muted-foreground text-sm">{summary.todayPending} pending</p>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tomorrow’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">{summary.tomorrowTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.tomorrowBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tasks Until Next Week</p>
            <p className="mt-2 text-2xl font-semibold">{summary.upcomingTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.upcomingBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>
        </div>

        {focusMode && (
          <div className="flex flex-col gap-1 rounded-lg border bg-muted/20 px-3 py-2 sm:flex-row sm:items-center sm:justify-between">
            <p className="text-sm">
              <span className="font-medium">Focus Mode:</span>{" "}
              showing tasks due in the next 4 hours (until{" "}
              <span className="font-medium">
                {formatDateTimeFromMs(nowMs + 4 * 60 * 60 * 1000)}
              </span>
              )
            </p>
            <Button type="button" variant="ghost" size="sm" onClick={() => setFocusMode(false)}>
              Exit
            </Button>
          </div>
        )}

        <Form {...form}>
          <form
            onSubmit={form.handleSubmit(addTodo)}
            className="space-y-2"
            noValidate
          >
            <div className="flex flex-col gap-2 sm:flex-row">
              <FormField
                control={form.control}
                name="title"
                render={({ field }) => (
                  <FormItem className="flex-1">
                    <FormControl>
                      <Input
                        placeholder="Add a task…"
                        autoComplete="off"
                        {...field}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="dueAt"
                render={({ field }) => (
                  <FormItem className="sm:w-64">
                    <FormControl>
                      <Input type="datetime-local" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <Button type="submit">Add</Button>
            </div>

            <FormField
              control={form.control}
              name="description"
              render={({ field }) => (
                <FormItem>
                  <FormControl>
                    <Textarea
                      rows={3}
                      placeholder="Description (optional)…"
                      {...field}
                    />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />
          </form>
        </Form>

        <Separator />

        <div className="space-y-3">
          <div className="flex flex-wrap items-center justify-between gap-2">
            <p className="text-sm font-medium">Filter by date & time</p>
            <div className="flex items-center gap-2">
              <Button
                type="button"
                size="sm"
                variant={filterMode === "between" ? "default" : "outline"}
                onClick={() => setFilterMode("between")}
              >
                Between
              </Button>
              <Button
                type="button"
                size="sm"
                variant={filterMode === "exact" ? "default" : "outline"}
                onClick={() => setFilterMode("exact")}
              >
                Exact
              </Button>
              <Button
                type="button"
                size="sm"
                variant="ghost"
                onClick={() => {
                  setFilterFromDate("")
                  setFilterFromTime("")
                  setFilterToDate("")
                  setFilterToTime("")
                  setFilterExactDate("")
                  setFilterExactTime("")
                }}
              >
                Clear
              </Button>
            </div>
          </div>

          {filterMode === "between" ? (
            <div className="grid gap-2 sm:grid-cols-2">
              <div className="grid gap-2 sm:grid-cols-2">
                <Input
                  type="date"
                  value={filterFromDate}
                  onChange={(e) => setFilterFromDate(e.target.value)}
                />
                <Input
                  type="time"
                  value={filterFromTime}
                  onChange={(e) => setFilterFromTime(e.target.value)}
                />
              </div>
              <div className="grid gap-2 sm:grid-cols-2">
                <Input
                  type="date"
                  value={filterToDate}
                  onChange={(e) => setFilterToDate(e.target.value)}
                />
                <Input
                  type="time"
                  value={filterToTime}
                  onChange={(e) => setFilterToTime(e.target.value)}
                />
              </div>
            </div>
          ) : (
            <div className="grid gap-2 sm:grid-cols-2">
              <Input
                type="date"
                value={filterExactDate}
                onChange={(e) => setFilterExactDate(e.target.value)}
              />
              <Input
                type="time"
                value={filterExactTime}
                onChange={(e) => setFilterExactTime(e.target.value)}
              />
            </div>
          )}
        </div>

        <Separator />

        <div className="space-y-2">
          {groupedTodos.length === 0 ? (
            <p className="text-muted-foreground text-sm">No tasks yet.</p>
          ) : (
            groupedTodos.map((group) => (
              <div key={group.date} className="space-y-2">
                <div className="flex items-center gap-3 pt-2">
                  <Separator className="flex-1" />
                  <span className="text-muted-foreground whitespace-nowrap text-xs font-medium">
                    {new Intl.DateTimeFormat(undefined, {
                      weekday: "short",
                      year: "numeric",
                      month: "short",
                      day: "2-digit",
                    }).format(parseLocalDateOnly(group.date))}
                  </span>
                  <Separator className="flex-1" />
                </div>

                {group.items.map((todo) => {
                  const flags = getTaskFlags(todo, nowMs, inProgressTaskId)

                  return (
                    <div
                      key={todo.id}
                      className={cn(
                        "rounded-lg border px-3 py-2",
                        flags.completed && "opacity-75",
                        flags.overdue &&
                          "border-destructive/40 bg-destructive/5 text-muted-foreground",
                        flags.inProgress && "border-sky-500/40 bg-sky-500/10",
                        conflictDueAt &&
                          todo.dueAt === conflictDueAt &&
                          "border-destructive/60 bg-destructive/5 ring-1 ring-destructive/30"
                      )}
                    >
                      <div className="flex items-start justify-between gap-3">
                        <label className="flex cursor-pointer items-start gap-3">
                        <Checkbox
                          checked={todo.completed}
                          onCheckedChange={(v) => {
                            const next = Boolean(v)
                            toggleTodo(todo.id, next)
                            if (next && !todo.completed) {
                              requestAttachmentsForTodo(todo.id)
                            }
                          }}
                          aria-label={`Mark "${todo.title}" as ${
                            todo.completed ? "not completed" : "completed"
                          }`}
                          className="mt-0.5"
                        />
                        <span
                          className={cn(
                            "leading-6",
                            todo.completed && "text-muted-foreground line-through"
                          )}
                        >
                          <span className="flex flex-wrap items-center gap-2">
                            <span className="block">{todo.title}</span>
                              <TaskBadges {...flags} />
                            {todo.description && (
                              <TooltipProvider>
                                <Tooltip>
                                  <TooltipTrigger asChild>
                                    <button
                                      type="button"
                                      className="text-muted-foreground hover:text-foreground inline-flex h-7 w-7 items-center justify-center rounded-md border bg-background"
                                      aria-label="View description"
                                    >
                                      <Info className="h-4 w-4" />
                                    </button>
                                  </TooltipTrigger>
                                  <TooltipContent className="max-w-xs">
                                    <p className="whitespace-pre-wrap text-sm">
                                      {todo.description}
                                    </p>
                                  </TooltipContent>
                                </Tooltip>
                              </TooltipProvider>
                            )}
                          </span>
                          <span className="text-muted-foreground block text-xs">
                            Due: {formatLocalDateTime(todo.dueAt)}
                          </span>
                        </span>
                      </label>

                      <div className="flex items-center gap-1">
                        {!todo.completed && (
                          <Button
                            type="button"
                            variant={flags.inProgress ? "default" : "outline"}
                            size="sm"
                            onClick={() => void setInProgress(flags.inProgress ? null : todo.id)}
                            className={cn(
                              flags.inProgress && "bg-sky-600 hover:bg-sky-600"
                            )}
                          >
                            {flags.inProgress ? (
                              <>
                                <CircleStop className="mr-1 h-4 w-4" />
                                Stop
                              </>
                            ) : (
                              <>
                                <CirclePlay className="mr-1 h-4 w-4" />
                                Start
                              </>
                            )}
                          </Button>
                        )}
                        {todo.completed && (
                          <Button
                            type="button"
                            variant="outline"
                            size="sm"
                            onClick={() => requestAttachmentsForTodo(todo.id)}
                          >
                            Add files
                          </Button>
                        )}
                        <Button
                          type="button"
                          variant="ghost"
                          size="icon"
                          aria-label={`Delete "${todo.title}"`}
                          onClick={() => deleteTodo(todo.id)}
                        >
                          <Trash2 className="h-4 w-4" />
                        </Button>
                      </div>
                    </div>

                    {todo.completed && todo.attachments.length > 0 && (
                      <div className="mt-3 space-y-2">
                        <p className="text-muted-foreground text-xs">Attachments</p>
                        <ul className="space-y-1">
                          {todo.attachments.map((a) => (
                            <li
                              key={a.id}
                              className="flex items-center justify-between gap-3 rounded-md bg-muted/30 px-2 py-1"
                            >
                              <div className="flex min-w-0 items-center gap-2">
                                <AttachmentIcon kind={a.kind} />
                                <span className="truncate text-sm">{a.name}</span>
                              </div>
                              <button
                                type="button"
                                onClick={() => void downloadAttachment(a)}
                                className="inline-flex items-center gap-1 text-sm font-medium underline underline-offset-4"
                              >
                                <Download className="h-4 w-4" />
                                Download
                              </button>
                            </li>
                          ))}
                        </ul>
                      </div>
                    )}
                  </div>
                  )
                })}
              </div>
            ))
          )}
        </div>

        {groupedTodos.length > 0 && (
          <div className="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
            <div className="flex items-center gap-2">
              <span className="text-muted-foreground text-sm">Items per page</span>
              <Select
                value={String(pageSize)}
                onValueChange={(v) => {
                  const next = Number(v)
                  setPageSize(next)
                  setPage(1)
                }}
              >
                <SelectTrigger className="w-[110px]">
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="5">5</SelectItem>
                  <SelectItem value="10">10</SelectItem>
                  <SelectItem value="15">15</SelectItem>
                  <SelectItem value="20">20</SelectItem>
                </SelectContent>
              </Select>
            </div>

            {showPagination && (
              <div className="flex items-center justify-between gap-3 sm:justify-end">
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={() => setPage((p) => Math.max(1, p - 1))}
                  disabled={page <= 1}
                >
                  Prev
                </Button>
                <span className="text-muted-foreground text-sm">
                  Page {page} of {totalPages}
                </span>
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={() => setPage((p) => Math.min(totalPages, p + 1))}
                  disabled={page >= totalPages}
                >
                  Next
                </Button>
              </div>
            )}
          </div>
        )}

        <div className="flex items-center justify-between gap-2">
          <Button
            type="button"
            variant="secondary"
            onClick={clearCompleted}
            disabled={completedCount === 0}
          >
            Clear completed
          </Button>
          <span className="text-muted-foreground text-sm">
            v 1.1.0
          </span>
    </div>
      </CardContent>
    </Card>
  )
}

```

I found why the build failed: `src/app/page.tsx` still contains a big chunk of leftover helper code from before the refactor, so TypeScript is trying to compile it. Next I’ll replace `src/app/page.tsx` entirely with a tiny wrapper that just renders `TodoPage`, then re-run the build.

```typescriptreact
"use client"

import { TodoPage } from "@/components/todo/TodoPage"

export default function Home() {
  return <TodoPage />
}


```

### Refactor complete: `page.tsx` is now clean
- `src/app/page.tsx` is now a **thin wrapper** that only renders `TodoPage`.

### Extracted reusable components/modules
Created a small feature folder under `src/components/todo/`:

- **Auth UI**: `src/components/todo/AuthCard.tsx`
- **User avatar dropdown**: `src/components/todo/UserMenu.tsx`
- **Task creation form**: `src/components/todo/TaskForm.tsx`
- **Task list (grouped, attachments, actions)**: `src/components/todo/TaskList.tsx`
- **Main container** (state + API calls + composition): `src/components/todo/TodoApp.tsx`
- **Page orchestrator** (auth gate + renders app): `src/components/todo/TodoPage.tsx`
- **Shared**: `types.ts`, `schemas.ts`, `mock-data.ts`, `utils.ts`

### Verified
- `npm run build` passes.

---

**User**

@src/components/todo/UserMenu.tsx:26-28 Use realistic profile images for the user avatar to achieve a more professional and polished look.

---

**Cursor**

I’ll update `UserMenu` to use `AvatarImage` with a deterministic, realistic placeholder profile photo (based on the user id) and keep the initials fallback for reliability. Next I’ll patch `src/components/todo/UserMenu.tsx` and run a quick build.

```typescriptreact
"use client"

import * as React from "react"
import { LogOut } from "lucide-react"

import { apiFetch } from "@/lib/api-client"
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar"
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu"

export function UserMenu({ userId, onSignedOut }: { userId: string; onSignedOut: () => void }) {
  // Deterministic, realistic placeholder avatars (no user-uploaded profile yet).
  // Using a stable index keeps the avatar consistent per user.
  const avatarIndex = React.useMemo(() => {
    const last2 = userId.slice(-2)
    const n = Number.parseInt(last2, 16)
    return Number.isFinite(n) ? (n % 100) : 0
  }, [userId])
  const avatarUrl = `https://randomuser.me/api/portraits/${avatarIndex % 2 === 0 ? "men" : "women"}/${avatarIndex}.jpg`

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <button
          type="button"
          className="rounded-full border bg-background p-0.5"
          aria-label="User menu"
        >
          <Avatar className="h-8 w-8">
            <AvatarImage src={avatarUrl} alt="User avatar" />
            <AvatarFallback>{userId.slice(0, 2).toUpperCase()}</AvatarFallback>
          </Avatar>
        </button>
      </DropdownMenuTrigger>
      <DropdownMenuContent align="end" className="w-48">
        <DropdownMenuLabel className="text-xs">Account</DropdownMenuLabel>
        <DropdownMenuSeparator />
        <DropdownMenuItem
          onSelect={(e) => {
            e.preventDefault()
            void apiFetch("/api/auth/sign-out", { method: "POST" })
              .catch(() => {})
              .finally(() => onSignedOut())
          }}
        >
          <LogOut className="mr-2 h-4 w-4" />
          Logout
        </DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  )
}


```

### Updated `UserMenu` avatar to use realistic profile images
In `src/components/todo/UserMenu.tsx`, the avatar now renders an `AvatarImage` using a **deterministic, realistic placeholder photo** (based on `userId`) and keeps the initials `AvatarFallback` if the image can’t load.

- **File updated**: `src/components/todo/UserMenu.tsx`
- Build verified: `npm run build` ✅

---

**User**

add a del  button (small and just icon) for remove attachment in task 

---

**Cursor**

Plan: add a small trash icon next to each attachment in the list, wire it to a new API route that (1) deletes the file from Supabase Storage and (2) removes it from the task’s `attachments` JSON, then update the UI state with the returned task. I’ll touch `src/components/todo/TaskList.tsx`, `src/components/todo/TodoApp.tsx`, and add an API route under `src/app/api/tasks/[id]/attachments/delete`.

```typescript
import { jsonError, jsonOk } from "@/app/api/_lib/response"
import { requireUser } from "@/app/api/_lib/supabase"
import { createServerSupabaseClient } from "@/lib/supabase/server"
import type { DbTaskRow } from "@/app/api/tasks/types"
import { coerceAttachments, fromDbTask } from "@/app/api/tasks/types"
import { z } from "zod"

const schema = z.object({
  attachmentId: z.string().min(1),
})

export async function POST(req: Request, ctx: { params: Promise<{ id: string }> }) {
  const { user, accessToken } = await requireUser()
  if (!user) return jsonError("Unauthorized", "UNAUTHORIZED", 401)

  const { id } = await ctx.params
  const body = await req.json().catch(() => null)
  const parsed = schema.safeParse(body)
  if (!parsed.success) return jsonError("Invalid request body.", "BAD_REQUEST", 400)

  const supabase = createServerSupabaseClient(accessToken ?? undefined)

  const { data: taskRow, error: taskErr } = await supabase
    .from("tasks")
    .select("*")
    .eq("id", id)
    .eq("user_id", user.id)
    .single()

  if (taskErr || !taskRow) return jsonError(taskErr?.message ?? "Task not found.", "DB", 404)

  const task = taskRow as DbTaskRow
  const current = coerceAttachments(task.attachments)
  const target = current.find((a) => a.id === parsed.data.attachmentId)
  if (!target) return jsonError("Attachment not found.", "NOT_FOUND", 404)

  // Best-effort delete from Storage first.
  const storageRes = await supabase.storage.from(target.bucket).remove([target.path])
  if (storageRes.error) return jsonError(storageRes.error.message, "STORAGE", 500)

  const nextAttachments = current.filter((a) => a.id !== parsed.data.attachmentId)

  const { data: updated, error: updErr } = await supabase
    .from("tasks")
    .update({ attachments: nextAttachments })
    .eq("id", id)
    .eq("user_id", user.id)
    .select("*")
    .single()

  if (updErr || !updated) return jsonError(updErr?.message ?? "Failed to update task.", "DB", 500)

  return jsonOk({ task: fromDbTask(updated as DbTaskRow) })
}


```

```typescriptreact
"use client"

import * as React from "react"
import {
  CirclePlay,
  CircleStop,
  Download,
  Trash2,
  File,
  FileSpreadsheet,
  FileText,
  Image as ImageIcon,
  Info,
  Music,
  Video,
} from "lucide-react"

import type { AttachmentKind, Todo } from "./types"
import { cn } from "@/lib/utils"
import { formatLocalDateTime, parseLocalDateOnly, parseLocalDateTime } from "./utils"
import { getTaskFlags } from "./utils"

import { Button } from "@/components/ui/button"
import { Checkbox } from "@/components/ui/checkbox"
import { Separator } from "@/components/ui/separator"
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip"
import { Badge } from "@/components/ui/badge"

function AttachmentIcon({ kind }: { kind: AttachmentKind }) {
  const className = "h-4 w-4 text-muted-foreground"
  switch (kind) {
    case "image":
      return <ImageIcon className={className} />
    case "audio":
      return <Music className={className} />
    case "video":
      return <Video className={className} />
    case "spreadsheet":
      return <FileSpreadsheet className={className} />
    case "pdf":
    case "document":
    case "text":
      return <FileText className={className} />
    default:
      return <File className={className} />
  }
}

function TaskBadges({
  completed,
  overdue,
  inProgress,
  planned,
}: {
  completed: boolean
  overdue: boolean
  inProgress: boolean
  planned: boolean
}) {
  if (completed) {
    return (
      <Badge className="gap-1 bg-emerald-600 text-white hover:bg-emerald-600">Completed</Badge>
    )
  }
  return (
    <span className="flex flex-wrap items-center gap-2">
      {inProgress && <Badge className="bg-sky-600 text-white hover:bg-sky-600">In progress</Badge>}
      {overdue && <Badge variant="destructive">Overdue</Badge>}
      {planned && <Badge variant="outline">Planned</Badge>}
    </span>
  )
}

export function TaskList({
  groups,
  nowMs,
  inProgressTaskId,
  conflictDueAt,
  onToggleCompleted,
  onToggleInProgress,
  onDelete,
  onAddFiles,
  onDownloadAttachment,
  onDeleteAttachment,
}: {
  groups: Array<{ date: string; items: Todo[] }>
  nowMs: number
  inProgressTaskId: string | null
  conflictDueAt: string | null
  onToggleCompleted: (id: string, completed: boolean) => void
  onToggleInProgress: (todoId: string, isInProgress: boolean) => void
  onDelete: (id: string) => void
  onAddFiles: (todoId: string) => void
  onDownloadAttachment: (a: Todo["attachments"][number]) => void
  onDeleteAttachment: (todoId: string, a: Todo["attachments"][number]) => void
}) {
  if (groups.length === 0) {
    return <p className="text-muted-foreground text-sm">No tasks yet.</p>
  }

  return (
    <div className="space-y-2">
      {groups.map((group) => (
        <div key={group.date} className="space-y-2">
          <div className="flex items-center gap-3 pt-2">
            <Separator className="flex-1" />
            <span className="text-muted-foreground whitespace-nowrap text-xs font-medium">
              {new Intl.DateTimeFormat(undefined, {
                weekday: "short",
                year: "numeric",
                month: "short",
                day: "2-digit",
              }).format(parseLocalDateOnly(group.date))}
            </span>
            <Separator className="flex-1" />
          </div>

          {group.items.map((todo) => {
            const flags = getTaskFlags(todo, nowMs, inProgressTaskId)

            return (
              <div
                key={todo.id}
                className={cn(
                  "rounded-lg border px-3 py-2",
                  flags.completed && "opacity-75",
                  flags.overdue && "border-destructive/40 bg-destructive/5 text-muted-foreground",
                  flags.inProgress && "border-sky-500/40 bg-sky-500/10",
                  conflictDueAt &&
                    todo.dueAt === conflictDueAt &&
                    "border-destructive/60 bg-destructive/5 ring-1 ring-destructive/30"
                )}
              >
                <div className="flex items-start justify-between gap-3">
                  <label className="flex cursor-pointer items-start gap-3">
                    <Checkbox
                      checked={todo.completed}
                      onCheckedChange={(v) => onToggleCompleted(todo.id, Boolean(v))}
                      aria-label={`Mark "${todo.title}" as ${
                        todo.completed ? "not completed" : "completed"
                      }`}
                      className="mt-0.5"
                    />
                    <span
                      className={cn(
                        "leading-6",
                        todo.completed && "text-muted-foreground line-through"
                      )}
                    >
                      <span className="flex flex-wrap items-center gap-2">
                        <span className="block">{todo.title}</span>
                        <TaskBadges {...flags} />
                        {todo.description && (
                          <TooltipProvider>
                            <Tooltip>
                              <TooltipTrigger asChild>
                                <button
                                  type="button"
                                  className="text-muted-foreground hover:text-foreground inline-flex h-7 w-7 items-center justify-center rounded-md border bg-background"
                                  aria-label="View description"
                                >
                                  <Info className="h-4 w-4" />
                                </button>
                              </TooltipTrigger>
                              <TooltipContent className="max-w-xs">
                                <p className="whitespace-pre-wrap text-sm">{todo.description}</p>
                              </TooltipContent>
                            </Tooltip>
                          </TooltipProvider>
                        )}
                      </span>
                      <span className="text-muted-foreground block text-xs">
                        Due: {formatLocalDateTime(todo.dueAt)}
                      </span>
                    </span>
                  </label>

                  <div className="flex items-center gap-1">
                    {!todo.completed && (
                      <Button
                        type="button"
                        variant={flags.inProgress ? "default" : "outline"}
                        size="sm"
                        onClick={() => onToggleInProgress(todo.id, flags.inProgress)}
                        className={cn(flags.inProgress && "bg-sky-600 hover:bg-sky-600")}
                      >
                        {flags.inProgress ? (
                          <>
                            <CircleStop className="mr-1 h-4 w-4" />
                            Stop
                          </>
                        ) : (
                          <>
                            <CirclePlay className="mr-1 h-4 w-4" />
                            Start
                          </>
                        )}
                      </Button>
                    )}

                    {todo.completed && (
                      <Button
                        type="button"
                        variant="outline"
                        size="sm"
                        onClick={() => onAddFiles(todo.id)}
                      >
                        Add files
                      </Button>
                    )}

                    <Button
                      type="button"
                      variant="ghost"
                      size="icon"
                      aria-label={`Delete "${todo.title}"`}
                      onClick={() => onDelete(todo.id)}
                    >
                      <Trash2 className="h-4 w-4" />
                    </Button>
                  </div>
                </div>

                {todo.completed && todo.attachments.length > 0 && (
                  <div className="mt-3 space-y-2">
                    <p className="text-muted-foreground text-xs">Attachments</p>
                    <ul className="space-y-1">
                      {todo.attachments.map((a) => (
                        <li
                          key={a.id}
                          className="flex items-center justify-between gap-3 rounded-md bg-muted/30 px-2 py-1"
                        >
                          <div className="flex min-w-0 items-center gap-2">
                            <AttachmentIcon kind={a.kind} />
                            <span className="truncate text-sm">{a.name}</span>
                          </div>
                          <div className="flex items-center gap-2">
                            <button
                              type="button"
                              onClick={() => onDownloadAttachment(a)}
                              className="inline-flex items-center gap-1 text-sm font-medium underline underline-offset-4"
                            >
                              <Download className="h-4 w-4" />
                              Download
                            </button>
                            <Button
                              type="button"
                              variant="ghost"
                              size="icon"
                              className="h-7 w-7"
                              aria-label={`Remove attachment "${a.name}"`}
                              onClick={() => onDeleteAttachment(todo.id, a)}
                            >
                              <Trash2 className="h-4 w-4" />
                            </Button>
                          </div>
                        </li>
                      ))}
                    </ul>
                  </div>
                )}
              </div>
            )
          })}
        </div>
      ))}
    </div>
  )
}


```

```typescriptreact
*** Begin Patch
*** Update File: src/components/todo/TodoApp.tsx
@@
         <TaskList
           groups={groupedTodos}
           nowMs={nowMs}
           inProgressTaskId={inProgressTaskId}
           conflictDueAt={conflictDueAt}
           onToggleCompleted={(id, completed) => void toggleTodo(id, completed)}
           onToggleInProgress={(id, isInProgress) => void setInProgress(isInProgress ? null : id)}
           onDelete={(id) => void deleteTodo(id)}
           onAddFiles={(id) => void requestAttachmentsForTodo(id)}
           onDownloadAttachment={(a) => void downloadAttachment(a)}
+          onDeleteAttachment={(todoId, a) => void deleteAttachment(todoId, a.id)}
         />
@@
   async function downloadAttachment(a: Todo["attachments"][number]) {
     const data = await apiFetch<{ signedUrl: string }>("/api/attachments/signed-url", {
       method: "POST",
       body: JSON.stringify({ bucket: a.bucket, path: a.path }),
     })
     window.open(data.signedUrl, "_blank", "noopener,noreferrer")
   }
+
+  async function deleteAttachment(todoId: string, attachmentId: string) {
+    try {
+      const data = await apiFetch<{ task: Todo }>(`/api/tasks/${todoId}/attachments/delete`, {
+        method: "POST",
+        body: JSON.stringify({ attachmentId }),
+      })
+      setTodos((prev) => prev.map((t) => (t.id === todoId ? data.task : t)))
+    } catch (e) {
+      toast.error("Failed to remove attachment", {
+        description: e instanceof Error ? e.message : "Failed.",
+      })
+    }
+  }
*** End Patch
```

```typescriptreact
"use client"

import * as React from "react"
import { Bell } from "lucide-react"
import { toast } from "sonner"

import type { DailyLoad, Todo } from "./types"
import { initialTodos } from "./mock-data"
import { TaskForm } from "./TaskForm"
import { TaskList } from "./TaskList"
import { UserMenu } from "./UserMenu"

import { apiFetch, ApiError } from "@/lib/api-client"
import { ModeToggle } from "@/components/mode-toggle"
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert"
import { Badge } from "@/components/ui/badge"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Input } from "@/components/ui/input"
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select"
import { Separator } from "@/components/ui/separator"
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip"

import type { TodoFormValues } from "./schemas"
import {
  addDays,
  endOfDay,
  formatDateTimeFromMs,
  formatLocalDateTime,
  getDailyLoad,
  getDatePart,
  getTimePart,
  localDateKey,
  minutesUntil,
  parseLocalDateOnly,
  parseLocalDateTime,
  parseLocalTimeToMinutes,
  startOfDay,
} from "./utils"

function DailyLoadBadge({ load }: { load: DailyLoad }) {
  if (load === "heavy") return <Badge variant="destructive">Heavy</Badge>
  if (load === "balanced") return <Badge variant="secondary">Balanced</Badge>
  return <Badge variant="outline">Light</Badge>
}

export function TodoApp({ userId, onSignedOut }: { userId: string; onSignedOut: () => void }) {
  const [todos, setTodos] = React.useState<Todo[]>([])
  const [tasksLoading, setTasksLoading] = React.useState(true)
  const [tasksError, setTasksError] = React.useState<{ code?: string; message: string } | null>(
    null
  )

  const [attachTargetTodoId, setAttachTargetTodoId] = React.useState<string | null>(null)
  const fileInputRef = React.useRef<HTMLInputElement>(null)

  const [conflictDueAt, setConflictDueAt] = React.useState<string | null>(null)
  const clearConflictTimerRef = React.useRef<number | null>(null)

  const [focusMode, setFocusMode] = React.useState(false)
  const [nowMs, setNowMs] = React.useState(() => Date.now())
  const [inProgressTaskId, setInProgressTaskId] = React.useState<string | null>(null)

  const [dismissedReminderTaskId, setDismissedReminderTaskId] = React.useState<string | null>(null)

  const [filterMode, setFilterMode] = React.useState<"between" | "exact">("between")
  const [filterFromDate, setFilterFromDate] = React.useState<string>("")
  const [filterFromTime, setFilterFromTime] = React.useState<string>("")
  const [filterToDate, setFilterToDate] = React.useState<string>("")
  const [filterToTime, setFilterToTime] = React.useState<string>("")
  const [filterExactDate, setFilterExactDate] = React.useState<string>("")
  const [filterExactTime, setFilterExactTime] = React.useState<string>("")

  const [pageSize, setPageSize] = React.useState<number>(5)
  const [page, setPage] = React.useState<number>(1)

  React.useEffect(() => {
    const id = window.setInterval(() => setNowMs(Date.now()), 30_000)
    return () => window.clearInterval(id)
  }, [])

  React.useEffect(() => {
    if (!inProgressTaskId) return
    const t = todos.find((x) => x.id === inProgressTaskId)
    if (!t || t.completed) setInProgressTaskId(null)
  }, [inProgressTaskId, todos])

  React.useEffect(() => {
    let alive = true
    async function load() {
      setTasksLoading(true)
      try {
        const data = await apiFetch<{ tasks: Todo[]; inProgressTaskId: string | null }>("/api/tasks")
        if (!alive) return
        setTodos(data.tasks)
        setInProgressTaskId(data.inProgressTaskId)
        setTasksError(null)
      } catch (e) {
        if (!alive) return
        if (e instanceof ApiError) setTasksError({ code: e.code, message: e.message })
        else setTasksError({ message: e instanceof Error ? e.message : "Failed to load tasks." })
        setTodos([])
        setInProgressTaskId(null)
      } finally {
        if (!alive) return
        setTasksLoading(false)
      }
    }
    void load()
    return () => {
      alive = false
    }
  }, [])

  const nextUpcoming = React.useMemo(() => {
    const upcoming = todos
      .filter((t) => !t.completed)
      .map((t) => ({ todo: t, dueMs: parseLocalDateTime(t.dueAt) }))
      .filter((x) => x.dueMs >= nowMs)
      .sort((a, b) => a.dueMs - b.dueMs)[0]
    return upcoming ?? null
  }, [nowMs, todos])

  React.useEffect(() => {
    if (nextUpcoming && nextUpcoming.todo.id !== dismissedReminderTaskId) return
    if (!nextUpcoming) setDismissedReminderTaskId(null)
  }, [dismissedReminderTaskId, nextUpcoming])

  const reminder = React.useMemo(() => {
    const REMINDER_WINDOW_MIN = 15
    if (!nextUpcoming) return null
    if (dismissedReminderTaskId === nextUpcoming.todo.id) return null
    const mins = minutesUntil(nextUpcoming.dueMs, nowMs)
    if (mins < 0 || mins > REMINDER_WINDOW_MIN) return null
    return { ...nextUpcoming, mins }
  }, [dismissedReminderTaskId, nextUpcoming, nowMs])

  const filteredTodos = React.useMemo(() => {
    if (focusMode) {
      const endMs = nowMs + 4 * 60 * 60 * 1000
      return todos.filter((t) => {
        const ms = parseLocalDateTime(t.dueAt)
        return ms >= nowMs && ms <= endMs
      })
    }

    if (filterMode === "exact") {
      if (!filterExactDate && !filterExactTime) return todos
      if (filterExactDate && !filterExactTime) {
        return todos.filter((t) => getDatePart(t.dueAt) === filterExactDate)
      }
      if (filterExactDate && filterExactTime) {
        const exactMs = parseLocalDateTime(`${filterExactDate}T${filterExactTime}`)
        return todos.filter((t) => parseLocalDateTime(t.dueAt) === exactMs)
      }
      return todos.filter((t) => getTimePart(t.dueAt) === filterExactTime)
    }

    const hasAnyDate = Boolean(filterFromDate || filterToDate)
    const hasAnyTime = Boolean(filterFromTime || filterToTime)

    const fromDateMs = filterFromDate
      ? startOfDay(parseLocalDateOnly(filterFromDate)).getTime()
      : Number.NEGATIVE_INFINITY
    const toDateMs = filterToDate
      ? endOfDay(parseLocalDateOnly(filterToDate)).getTime()
      : Number.POSITIVE_INFINITY

    const fromTimeMin = filterFromTime ? parseLocalTimeToMinutes(filterFromTime) : 0
    const toTimeMin = filterToTime ? parseLocalTimeToMinutes(filterToTime) : 24 * 60 - 1

    return todos.filter((t) => {
      const ms = parseLocalDateTime(t.dueAt)
      if (hasAnyDate && (ms < fromDateMs || ms > toDateMs)) return false
      if (hasAnyTime) {
        const time = getTimePart(t.dueAt)
        if (!time) return false
        const mins = parseLocalTimeToMinutes(time)
        if (mins < fromTimeMin || mins > toTimeMin) return false
      }
      return true
    })
  }, [
    todos,
    focusMode,
    nowMs,
    filterMode,
    filterExactDate,
    filterExactTime,
    filterFromDate,
    filterFromTime,
    filterToDate,
    filterToTime,
  ])

  const sortedFilteredTodos = React.useMemo(
    () =>
      filteredTodos
        .slice()
        .sort((a, b) => parseLocalDateTime(a.dueAt) - parseLocalDateTime(b.dueAt)),
    [filteredTodos]
  )

  React.useEffect(() => {
    const totalPages = Math.max(1, Math.ceil(sortedFilteredTodos.length / pageSize))
    setPage((p) => Math.min(Math.max(1, p), totalPages))
  }, [pageSize, sortedFilteredTodos.length])

  const totalItems = sortedFilteredTodos.length
  const totalPages = Math.max(1, Math.ceil(totalItems / pageSize))
  const showPagination = totalPages > 1

  const pageItems = React.useMemo(() => {
    const start = (page - 1) * pageSize
    return sortedFilteredTodos.slice(start, start + pageSize)
  }, [page, pageSize, sortedFilteredTodos])

  const groupedTodos = React.useMemo(() => {
    const groups: Array<{ date: string; items: Todo[] }> = []
    for (const t of pageItems) {
      const date = getDatePart(t.dueAt)
      const last = groups[groups.length - 1]
      if (!last || last.date !== date) groups.push({ date, items: [t] })
      else last.items.push(t)
    }
    return groups
  }, [pageItems])

  const completedCount = filteredTodos.filter((t) => t.completed).length

  async function requestAttachmentsForTodo(todoId: string) {
    setAttachTargetTodoId(todoId)
    queueMicrotask(() => fileInputRef.current?.click())
  }

  async function handleFilesPicked(e: React.ChangeEvent<HTMLInputElement>) {
    const files = Array.from(e.target.files ?? [])
    const targetId = attachTargetTodoId
    e.target.value = ""
    setAttachTargetTodoId(null)
    if (!targetId || files.length === 0) return

    const form = new FormData()
    for (const f of files) form.append("files", f)

    try {
      const res = await fetch(`/api/tasks/${targetId}/attachments`, {
        method: "POST",
        credentials: "include",
        body: form,
      })
      const json = (await res.json().catch(() => null)) as
        | { ok: true; data: { task: Todo } }
        | { ok: false; error: { message: string } }
        | null
      if (!json || !json.ok) throw new Error(json?.error.message ?? "Upload failed.")
      setTodos((prev) => prev.map((t) => (t.id === targetId ? json.data.task : t)))
    } catch (err) {
      toast.error("Upload failed", { description: err instanceof Error ? err.message : "Failed." })
    }
  }

  async function addTodo(values: TodoFormValues) {
    const conflicts = todos.filter((t) => t.dueAt === values.dueAt)
    if (conflicts.length > 0) {
      setConflictDueAt(values.dueAt)
      if (clearConflictTimerRef.current) window.clearTimeout(clearConflictTimerRef.current)
      clearConflictTimerRef.current = window.setTimeout(() => setConflictDueAt(null), 8000)

      const [d, time] = values.dueAt.split("T")
      setFilterMode("exact")
      setFilterExactDate(d ?? "")
      setFilterExactTime(time ?? "")
      setPage(1)

      toast.error("Time conflict", {
        description: `You already have ${conflicts.length} task(s) scheduled at ${formatLocalDateTime(
          values.dueAt
        )}.`,
      })
    }

    const data = await apiFetch<{ task: Todo }>("/api/tasks", {
      method: "POST",
      body: JSON.stringify(values),
    })
    setTodos((prev) => [data.task, ...prev])
  }

  async function toggleTodo(id: string, completed: boolean) {
    const before = todos.find((t) => t.id === id)
    setTodos((prev) => prev.map((t) => (t.id === id ? { ...t, completed } : t)))
    if (completed) setInProgressTaskId((cur) => (cur === id ? null : cur))

    try {
      await apiFetch("/api/tasks/" + id, { method: "PATCH", body: JSON.stringify({ completed }) })
    } catch (e) {
      toast.error("Failed to update task", { description: e instanceof Error ? e.message : "Failed." })
    }

    if (completed && before && !before.completed) {
      await requestAttachmentsForTodo(id)
    }
  }

  async function deleteTodo(id: string) {
    setTodos((prev) => prev.filter((t) => t.id !== id))
    setInProgressTaskId((cur) => (cur === id ? null : cur))
    try {
      await apiFetch("/api/tasks/" + id, { method: "DELETE" })
    } catch (e) {
      toast.error("Failed to delete task", { description: e instanceof Error ? e.message : "Failed." })
    }
  }

  async function clearCompleted() {
    const completedIds = new Set(todos.filter((t) => t.completed).map((t) => t.id))
    if (completedIds.size === 0) return
    setTodos((prev) => prev.filter((t) => !completedIds.has(t.id)))
    try {
      await apiFetch("/api/tasks/clear-completed", { method: "POST" })
    } catch (e) {
      toast.error("Failed to clear completed", { description: e instanceof Error ? e.message : "Failed." })
    }
  }

  async function setInProgress(taskId: string | null) {
    setInProgressTaskId(taskId)
    try {
      const data = await apiFetch<{ inProgressTaskId: string | null }>("/api/tasks/in-progress", {
        method: "POST",
        body: JSON.stringify({ id: taskId }),
      })
      setInProgressTaskId(data.inProgressTaskId)
    } catch (e) {
      toast.error("Failed to update in-progress", { description: e instanceof Error ? e.message : "Failed." })
    }
  }

  async function downloadAttachment(a: Todo["attachments"][number]) {
    const data = await apiFetch<{ signedUrl: string }>("/api/attachments/signed-url", {
      method: "POST",
      body: JSON.stringify({ bucket: a.bucket, path: a.path }),
    })
    window.open(data.signedUrl, "_blank", "noopener,noreferrer")
  }

  async function deleteAttachment(todoId: string, attachmentId: string) {
    try {
      const data = await apiFetch<{ task: Todo }>(`/api/tasks/${todoId}/attachments/delete`, {
        method: "POST",
        body: JSON.stringify({ attachmentId }),
      })
      setTodos((prev) => prev.map((t) => (t.id === todoId ? data.task : t)))
    } catch (e) {
      toast.error("Failed to remove attachment", {
        description: e instanceof Error ? e.message : "Failed.",
      })
    }
  }

  async function seedDemoTasks() {
    if (todos.length > 0) return
    const data = await apiFetch<{ tasks: Todo[] }>("/api/tasks/seed", {
      method: "POST",
      body: JSON.stringify({ tasks: initialTodos }),
    })
    setTodos(data.tasks)
  }

  const loadDayKey = React.useMemo(() => {
    if (filterMode === "exact" && filterExactDate) return filterExactDate
    if (filterFromDate && !filterToDate) return filterFromDate
    if (filterFromDate && filterToDate && filterFromDate === filterToDate) return filterFromDate
    if (!filterFromDate && filterToDate) return filterToDate
    return localDateKey(new Date(nowMs))
  }, [filterExactDate, filterFromDate, filterMode, filterToDate, nowMs])

  const dailyLoad = React.useMemo(() => {
    const dayTodos = todos.filter((t) => getDatePart(t.dueAt) === loadDayKey)
    return getDailyLoad(dayTodos)
  }, [loadDayKey, todos])

  const summary = React.useMemo(() => {
    const now = new Date(nowMs)
    const todayKey = localDateKey(now)
    const tomorrow = addDays(now, 1)
    const tomorrowKey = localDateKey(tomorrow)
    const labels = dailyLoad.labels

    const todays = todos.filter((t) => t.dueAt.startsWith(todayKey))
    const todayCompleted = todays.filter((t) => t.completed).length
    const todayPending = todays.length - todayCompleted

    const tomorrowTasks = todos.filter((t) => t.dueAt.startsWith(tomorrowKey))
    const tomorrowBuckets = Array.from({ length: 6 }, () => 0) as number[]
    for (const t of tomorrowTasks) {
      const hour = new Date(parseLocalDateTime(t.dueAt)).getHours()
      tomorrowBuckets[Math.floor(hour / 4)]++
    }

    const rangeStart = startOfDay(tomorrow).getTime()
    const rangeEnd = addDays(startOfDay(tomorrow), 7).getTime()
    const buckets = Array.from({ length: 6 }, () => 0) as number[]
    const upcoming = todos.filter((t) => {
      const ms = parseLocalDateTime(t.dueAt)
      return ms >= rangeStart && ms < rangeEnd
    })
    for (const t of upcoming) {
      const hour = new Date(parseLocalDateTime(t.dueAt)).getHours()
      buckets[Math.floor(hour / 4)]++
    }

    return {
      todayCompleted,
      todayPending,
      tomorrowTotal: tomorrowTasks.length,
      tomorrowBuckets: labels.map((label, i) => ({ label, count: tomorrowBuckets[i] ?? 0 })),
      upcomingTotal: upcoming.length,
      upcomingBuckets: labels.map((label, i) => ({ label, count: buckets[i] ?? 0 })),
    }
  }, [dailyLoad.labels, nowMs, todos])

  return (
    <Card>
      <CardHeader className="flex flex-row items-center justify-between gap-4">
        <div className="space-y-1">
          <div className="flex flex-row items-center gap-2">
        <UserMenu userId={userId} onSignedOut={onSignedOut} />
          <CardTitle className="text-2xl">To‑Do</CardTitle>
          </div>
          <p className="text-muted-foreground text-sm">
            {completedCount}/{filteredTodos.length} completed
          </p>
        </div>

        <div className="flex items-center gap-2">
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <Button
                  type="button"
                  variant={focusMode ? "default" : "outline"}
                  size="sm"
                  onClick={() => {
                    setFocusMode((v) => !v)
                    setPage(1)
                  }}
                >
                  Focus Mode
                </Button>
              </TooltipTrigger>
              <TooltipContent>
                <p>Show tasks for the next 4 hours.</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>

        
          <ModeToggle />
        </div>
      </CardHeader>

      <CardContent className="space-y-6">
        {tasksLoading && <p className="text-muted-foreground text-sm">Loading tasks…</p>}

        {!tasksLoading && tasksError?.code === "MISSING_TABLE" && (
          <Alert variant="destructive">
            <AlertTitle>Database not initialized</AlertTitle>
            <AlertDescription>
              <div className="space-y-2">
                <p>
                  The Supabase table <code>public.tasks</code> was not found. Run the SQL in{" "}
                  <code>supabase/schema.sql</code> (Supabase Dashboard → SQL Editor), then refresh.
                </p>
                <p className="text-xs opacity-90">{tasksError.message}</p>
              </div>
            </AlertDescription>
          </Alert>
        )}

        {!tasksLoading && tasksError && tasksError.code !== "MISSING_TABLE" && (
          <Alert variant="destructive">
            <AlertTitle>Failed to load tasks</AlertTitle>
            <AlertDescription>{tasksError.message}</AlertDescription>
          </Alert>
        )}

        {!tasksLoading && todos.length === 0 && (
          <div className="flex items-center justify-between gap-3 rounded-lg border bg-muted/20 px-3 py-2">
            <p className="text-muted-foreground text-sm">No tasks yet.</p>
            <Button type="button" variant="outline" size="sm" onClick={() => void seedDemoTasks()}>
              Seed demo tasks
            </Button>
          </div>
        )}

        <input
          ref={fileInputRef}
          type="file"
          multiple
          className="hidden"
          accept={[
            "image/*",
            "audio/*",
            "video/*",
            ".pdf",
            ".doc",
            ".docx",
            ".xls",
            ".xlsx",
            ".csv",
            ".txt",
            ".md",
            ".rtf",
          ].join(",")}
          onChange={handleFilesPicked}
        />

        {reminder && (
          <Alert className="border-primary/30 bg-primary/5">
            <Bell className="h-4 w-4" />
            <div className="flex flex-1 flex-col gap-1">
              <div className="flex flex-wrap items-center justify-between gap-2">
                <AlertTitle className="text-sm">
                  Next task starts in {reminder.mins} minute{reminder.mins === 1 ? "" : "s"}
                </AlertTitle>
                <Button
                  type="button"
                  variant="ghost"
                  size="sm"
                  onClick={() => setDismissedReminderTaskId(reminder.todo.id)}
                >
                  Dismiss
                </Button>
              </div>
              <AlertDescription className="text-sm">
                <span className="font-medium">{reminder.todo.title}</span> ·{" "}
                {formatDateTimeFromMs(reminder.dueMs)}
              </AlertDescription>
            </div>
          </Alert>
        )}

        <div className="rounded-xl border bg-card p-4">
          <div className="flex flex-wrap items-center justify-between gap-2">
            <p className="text-sm font-medium">
              Daily load{" "}
              <span className="text-muted-foreground font-normal">
                ({new Intl.DateTimeFormat(undefined, {
                  weekday: "short",
                  year: "numeric",
                  month: "short",
                  day: "2-digit",
                }).format(parseLocalDateOnly(loadDayKey))})
              </span>
            </p>
            <DailyLoadBadge load={dailyLoad.load} />
          </div>
          <p className="text-muted-foreground mt-2 text-sm">
            {dailyLoad.total} task(s) · busiest window {dailyLoad.busiestWindow} ({dailyLoad.peak})
          </p>
        </div>

        <div className="grid gap-3 sm:grid-cols-3">
          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Today’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">{summary.todayCompleted} completed</p>
            <p className="text-muted-foreground text-sm">{summary.todayPending} pending</p>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tomorrow’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">{summary.tomorrowTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.tomorrowBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tasks Until Next Week</p>
            <p className="mt-2 text-2xl font-semibold">{summary.upcomingTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.upcomingBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>
        </div>

        {focusMode && (
          <div className="flex flex-col gap-1 rounded-lg border bg-muted/20 px-3 py-2 sm:flex-row sm:items-center sm:justify-between">
            <p className="text-sm">
              <span className="font-medium">Focus Mode:</span> showing tasks due in the next 4 hours
              (until <span className="font-medium">{formatDateTimeFromMs(nowMs + 4 * 60 * 60 * 1000)}</span>)
            </p>
            <Button type="button" variant="ghost" size="sm" onClick={() => setFocusMode(false)}>
              Exit
            </Button>
          </div>
        )}

        <TaskForm onAdd={addTodo} />

        <Separator />

        <div className="space-y-3">
          <div className="flex flex-wrap items-center justify-between gap-2">
            <p className="text-sm font-medium">Filter by date & time</p>
            <div className="flex items-center gap-2">
              <Button
                type="button"
                size="sm"
                variant={filterMode === "between" ? "default" : "outline"}
                onClick={() => setFilterMode("between")}
              >
                Between
              </Button>
              <Button
                type="button"
                size="sm"
                variant={filterMode === "exact" ? "default" : "outline"}
                onClick={() => setFilterMode("exact")}
              >
                Exact
              </Button>
              <Button
                type="button"
                size="sm"
                variant="ghost"
                onClick={() => {
                  setFilterFromDate("")
                  setFilterFromTime("")
                  setFilterToDate("")
                  setFilterToTime("")
                  setFilterExactDate("")
                  setFilterExactTime("")
                }}
              >
                Clear
              </Button>
            </div>
          </div>

          {filterMode === "between" ? (
            <div className="grid gap-2 sm:grid-cols-2">
              <div className="grid gap-2 sm:grid-cols-2">
                <Input type="date" value={filterFromDate} onChange={(e) => setFilterFromDate(e.target.value)} />
                <Input type="time" value={filterFromTime} onChange={(e) => setFilterFromTime(e.target.value)} />
              </div>
              <div className="grid gap-2 sm:grid-cols-2">
                <Input type="date" value={filterToDate} onChange={(e) => setFilterToDate(e.target.value)} />
                <Input type="time" value={filterToTime} onChange={(e) => setFilterToTime(e.target.value)} />
              </div>
            </div>
          ) : (
            <div className="grid gap-2 sm:grid-cols-2">
              <Input type="date" value={filterExactDate} onChange={(e) => setFilterExactDate(e.target.value)} />
              <Input type="time" value={filterExactTime} onChange={(e) => setFilterExactTime(e.target.value)} />
            </div>
          )}
        </div>

        <Separator />

        <TaskList
          groups={groupedTodos}
          nowMs={nowMs}
          inProgressTaskId={inProgressTaskId}
          conflictDueAt={conflictDueAt}
          onToggleCompleted={(id, completed) => void toggleTodo(id, completed)}
          onToggleInProgress={(id, isInProgress) => void setInProgress(isInProgress ? null : id)}
          onDelete={(id) => void deleteTodo(id)}
          onAddFiles={(id) => void requestAttachmentsForTodo(id)}
          onDownloadAttachment={(a) => void downloadAttachment(a)}
        />

        <div className="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
          <div className="flex items-center gap-2">
            <span className="text-muted-foreground text-sm">Items per page</span>
            <Select
              value={String(pageSize)}
              onValueChange={(v) => {
                const next = Number(v)
                setPageSize(next)
                setPage(1)
              }}
            >
              <SelectTrigger className="w-[110px]">
                <SelectValue />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="5">5</SelectItem>
                <SelectItem value="10">10</SelectItem>
                <SelectItem value="15">15</SelectItem>
                <SelectItem value="20">20</SelectItem>
              </SelectContent>
            </Select>
          </div>

          {showPagination && (
            <div className="flex items-center justify-between gap-3 sm:justify-end">
              <Button
                type="button"
                variant="outline"
                size="sm"
                onClick={() => setPage((p) => Math.max(1, p - 1))}
                disabled={page <= 1}
              >
                Prev
              </Button>
              <span className="text-muted-foreground text-sm">
                Page {page} of {totalPages}
              </span>
              <Button
                type="button"
                variant="outline"
                size="sm"
                onClick={() => setPage((p) => Math.min(totalPages, p + 1))}
                disabled={page >= totalPages}
              >
                Next
              </Button>
            </div>
          )}
        </div>

        <div className="flex items-center justify-between gap-2">
          <Button
            type="button"
            variant="secondary"
            onClick={() => void clearCompleted()}
            disabled={completedCount === 0}
          >
            Clear completed
          </Button>
          <span className="text-muted-foreground text-sm">Supabase-backed</span>
        </div>
      </CardContent>
    </Card>
  )
}


```

```typescriptreact
"use client"

import * as React from "react"
import { Bell } from "lucide-react"
import { toast } from "sonner"

import type { DailyLoad, Todo } from "./types"
import { initialTodos } from "./mock-data"
import { TaskForm } from "./TaskForm"
import { TaskList } from "./TaskList"
import { UserMenu } from "./UserMenu"

import { apiFetch, ApiError } from "@/lib/api-client"
import { ModeToggle } from "@/components/mode-toggle"
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert"
import { Badge } from "@/components/ui/badge"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Input } from "@/components/ui/input"
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select"
import { Separator } from "@/components/ui/separator"
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip"

import type { TodoFormValues } from "./schemas"
import {
  addDays,
  endOfDay,
  formatDateTimeFromMs,
  formatLocalDateTime,
  getDailyLoad,
  getDatePart,
  getTimePart,
  localDateKey,
  minutesUntil,
  parseLocalDateOnly,
  parseLocalDateTime,
  parseLocalTimeToMinutes,
  startOfDay,
} from "./utils"

function DailyLoadBadge({ load }: { load: DailyLoad }) {
  if (load === "heavy") return <Badge variant="destructive">Heavy</Badge>
  if (load === "balanced") return <Badge variant="secondary">Balanced</Badge>
  return <Badge variant="outline">Light</Badge>
}

export function TodoApp({ userId, onSignedOut }: { userId: string; onSignedOut: () => void }) {
  const [todos, setTodos] = React.useState<Todo[]>([])
  const [tasksLoading, setTasksLoading] = React.useState(true)
  const [tasksError, setTasksError] = React.useState<{ code?: string; message: string } | null>(
    null
  )

  const [attachTargetTodoId, setAttachTargetTodoId] = React.useState<string | null>(null)
  const fileInputRef = React.useRef<HTMLInputElement>(null)

  const [conflictDueAt, setConflictDueAt] = React.useState<string | null>(null)
  const clearConflictTimerRef = React.useRef<number | null>(null)

  const [focusMode, setFocusMode] = React.useState(false)
  const [nowMs, setNowMs] = React.useState(() => Date.now())
  const [inProgressTaskId, setInProgressTaskId] = React.useState<string | null>(null)

  const [dismissedReminderTaskId, setDismissedReminderTaskId] = React.useState<string | null>(null)

  const [filterMode, setFilterMode] = React.useState<"between" | "exact">("between")
  const [filterFromDate, setFilterFromDate] = React.useState<string>("")
  const [filterFromTime, setFilterFromTime] = React.useState<string>("")
  const [filterToDate, setFilterToDate] = React.useState<string>("")
  const [filterToTime, setFilterToTime] = React.useState<string>("")
  const [filterExactDate, setFilterExactDate] = React.useState<string>("")
  const [filterExactTime, setFilterExactTime] = React.useState<string>("")

  const [pageSize, setPageSize] = React.useState<number>(5)
  const [page, setPage] = React.useState<number>(1)

  React.useEffect(() => {
    const id = window.setInterval(() => setNowMs(Date.now()), 30_000)
    return () => window.clearInterval(id)
  }, [])

  React.useEffect(() => {
    if (!inProgressTaskId) return
    const t = todos.find((x) => x.id === inProgressTaskId)
    if (!t || t.completed) setInProgressTaskId(null)
  }, [inProgressTaskId, todos])

  React.useEffect(() => {
    let alive = true
    async function load() {
      setTasksLoading(true)
      try {
        const data = await apiFetch<{ tasks: Todo[]; inProgressTaskId: string | null }>("/api/tasks")
        if (!alive) return
        setTodos(data.tasks)
        setInProgressTaskId(data.inProgressTaskId)
        setTasksError(null)
      } catch (e) {
        if (!alive) return
        if (e instanceof ApiError) setTasksError({ code: e.code, message: e.message })
        else setTasksError({ message: e instanceof Error ? e.message : "Failed to load tasks." })
        setTodos([])
        setInProgressTaskId(null)
      } finally {
        if (!alive) return
        setTasksLoading(false)
      }
    }
    void load()
    return () => {
      alive = false
    }
  }, [])

  const nextUpcoming = React.useMemo(() => {
    const upcoming = todos
      .filter((t) => !t.completed)
      .map((t) => ({ todo: t, dueMs: parseLocalDateTime(t.dueAt) }))
      .filter((x) => x.dueMs >= nowMs)
      .sort((a, b) => a.dueMs - b.dueMs)[0]
    return upcoming ?? null
  }, [nowMs, todos])

  React.useEffect(() => {
    if (nextUpcoming && nextUpcoming.todo.id !== dismissedReminderTaskId) return
    if (!nextUpcoming) setDismissedReminderTaskId(null)
  }, [dismissedReminderTaskId, nextUpcoming])

  const reminder = React.useMemo(() => {
    const REMINDER_WINDOW_MIN = 15
    if (!nextUpcoming) return null
    if (dismissedReminderTaskId === nextUpcoming.todo.id) return null
    const mins = minutesUntil(nextUpcoming.dueMs, nowMs)
    if (mins < 0 || mins > REMINDER_WINDOW_MIN) return null
    return { ...nextUpcoming, mins }
  }, [dismissedReminderTaskId, nextUpcoming, nowMs])

  const filteredTodos = React.useMemo(() => {
    if (focusMode) {
      const endMs = nowMs + 4 * 60 * 60 * 1000
      return todos.filter((t) => {
        const ms = parseLocalDateTime(t.dueAt)
        return ms >= nowMs && ms <= endMs
      })
    }

    if (filterMode === "exact") {
      if (!filterExactDate && !filterExactTime) return todos
      if (filterExactDate && !filterExactTime) {
        return todos.filter((t) => getDatePart(t.dueAt) === filterExactDate)
      }
      if (filterExactDate && filterExactTime) {
        const exactMs = parseLocalDateTime(`${filterExactDate}T${filterExactTime}`)
        return todos.filter((t) => parseLocalDateTime(t.dueAt) === exactMs)
      }
      return todos.filter((t) => getTimePart(t.dueAt) === filterExactTime)
    }

    const hasAnyDate = Boolean(filterFromDate || filterToDate)
    const hasAnyTime = Boolean(filterFromTime || filterToTime)

    const fromDateMs = filterFromDate
      ? startOfDay(parseLocalDateOnly(filterFromDate)).getTime()
      : Number.NEGATIVE_INFINITY
    const toDateMs = filterToDate
      ? endOfDay(parseLocalDateOnly(filterToDate)).getTime()
      : Number.POSITIVE_INFINITY

    const fromTimeMin = filterFromTime ? parseLocalTimeToMinutes(filterFromTime) : 0
    const toTimeMin = filterToTime ? parseLocalTimeToMinutes(filterToTime) : 24 * 60 - 1

    return todos.filter((t) => {
      const ms = parseLocalDateTime(t.dueAt)
      if (hasAnyDate && (ms < fromDateMs || ms > toDateMs)) return false
      if (hasAnyTime) {
        const time = getTimePart(t.dueAt)
        if (!time) return false
        const mins = parseLocalTimeToMinutes(time)
        if (mins < fromTimeMin || mins > toTimeMin) return false
      }
      return true
    })
  }, [
    todos,
    focusMode,
    nowMs,
    filterMode,
    filterExactDate,
    filterExactTime,
    filterFromDate,
    filterFromTime,
    filterToDate,
    filterToTime,
  ])

  const sortedFilteredTodos = React.useMemo(
    () =>
      filteredTodos
        .slice()
        .sort((a, b) => parseLocalDateTime(a.dueAt) - parseLocalDateTime(b.dueAt)),
    [filteredTodos]
  )

  React.useEffect(() => {
    const totalPages = Math.max(1, Math.ceil(sortedFilteredTodos.length / pageSize))
    setPage((p) => Math.min(Math.max(1, p), totalPages))
  }, [pageSize, sortedFilteredTodos.length])

  const totalItems = sortedFilteredTodos.length
  const totalPages = Math.max(1, Math.ceil(totalItems / pageSize))
  const showPagination = totalPages > 1

  const pageItems = React.useMemo(() => {
    const start = (page - 1) * pageSize
    return sortedFilteredTodos.slice(start, start + pageSize)
  }, [page, pageSize, sortedFilteredTodos])

  const groupedTodos = React.useMemo(() => {
    const groups: Array<{ date: string; items: Todo[] }> = []
    for (const t of pageItems) {
      const date = getDatePart(t.dueAt)
      const last = groups[groups.length - 1]
      if (!last || last.date !== date) groups.push({ date, items: [t] })
      else last.items.push(t)
    }
    return groups
  }, [pageItems])

  const completedCount = filteredTodos.filter((t) => t.completed).length

  async function requestAttachmentsForTodo(todoId: string) {
    setAttachTargetTodoId(todoId)
    queueMicrotask(() => fileInputRef.current?.click())
  }

  async function handleFilesPicked(e: React.ChangeEvent<HTMLInputElement>) {
    const files = Array.from(e.target.files ?? [])
    const targetId = attachTargetTodoId
    e.target.value = ""
    setAttachTargetTodoId(null)
    if (!targetId || files.length === 0) return

    const form = new FormData()
    for (const f of files) form.append("files", f)

    try {
      const res = await fetch(`/api/tasks/${targetId}/attachments`, {
        method: "POST",
        credentials: "include",
        body: form,
      })
      const json = (await res.json().catch(() => null)) as
        | { ok: true; data: { task: Todo } }
        | { ok: false; error: { message: string } }
        | null
      if (!json || !json.ok) throw new Error(json?.error.message ?? "Upload failed.")
      setTodos((prev) => prev.map((t) => (t.id === targetId ? json.data.task : t)))
    } catch (err) {
      toast.error("Upload failed", { description: err instanceof Error ? err.message : "Failed." })
    }
  }

  async function addTodo(values: TodoFormValues) {
    const conflicts = todos.filter((t) => t.dueAt === values.dueAt)
    if (conflicts.length > 0) {
      setConflictDueAt(values.dueAt)
      if (clearConflictTimerRef.current) window.clearTimeout(clearConflictTimerRef.current)
      clearConflictTimerRef.current = window.setTimeout(() => setConflictDueAt(null), 8000)

      const [d, time] = values.dueAt.split("T")
      setFilterMode("exact")
      setFilterExactDate(d ?? "")
      setFilterExactTime(time ?? "")
      setPage(1)

      toast.error("Time conflict", {
        description: `You already have ${conflicts.length} task(s) scheduled at ${formatLocalDateTime(
          values.dueAt
        )}.`,
      })
    }

    const data = await apiFetch<{ task: Todo }>("/api/tasks", {
      method: "POST",
      body: JSON.stringify(values),
    })
    setTodos((prev) => [data.task, ...prev])
  }

  async function toggleTodo(id: string, completed: boolean) {
    const before = todos.find((t) => t.id === id)
    setTodos((prev) => prev.map((t) => (t.id === id ? { ...t, completed } : t)))
    if (completed) setInProgressTaskId((cur) => (cur === id ? null : cur))

    try {
      await apiFetch("/api/tasks/" + id, { method: "PATCH", body: JSON.stringify({ completed }) })
    } catch (e) {
      toast.error("Failed to update task", { description: e instanceof Error ? e.message : "Failed." })
    }

    if (completed && before && !before.completed) {
      await requestAttachmentsForTodo(id)
    }
  }

  async function deleteTodo(id: string) {
    setTodos((prev) => prev.filter((t) => t.id !== id))
    setInProgressTaskId((cur) => (cur === id ? null : cur))
    try {
      await apiFetch("/api/tasks/" + id, { method: "DELETE" })
    } catch (e) {
      toast.error("Failed to delete task", { description: e instanceof Error ? e.message : "Failed." })
    }
  }

  async function clearCompleted() {
    const completedIds = new Set(todos.filter((t) => t.completed).map((t) => t.id))
    if (completedIds.size === 0) return
    setTodos((prev) => prev.filter((t) => !completedIds.has(t.id)))
    try {
      await apiFetch("/api/tasks/clear-completed", { method: "POST" })
    } catch (e) {
      toast.error("Failed to clear completed", { description: e instanceof Error ? e.message : "Failed." })
    }
  }

  async function setInProgress(taskId: string | null) {
    setInProgressTaskId(taskId)
    try {
      const data = await apiFetch<{ inProgressTaskId: string | null }>("/api/tasks/in-progress", {
        method: "POST",
        body: JSON.stringify({ id: taskId }),
      })
      setInProgressTaskId(data.inProgressTaskId)
    } catch (e) {
      toast.error("Failed to update in-progress", { description: e instanceof Error ? e.message : "Failed." })
    }
  }

  async function downloadAttachment(a: Todo["attachments"][number]) {
    const data = await apiFetch<{ signedUrl: string }>("/api/attachments/signed-url", {
      method: "POST",
      body: JSON.stringify({ bucket: a.bucket, path: a.path }),
    })
    window.open(data.signedUrl, "_blank", "noopener,noreferrer")
  }

  async function deleteAttachment(todoId: string, attachmentId: string) {
    try {
      const data = await apiFetch<{ task: Todo }>(`/api/tasks/${todoId}/attachments/delete`, {
        method: "POST",
        body: JSON.stringify({ attachmentId }),
      })
      setTodos((prev) => prev.map((t) => (t.id === todoId ? data.task : t)))
    } catch (e) {
      toast.error("Failed to remove attachment", {
        description: e instanceof Error ? e.message : "Failed.",
      })
    }
  }

  async function seedDemoTasks() {
    if (todos.length > 0) return
    const data = await apiFetch<{ tasks: Todo[] }>("/api/tasks/seed", {
      method: "POST",
      body: JSON.stringify({ tasks: initialTodos }),
    })
    setTodos(data.tasks)
  }

  const loadDayKey = React.useMemo(() => {
    if (filterMode === "exact" && filterExactDate) return filterExactDate
    if (filterFromDate && !filterToDate) return filterFromDate
    if (filterFromDate && filterToDate && filterFromDate === filterToDate) return filterFromDate
    if (!filterFromDate && filterToDate) return filterToDate
    return localDateKey(new Date(nowMs))
  }, [filterExactDate, filterFromDate, filterMode, filterToDate, nowMs])

  const dailyLoad = React.useMemo(() => {
    const dayTodos = todos.filter((t) => getDatePart(t.dueAt) === loadDayKey)
    return getDailyLoad(dayTodos)
  }, [loadDayKey, todos])

  const summary = React.useMemo(() => {
    const now = new Date(nowMs)
    const todayKey = localDateKey(now)
    const tomorrow = addDays(now, 1)
    const tomorrowKey = localDateKey(tomorrow)
    const labels = dailyLoad.labels

    const todays = todos.filter((t) => t.dueAt.startsWith(todayKey))
    const todayCompleted = todays.filter((t) => t.completed).length
    const todayPending = todays.length - todayCompleted

    const tomorrowTasks = todos.filter((t) => t.dueAt.startsWith(tomorrowKey))
    const tomorrowBuckets = Array.from({ length: 6 }, () => 0) as number[]
    for (const t of tomorrowTasks) {
      const hour = new Date(parseLocalDateTime(t.dueAt)).getHours()
      tomorrowBuckets[Math.floor(hour / 4)]++
    }

    const rangeStart = startOfDay(tomorrow).getTime()
    const rangeEnd = addDays(startOfDay(tomorrow), 7).getTime()
    const buckets = Array.from({ length: 6 }, () => 0) as number[]
    const upcoming = todos.filter((t) => {
      const ms = parseLocalDateTime(t.dueAt)
      return ms >= rangeStart && ms < rangeEnd
    })
    for (const t of upcoming) {
      const hour = new Date(parseLocalDateTime(t.dueAt)).getHours()
      buckets[Math.floor(hour / 4)]++
    }

    return {
      todayCompleted,
      todayPending,
      tomorrowTotal: tomorrowTasks.length,
      tomorrowBuckets: labels.map((label, i) => ({ label, count: tomorrowBuckets[i] ?? 0 })),
      upcomingTotal: upcoming.length,
      upcomingBuckets: labels.map((label, i) => ({ label, count: buckets[i] ?? 0 })),
    }
  }, [dailyLoad.labels, nowMs, todos])

  return (
    <Card>
      <CardHeader className="flex flex-row items-center justify-between gap-4">
        <div className="space-y-1">
          <div className="flex flex-row items-center gap-2">
        <UserMenu userId={userId} onSignedOut={onSignedOut} />
          <CardTitle className="text-2xl">To‑Do</CardTitle>
          </div>
          <p className="text-muted-foreground text-sm">
            {completedCount}/{filteredTodos.length} completed
          </p>
        </div>

        <div className="flex items-center gap-2">
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <Button
                  type="button"
                  variant={focusMode ? "default" : "outline"}
                  size="sm"
                  onClick={() => {
                    setFocusMode((v) => !v)
                    setPage(1)
                  }}
                >
                  Focus Mode
                </Button>
              </TooltipTrigger>
              <TooltipContent>
                <p>Show tasks for the next 4 hours.</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>

        
          <ModeToggle />
        </div>
      </CardHeader>

      <CardContent className="space-y-6">
        {tasksLoading && <p className="text-muted-foreground text-sm">Loading tasks…</p>}

        {!tasksLoading && tasksError?.code === "MISSING_TABLE" && (
          <Alert variant="destructive">
            <AlertTitle>Database not initialized</AlertTitle>
            <AlertDescription>
              <div className="space-y-2">
                <p>
                  The Supabase table <code>public.tasks</code> was not found. Run the SQL in{" "}
                  <code>supabase/schema.sql</code> (Supabase Dashboard → SQL Editor), then refresh.
                </p>
                <p className="text-xs opacity-90">{tasksError.message}</p>
              </div>
            </AlertDescription>
          </Alert>
        )}

        {!tasksLoading && tasksError && tasksError.code !== "MISSING_TABLE" && (
          <Alert variant="destructive">
            <AlertTitle>Failed to load tasks</AlertTitle>
            <AlertDescription>{tasksError.message}</AlertDescription>
          </Alert>
        )}

        {!tasksLoading && todos.length === 0 && (
          <div className="flex items-center justify-between gap-3 rounded-lg border bg-muted/20 px-3 py-2">
            <p className="text-muted-foreground text-sm">No tasks yet.</p>
            <Button type="button" variant="outline" size="sm" onClick={() => void seedDemoTasks()}>
              Seed demo tasks
            </Button>
          </div>
        )}

        <input
          ref={fileInputRef}
          type="file"
          multiple
          className="hidden"
          accept={[
            "image/*",
            "audio/*",
            "video/*",
            ".pdf",
            ".doc",
            ".docx",
            ".xls",
            ".xlsx",
            ".csv",
            ".txt",
            ".md",
            ".rtf",
          ].join(",")}
          onChange={handleFilesPicked}
        />

        {reminder && (
          <Alert className="border-primary/30 bg-primary/5">
            <Bell className="h-4 w-4" />
            <div className="flex flex-1 flex-col gap-1">
              <div className="flex flex-wrap items-center justify-between gap-2">
                <AlertTitle className="text-sm">
                  Next task starts in {reminder.mins} minute{reminder.mins === 1 ? "" : "s"}
                </AlertTitle>
                <Button
                  type="button"
                  variant="ghost"
                  size="sm"
                  onClick={() => setDismissedReminderTaskId(reminder.todo.id)}
                >
                  Dismiss
                </Button>
              </div>
              <AlertDescription className="text-sm">
                <span className="font-medium">{reminder.todo.title}</span> ·{" "}
                {formatDateTimeFromMs(reminder.dueMs)}
              </AlertDescription>
            </div>
          </Alert>
        )}

        <div className="rounded-xl border bg-card p-4">
          <div className="flex flex-wrap items-center justify-between gap-2">
            <p className="text-sm font-medium">
              Daily load{" "}
              <span className="text-muted-foreground font-normal">
                ({new Intl.DateTimeFormat(undefined, {
                  weekday: "short",
                  year: "numeric",
                  month: "short",
                  day: "2-digit",
                }).format(parseLocalDateOnly(loadDayKey))})
              </span>
            </p>
            <DailyLoadBadge load={dailyLoad.load} />
          </div>
          <p className="text-muted-foreground mt-2 text-sm">
            {dailyLoad.total} task(s) · busiest window {dailyLoad.busiestWindow} ({dailyLoad.peak})
          </p>
        </div>

        <div className="grid gap-3 sm:grid-cols-3">
          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Today’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">{summary.todayCompleted} completed</p>
            <p className="text-muted-foreground text-sm">{summary.todayPending} pending</p>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tomorrow’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">{summary.tomorrowTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.tomorrowBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tasks Until Next Week</p>
            <p className="mt-2 text-2xl font-semibold">{summary.upcomingTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.upcomingBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>
        </div>

        {focusMode && (
          <div className="flex flex-col gap-1 rounded-lg border bg-muted/20 px-3 py-2 sm:flex-row sm:items-center sm:justify-between">
            <p className="text-sm">
              <span className="font-medium">Focus Mode:</span> showing tasks due in the next 4 hours
              (until <span className="font-medium">{formatDateTimeFromMs(nowMs + 4 * 60 * 60 * 1000)}</span>)
            </p>
            <Button type="button" variant="ghost" size="sm" onClick={() => setFocusMode(false)}>
              Exit
            </Button>
          </div>
        )}

        <TaskForm onAdd={addTodo} />

        <Separator />

        <div className="space-y-3">
          <div className="flex flex-wrap items-center justify-between gap-2">
            <p className="text-sm font-medium">Filter by date & time</p>
            <div className="flex items-center gap-2">
              <Button
                type="button"
                size="sm"
                variant={filterMode === "between" ? "default" : "outline"}
                onClick={() => setFilterMode("between")}
              >
                Between
              </Button>
              <Button
                type="button"
                size="sm"
                variant={filterMode === "exact" ? "default" : "outline"}
                onClick={() => setFilterMode("exact")}
              >
                Exact
              </Button>
              <Button
                type="button"
                size="sm"
                variant="ghost"
                onClick={() => {
                  setFilterFromDate("")
                  setFilterFromTime("")
                  setFilterToDate("")
                  setFilterToTime("")
                  setFilterExactDate("")
                  setFilterExactTime("")
                }}
              >
                Clear
              </Button>
            </div>
          </div>

          {filterMode === "between" ? (
            <div className="grid gap-2 sm:grid-cols-2">
              <div className="grid gap-2 sm:grid-cols-2">
                <Input type="date" value={filterFromDate} onChange={(e) => setFilterFromDate(e.target.value)} />
                <Input type="time" value={filterFromTime} onChange={(e) => setFilterFromTime(e.target.value)} />
              </div>
              <div className="grid gap-2 sm:grid-cols-2">
                <Input type="date" value={filterToDate} onChange={(e) => setFilterToDate(e.target.value)} />
                <Input type="time" value={filterToTime} onChange={(e) => setFilterToTime(e.target.value)} />
              </div>
            </div>
          ) : (
            <div className="grid gap-2 sm:grid-cols-2">
              <Input type="date" value={filterExactDate} onChange={(e) => setFilterExactDate(e.target.value)} />
              <Input type="time" value={filterExactTime} onChange={(e) => setFilterExactTime(e.target.value)} />
            </div>
          )}
        </div>

        <Separator />

        <TaskList
          groups={groupedTodos}
          nowMs={nowMs}
          inProgressTaskId={inProgressTaskId}
          conflictDueAt={conflictDueAt}
          onToggleCompleted={(id, completed) => void toggleTodo(id, completed)}
          onToggleInProgress={(id, isInProgress) => void setInProgress(isInProgress ? null : id)}
          onDelete={(id) => void deleteTodo(id)}
          onAddFiles={(id) => void requestAttachmentsForTodo(id)}
          onDownloadAttachment={(a) => void downloadAttachment(a)}
          onDeleteAttachment={(todoId, a) => void deleteAttachment(todoId, a.id)}
        />

        <div className="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
          <div className="flex items-center gap-2">
            <span className="text-muted-foreground text-sm">Items per page</span>
            <Select
              value={String(pageSize)}
              onValueChange={(v) => {
                const next = Number(v)
                setPageSize(next)
                setPage(1)
              }}
            >
              <SelectTrigger className="w-[110px]">
                <SelectValue />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="5">5</SelectItem>
                <SelectItem value="10">10</SelectItem>
                <SelectItem value="15">15</SelectItem>
                <SelectItem value="20">20</SelectItem>
              </SelectContent>
            </Select>
          </div>

          {showPagination && (
            <div className="flex items-center justify-between gap-3 sm:justify-end">
              <Button
                type="button"
                variant="outline"
                size="sm"
                onClick={() => setPage((p) => Math.max(1, p - 1))}
                disabled={page <= 1}
              >
                Prev
              </Button>
              <span className="text-muted-foreground text-sm">
                Page {page} of {totalPages}
              </span>
              <Button
                type="button"
                variant="outline"
                size="sm"
                onClick={() => setPage((p) => Math.min(totalPages, p + 1))}
                disabled={page >= totalPages}
              >
                Next
              </Button>
            </div>
          )}
        </div>

        <div className="flex items-center justify-between gap-2">
          <Button
            type="button"
            variant="secondary"
            onClick={() => void clearCompleted()}
            disabled={completedCount === 0}
          >
            Clear completed
          </Button>
          <span className="text-muted-foreground text-sm">Supabase-backed</span>
        </div>
      </CardContent>
    </Card>
  )
}


```

### Added attachment delete button (icon-only)
- In the task attachment list, each attachment now has a **small trash icon button** to remove it.

### How it works
- Clicking the trash icon will:
  - **Delete the file from Supabase Storage**
  - **Remove the attachment from the task’s `attachments` JSON**
  - Update the UI with the returned updated task

### Files changed
- **UI**
  - `src/components/todo/TaskList.tsx` (added icon delete button)
  - `src/components/todo/TodoApp.tsx` (wired handler to API + updates state)
- **API**
  - `src/app/api/tasks/[id]/attachments/delete/route.ts` (delete storage object + update task)

Build verified ✅

---

**User**

When a task is marked as completed, it should not have a Delete button.

---

**Cursor**

Plan: I’ll update the task row actions so the **Delete** (trash) button only appears for **non-completed** tasks. Completed tasks will still allow **Add files** and attachment management. Then I’ll run a quick build to confirm.

```typescriptreact
"use client"

import * as React from "react"
import {
  CirclePlay,
  CircleStop,
  Download,
  Trash2,
  File,
  FileSpreadsheet,
  FileText,
  Image as ImageIcon,
  Info,
  Music,
  Video,
} from "lucide-react"

import type { AttachmentKind, Todo } from "./types"
import { cn } from "@/lib/utils"
import { formatLocalDateTime, parseLocalDateOnly, parseLocalDateTime } from "./utils"
import { getTaskFlags } from "./utils"

import { Button } from "@/components/ui/button"
import { Checkbox } from "@/components/ui/checkbox"
import { Separator } from "@/components/ui/separator"
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip"
import { Badge } from "@/components/ui/badge"

function AttachmentIcon({ kind }: { kind: AttachmentKind }) {
  const className = "h-4 w-4 text-muted-foreground"
  switch (kind) {
    case "image":
      return <ImageIcon className={className} />
    case "audio":
      return <Music className={className} />
    case "video":
      return <Video className={className} />
    case "spreadsheet":
      return <FileSpreadsheet className={className} />
    case "pdf":
    case "document":
    case "text":
      return <FileText className={className} />
    default:
      return <File className={className} />
  }
}

function TaskBadges({
  completed,
  overdue,
  inProgress,
  planned,
}: {
  completed: boolean
  overdue: boolean
  inProgress: boolean
  planned: boolean
}) {
  if (completed) {
    return (
      <Badge className="gap-1 bg-emerald-600 text-white hover:bg-emerald-600">Completed</Badge>
    )
  }
  return (
    <span className="flex flex-wrap items-center gap-2">
      {inProgress && <Badge className="bg-sky-600 text-white hover:bg-sky-600">In progress</Badge>}
      {overdue && <Badge variant="destructive">Overdue</Badge>}
      {planned && <Badge variant="outline">Planned</Badge>}
    </span>
  )
}

export function TaskList({
  groups,
  nowMs,
  inProgressTaskId,
  conflictDueAt,
  onToggleCompleted,
  onToggleInProgress,
  onDelete,
  onAddFiles,
  onDownloadAttachment,
  onDeleteAttachment,
}: {
  groups: Array<{ date: string; items: Todo[] }>
  nowMs: number
  inProgressTaskId: string | null
  conflictDueAt: string | null
  onToggleCompleted: (id: string, completed: boolean) => void
  onToggleInProgress: (todoId: string, isInProgress: boolean) => void
  onDelete: (id: string) => void
  onAddFiles: (todoId: string) => void
  onDownloadAttachment: (a: Todo["attachments"][number]) => void
  onDeleteAttachment: (todoId: string, a: Todo["attachments"][number]) => void
}) {
  if (groups.length === 0) {
    return <p className="text-muted-foreground text-sm">No tasks yet.</p>
  }

  return (
    <div className="space-y-2">
      {groups.map((group) => (
        <div key={group.date} className="space-y-2">
          <div className="flex items-center gap-3 pt-2">
            <Separator className="flex-1" />
            <span className="text-muted-foreground whitespace-nowrap text-xs font-medium">
              {new Intl.DateTimeFormat(undefined, {
                weekday: "short",
                year: "numeric",
                month: "short",
                day: "2-digit",
              }).format(parseLocalDateOnly(group.date))}
            </span>
            <Separator className="flex-1" />
          </div>

          {group.items.map((todo) => {
            const flags = getTaskFlags(todo, nowMs, inProgressTaskId)

            return (
              <div
                key={todo.id}
                className={cn(
                  "rounded-lg border px-3 py-2",
                  flags.completed && "opacity-75",
                  flags.overdue && "border-destructive/40 bg-destructive/5 text-muted-foreground",
                  flags.inProgress && "border-sky-500/40 bg-sky-500/10",
                  conflictDueAt &&
                    todo.dueAt === conflictDueAt &&
                    "border-destructive/60 bg-destructive/5 ring-1 ring-destructive/30"
                )}
              >
                <div className="flex items-start justify-between gap-3">
                  <label className="flex cursor-pointer items-start gap-3">
                    <Checkbox
                      checked={todo.completed}
                      onCheckedChange={(v) => onToggleCompleted(todo.id, Boolean(v))}
                      aria-label={`Mark "${todo.title}" as ${
                        todo.completed ? "not completed" : "completed"
                      }`}
                      className="mt-0.5"
                    />
                    <span
                      className={cn(
                        "leading-6",
                        todo.completed && "text-muted-foreground line-through"
                      )}
                    >
                      <span className="flex flex-wrap items-center gap-2">
                        <span className="block">{todo.title}</span>
                        <TaskBadges {...flags} />
                        {todo.description && (
                          <TooltipProvider>
                            <Tooltip>
                              <TooltipTrigger asChild>
                                <button
                                  type="button"
                                  className="text-muted-foreground hover:text-foreground inline-flex h-7 w-7 items-center justify-center rounded-md border bg-background"
                                  aria-label="View description"
                                >
                                  <Info className="h-4 w-4" />
                                </button>
                              </TooltipTrigger>
                              <TooltipContent className="max-w-xs">
                                <p className="whitespace-pre-wrap text-sm">{todo.description}</p>
                              </TooltipContent>
                            </Tooltip>
                          </TooltipProvider>
                        )}
                      </span>
                      <span className="text-muted-foreground block text-xs">
                        Due: {formatLocalDateTime(todo.dueAt)}
                      </span>
                    </span>
                  </label>

                  <div className="flex items-center gap-1">
                    {!todo.completed && (
                      <Button
                        type="button"
                        variant={flags.inProgress ? "default" : "outline"}
                        size="sm"
                        onClick={() => onToggleInProgress(todo.id, flags.inProgress)}
                        className={cn(flags.inProgress && "bg-sky-600 hover:bg-sky-600")}
                      >
                        {flags.inProgress ? (
                          <>
                            <CircleStop className="mr-1 h-4 w-4" />
                            Stop
                          </>
                        ) : (
                          <>
                            <CirclePlay className="mr-1 h-4 w-4" />
                            Start
                          </>
                        )}
                      </Button>
                    )}

                    {todo.completed && (
                      <Button
                        type="button"
                        variant="outline"
                        size="sm"
                        onClick={() => onAddFiles(todo.id)}
                      >
                        Add files
                      </Button>
                    )}

                    {!todo.completed && (
                      <Button
                        type="button"
                        variant="ghost"
                        size="icon"
                        aria-label={`Delete "${todo.title}"`}
                        onClick={() => onDelete(todo.id)}
                      >
                        <Trash2 className="h-4 w-4" />
                      </Button>
                    )}
                  </div>
                </div>

                {todo.completed && todo.attachments.length > 0 && (
                  <div className="mt-3 space-y-2">
                    <p className="text-muted-foreground text-xs">Attachments</p>
                    <ul className="space-y-1">
                      {todo.attachments.map((a) => (
                        <li
                          key={a.id}
                          className="flex items-center justify-between gap-3 rounded-md bg-muted/30 px-2 py-1"
                        >
                          <div className="flex min-w-0 items-center gap-2">
                            <AttachmentIcon kind={a.kind} />
                            <span className="truncate text-sm">{a.name}</span>
                          </div>
                          <div className="flex items-center gap-2">
                            <button
                              type="button"
                              onClick={() => onDownloadAttachment(a)}
                              className="inline-flex items-center gap-1 text-sm font-medium underline underline-offset-4"
                            >
                              <Download className="h-4 w-4" />
                              Download
                            </button>
                            <Button
                              type="button"
                              variant="ghost"
                              size="icon"
                              className="h-7 w-7"
                              aria-label={`Remove attachment "${a.name}"`}
                              onClick={() => onDeleteAttachment(todo.id, a)}
                            >
                              <Trash2 className="h-4 w-4" />
                            </Button>
                          </div>
                        </li>
                      ))}
                    </ul>
                  </div>
                )}
              </div>
            )
          })}
        </div>
      ))}
    </div>
  )
}


```

### Done
- **Completed tasks no longer show the Delete (trash) button.**
- Non-completed tasks still show Delete as before.

### File updated
- `src/components/todo/TaskList.tsx`

---

**User**

Make the UI fully responsive and ensure it displays correctly across all screen sizes, including mobile, tablet, and desktop.

---

**Cursor**

Plan: I’ll review the main layout components (`TodoApp`, `TaskForm`, `TaskList`, `TodoPage`) for any flex/grid sections that can overflow on small screens, then adjust Tailwind classes (wrapping, stacking, truncation, spacing) to ensure it looks clean on **mobile / tablet / desktop**. After that, I’ll run a build to confirm nothing broke.

Got it. I’ll focus on the main responsive pain points: the header/action area, the “no tasks” row, form button sizing, and list rows/attachments (wrapping + truncation) so nothing overflows on mobile while staying compact on desktop. Then I’ll run a build to confirm.

```typescriptreact
"use client"

import * as React from "react"

import { apiFetch } from "@/lib/api-client"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"

import { AuthCard } from "./AuthCard"
import { TodoApp } from "./TodoApp"

export function TodoPage() {
  const [user, setUser] = React.useState<{ id: string; email?: string } | null>(null)
  const [authLoading, setAuthLoading] = React.useState(true)
  const [authError, setAuthError] = React.useState<string | null>(null)

  const refreshAuth = React.useCallback(async () => {
    setAuthLoading(true)
    try {
      const data = await apiFetch<{ user: { id: string; email?: string } | null }>("/api/auth/me")
      setUser(data.user)
      setAuthError(null)
    } catch (e) {
      setUser(null)
      setAuthError(e instanceof Error ? e.message : "Auth check failed.")
    } finally {
      setAuthLoading(false)
    }
  }, [])

  React.useEffect(() => {
    void refreshAuth()
  }, [refreshAuth])

  if (authLoading) {
    return (
      <div className="mx-auto flex min-h-screen max-w-2xl flex-col justify-center px-4 py-10">
        <p className="text-muted-foreground text-sm">Loading…</p>
      </div>
    )
  }

  if (authError) {
    return (
      <div className="mx-auto flex min-h-screen max-w-2xl flex-col justify-center gap-4 px-4 py-10">
        <Card>
          <CardHeader>
            <CardTitle>Auth unavailable</CardTitle>
          </CardHeader>
          <CardContent className="space-y-2">
            <p className="text-muted-foreground text-sm">{authError}</p>
            <p className="text-muted-foreground text-sm">
              your not permitted to access this page.
            </p>
            <Button type="button" variant="outline" onClick={() => void refreshAuth()}>
              Retry
            </Button>
          </CardContent>
        </Card>
      </div>
    )
  }

  if (!user) return <AuthCard onAuthed={() => void refreshAuth()} />

  return (
    <div className="mx-auto flex min-h-screen max-w-2xl flex-col gap-6 px-4 py-6 sm:py-10">
      <TodoApp userId={user.id} onSignedOut={() => void refreshAuth()} />
    </div>
  )
}


```

```typescriptreact
"use client"

import * as React from "react"
import { zodResolver } from "@hookform/resolvers/zod"
import { useForm } from "react-hook-form"

import { Button } from "@/components/ui/button"
import { Form, FormControl, FormField, FormItem, FormMessage } from "@/components/ui/form"
import { Input } from "@/components/ui/input"
import { Textarea } from "@/components/ui/textarea"

import { todoSchema, type TodoFormValues } from "./schemas"

export function TaskForm({ onAdd }: { onAdd: (values: TodoFormValues) => Promise<void> }) {
  const form = useForm<TodoFormValues>({
    resolver: zodResolver(todoSchema),
    defaultValues: { title: "", description: "", dueAt: "" },
    mode: "onSubmit",
  })

  return (
    <Form {...form}>
      <form
        onSubmit={form.handleSubmit(async (values) => {
          await onAdd(values)
          form.reset()
        })}
        className="space-y-2"
        noValidate
      >
        <div className="flex flex-col gap-2 sm:flex-row">
          <FormField
            control={form.control}
            name="title"
            render={({ field }) => (
              <FormItem className="flex-1">
                <FormControl>
                  <Input placeholder="Add a task…" autoComplete="off" {...field} />
                </FormControl>
                <FormMessage />
              </FormItem>
            )}
          />
          <FormField
            control={form.control}
            name="dueAt"
            render={({ field }) => (
              <FormItem className="sm:w-64">
                <FormControl>
                  <Input type="datetime-local" {...field} />
                </FormControl>
                <FormMessage />
              </FormItem>
            )}
          />
          <Button type="submit" className="w-full sm:w-auto">
            Add
          </Button>
        </div>

        <FormField
          control={form.control}
          name="description"
          render={({ field }) => (
            <FormItem>
              <FormControl>
                <Textarea rows={3} placeholder="Description (optional)…" {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
      </form>
    </Form>
  )
}


```

```typescriptreact
"use client"

import * as React from "react"
import { Bell } from "lucide-react"
import { toast } from "sonner"

import type { DailyLoad, Todo } from "./types"
import { initialTodos } from "./mock-data"
import { TaskForm } from "./TaskForm"
import { TaskList } from "./TaskList"
import { UserMenu } from "./UserMenu"

import { apiFetch, ApiError } from "@/lib/api-client"
import { ModeToggle } from "@/components/mode-toggle"
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert"
import { Badge } from "@/components/ui/badge"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Input } from "@/components/ui/input"
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select"
import { Separator } from "@/components/ui/separator"
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip"

import type { TodoFormValues } from "./schemas"
import {
  addDays,
  endOfDay,
  formatDateTimeFromMs,
  formatLocalDateTime,
  getDailyLoad,
  getDatePart,
  getTimePart,
  localDateKey,
  minutesUntil,
  parseLocalDateOnly,
  parseLocalDateTime,
  parseLocalTimeToMinutes,
  startOfDay,
} from "./utils"

function DailyLoadBadge({ load }: { load: DailyLoad }) {
  if (load === "heavy") return <Badge variant="destructive">Heavy</Badge>
  if (load === "balanced") return <Badge variant="secondary">Balanced</Badge>
  return <Badge variant="outline">Light</Badge>
}

export function TodoApp({ userId, onSignedOut }: { userId: string; onSignedOut: () => void }) {
  const [todos, setTodos] = React.useState<Todo[]>([])
  const [tasksLoading, setTasksLoading] = React.useState(true)
  const [tasksError, setTasksError] = React.useState<{ code?: string; message: string } | null>(
    null
  )

  const [attachTargetTodoId, setAttachTargetTodoId] = React.useState<string | null>(null)
  const fileInputRef = React.useRef<HTMLInputElement>(null)

  const [conflictDueAt, setConflictDueAt] = React.useState<string | null>(null)
  const clearConflictTimerRef = React.useRef<number | null>(null)

  const [focusMode, setFocusMode] = React.useState(false)
  const [nowMs, setNowMs] = React.useState(() => Date.now())
  const [inProgressTaskId, setInProgressTaskId] = React.useState<string | null>(null)

  const [dismissedReminderTaskId, setDismissedReminderTaskId] = React.useState<string | null>(null)

  const [filterMode, setFilterMode] = React.useState<"between" | "exact">("between")
  const [filterFromDate, setFilterFromDate] = React.useState<string>("")
  const [filterFromTime, setFilterFromTime] = React.useState<string>("")
  const [filterToDate, setFilterToDate] = React.useState<string>("")
  const [filterToTime, setFilterToTime] = React.useState<string>("")
  const [filterExactDate, setFilterExactDate] = React.useState<string>("")
  const [filterExactTime, setFilterExactTime] = React.useState<string>("")

  const [pageSize, setPageSize] = React.useState<number>(5)
  const [page, setPage] = React.useState<number>(1)

  React.useEffect(() => {
    const id = window.setInterval(() => setNowMs(Date.now()), 30_000)
    return () => window.clearInterval(id)
  }, [])

  React.useEffect(() => {
    if (!inProgressTaskId) return
    const t = todos.find((x) => x.id === inProgressTaskId)
    if (!t || t.completed) setInProgressTaskId(null)
  }, [inProgressTaskId, todos])

  React.useEffect(() => {
    let alive = true
    async function load() {
      setTasksLoading(true)
      try {
        const data = await apiFetch<{ tasks: Todo[]; inProgressTaskId: string | null }>("/api/tasks")
        if (!alive) return
        setTodos(data.tasks)
        setInProgressTaskId(data.inProgressTaskId)
        setTasksError(null)
      } catch (e) {
        if (!alive) return
        if (e instanceof ApiError) setTasksError({ code: e.code, message: e.message })
        else setTasksError({ message: e instanceof Error ? e.message : "Failed to load tasks." })
        setTodos([])
        setInProgressTaskId(null)
      } finally {
        if (!alive) return
        setTasksLoading(false)
      }
    }
    void load()
    return () => {
      alive = false
    }
  }, [])

  const nextUpcoming = React.useMemo(() => {
    const upcoming = todos
      .filter((t) => !t.completed)
      .map((t) => ({ todo: t, dueMs: parseLocalDateTime(t.dueAt) }))
      .filter((x) => x.dueMs >= nowMs)
      .sort((a, b) => a.dueMs - b.dueMs)[0]
    return upcoming ?? null
  }, [nowMs, todos])

  React.useEffect(() => {
    if (nextUpcoming && nextUpcoming.todo.id !== dismissedReminderTaskId) return
    if (!nextUpcoming) setDismissedReminderTaskId(null)
  }, [dismissedReminderTaskId, nextUpcoming])

  const reminder = React.useMemo(() => {
    const REMINDER_WINDOW_MIN = 15
    if (!nextUpcoming) return null
    if (dismissedReminderTaskId === nextUpcoming.todo.id) return null
    const mins = minutesUntil(nextUpcoming.dueMs, nowMs)
    if (mins < 0 || mins > REMINDER_WINDOW_MIN) return null
    return { ...nextUpcoming, mins }
  }, [dismissedReminderTaskId, nextUpcoming, nowMs])

  const filteredTodos = React.useMemo(() => {
    if (focusMode) {
      const endMs = nowMs + 4 * 60 * 60 * 1000
      return todos.filter((t) => {
        const ms = parseLocalDateTime(t.dueAt)
        return ms >= nowMs && ms <= endMs
      })
    }

    if (filterMode === "exact") {
      if (!filterExactDate && !filterExactTime) return todos
      if (filterExactDate && !filterExactTime) {
        return todos.filter((t) => getDatePart(t.dueAt) === filterExactDate)
      }
      if (filterExactDate && filterExactTime) {
        const exactMs = parseLocalDateTime(`${filterExactDate}T${filterExactTime}`)
        return todos.filter((t) => parseLocalDateTime(t.dueAt) === exactMs)
      }
      return todos.filter((t) => getTimePart(t.dueAt) === filterExactTime)
    }

    const hasAnyDate = Boolean(filterFromDate || filterToDate)
    const hasAnyTime = Boolean(filterFromTime || filterToTime)

    const fromDateMs = filterFromDate
      ? startOfDay(parseLocalDateOnly(filterFromDate)).getTime()
      : Number.NEGATIVE_INFINITY
    const toDateMs = filterToDate
      ? endOfDay(parseLocalDateOnly(filterToDate)).getTime()
      : Number.POSITIVE_INFINITY

    const fromTimeMin = filterFromTime ? parseLocalTimeToMinutes(filterFromTime) : 0
    const toTimeMin = filterToTime ? parseLocalTimeToMinutes(filterToTime) : 24 * 60 - 1

    return todos.filter((t) => {
      const ms = parseLocalDateTime(t.dueAt)
      if (hasAnyDate && (ms < fromDateMs || ms > toDateMs)) return false
      if (hasAnyTime) {
        const time = getTimePart(t.dueAt)
        if (!time) return false
        const mins = parseLocalTimeToMinutes(time)
        if (mins < fromTimeMin || mins > toTimeMin) return false
      }
      return true
    })
  }, [
    todos,
    focusMode,
    nowMs,
    filterMode,
    filterExactDate,
    filterExactTime,
    filterFromDate,
    filterFromTime,
    filterToDate,
    filterToTime,
  ])

  const sortedFilteredTodos = React.useMemo(
    () =>
      filteredTodos
        .slice()
        .sort((a, b) => parseLocalDateTime(a.dueAt) - parseLocalDateTime(b.dueAt)),
    [filteredTodos]
  )

  React.useEffect(() => {
    const totalPages = Math.max(1, Math.ceil(sortedFilteredTodos.length / pageSize))
    setPage((p) => Math.min(Math.max(1, p), totalPages))
  }, [pageSize, sortedFilteredTodos.length])

  const totalItems = sortedFilteredTodos.length
  const totalPages = Math.max(1, Math.ceil(totalItems / pageSize))
  const showPagination = totalPages > 1

  const pageItems = React.useMemo(() => {
    const start = (page - 1) * pageSize
    return sortedFilteredTodos.slice(start, start + pageSize)
  }, [page, pageSize, sortedFilteredTodos])

  const groupedTodos = React.useMemo(() => {
    const groups: Array<{ date: string; items: Todo[] }> = []
    for (const t of pageItems) {
      const date = getDatePart(t.dueAt)
      const last = groups[groups.length - 1]
      if (!last || last.date !== date) groups.push({ date, items: [t] })
      else last.items.push(t)
    }
    return groups
  }, [pageItems])

  const completedCount = filteredTodos.filter((t) => t.completed).length

  async function requestAttachmentsForTodo(todoId: string) {
    setAttachTargetTodoId(todoId)
    queueMicrotask(() => fileInputRef.current?.click())
  }

  async function handleFilesPicked(e: React.ChangeEvent<HTMLInputElement>) {
    const files = Array.from(e.target.files ?? [])
    const targetId = attachTargetTodoId
    e.target.value = ""
    setAttachTargetTodoId(null)
    if (!targetId || files.length === 0) return

    const form = new FormData()
    for (const f of files) form.append("files", f)

    try {
      const res = await fetch(`/api/tasks/${targetId}/attachments`, {
        method: "POST",
        credentials: "include",
        body: form,
      })
      const json = (await res.json().catch(() => null)) as
        | { ok: true; data: { task: Todo } }
        | { ok: false; error: { message: string } }
        | null
      if (!json || !json.ok) throw new Error(json?.error.message ?? "Upload failed.")
      setTodos((prev) => prev.map((t) => (t.id === targetId ? json.data.task : t)))
    } catch (err) {
      toast.error("Upload failed", { description: err instanceof Error ? err.message : "Failed." })
    }
  }

  async function addTodo(values: TodoFormValues) {
    const conflicts = todos.filter((t) => t.dueAt === values.dueAt)
    if (conflicts.length > 0) {
      setConflictDueAt(values.dueAt)
      if (clearConflictTimerRef.current) window.clearTimeout(clearConflictTimerRef.current)
      clearConflictTimerRef.current = window.setTimeout(() => setConflictDueAt(null), 8000)

      const [d, time] = values.dueAt.split("T")
      setFilterMode("exact")
      setFilterExactDate(d ?? "")
      setFilterExactTime(time ?? "")
      setPage(1)

      toast.error("Time conflict", {
        description: `You already have ${conflicts.length} task(s) scheduled at ${formatLocalDateTime(
          values.dueAt
        )}.`,
      })
    }

    const data = await apiFetch<{ task: Todo }>("/api/tasks", {
      method: "POST",
      body: JSON.stringify(values),
    })
    setTodos((prev) => [data.task, ...prev])
  }

  async function toggleTodo(id: string, completed: boolean) {
    const before = todos.find((t) => t.id === id)
    setTodos((prev) => prev.map((t) => (t.id === id ? { ...t, completed } : t)))
    if (completed) setInProgressTaskId((cur) => (cur === id ? null : cur))

    try {
      await apiFetch("/api/tasks/" + id, { method: "PATCH", body: JSON.stringify({ completed }) })
    } catch (e) {
      toast.error("Failed to update task", { description: e instanceof Error ? e.message : "Failed." })
    }

    if (completed && before && !before.completed) {
      await requestAttachmentsForTodo(id)
    }
  }

  async function deleteTodo(id: string) {
    setTodos((prev) => prev.filter((t) => t.id !== id))
    setInProgressTaskId((cur) => (cur === id ? null : cur))
    try {
      await apiFetch("/api/tasks/" + id, { method: "DELETE" })
    } catch (e) {
      toast.error("Failed to delete task", { description: e instanceof Error ? e.message : "Failed." })
    }
  }

  async function clearCompleted() {
    const completedIds = new Set(todos.filter((t) => t.completed).map((t) => t.id))
    if (completedIds.size === 0) return
    setTodos((prev) => prev.filter((t) => !completedIds.has(t.id)))
    try {
      await apiFetch("/api/tasks/clear-completed", { method: "POST" })
    } catch (e) {
      toast.error("Failed to clear completed", { description: e instanceof Error ? e.message : "Failed." })
    }
  }

  async function setInProgress(taskId: string | null) {
    setInProgressTaskId(taskId)
    try {
      const data = await apiFetch<{ inProgressTaskId: string | null }>("/api/tasks/in-progress", {
        method: "POST",
        body: JSON.stringify({ id: taskId }),
      })
      setInProgressTaskId(data.inProgressTaskId)
    } catch (e) {
      toast.error("Failed to update in-progress", { description: e instanceof Error ? e.message : "Failed." })
    }
  }

  async function downloadAttachment(a: Todo["attachments"][number]) {
    const data = await apiFetch<{ signedUrl: string }>("/api/attachments/signed-url", {
      method: "POST",
      body: JSON.stringify({ bucket: a.bucket, path: a.path }),
    })
    window.open(data.signedUrl, "_blank", "noopener,noreferrer")
  }

  async function deleteAttachment(todoId: string, attachmentId: string) {
    try {
      const data = await apiFetch<{ task: Todo }>(`/api/tasks/${todoId}/attachments/delete`, {
        method: "POST",
        body: JSON.stringify({ attachmentId }),
      })
      setTodos((prev) => prev.map((t) => (t.id === todoId ? data.task : t)))
    } catch (e) {
      toast.error("Failed to remove attachment", {
        description: e instanceof Error ? e.message : "Failed.",
      })
    }
  }

  async function seedDemoTasks() {
    if (todos.length > 0) return
    const data = await apiFetch<{ tasks: Todo[] }>("/api/tasks/seed", {
      method: "POST",
      body: JSON.stringify({ tasks: initialTodos }),
    })
    setTodos(data.tasks)
  }

  const loadDayKey = React.useMemo(() => {
    if (filterMode === "exact" && filterExactDate) return filterExactDate
    if (filterFromDate && !filterToDate) return filterFromDate
    if (filterFromDate && filterToDate && filterFromDate === filterToDate) return filterFromDate
    if (!filterFromDate && filterToDate) return filterToDate
    return localDateKey(new Date(nowMs))
  }, [filterExactDate, filterFromDate, filterMode, filterToDate, nowMs])

  const dailyLoad = React.useMemo(() => {
    const dayTodos = todos.filter((t) => getDatePart(t.dueAt) === loadDayKey)
    return getDailyLoad(dayTodos)
  }, [loadDayKey, todos])

  const summary = React.useMemo(() => {
    const now = new Date(nowMs)
    const todayKey = localDateKey(now)
    const tomorrow = addDays(now, 1)
    const tomorrowKey = localDateKey(tomorrow)
    const labels = dailyLoad.labels

    const todays = todos.filter((t) => t.dueAt.startsWith(todayKey))
    const todayCompleted = todays.filter((t) => t.completed).length
    const todayPending = todays.length - todayCompleted

    const tomorrowTasks = todos.filter((t) => t.dueAt.startsWith(tomorrowKey))
    const tomorrowBuckets = Array.from({ length: 6 }, () => 0) as number[]
    for (const t of tomorrowTasks) {
      const hour = new Date(parseLocalDateTime(t.dueAt)).getHours()
      tomorrowBuckets[Math.floor(hour / 4)]++
    }

    const rangeStart = startOfDay(tomorrow).getTime()
    const rangeEnd = addDays(startOfDay(tomorrow), 7).getTime()
    const buckets = Array.from({ length: 6 }, () => 0) as number[]
    const upcoming = todos.filter((t) => {
      const ms = parseLocalDateTime(t.dueAt)
      return ms >= rangeStart && ms < rangeEnd
    })
    for (const t of upcoming) {
      const hour = new Date(parseLocalDateTime(t.dueAt)).getHours()
      buckets[Math.floor(hour / 4)]++
    }

    return {
      todayCompleted,
      todayPending,
      tomorrowTotal: tomorrowTasks.length,
      tomorrowBuckets: labels.map((label, i) => ({ label, count: tomorrowBuckets[i] ?? 0 })),
      upcomingTotal: upcoming.length,
      upcomingBuckets: labels.map((label, i) => ({ label, count: buckets[i] ?? 0 })),
    }
  }, [dailyLoad.labels, nowMs, todos])

  return (
    <Card>
      <CardHeader className="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
        <div className="space-y-1">
          <CardTitle className="text-2xl">To‑Do</CardTitle>
          <p className="text-muted-foreground text-sm">
            {completedCount}/{filteredTodos.length} completed
          </p>
        </div>

        <div className="flex flex-wrap items-center justify-between gap-2 sm:justify-end">
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <Button
                  type="button"
                  variant={focusMode ? "default" : "outline"}
                  size="sm"
                  onClick={() => {
                    setFocusMode((v) => !v)
                    setPage(1)
                  }}
                >
                  Focus Mode
                </Button>
              </TooltipTrigger>
              <TooltipContent>
                <p>Show tasks for the next 4 hours.</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>

          <UserMenu userId={userId} onSignedOut={onSignedOut} />
          <ModeToggle />
        </div>
      </CardHeader>

      <CardContent className="space-y-6">
        {tasksLoading && <p className="text-muted-foreground text-sm">Loading tasks…</p>}

        {!tasksLoading && tasksError?.code === "MISSING_TABLE" && (
          <Alert variant="destructive">
            <AlertTitle>Database not initialized</AlertTitle>
            <AlertDescription>
              <div className="space-y-2">
                <p>
                  The Supabase table <code>public.tasks</code> was not found. Run the SQL in{" "}
                  <code>supabase/schema.sql</code> (Supabase Dashboard → SQL Editor), then refresh.
                </p>
                <p className="text-xs opacity-90">{tasksError.message}</p>
              </div>
            </AlertDescription>
          </Alert>
        )}

        {!tasksLoading && tasksError && tasksError.code !== "MISSING_TABLE" && (
          <Alert variant="destructive">
            <AlertTitle>Failed to load tasks</AlertTitle>
            <AlertDescription>{tasksError.message}</AlertDescription>
          </Alert>
        )}

        {!tasksLoading && todos.length === 0 && (
          <div className="flex flex-col gap-3 rounded-lg border bg-muted/20 px-3 py-2 sm:flex-row sm:items-center sm:justify-between">
            <p className="text-muted-foreground text-sm">No tasks yet.</p>
            <Button
              type="button"
              variant="outline"
              size="sm"
              className="w-full sm:w-auto"
              onClick={() => void seedDemoTasks()}
            >
              Seed demo tasks
            </Button>
          </div>
        )}

        <input
          ref={fileInputRef}
          type="file"
          multiple
          className="hidden"
          accept={[
            "image/*",
            "audio/*",
            "video/*",
            ".pdf",
            ".doc",
            ".docx",
            ".xls",
            ".xlsx",
            ".csv",
            ".txt",
            ".md",
            ".rtf",
          ].join(",")}
          onChange={handleFilesPicked}
        />

        {reminder && (
          <Alert className="border-primary/30 bg-primary/5">
            <Bell className="h-4 w-4" />
            <div className="flex flex-1 flex-col gap-1">
              <div className="flex flex-wrap items-center justify-between gap-2">
                <AlertTitle className="text-sm">
                  Next task starts in {reminder.mins} minute{reminder.mins === 1 ? "" : "s"}
                </AlertTitle>
                <Button
                  type="button"
                  variant="ghost"
                  size="sm"
                  onClick={() => setDismissedReminderTaskId(reminder.todo.id)}
                >
                  Dismiss
                </Button>
              </div>
              <AlertDescription className="text-sm">
                <span className="font-medium">{reminder.todo.title}</span> ·{" "}
                {formatDateTimeFromMs(reminder.dueMs)}
              </AlertDescription>
            </div>
          </Alert>
        )}

        <div className="rounded-xl border bg-card p-4">
          <div className="flex flex-wrap items-center justify-between gap-2">
            <p className="text-sm font-medium">
              Daily load{" "}
              <span className="text-muted-foreground font-normal">
                ({new Intl.DateTimeFormat(undefined, {
                  weekday: "short",
                  year: "numeric",
                  month: "short",
                  day: "2-digit",
                }).format(parseLocalDateOnly(loadDayKey))})
              </span>
            </p>
            <DailyLoadBadge load={dailyLoad.load} />
          </div>
          <p className="text-muted-foreground mt-2 text-sm">
            {dailyLoad.total} task(s) · busiest window {dailyLoad.busiestWindow} ({dailyLoad.peak})
          </p>
        </div>

        <div className="grid gap-3 sm:grid-cols-3">
          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Today’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">{summary.todayCompleted} completed</p>
            <p className="text-muted-foreground text-sm">{summary.todayPending} pending</p>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tomorrow’s Tasks</p>
            <p className="mt-2 text-2xl font-semibold">{summary.tomorrowTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.tomorrowBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>

          <div className="rounded-xl border bg-card p-4">
            <p className="text-sm font-medium">Tasks Until Next Week</p>
            <p className="mt-2 text-2xl font-semibold">{summary.upcomingTotal}</p>
            <div className="mt-2 space-y-1">
              {summary.upcomingBuckets.map((b) => (
                <div key={b.label} className="flex items-center justify-between text-xs">
                  <span className="text-muted-foreground">{b.label}</span>
                  <span className="font-medium">{b.count}</span>
                </div>
              ))}
            </div>
          </div>
        </div>

        {focusMode && (
          <div className="flex flex-col gap-1 rounded-lg border bg-muted/20 px-3 py-2 sm:flex-row sm:items-center sm:justify-between">
            <p className="text-sm">
              <span className="font-medium">Focus Mode:</span> showing tasks due in the next 4 hours
              (until <span className="font-medium">{formatDateTimeFromMs(nowMs + 4 * 60 * 60 * 1000)}</span>)
            </p>
            <Button type="button" variant="ghost" size="sm" onClick={() => setFocusMode(false)}>
              Exit
            </Button>
          </div>
        )}

        <TaskForm onAdd={addTodo} />

        <Separator />

        <div className="space-y-3">
          <div className="flex flex-wrap items-center justify-between gap-2">
            <p className="text-sm font-medium">Filter by date & time</p>
            <div className="flex flex-wrap items-center gap-2">
              <Button
                type="button"
                size="sm"
                variant={filterMode === "between" ? "default" : "outline"}
                onClick={() => setFilterMode("between")}
              >
                Between
              </Button>
              <Button
                type="button"
                size="sm"
                variant={filterMode === "exact" ? "default" : "outline"}
                onClick={() => setFilterMode("exact")}
              >
                Exact
              </Button>
              <Button
                type="button"
                size="sm"
                variant="ghost"
                onClick={() => {
                  setFilterFromDate("")
                  setFilterFromTime("")
                  setFilterToDate("")
                  setFilterToTime("")
                  setFilterExactDate("")
                  setFilterExactTime("")
                }}
              >
                Clear
              </Button>
            </div>
          </div>

          {filterMode === "between" ? (
            <div className="grid gap-2 sm:grid-cols-2">
              <div className="grid gap-2 sm:grid-cols-2">
                <Input type="date" value={filterFromDate} onChange={(e) => setFilterFromDate(e.target.value)} />
                <Input type="time" value={filterFromTime} onChange={(e) => setFilterFromTime(e.target.value)} />
              </div>
              <div className="grid gap-2 sm:grid-cols-2">
                <Input type="date" value={filterToDate} onChange={(e) => setFilterToDate(e.target.value)} />
                <Input type="time" value={filterToTime} onChange={(e) => setFilterToTime(e.target.value)} />
              </div>
            </div>
          ) : (
            <div className="grid gap-2 sm:grid-cols-2">
              <Input type="date" value={filterExactDate} onChange={(e) => setFilterExactDate(e.target.value)} />
              <Input type="time" value={filterExactTime} onChange={(e) => setFilterExactTime(e.target.value)} />
            </div>
          )}
        </div>

        <Separator />

        <TaskList
          groups={groupedTodos}
          nowMs={nowMs}
          inProgressTaskId={inProgressTaskId}
          conflictDueAt={conflictDueAt}
          onToggleCompleted={(id, completed) => void toggleTodo(id, completed)}
          onToggleInProgress={(id, isInProgress) => void setInProgress(isInProgress ? null : id)}
          onDelete={(id) => void deleteTodo(id)}
          onAddFiles={(id) => void requestAttachmentsForTodo(id)}
          onDownloadAttachment={(a) => void downloadAttachment(a)}
          onDeleteAttachment={(todoId, a) => void deleteAttachment(todoId, a.id)}
        />

        <div className="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
          <div className="flex flex-wrap items-center gap-2">
            <span className="text-muted-foreground text-sm">Items per page</span>
            <Select
              value={String(pageSize)}
              onValueChange={(v) => {
                const next = Number(v)
                setPageSize(next)
                setPage(1)
              }}
            >
              <SelectTrigger className="w-[110px]">
                <SelectValue />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="5">5</SelectItem>
                <SelectItem value="10">10</SelectItem>
                <SelectItem value="15">15</SelectItem>
                <SelectItem value="20">20</SelectItem>
              </SelectContent>
            </Select>
          </div>

          {showPagination && (
            <div className="flex flex-wrap items-center justify-between gap-3 sm:justify-end">
              <Button
                type="button"
                variant="outline"
                size="sm"
                onClick={() => setPage((p) => Math.max(1, p - 1))}
                disabled={page <= 1}
              >
                Prev
              </Button>
              <span className="text-muted-foreground text-sm">
                Page {page} of {totalPages}
              </span>
              <Button
                type="button"
                variant="outline"
                size="sm"
                onClick={() => setPage((p) => Math.min(totalPages, p + 1))}
                disabled={page >= totalPages}
              >
                Next
              </Button>
            </div>
          )}
        </div>

        <div className="flex items-center justify-between gap-2">
          <Button
            type="button"
            variant="secondary"
            onClick={() => void clearCompleted()}
            disabled={completedCount === 0}
          >
            Clear completed
          </Button>
          <span className="text-muted-foreground text-sm">Supabase-backed</span>
        </div>
      </CardContent>
    </Card>
  )
}


```

```typescriptreact
"use client"

import * as React from "react"
import {
  CirclePlay,
  CircleStop,
  Download,
  Trash2,
  File,
  FileSpreadsheet,
  FileText,
  Image as ImageIcon,
  Info,
  Music,
  Video,
} from "lucide-react"

import type { AttachmentKind, Todo } from "./types"
import { cn } from "@/lib/utils"
import { formatLocalDateTime, parseLocalDateOnly, parseLocalDateTime } from "./utils"
import { getTaskFlags } from "./utils"

import { Button } from "@/components/ui/button"
import { Checkbox } from "@/components/ui/checkbox"
import { Separator } from "@/components/ui/separator"
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip"
import { Badge } from "@/components/ui/badge"

function AttachmentIcon({ kind }: { kind: AttachmentKind }) {
  const className = "h-4 w-4 text-muted-foreground"
  switch (kind) {
    case "image":
      return <ImageIcon className={className} />
    case "audio":
      return <Music className={className} />
    case "video":
      return <Video className={className} />
    case "spreadsheet":
      return <FileSpreadsheet className={className} />
    case "pdf":
    case "document":
    case "text":
      return <FileText className={className} />
    default:
      return <File className={className} />
  }
}

function TaskBadges({
  completed,
  overdue,
  inProgress,
  planned,
}: {
  completed: boolean
  overdue: boolean
  inProgress: boolean
  planned: boolean
}) {
  if (completed) {
    return (
      <Badge className="gap-1 bg-emerald-600 text-white hover:bg-emerald-600">Completed</Badge>
    )
  }
  return (
    <span className="flex flex-wrap items-center gap-2">
      {inProgress && <Badge className="bg-sky-600 text-white hover:bg-sky-600">In progress</Badge>}
      {overdue && <Badge variant="destructive">Overdue</Badge>}
      {planned && <Badge variant="outline">Planned</Badge>}
    </span>
  )
}

export function TaskList({
  groups,
  nowMs,
  inProgressTaskId,
  conflictDueAt,
  onToggleCompleted,
  onToggleInProgress,
  onDelete,
  onAddFiles,
  onDownloadAttachment,
  onDeleteAttachment,
}: {
  groups: Array<{ date: string; items: Todo[] }>
  nowMs: number
  inProgressTaskId: string | null
  conflictDueAt: string | null
  onToggleCompleted: (id: string, completed: boolean) => void
  onToggleInProgress: (todoId: string, isInProgress: boolean) => void
  onDelete: (id: string) => void
  onAddFiles: (todoId: string) => void
  onDownloadAttachment: (a: Todo["attachments"][number]) => void
  onDeleteAttachment: (todoId: string, a: Todo["attachments"][number]) => void
}) {
  if (groups.length === 0) {
    return <p className="text-muted-foreground text-sm">No tasks yet.</p>
  }

  return (
    <div className="space-y-2">
      {groups.map((group) => (
        <div key={group.date} className="space-y-2">
          <div className="flex items-center gap-3 pt-2">
            <Separator className="flex-1" />
            <span className="text-muted-foreground whitespace-nowrap text-xs font-medium">
              {new Intl.DateTimeFormat(undefined, {
                weekday: "short",
                year: "numeric",
                month: "short",
                day: "2-digit",
              }).format(parseLocalDateOnly(group.date))}
            </span>
            <Separator className="flex-1" />
          </div>

          {group.items.map((todo) => {
            const flags = getTaskFlags(todo, nowMs, inProgressTaskId)

            return (
              <div
                key={todo.id}
                className={cn(
                  "rounded-lg border px-3 py-2",
                  flags.completed && "opacity-75",
                  flags.overdue && "border-destructive/40 bg-destructive/5 text-muted-foreground",
                  flags.inProgress && "border-sky-500/40 bg-sky-500/10",
                  conflictDueAt &&
                    todo.dueAt === conflictDueAt &&
                    "border-destructive/60 bg-destructive/5 ring-1 ring-destructive/30"
                )}
              >
                <div className="flex flex-col gap-3 sm:flex-row sm:items-start sm:justify-between">
                  <label className="flex min-w-0 cursor-pointer items-start gap-3">
                    <Checkbox
                      checked={todo.completed}
                      onCheckedChange={(v) => onToggleCompleted(todo.id, Boolean(v))}
                      aria-label={`Mark "${todo.title}" as ${
                        todo.completed ? "not completed" : "completed"
                      }`}
                      className="mt-0.5"
                    />
                    <span
                      className={cn(
                        "leading-6",
                        todo.completed && "text-muted-foreground line-through"
                      )}
                    >
                      <span className="flex min-w-0 flex-wrap items-center gap-2">
                        <span className="block min-w-0 truncate">{todo.title}</span>
                        <TaskBadges {...flags} />
                        {todo.description && (
                          <TooltipProvider>
                            <Tooltip>
                              <TooltipTrigger asChild>
                                <button
                                  type="button"
                                  className="text-muted-foreground hover:text-foreground inline-flex h-7 w-7 items-center justify-center rounded-md border bg-background"
                                  aria-label="View description"
                                >
                                  <Info className="h-4 w-4" />
                                </button>
                              </TooltipTrigger>
                              <TooltipContent className="max-w-xs">
                                <p className="whitespace-pre-wrap text-sm">{todo.description}</p>
                              </TooltipContent>
                            </Tooltip>
                          </TooltipProvider>
                        )}
                      </span>
                      <span className="text-muted-foreground block text-xs">
                        Due: {formatLocalDateTime(todo.dueAt)}
                      </span>
                    </span>
                  </label>

                  <div className="flex flex-wrap items-center justify-end gap-2">
                    {!todo.completed && (
                      <Button
                        type="button"
                        variant={flags.inProgress ? "default" : "outline"}
                        size="sm"
                        onClick={() => onToggleInProgress(todo.id, flags.inProgress)}
                        className={cn(flags.inProgress && "bg-sky-600 hover:bg-sky-600")}
                      >
                        {flags.inProgress ? (
                          <>
                            <CircleStop className="mr-1 h-4 w-4" />
                            Stop
                          </>
                        ) : (
                          <>
                            <CirclePlay className="mr-1 h-4 w-4" />
                            Start
                          </>
                        )}
                      </Button>
                    )}

                    {todo.completed && (
                      <Button
                        type="button"
                        variant="outline"
                        size="sm"
                        onClick={() => onAddFiles(todo.id)}
                      >
                        Add files
                      </Button>
                    )}

                    {!todo.completed && (
                      <Button
                        type="button"
                        variant="ghost"
                        size="icon"
                        aria-label={`Delete "${todo.title}"`}
                        onClick={() => onDelete(todo.id)}
                      >
                        <Trash2 className="h-4 w-4" />
                      </Button>
                    )}
                  </div>
                </div>

                {todo.completed && todo.attachments.length > 0 && (
                  <div className="mt-3 space-y-2">
                    <p className="text-muted-foreground text-xs">Attachments</p>
                    <ul className="space-y-1">
                      {todo.attachments.map((a) => (
                        <li
                          key={a.id}
                          className="flex flex-col gap-2 rounded-md bg-muted/30 px-2 py-1 sm:flex-row sm:items-center sm:justify-between"
                        >
                          <div className="flex min-w-0 items-center gap-2">
                            <AttachmentIcon kind={a.kind} />
                            <span className="truncate text-sm">{a.name}</span>
                          </div>
                          <div className="flex items-center justify-end gap-2">
                            <button
                              type="button"
                              onClick={() => onDownloadAttachment(a)}
                              className="inline-flex items-center gap-1 text-sm font-medium underline underline-offset-4"
                            >
                              <Download className="h-4 w-4" />
                              Download
                            </button>
                            <Button
                              type="button"
                              variant="ghost"
                              size="icon"
                              className="h-7 w-7"
                              aria-label={`Remove attachment "${a.name}"`}
                              onClick={() => onDeleteAttachment(todo.id, a)}
                            >
                              <Trash2 className="h-4 w-4" />
                            </Button>
                          </div>
                        </li>
                      ))}
                    </ul>
                  </div>
                )}
              </div>
            )
          })}
        </div>
      ))}
    </div>
  )
}


```

### Responsive UI improvements applied
Updated layout and overflow handling so the app behaves well on **mobile / tablet / desktop**:

- **Header** (`TodoApp`): now stacks on small screens (`flex-col`) and wraps controls instead of squishing/overflowing.
- **“No tasks yet” row**: now stacks on mobile; button becomes full-width on small screens.
- **Task form**: **Add** button is full-width on mobile.
- **Task list rows**: better wrapping + truncation (`min-w-0`, `truncate`), actions wrap cleanly.
- **Attachment rows**: stack vertically on mobile; actions align nicely without overflow.
- **General spacing**: adjusted top padding for small vs desktop.

### Files updated
- `src/components/todo/TodoApp.tsx`
- `src/components/todo/TaskList.tsx`
- `src/components/todo/TaskForm.tsx`
- `src/components/todo/TodoPage.tsx`

Build verified ✅

---

**User**

Create a professional README.md file for this project.
The README should clearly describe the application, its purpose, architecture, and all implemented features.
Include sections for:

Project overview and goals

Key features (task management, time-based planning, focus mode, visual states, daily load indicator)

UX decisions and product thinking

Backend integration with Supabase (auth, tasks table, storage bucket, RLS)

Architecture and code structure (API-based logic, component-based UI)

Responsive design and accessibility considerations

Setup and running instructions

Notes on design decisions and trade-offs

Write it in clear, professional English suitable for a public GitHub repository.

---

**Cursor**

I’ll add a polished `README.md` at the project root that documents the app’s purpose, UX/product decisions, Supabase setup (schema + storage + RLS), and the architecture split between API routes and UI components—plus clear run instructions.

```markdown
# To‑Do App (Next.js + shadcn/ui + Supabase)

## Project overview & goals
This project is a **time-aware to‑do application** built with **Next.js (App Router)** and a **dark-first UI** using **shadcn/ui**.  
The primary goal is to provide a simple but professional task planner that supports:

- Scheduling tasks with **date + time**
- Fast views for “what’s next” (**Focus Mode**, reminders)
- Clear visual task states (**Planned / In Progress / Completed / Overdue**)
- Persistent storage and authentication via **Supabase** (database + storage)

## Key features

### Task management
- **Create tasks** with:
  - Title (required)
  - **Optional description** (textarea)
  - **Due date & time** (required)
- **Complete / uncomplete** tasks.
- **Delete** tasks (note: the **Delete button is hidden for completed tasks**).
- **Seed demo tasks** (useful on fresh accounts).

### Attachments (Supabase Storage)
- Attach multiple files to a task **when it is completed**.
- Supported examples: PDFs, spreadsheets, documents, text, images, audio, video.
- Attachment list includes:
  - Type icon
  - Download action (via signed URL)
  - **Remove attachment** (trash icon) which deletes from Storage and updates the task record.

### Time-based planning & filtering
- **Filter** tasks by:
  - Date only (show tasks for that date)
  - Time only (show tasks matching time-of-day)
  - Between ranges (date range and/or time-of-day range)
  - Exact matching (date, or date+time)
- Task list is **grouped by date** with a divider/label for clarity.
- **Pagination** when list is large, with user-selectable page size (dropdown).

### Focus Mode
- One-click **Focus Mode** to show tasks due in the **next 4 hours** from the current time.

### Visual task states
Tasks communicate state via badges + subtle styling (no disruptive notifications):
- **Planned**: scheduled in the future
- **In Progress**: user-selected “current focus” (only one at a time)
- **Overdue**: due date/time is in the past and task is not completed (**automatic**)
- **Completed**: finished

Note: **Overdue** and **In Progress** can be shown simultaneously (time-based + user focus).

### Daily load indicator
At the top of the page, a **Daily Load** panel classifies the day as:
- **Light / Balanced / Heavy**

This is computed from the number of tasks for the target day and how concentrated they are within **4-hour time windows**.

### Summary cards
- **Today’s Tasks**: completed vs pending
- **Tomorrow’s Tasks**: total + 4-hour window breakdown
- **Tasks Until Next Week**: upcoming count + 4-hour window breakdown

### Non-intrusive reminder
As the next task time approaches, the app shows an **in-app reminder banner** (no toast) when the next upcoming task is within a short window (currently 15 minutes).  
Users can dismiss the reminder per-task.

### Time conflict hint
When adding a task, the app detects **conflicts at the same date+time** and:
- highlights conflicting tasks
- shows a toast explaining the conflict

## UX decisions & product thinking
- **Dark-first**: the default theme is dark for comfort in long sessions; toggle is always accessible.
- **Time is a first-class field**: due date/time is required to support planning.
- **Non-disruptive feedback**: most guidance is inline (badges, banners, highlights). Toasts are used sparingly for actionable events (e.g., conflict).
- **Progress visibility**: counts (completed vs total) and summary cards make the current workload obvious.
- **Fast “next action”**: Focus Mode helps narrow attention to the next few hours.

## Backend: Supabase integration

### Authentication
- Email/password auth via **Supabase Auth**.
- Session tokens are stored in **httpOnly cookies** and managed by API routes.

### Database
- `public.tasks` stores tasks per user with **Row Level Security (RLS)**.
- Includes a single-task “in progress” guarantee via a **partial unique index**.

### Storage
- Bucket: **`task-attachments`** (private)
- Attachments are stored in Storage; task rows store attachment metadata in `tasks.attachments` (jsonb).
- Downloads use **signed URLs** (short-lived).

### RLS (simple policies)
The provided SQL configures:
- Tasks: users can only select/insert/update/delete their own tasks
- Storage: users can only read/write/delete their own objects in the bucket

## Architecture & code structure

### API-based logic (clean separation)
All Supabase operations are performed in **Next.js API routes** under:

- `src/app/api/auth/*` — sign-in / sign-up / sign-out / me
- `src/app/api/tasks/*` — list/create/update/delete/seed/in-progress/attachments
- `src/app/api/attachments/*` — signed download URLs

Shared server helpers:
- `src/app/api/_lib/*` — cookie/session helpers, response helpers, Supabase request helpers

Client API wrapper:
- `src/lib/api-client.ts` — typed JSON helper + `ApiError`

### Component-based UI
The UI is decomposed into a small “feature folder”:

- `src/components/todo/TodoPage.tsx` — auth gate + mounts the app
- `src/components/todo/TodoApp.tsx` — main state + orchestration + layout
- `src/components/todo/TaskForm.tsx` — RHF + Zod task form
- `src/components/todo/TaskList.tsx` — grouped list rendering + attachment UI
- `src/components/todo/UserMenu.tsx` — avatar dropdown + logout
- `src/components/todo/AuthCard.tsx` — sign in/up
- `src/components/todo/utils.ts` — date/time helpers + daily load logic
- `src/components/todo/types.ts`, `src/components/todo/schemas.ts`, `src/components/todo/mock-data.ts`

UI toolkit:
- `src/components/ui/*` — shadcn/ui components

## Responsive design & accessibility
- The layout uses Tailwind responsive classes (`sm:*`) to ensure the UI **stacks cleanly on mobile**, and expands naturally on tablet/desktop.
- Common overflow issues are handled with `min-w-0`, `truncate`, and stacked attachment rows on small screens.
- Buttons and controls include `aria-label`s where appropriate (e.g., icon-only actions).
- Inputs are keyboard accessible; dropdown/tooltip components use Radix (via shadcn/ui).

## Setup & running

### Prerequisites
- Node.js (modern LTS recommended)
- A Supabase project (free tier is fine)

### 1) Install dependencies
```bash
npm install
```

### 2) Configure environment variables
Create a `.env.local` file in the project root:

```txt
NEXT_PUBLIC_SUPABASE_URL=...
NEXT_PUBLIC_SUPABASE_ANON_KEY=...
```

You can copy from `supabase.env.example`.

### 3) Create tables, bucket, and policies
In Supabase Dashboard → **SQL Editor**, run:
- `supabase/schema.sql`

### 4) Run the app
```bash
npm run dev
```

Then open the local URL printed by Next.js.

## Notes on design decisions & trade-offs
- **`due_at` stored as a string** (`YYYY-MM-DDTHH:mm`) for simple client-side sorting/filtering and easy `datetime-local` interoperability. A true `timestamptz` would be better for multi-timezone products, but requires more careful UX/timezone handling.
- **Attachments stored as `jsonb`** on the task row to keep the schema lightweight. For large-scale usage, a normalized `task_attachments` table would be more flexible (queries, indexing, analytics).
- **API routes instead of direct Supabase client usage** in UI: improves separation of concerns, centralizes security/session handling, and keeps components focused on presentation/state.
- **Avatar image**: currently uses a deterministic “realistic placeholder” image source in the UI. For production, you’d typically store a user profile record and use Storage or a trusted CDN.

This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts) to automatically optimize and load [Geist](https://vercel.com/font), a new font family for Vercel.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying) for more details.

```

### README added
Created a professional `README.md` in the project root covering:

- **Project overview & goals**
- **Full feature list** (tasks, scheduling/filtering, focus mode, visual states, daily load, reminders, attachments)
- **UX/product thinking**
- **Supabase backend setup** (auth, `tasks` table, storage bucket, RLS, schema SQL)
- **Architecture** (API-based logic + component-based UI structure)
- **Responsive & accessibility notes**
- **Setup/run instructions**
- **Design decisions & trade-offs**

---

**User**

@src/components/todo/AuthCard.tsx:64-78 Display the demo username and password as a hint inside a small box above the login form, so users can easily sign in.

---

**Cursor**

I’ll add a small “Demo credentials” hint box right above the login form in `AuthCard`, showing the demo email + password (as copy-friendly code text). Then I’ll run a quick build to make sure it compiles.

```typescriptreact
"use client"

import * as React from "react"
import { useForm } from "react-hook-form"
import { toast } from "sonner"

import { apiFetch } from "@/lib/api-client"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Form, FormControl, FormField, FormItem, FormMessage } from "@/components/ui/form"
import { Input } from "@/components/ui/input"
import { zodResolver } from "@hookform/resolvers/zod"

import { authSchema, type AuthValues } from "./schemas"

const DEMO_EMAIL = "demo@todoapp.dev"
const DEMO_PASSWORD = "Demo123!"

export function AuthCard({ onAuthed }: { onAuthed: () => void }) {
  const [mode, setMode] = React.useState<"sign_in" | "sign_up">("sign_in")
  const [busy, setBusy] = React.useState(false)

  const form = useForm<AuthValues>({
    resolver: zodResolver(authSchema),
    defaultValues: { email: "", password: "" },
  })

  async function onSubmit(values: AuthValues) {
    setBusy(true)
    try {
      if (mode === "sign_in") {
        await apiFetch("/api/auth/sign-in", {
          method: "POST",
          body: JSON.stringify(values),
        })
        onAuthed()
      } else {
        await apiFetch("/api/auth/sign-up", {
          method: "POST",
          body: JSON.stringify(values),
        })
        toast.success("Account created", {
          description: "You can now sign in (or confirm email if required).",
        })
        setMode("sign_in")
      }
    } catch (e) {
      toast.error("Authentication failed", {
        description: e instanceof Error ? e.message : "Please try again.",
      })
    } finally {
      setBusy(false)
    }
  }

  return (
    <div className="mx-auto flex min-h-screen max-w-md flex-col justify-center px-4 py-10">
      <Card>
        <CardHeader>
          <CardTitle className="text-2xl">{mode === "sign_in" ? "Sign in" : "Sign up"}</CardTitle>
          <p className="text-muted-foreground text-sm">
            {mode === "sign_in"
              ? "Use your email and password."
              : "Create an account with email and password."}
          </p>
        </CardHeader>
        <CardContent className="space-y-4">
          {mode === "sign_in" && (
            <div className="rounded-lg border bg-muted/20 px-3 py-2 text-sm">
              <p className="font-medium">Demo credentials</p>
              <p className="text-muted-foreground mt-1">
                Email: <code>{DEMO_EMAIL}</code>
                <br />
                Password: <code>{DEMO_PASSWORD}</code>
              </p>
            </div>
          )}
          <Form {...form}>
            <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-3" noValidate>
              <FormField
                control={form.control}
                name="email"
                render={({ field }) => (
                  <FormItem>
                    <FormControl>
                      <Input placeholder="Enter your email" autoComplete="email" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="password"
                render={({ field }) => (
                  <FormItem>
                    <FormControl>
                      <Input
                        type="password"
                        placeholder="Password"
                        autoComplete={mode === "sign_in" ? "current-password" : "new-password"}
                        {...field}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <Button type="submit" className="w-full" disabled={busy}>
                {mode === "sign_in" ? "Sign in" : "Sign up"}
              </Button>
            </form>
          </Form>

          <div className="flex items-center justify-between gap-3 text-sm">
            <span className="text-muted-foreground">
              {mode === "sign_in" ? "No account?" : "Already have an account?"}
            </span>
            <Button
              type="button"
              variant="link"
              className="px-0"
              onClick={() => setMode((m) => (m === "sign_in" ? "sign_up" : "sign_in"))}
            >
              {mode === "sign_in" ? "Sign up" : "Sign in"}
            </Button>
          </div>
        </CardContent>
      </Card>
    </div>
  )
}


```

Added a **small “Demo credentials” box** above the sign-in form in `src/components/todo/AuthCard.tsx` (only shows in **Sign in** mode), displaying:

- Email: `demo@todoapp.dev`
- Password: `Demo123!`

---

**User**

i can't see a user and password here 

---

**Cursor**

I see what’s happening: the demo box is rendered above the form in `AuthCard`, but in your UI it’s either not being picked up (stale dev build) or it’s too subtle against the dark card background. I’ll make the demo credentials section **more prominent** and add a **“Use demo”** button that autofills the form so it’s impossible to miss.

```typescriptreact
"use client"

import * as React from "react"
import { useForm } from "react-hook-form"
import { toast } from "sonner"

import { apiFetch } from "@/lib/api-client"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Form, FormControl, FormField, FormItem, FormMessage } from "@/components/ui/form"
import { Input } from "@/components/ui/input"
import { zodResolver } from "@hookform/resolvers/zod"

import { authSchema, type AuthValues } from "./schemas"

const DEMO_EMAIL = "demo@todoapp.dev"
const DEMO_PASSWORD = "Demo123!"

export function AuthCard({ onAuthed }: { onAuthed: () => void }) {
  const [mode, setMode] = React.useState<"sign_in" | "sign_up">("sign_in")
  const [busy, setBusy] = React.useState(false)

  const form = useForm<AuthValues>({
    resolver: zodResolver(authSchema),
    defaultValues: { email: "", password: "" },
  })

  async function onSubmit(values: AuthValues) {
    setBusy(true)
    try {
      if (mode === "sign_in") {
        await apiFetch("/api/auth/sign-in", {
          method: "POST",
          body: JSON.stringify(values),
        })
        onAuthed()
      } else {
        await apiFetch("/api/auth/sign-up", {
          method: "POST",
          body: JSON.stringify(values),
        })
        toast.success("Account created", {
          description: "You can now sign in (or confirm email if required).",
        })
        setMode("sign_in")
      }
    } catch (e) {
      toast.error("Authentication failed", {
        description: e instanceof Error ? e.message : "Please try again.",
      })
    } finally {
      setBusy(false)
    }
  }

  return (
    <div className="mx-auto flex min-h-screen max-w-md flex-col justify-center px-4 py-10">
      <Card>
        <CardHeader>
          <CardTitle className="text-2xl">{mode === "sign_in" ? "Sign in" : "Sign up"}</CardTitle>
          <p className="text-muted-foreground text-sm">
            {mode === "sign_in"
              ? "Use your email and password."
              : "Create an account with email and password."}
          </p>
        </CardHeader>
        <CardContent className="space-y-4">
          {mode === "sign_in" && (
            <div className="rounded-lg border bg-muted/40 px-3 py-3 text-sm">
              <div className="flex items-start justify-between gap-3">
                <div className="min-w-0">
                  <p className="font-medium">Demo credentials</p>
                  <p className="text-muted-foreground mt-1 break-words">
                    Email: <code>{DEMO_EMAIL}</code>
                    <br />
                    Password: <code>{DEMO_PASSWORD}</code>
                  </p>
                </div>
                <Button
                  type="button"
                  variant="secondary"
                  size="sm"
                  onClick={() => {
                    form.setValue("email", DEMO_EMAIL, { shouldDirty: true })
                    form.setValue("password", DEMO_PASSWORD, { shouldDirty: true })
                  }}
                >
                  Use demo
                </Button>
              </div>
            </div>
          )}
          <Form {...form}>
            <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-3" noValidate>
              <FormField
                control={form.control}
                name="email"
                render={({ field }) => (
                  <FormItem>
                    <FormControl>
                      <Input placeholder="Enter your email" autoComplete="email" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="password"
                render={({ field }) => (
                  <FormItem>
                    <FormControl>
                      <Input
                        type="password"
                        placeholder="Password"
                        autoComplete={mode === "sign_in" ? "current-password" : "new-password"}
                        {...field}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <Button type="submit" className="w-full" disabled={busy}>
                {mode === "sign_in" ? "Sign in" : "Sign up"}
              </Button>
            </form>
          </Form>

          <div className="flex items-center justify-between gap-3 text-sm">
            <span className="text-muted-foreground">
              {mode === "sign_in" ? "No account?" : "Already have an account?"}
            </span>
            <Button
              type="button"
              variant="link"
              className="px-0"
              onClick={() => setMode((m) => (m === "sign_in" ? "sign_up" : "sign_in"))}
            >
              {mode === "sign_in" ? "Sign up" : "Sign in"}
            </Button>
          </div>
        </CardContent>
      </Card>
    </div>
  )
}


```

I made the **demo credentials box more visible** and added a **“Use demo”** button that auto-fills the email + password.

- **Updated file**: `src/components/todo/AuthCard.tsx`

If you still don’t see it after this change, do a **hard refresh** (Ctrl+F5) and restart dev server:

```bash
npm run dev
```

```shellscript
npm run dev
```

